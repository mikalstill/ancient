<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book>

<bookinfo>
<title>OLS 2004: Userspace filesystems using FUSE</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>
</bookinfo>

<chapter><title>Introduction</title>
<para>
<emphasis>This is a draft version of this document. It is by no means complete. Please don't redistribute this version of the document, wait for the final one to come out first. If you have suggestions on how to improve the tutorial, please mail them to me at mikal@stillhq.com</emphasis>
</para>

<para>
This tutorial covers FUSE, a userspace library and kernel module which facilitates the implementation of Linux filesystems in userspace. FUSE can be found at http://sourceforge.net/projects/avf/, and first came to my attention because of an article from LWN at http://lwn.net/Articles/68104/.
</para>

<sect1><title>Why would you want custom filesystems?</title>
<para>
When you think about it, filesystems are an incredibly useful thing, and there are many reasons to write small filesystems to perform specific tasks. I first encountered FUSE when I had a need for something to cache the result of reads over a slow NFS network. For example, the university which I am studying at has labs full of machines which use NFS for read only storage of dependancies for student projects. It isn't practical to copy all of these files to the local machines until they are needed, as the machines have limited storage. A caching filesystem solves this problem by only storing the files which are actually used locally.
</para>

<para>
There are other obvious examples. I do a lot of image programming, and one of things that I have in my collection of test images is a set of every possible TIFF image (within certain limits). This lets me test my code exhaustively before putting it into production. Now, it's easy to generate those test images are required from one or two source images, but that would mean having much more complicated test clients. A custom filesystem lets me instead have those images generated on demand when I am testing. While this makes the testing process slower, it is worth it for not having to store many gigabytes of test images.
</para>
</sect1>

<sect1><title>Why in userspace?</title>
<para>
So, why would you put these custom filesystems into user space? Well, kernel programming is a lot harder to debug, and doesn't feel natural for a lot of application developers. Userspace code on the other hand has access to all the standard debugging tools which most programmers are familiar with.
</para>

<para>
Additionally, there is a lot of userspace support code to do almost anything you could want to put into your filesystem. In my example of a filesystem which generates test images, all of the image processing code exists in userspace already. If I was to write such a filesystem in kernel space, then I would also have to come up with the image processing code as well. It also seems wrong headed to do lots of image processing code in the kernel -- the kernel should be short and sweet.
</para>
</sect1>

<sect1><title>Its a useful learning tool for students</title>
<para>
Because a userspace filesystem is not running in the kernel, it makes it a little less scary when a bug happens in your filesystem -- the machine wont nessesarily stop.
</para>
</sect1>
</chapter>

<chapter><title>A first glance at the FUSE implementation</title>
<para>
TODO
</para>

<sect1><title>The kernel module</title>
<para>
On startup, the file /proc/fs/fuse/dev is registered. This is then used for communication between the userspace worker process and the kernel module which hooks FUSE into the VFS layer of the kernel.
</para>
</sect1>

<sect1><title>The user space library</title>
<para>
TODO
</para>

<sect2><title>The fuse_operations structure</title>
<para>
As with many modules within the kernel itself, the operations which can be performed on your userspace filesystem are handed to FUSE using a structure containing a list of function pointers. Here's a sample:
</para>

<programlisting>
static struct fuse_operations mcachefs_oper = {
    .getattr    = mcachefs_getattr,
    .readlink   = mcachefs_readlink,
    .getdir     = mcachefs_getdir,
    .mknod      = mcachefs_mknod,
    .mkdir      = mcachefs_mkdir,
    .symlink    = mcachefs_symlink,
    .unlink     = mcachefs_unlink,
    .rmdir      = mcachefs_rmdir,
    .rename     = mcachefs_rename,
    .link       = mcachefs_link,
    .chmod      = mcachefs_chmod,
    .chown      = mcachefs_chown,
    .truncate   = mcachefs_truncate,
    .utime      = mcachefs_utime,
    .open       = mcachefs_open,
    .read       = mcachefs_read,
    .write      = mcachefs_write,
    .statfs     = mcachefs_statfs,
    .release    = mcachefs_release,
    .fsync      = mcachefs_fsync   
};
</programlisting>

<para>
When the userspace program which implements your filesystem starts up, it passes this structure to the FUSE library with the <emphasis>fuse_main</emphasis>() function call. The call I used for the <emphasis>fuse_operations</emphasis> structure above was:
</para>

<programlisting>
fuse_main(argc, argv, &amp;mcachefs_oper);
</programlisting>

<para>
<emphasis>fuse_main</emphasis>() performs some command line arguement parsing (hence the argc and argv arguements), and then starts processing requests for the filesystem. <emphasis>fuse_main </emphasis>() doesn't return until the userspace filesystem is unmounted.
</para>
</sect2>
</sect1>
</chapter>

<chapter><title>A first pass at a FUSE filesystem</title>
<para>
The example which we will follow through for this tutorial is my caching userspace filesystem. When I originally wrote the filesystem, it took the <command>open</command>() call for a file, checked for existance in the cache, and if the file didn't exist in the cache copied it across the network to the cache. All subsequent requests go to the cache, so if the file doesn't exist when <command>open</command>()ed, the cache wouldn't be populated, and subsequent operations on the file would fail as well.
</para>

<para>
The advantage of this is that cache management can be done in userspace with a find command, on the proviso that there is no one accessing the cache while the maintence is being performed. It is also a relatively simple filesystem to implement and understand. The disadvantages are that none of the metadata is cached, and the <command>open</command>() operation is <emphasis>very</emphasis> slow to complete. Imagine copying a two gigabyte file over the network before the <command>open</command>() completes.
</para>

<programlisting>
/*
    mcachefs -- a caching filesystem to deal with slow filesystem accesses. This
    filesystem assumes that the backing store is fast and local! The filesystem is
    currently read only
    Copyright (C) 2004  Michael Still (mikal@stillhq.com)

    Heavily based on example code that is:
    Copyright (C) 2001  Miklos Szeredi (mszeredi@inf.bme.hu)

    This program can be distributed under the terms of the GNU GPL.
    See the file COPYING.
*/

#ifdef linux
/* For pread()/pwrite() */
#define _XOPEN_SOURCE 500
#endif

#include &lt;fuse.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/statfs.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/file.h&gt;

#include &lt;tdb.h&gt;

#include "config.h"

#define FUNCTIONCALL 1

char *target;
char *backing;
int verbose;
TDB_CONTEXT *db;


static char *mcachefs_makepath(const char *path, char *prefix)
{
  char *newpath;
  int len;

  len = strlen(path) + strlen(prefix) + 1;
  newpath = malloc(len + 1);
  if(newpath == NULL)
    {
      printf("  Failed to convert path\n");
      return NULL;
    }

  snprintf(newpath, len, "%s%s", prefix, path);
  return newpath;
}

static char *mcachefs_makerealpath(const char *path)
{
  return mcachefs_makepath(path, target);
}

static char *mcachefs_makebackingpath(const char *path)
{
  return mcachefs_makepath(path, backing);
}

int mcachefs_fileinbacking(const char *path)
{
  char *backingpath;
  int fd;
  
  backingpath = mcachefs_makebackingpath(path);
  if(backingpath == NULL)
    return 0;

  if((fd = open(backingpath, O_RDONLY)) &gt; 0)
    {
      close(fd);
      return 1;
    }
  return 0;
}

void mcachefs_copytobacking(const char *path)
{
  char *realpath, *backingpath, *victim, *temppath, *tok;
  char *realfile, *backingfile;
  struct stat sb;
  int len, realfd, backingfd;

  /* Get useful paths: this has to happen here so that the client blocks */
  realpath = mcachefs_makerealpath(path);
  if(realpath == NULL)
    {
      printf("Backing store: couldn't make real file path\n");
      return;
    }
  
  backingpath = mcachefs_makebackingpath(path);
  if(backingpath == NULL)
    {
      printf("Backing store: couldn't make backing store file path\n");
      goto copyoutnofds;
    }

  printf("Backing store: copying %s to %s\n", realpath, backingpath);

  /* Does the path in the backing store exist? */
  victim = strdup(backingpath);
  if(victim == NULL)
    {
      printf("Backing store: couldn't make victim store file path\n");
      goto copyoutnofds;
    }
  len = strlen(victim);
  while((len &gt; 0) &amp;&amp; (victim[len] != '/'))
    len--;
  victim[len] = 0;
  
  len = strlen(victim) + 1;
  temppath = malloc(len + 1);
  if(!temppath)
    {
      printf("Backing store: could not allocate memory\n");
      free(victim);
      goto copyoutnofds;
    }
  
  tok = strtok(victim, "/");
  snprintf(temppath, len, "/%s", tok);
  while(tok)
    {
      if(stat(temppath, &amp;sb) &lt; 0)
    {
      // The path element didn't exist
      mkdir(temppath, S_IRWXU);
    }
      
      if(!S_ISDIR(sb.st_mode))
    {
      printf("Backing store: %s not a directory\n", temppath);
      free(victim);
      free(temppath);
      goto copyoutnofds;
    }
      
      tok = strtok(NULL, "/");
      if(tok)
    {
      strncat(temppath, "/", len);
      strncat(temppath, tok, len);
    }
    }
  free(victim);
  free(temppath);
  
  if ((realfd = open (realpath, O_RDONLY)) &lt; 0)
    {
      printf("Backing store: couldn't open the real file\n");
      goto copyoutnofds;
    }
  
  if ((backingfd = open (backingpath, O_CREAT | O_RDWR, S_IRWXU)) &lt; 0)
    {
      printf("Backing store: couldn't open the backing file\n");
      goto copyoutnobackingfd;
    }

  /* A simple mmap()ed copy -- we might want to one day offer byte
     range copying as well (that would be in the read method)*/
  if(fstat(realfd, &amp;sb) &lt; 0)
    {
      printf("Backing store: couldn't stat the real file\n");
      goto copyout;
    }
  
  if(ftruncate(backingfd, sb.st_size) &lt; 0)
    {
      printf("Backing store: couldn't allocate space for backing data\n");
      goto copyout;
    }
  
  if ((int) (realfile =
       (char *) mmap (NULL, sb.st_size, PROT_READ, 
              MAP_SHARED, realfd, 0)) == -1)
    {
      printf("Backing store: couldn't mmap the real file\n");
      goto copyout;
    }
  
  if ((int) (backingfile =
       (char *) mmap (NULL, sb.st_size, PROT_WRITE, 
              MAP_SHARED, backingfd, 0)) == -1)
    {
      printf("Backing store: couldn't mmap the backing file\n");
      goto copyout;
    }
  
  memcpy(backingfile, realfile, sb.st_size);

  if(munmap(realfile, sb.st_size) &lt; 0)
    {
      printf("Backing store: couldn't munmap the real file\n");
      goto copyout;
    }
  
  if(munmap(backingfile, sb.st_size) &lt; 0)
    {
      printf("Backing store: couldn't munmap the backing file\n");
      goto copyout;
    }
  
 copyout:
  close(backingfd);

 copyoutnobackingfd:
  close(realfd);

 copyoutnofds:
  if(backingpath)
    free(backingpath);
  if(realpath)
    free(realpath);

  printf("Backing store: done\n");
  return;
}


static int mcachefs_getattr(const char *path, struct stat *stbuf)
{
    int res;
    char *realpath;

    printf("mcachefs_getattr(path = %s, stbuf = ...\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }
    
    res = lstat(realpath, stbuf);

    free(realpath);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_readlink(const char *path, char *buf, size_t size)
{
    int res;
    char *realpath;
    
    printf("mcachefs_readlink(path = %s, buf = ..., size = ...)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }
    
    res = readlink(realpath, buf, size - 1);

    free(realpath);
    if(res == -1)
      return -errno;

    buf[res] = '\0';
    return 0;
}


static int mcachefs_getdir(const char *path, fuse_dirh_t h, fuse_dirfil_t filler)
{
    DIR *dp;
    struct dirent *de;
    int res = 0;
    char *realpath;

    printf("mcachefs_getdir(path = %s, h = ..., filler = ...)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    dp = opendir(realpath);
    
    free(realpath);
    if(dp == NULL)
      return -errno;

    while((de = readdir(dp)) != NULL) {
        res = filler(h, de-&gt;d_name, de-&gt;d_type);
        if(res != 0)
            break;
    }

    closedir(dp);
    return res;
}

static int mcachefs_mknod(const char *path, mode_t mode, dev_t rdev)
{
    int res;
    char * realpath;

    printf("mcachefs_mknod(path = %s, mode = ***, rdev = ***\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }
    
    res = mknod(realpath, mode, rdev);

    free(realpath);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_mkdir(const char *path, mode_t mode)
{
    int res;
    char *realpath;

    printf("mcachefs_mkdir(path = %s, mode = ***\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = mkdir(realpath, mode);
    
    free(realpath);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_unlink(const char *path)
{
    int res;
    char *realpath;

    printf("mcachefs_unlink(path = %s)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = unlink(realpath);

    free(realpath);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_rmdir(const char *path)
{
    int res;
    char *realpath;

    printf("mcachefs_rmdir(path = %s)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = rmdir(realpath);
    
    free(realpath);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_symlink(const char *from, const char *to)
{
    int res;
    char *realfrom, *realto;

    printf("mcachefs_symlink(path = %s, to = %s\n", from, to);
    realfrom = mcachefs_makerealpath(from);
    if(realfrom == NULL)
      {
    return -ENOMEM;
      }
    realto = mcachefs_makerealpath(to);
    if(realto == NULL)
      {
    free(realfrom);
    return -ENOMEM;
      }

    res = symlink(realfrom, realto);

    free(realfrom);
    free(realto);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_rename(const char *from, const char *to)
{
    int res;
    char *realfrom, *realto;

    printf("mcachefs_rename(from = %s, to = %s\n", from, to);
    realfrom = mcachefs_makerealpath(from);
    if(realfrom == NULL)
      {
    return -ENOMEM;
      }
    realto = mcachefs_makerealpath(to);
    if(realto == NULL)
      {
    free(realfrom);
    return -ENOMEM;
      }

    res = rename(realfrom, realto);

    free(realfrom);
    free(realto);
    if(res == -1)
      return -errno;
    return 0;
}

static int mcachefs_link(const char *from, const char *to)
{
    int res;
    char *realfrom, *realto;

    printf("mcachefs_link(from = %s, to = %s)\n", from, to);
    realfrom = mcachefs_makerealpath(from);
    if(realfrom == NULL)
      {
    return -ENOMEM;
      }
    realto = mcachefs_makerealpath(to);
    if(realto == NULL)
      {
    free(realfrom);
    return -ENOMEM;
      }

    res = link(realfrom, realto);

    free(realfrom);
    free(realto);
    if(res == -1)
        return -errno;

    return 0;
}

static int mcachefs_chmod(const char *path, mode_t mode)
{
    int res;
    char *realpath;

    printf("mcachefs_chmod(path = %s, mode = ***)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = chmod(realpath, mode);

    free(realpath);
    if(res == -1)
        return -errno;
    
    return 0;
}

static int mcachefs_chown(const char *path, uid_t uid, gid_t gid)
{
    int res;
    char *realpath;

    printf("mcachefs_chown(path = %s, uid = ***, gid = ***)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = lchown(realpath, uid, gid);

    free(realpath);
    if(res == -1)
        return -errno;

    return 0;
}

static int mcachefs_truncate(const char *path, off_t size)
{
    int res;
    char *realpath;
    
    printf("mcachefs_truncate(path = %s, size = ***)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = truncate(realpath, size);

    free(realpath);
    if(res == -1)
        return -errno;

    return 0;
}

static int mcachefs_utime(const char *path, struct utimbuf *buf)
{
    int res;
    char *realpath;
    
    printf("mcachefs_utime(path = %s, buf = ***)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    res = utime(realpath, buf);

    free(realpath);
    if(res == -1)
        return -errno;

    return 0;
}

/* mcachefs_open() is effectively an existance check. We also take the
   opportunity to fire off a copy process to pull the content into the backing
   store. This will hopefully have pulled the data that the client is going
   to ask for before the client needs it. If it hasn't then we're going
   to have to block... */
static int mcachefs_open(const char *path, int flags)
{
    int res;
    char *realpath;

    printf("mcachefs_open(path = %s, flags = ***)\n", path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    printf("Couldn't generate a real path for the open\n");
    return -ENOMEM;
      }

    res = open(realpath, flags);

    free(realpath);
    if(res == -1)
      {
    printf("File doesn't appear to exist for opening\n");
        return -errno;
      }

    close(res);

    /* The file existed -- pull it into the backing store */
    if(!mcachefs_fileinbacking(path))
      {
    printf("Inserting file into cache\n");
    mcachefs_copytobacking(path);
    printf("Finished inserting file into cache\n");
      }
    return 0;
}

static int mcachefs_read(const char *path, char *buf, size_t size, off_t offset)
{
    int fd;
    int res;
    char *backingpath;

    if(verbose &gt; FUNCTIONCALL)
      printf("mcachefs_read(path = %s, buf = ..., size = %d, offset = %d)\n",
         path, size, offset);

    if(!mcachefs_fileinbacking(path))
      mcachefs_copytobacking(path);

    backingpath = mcachefs_makebackingpath(path);
    if(backingpath == NULL)
      {
    return -ENOMEM;
      }

    fd = open(backingpath, O_RDONLY);

    free(backingpath);
    if(fd == -1)
        return -errno;
    
    res = pread(fd, buf, size, offset);
    if(res == -1)
        res = -errno;
    
    close(fd);
    return res;
}

static int mcachefs_write(const char *path, const char *buf, size_t size,
                     off_t offset)
{
    int fd;
    int res;
    char *realpath;

    printf("mcachefs_write(path = %s, buf = ..., size = ..., offset = ...)\n",
       path);
    realpath = mcachefs_makerealpath(path);
    if(realpath == NULL)
      {
    return -ENOMEM;
      }

    fd = open(realpath, O_WRONLY);

    free(realpath);
    if(fd == -1)
        return -errno;

    res = pwrite(fd, buf, size, offset);
    if(res == -1)
        res = -errno;
    
    close(fd);
    return res;
}

static int mcachefs_statfs(struct fuse_statfs *fst)
{
    struct statfs st;
    int rv = statfs("/",&amp;st);

    printf("mcachefs_statfs(fst = ...)\n");

    if(!rv) {
        fst-&gt;block_size  = st.f_bsize;
        fst-&gt;blocks      = st.f_blocks;
        fst-&gt;blocks_free = st.f_bavail;
        fst-&gt;files       = st.f_files;
        fst-&gt;files_free  = st.f_ffree;
        fst-&gt;namelen     = st.f_namelen;
    }
    return rv;
}

static int mcachefs_release(const char *path, int flags)
{
    /* Just a stub.  This method is optional and can safely be left
       unimplemented */

    printf("mcachefs_release\n");

    (void) path;
    (void) flags;
    return 0;
}

static int mcachefs_fsync(const char *path, int isdatasync)
{
    /* Just a stub.  This method is optional and can safely be left
       unimplemented */

  printf("mcachefs_sync\n");

    (void) path;
    (void) isdatasync;
    return 0;
}

static struct fuse_operations mcachefs_oper = {
    .getattr    = mcachefs_getattr,
    .readlink    = mcachefs_readlink,
    .getdir    = mcachefs_getdir,
    .mknod    = mcachefs_mknod,
    .mkdir    = mcachefs_mkdir,
    .symlink    = mcachefs_symlink,
    .unlink    = mcachefs_unlink,
    .rmdir    = mcachefs_rmdir,
    .rename    = mcachefs_rename,
    .link    = mcachefs_link,
    .chmod    = mcachefs_chmod,
    .chown    = mcachefs_chown,
    .truncate    = mcachefs_truncate,
    .utime    = mcachefs_utime,
    .open    = mcachefs_open,
    .read    = mcachefs_read,
    .write    = mcachefs_write,
    .statfs    = mcachefs_statfs,
    .release    = mcachefs_release,
    .fsync    = mcachefs_fsync
    
};

int main(int argc, char *argv[])
{
  config_state *cfg;
  char *key, *val, *tdbpath;
  int keylen;

  printf("mcachefs 0.1 starting up...\n");

  cfg = config_open("mcachefs");
  if(!cfg)
    {
      printf("Couldn't open config file\n");
      return 2;
    }

  if(argc &gt; 1)
    {
      keylen = strlen(argv[1]) + 100;
      key = (char *) malloc(keylen);
      if(!key)
    {
      perror("Couldn't allocate memory for key value");
      exit(2);
    }

      snprintf(key, keylen, "%s/target", argv[1]);
      target = config_getstring(cfg, key);
      snprintf(key, keylen, "%s/backing", argv[1]);
      backing = config_getstring(cfg, key);
      snprintf(key, keylen, "%s/verbose", argv[1]);
      val = config_getstring(cfg, key);
      if(val)
    verbose = atoi(val);
      snprintf(key, keylen, "%s/blockdb", argv[1]);
      tdbpath = config_getstring(cfg, key);

      printf("Filesystem now serving requests...\n");
      printf("  target = %s\n", target);
      printf("  backing = %s\n", backing);
      printf("  verbosity = %d\n", verbose);
      printf("  block database = %s\n", tdbpath);

      /* Now open the TDB */
      db = tdb_open(tdbpath, 0, 0, O_CREAT | O_RDWR, S_IRWXU);
      if(!db)
    {
      perror("Couldn't open block database");
      exit(2);
    }
    }
  else
    {
      target = NULL;
      backing = NULL;
      tdbpath = NULL;
      verbose = 0;
    }

  fuse_main(argc, argv, &amp;mcachefs_oper);
  return 0;
}
</programlisting>
<para><emphasis>Code: mcachefs.c</emphasis></para>
</chapter>


<appendix><title>config.[ch] as used in examples</title>
<para>
Several of the examples refer to a file named config.c or config.h, which are reproduced here.
</para>

<programlisting>
/* 
 * A config file parser. Copyright (c) Michael Still (mikal@stillhq.com) 2004, 
 * released under the terms of the GNU GPL version 2 
 */

#ifndef CONFIG_H
#define CONFIG_H

#include "list.h"

/*
 * Internal structures
 */
struct config_list
{
  struct list_head list;
  char *line;
  char *key;
  char *value;
};

/*
 * State is handled by this structure
 */
typedef struct config_state_internal
{
  struct config_list *lines;
  char *file;
  off_t size;
}
  config_state;

/*
 * Externally used functions
 */

config_state *config_open(char *);

char *config_getstring(config_state *, char *);

/*
 * Internal helper functions
 */

int config_file_open(char *, char *, int);
struct config_list *config_parse(char *);
void config_close(config_state *);
void config_tokenizeline(struct config_list *);

#endif
</programlisting>
<para><emphasis>Code: config.h</emphasis></para>

<programlisting>
/* 
 * A config file parser. Copyright (c) Michael Still (mikal@stillhq.com) 2004, 
 * released under the terms of the GNU GPL version 2 
 */

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;

#include "config.h"

#ifdef TESTING

int main(int argc, char *argv[])
{
  config_state *cfg;
  char *val;

  /* 
   * This will result in the following config files being checked for existance:
   *    - /etc/testing
   *    - ~/.testing
   *    - ./testing
   */
  cfg = config_open("testing");
  if(!cfg)
    {
      printf("Config file reading failed\n");
      return 2;
    }

  /*
   * Now we can read values from that config file
   */
  printf("A banana is a %s\n", config_getstring(cfg, "banana"));

  /*
   * Now we can close the config file just like a normal file
   */
  config_close(cfg);
}

#endif

config_state *config_open(char *name)
{
  int fd;
  config_state *cfg;
  struct stat sb;

  cfg = malloc(sizeof(config_state));
  if(!cfg)
    {
      perror("config: could not allocate a config structure");
      return NULL;
    }
  
  fd = config_file_open("/etc", name, 0);

  if(fd == -1)
    {
      char *home = getenv("HOME");
      fd = config_file_open(home, name, 1);
      if(home)
    free(home);
    }

  if(fd == -1)
    {
      char *fname = malloc(strlen(name) + 5);
      if(!fname)
    {
      perror("config: could not allocate memory for config filename");
      free(cfg);
      return NULL;
    }
      snprintf(fname, strlen(name) + 5, "%s.cfg", name);
      fd = config_file_open(".", fname, 0);
      free(fname);
    }

  if(fd == -1)
    {
      free(cfg);
      return NULL;
    }

  /*
   * We return a mmapped view of the file
   */

  if(fstat(fd, &amp;sb) &lt; 0)
    {
      perror("config: could not stat config file");
      close(fd);
      return NULL;
    }

  cfg-&gt;size = sb.st_size;
  if((int) (cfg-&gt;file = (char *) mmap(NULL, cfg-&gt;size, PROT_READ | PROT_WRITE, 
                      MAP_PRIVATE, fd, 0)) == -1)
    {
      perror("config: could not mmap config file");
      close(fd);
      return NULL;
    }

  /*
   * We prebuild a list of the config strings in this file, to save
   * repeatedly parsing the file over and over later
   */
  cfg-&gt;lines = config_parse(cfg-&gt;file);
  return cfg;
}

void config_close(config_state *cfg)
{
  if(cfg-&gt;file)
    {
      munmap(cfg-&gt;file, cfg-&gt;size);
    }
}

int config_file_open(char *dir, char *name, int dotted)
{
  char *path;
  int fd, chars;
  
  chars = strlen(dir) + strlen(name) + 3;
  path = malloc(sizeof(char) * chars);
  if(path == NULL)
    {
      perror("config: couldn't allocate memory to open config file");
      return -1;
    }

  snprintf(path, chars, "%s/%s%s", dir, dotted ? "." : "", name);
  fd = open(path, O_RDONLY);
  return fd;
}

struct config_list *config_parse(char *file)
{
  struct config_list *head, *p;
  struct list_head *lh;
  char *line;

  head = (struct config_list *) malloc(sizeof(struct config_list));
  if(!head)
    return NULL;

  /*
   * Work through the file and build a linked list of lines
   */

  line = strtok(file, "\n");
  INIT_LIST_HEAD(&amp;head-&gt;list);
  head-&gt;line = line;
  head-&gt;key = NULL;
  head-&gt;value = NULL;

  while((line = strtok(NULL, "\n")) != NULL)
    {
      p = (struct config_list *) malloc(sizeof(struct config_list));
      if(!p)
    return NULL;
      
      p-&gt;line = line;
      p-&gt;key = NULL;
      p-&gt;value = NULL;

      list_add_tail(&amp;p-&gt;list, &amp;head-&gt;list);
    }

  /*
   * Now split those lines in the key value pairs
   */
  
  config_tokenizeline(head);
  list_for_each(lh, &amp;head-&gt;list)
    {
      config_tokenizeline(list_entry(lh, struct config_list, list));
    }

  return head;
}

void config_tokenizeline(struct config_list *cfg)
{
  cfg-&gt;key = strtok(cfg-&gt;line, "\t");
  cfg-&gt;value = strtok(NULL, "\t");
}

char *config_getstring(config_state *cfg, char *key)
{
  struct list_head *lh;

  if(strcmp(cfg-&gt;lines-&gt;key, key) == 0)
    return cfg-&gt;lines-&gt;value;

  list_for_each(lh, &amp;cfg-&gt;lines-&gt;list)
    {
      struct config_list *item = list_entry(lh, struct config_list, list);
      if(strcmp(item-&gt;key, key) == 0)
    return item-&gt;value;
    }

  return NULL;
}
</programlisting>
<para><emphasis>Code: config.c</emphasis></para>
</appendix>

</book>
