<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article>
<title>trivsql: A trivial SQL engine for your application</title>

<sect1><title>Introduction</title>
<para>
<command>trivsql</command> is a simple SQL engine, implemented on the <command>tdb</command> database engine. The intention of <command>trivsql</command> is that it is embedded into your application, allowing the use of familiar SQL constructs for accessing data stored within your application.
</para>

<para>
<command>trivsql</command> is licensed under the terms of the GNU GPL, as is the <command>tdb</command> engine upon which it depends.
</para>
</sect1>

<sect1><title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document.
</para>

<para>
Michael has a website at http://www.stillhq.com.
</para>
</sect1>

<sect1>
<title>An introduction to tdb</title>
<para>
<command>tdb</command> is a (name, value) pair database similar to <command>gdbm</command>. It was originally implemented for the Samba project, as a way of avoiding having to implement a large number of in memory linked lists for storing usage and access information. The code for <command>tdb</command> is available from the Samba CVS server.
</para>

<para>
To quote from the Samba source code: <quote>This is a simple database API. 
It was inspired by the realisation that
in Samba we have several ad-hoc bits of code that essentially
implement small databases for sharing structures between parts of
Samba. As I was about to add another I realised that a generic
database module was called for to replace all the ad-hoc bits.

I based the interface on gdbm. I couldn't use gdbm as we need to be
able to have multiple writers to the databases at one time.</quote>
</para>

<para>
To make use of a <command>tdb</command> database at the most trivial level, you open the database with a <command>tdb_open</command> function call, you can then add pairs to the database using the <command>tdb_store</command> function, and retrieve pairs from the database with the <command>tdb_fetch</command> function. The database is closed when you are finished with the via the <command>tdb_close</command> function.

<footnote>
<para>
There are also functions which allow you to do slightly more interesting operations, such as enumerating all of the keys defined in the database.
</para>
</footnote>

</para>
</sect1>

<sect1><title>Why trivsql?</title>
<para>
The functionality offered by <command>tdb</command> is satisfactory for simple databases where all you want to store is small nuggets of data. For instance, when you want to store that the user Daniel is logged on, then a piece of code such as:
</para>

<programlisting>
  TDB_CONTEXT db;
  TDB_DATA dbkey, dbdata;

  // Open the database
  document->db = tdb_open ("foo.tdb", 0,
                           TDB_CLEAR_IF_FIRST, O_RDWR | O_CREAT | O_TRUNC,
                           0600);

  // Store the value
  dbkey.dptr = "Daniel";
  dbkey.dsize = strlen (key) + 1;
  dbdata.dptr = "LoggedOn";
  dbdata.dsize = strlen (value) + 1;

  if (tdb_store (db, dbkey, dbdata, TDB_REPLACE) != 0)
    {
      fprintf(stderr, "Could not store value");
    }
</programlisting>

<para>
And to retrieve the value:
</para>

<programlisting>
  TDB_CONTEXT db;
  TDB_DATA dbkey, dbdata;

  // Open the database
  document->db = tdb_open ("foo.tdb", 0,
                           TDB_CLEAR_IF_FIRST, O_RDWR | O_CREAT | O_TRUNC,
                           0600);

  // Fetch the value
  dbkey.dptr = "Daniel";
  dbkey.dsize = strlen (key) + 1;

  dbdata = tdb_fetch (document->db, dbkey);
</programlisting>

<para>
This doesn't work so well when the data you want to store is more complex. For example, let's imagine that we want to store some more information about Daniel -- for instance how many bytes he has transfered this session and a list of his favourite users. I can think of four ways that we can store this information in a <command>tdb</command> database:

<orderedlist>
<listitem><para>We can define a structure that contains these elements, and then store the pointer to this structure in the <command>tdb</command>. The problem with this is that it doesn't persist across restarts of the program, because the pointer will no longer be valid.</para></listitem>

<listitem><para>We can use a series of interestingly named keys, each storing a piece of information. For example:
     <orderedlist>
     <listitem><para>daniel-bytestransfered</para></listitem>
     <listitem><para>daniel-friends</para></listitem>
     <listitem><para>et cetera</para></listitem>
     </orderedlist>

The problem with this is that it produces horribly verbose code, because the code to read a single key is repeated all over the place.
</para></listitem>

<listitem><para>We can push all the information into one string, and then store that in the <command>tdb</command>, but this means that we have to handle parsing the information again when you need it back. Since writing <command>trivsql</command> the Samba team has dealt with exactly this problem in this manner. To ease the implementation, Dr Andrew Tridgell has written <command>genstruct</command>, which takes c structures (including pointers) and serializes them into strings. <command>genstruct</command> is available from http://www.samba.org.</para></listitem>

<listitem><para>You can use <command>trivsql</command>, which looks after all the ugliness for you, and allows you to perform select and insert statements in a manner familiar to many programmers.</para></listitem>
</orderedlist>
</para>
</sect1>

<sect1><title>Why SQL?</title>
<para>
SQL was selected as a logical layer over <command>tdb</command> because there are many developers in the world which are already familiar with it. It is also relatively simple to parse and process the commands.
</para>

<sect2><title>Parsing SQL</title>
<para>
The SQL parser for <command>trivsql</command> is implemented in <command>flex</command> and <command>bison</command>, the listings for which are included at the end of this article. These files define a simple grammar for the supported SQL commands.
</para>

<para>
The following SQL commands are currently supported:
</para>

<itemizedlist>
<listitem><para><command>CREATE</command>: used to create a table, for example <emphasis>CREATE TABLE newtable (cola, colb, colc);</emphasis>. Inside the brackets is a comma separated list of column names. Note that <command>trivsql</command> doesn't currently support datatypes for the columns of tables, so it is up to the user to make sure that they parse the string values in each column correctly -- this will change in a later version of <command>trivsql</command>.</para></listitem>

<listitem><para><command>INSERT</command>: for example <emphasis>INSERT INTO newtable (cola, colc) VALUES ('123', 'banana');</emphasis>. Here we are inserting the given values into the table <emphasis>newtable</emphasis> as specified in the column list. <command>trivsql</command> supports NULL values, so the list of columns here does not need to include every column in the table.</para></listitem>

<listitem><para><command>SELECT</command>: this is the most compilicated of the SQL commands supported by <command>trivsql</command>. An example is <emphasis>SELECT * FROM newtable WHERE cola = '123';</emphasis>. You are not required to have a conditional applied to the select statement -- so <emphasis>SELECT * FROM newtable</emphasis> will return all the rows in the table. If the select has returned a column value which has a NULL value (i.e. data has never been inserted there), then you'll recieve a (char *) NULL. The available conditions are discussed below.</para></listitem>

<listitem><para><command>ALTER</command>: <emphasis>ALTER newtable ADD COLUMN cold;</emphasis> allows you to add columns to a table. At the moment you can only add columns to a table with the <emphasis>ALTER</emphasis> command.</para></listitem>

<listitem><para><command>UPDATE</command>: allows commands of the form <emphasis>UPDATE newtable SET two = 'g' WHERE two = 'f';</emphasis>. This is useful for changing existing values in a row without having to remove the entire row and then readd it.</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>Available conditional statements</title>
<para>
The following selectors are currently available:
</para>

<itemizedlist>
<listitem><para><command>Equality</command>: for instance 'foo' = 7</para></listitem>
<listitem><para><command>Like</command>: although the % syntax is not implemented</para></listitem>
<listitem><para><command>And / or</command>: so that you can have more than one criteria (including using brackets to apply precidence)</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>Execution strategy for conditional statements</title>
<para>

</para>
</sect2>
</sect1>

<sect1><title>The current state of play</title>
<para>
As shown by the list of SQL commands supported, <command>trivsql</command> is by no means a complete SQL implementation at this time. It is however quite useful, and stable. Because it is open source, it is also possible for users to add support for their own SQL commands if they are needed.
</para>

<para>
<command>trivsql</command> is still being actively developed -- future releases will include greater functionality, so users should keep track of what has recently been released by occassionally visiting http://www.stillhq.com
</para>
</sect1>

<sect1><title>Interface to trivsql</title>
<para>
...
</para>
</sect1>









<sect1><title>An example usage</title>
<para>
<command>trivsql</command> is really easy to use. The code snippet below is from the <command>trivsql</command> distribution. It simply reads commands from standard input, and executes them with <command>trivsql</command>. If the command returned a recordset (which is how all data is returned to the caller), then the recordset is displayed.
</para>

<programlisting>

#include &lt;stdio.h&gt;
#include "trivsql.h"

int main(int argc, char *argv[]){
  trivsql_state *ourState;
  trivsql_recordset *rs;
  char cmd[1000];

  if(argc != 2){
    fprintf(stderr, "Please specify a db file\n");
    exit(42);
  }

  ourState = trivsql_opendb(argv[1]);
  if(trivsql_initok(ourState) != TRIVSQL_TRUE){
    fprintf(stderr, "Database open failed\n");
    exit(42);
  }

  while(fgets(cmd, 1000, stdin) != NULL){
    rs = trivsql_execute(ourState, cmd);
    if(rs != NULL) trivsql_displayrs(rs);
    else printf("NULL recordset\n");
    trivsql_xfree(rs);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/example.c</emphasis></para>

<sect2><title>Input</title>
<para>
The following input:
</para>

<programlisting>
CREATE TABLE newtable (cola, colb, colc);
SELECT * FROM newtable;
INSERT INTO newtable (cola, colc) VALUES ('123', 'banana');
SELECT * FROM newtable;
SELECT * FROM newtable WHERE cola = '123';
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/example.sql</emphasis></para>

<para>
Produces the following output:
</para>

</sect2>
</sect1>







<sect1><title>Genstruct as an alternative</title>
<para>
Given that the Samba team chose to use <command>genstruct</command> to solve this same problem, it is worthwhile to briefly discuss their solution.
</para>
</sect1>

<sect1><title>What is genstruct?</title>
<para>
<command>genstruct</command> is very similar in some respects to the perl <command>Data::Dumper</command>. It is therefore useful to provide a brief introduction to that functionality before moving onto <command>genstruct</command>.
</para>

<sect2><title>Perl's Data::Dumper in a nutshell</title>
<para>
Perl's <command>Data::Dumper</command> is quite simple to use:
</para>


<para>
Which produces...
</para>

<programlisting>
$VAR1 = [
          'foo',
          'bar'
        ];
$VAR2 = {
          'walter' => 'wibble',
          'carl' => 'chicken',
          'bob' => 'banana'
        };
$VAR3 = 42;
</programlisting>
</sect2>

<sect2><title>Genstruct</title>
<para>
<command>genstruct</command> is a perl program which is run at compile time. It parses the c header files for the program you want to use <command>genstruct</command> with, using tags that you have to embed into the header file. For example, the sample which comes with <command>genstruct</command> is as follows:
</para>

<programlisting>
GENSTRUCT enum fruit {APPLE, ORANGE=2, PEAR,
		      RASBERRY, PEACH};

GENSTRUCT
struct test2 
{
	int x1;
	char *foo;
	char fstring[20]; _NULLTERM
	int dlen;
	char *dfoo; _LEN(dlen)
	enum fruit fvalue;
	struct test2 *next;
};

GENSTRUCT struct test1 {
	char foo[100];
	char *foo2[20];
	int xlen;
	int *iarray; _LEN(xlen);
	unsigned slen;
	char **strings; _LEN(slen);
	char *s2[5];
	double d1, d2, d3;
	struct test2 *test2;
	int alen;
	struct test2 *test2_array; _LEN(alen);
	struct test2 *test2_fixed[2];
	int plen;
	struct test2 **test2_parray; _LEN(plen)
};
</programlisting>
<para><emphasis>Code: ../short-genstruct/article.sgml</emphasis></para>

<para>
In this example you can see that structures which should have <command>genstruct</command> enabled have the <command>GENSTRUCT</command> attribute associated with them, you are therefore not required to have all of the data structures in your code exportable. <command>GENSTRUCT</command> is merely an empty #define, which the <command>genstruct</command> header file parser can search for.
</para>

<para>
To create a string representation of a data structure, simply:
</para>

<programlisting>
char *s;
struct test1 t;

// ... we need to populate t with data here ...

s = gen_dump(pinfo_test1, (char *) &amp;t, 0);
</programlisting>

<para>
In this code, we define a structure, fill it with data, and then use the <command>gen_dump</command> function to create a string representation of that structure. The arguments to <command>gen_dump</command> are:

<programlisting>
char *gen_dump(const struct parse_struct *pinfo, 
               const char *data, 
               unsigned indent);
</programlisting>

<itemizedlist>
<listitem><para><emphasis>const struct parse_struct *pinfo</emphasis>: is generated at compile time by <command>genstruct</command>, and is located in the output to that command.</para></listitem>
<listitem><para><emphasis>const char *data</emphasis>: is the data to dump to the string representation (simply cast your structure to a char * before passing it.</para></listitem>
<listitem><para><emphasis>unsigned indent</emphasis>: is the starting indent for ease of recursive calling. Set it to zero.</para></listitem>
<listitem><para><command>Returns</command>: a string representation of the structure.</para></listitem>
</itemizedlist>
</para>

<para>
The most interesting thing here is the <emphasis>pinfo</emphasis> structure which is the first argument to this <command>gen_dump</command> function. The <emphasis>pinfo_test1</emphasis> in this example looks like:
</para>

<programlisting>
static const struct parse_struct pinfo_test1[] = {
{"foo", 0, sizeof(char), offsetof(struct test1, foo), 100, NULL, 
  0, gen_dump_char, gen_parse_char},
{"foo2", 1, sizeof(char), offsetof(struct test1, foo2), 20, NULL, 
  0, gen_dump_char, gen_parse_char},
{"xlen", 0, sizeof(int), offsetof(struct test1, xlen), 0, NULL, 
  0, gen_dump_int, gen_parse_int},
{"iarray", 1, sizeof(int), offsetof(struct test1, iarray), 0, 
  "xlen", 0, gen_dump_int, gen_parse_int},
// ... and so on ...
{NULL, 0, 0, 0, 0, NULL, 0, NULL, NULL}};
</programlisting>

<para>
This table might seem a bit daunting at first, but readers need to remember that they're not expected to be able to read, generate, or use these tables. They are created solely for the use of <command>genstruct</command>.
</para>

<para>
The output of the <command>gen_dump</command> function call will be something like:
</para>

<programlisting>
foo = {hello foo}
foo2 = 1:{foo2 \7d you}, 2:{foo2 you 2}
xlen = 6
iarray = 0:9, 1:4, 2:3, 3:9, 4:7
slen = 3
strings = 0:{test string 48}, 1:{test string 69}, 2:{test string 36}
s2 = 2:{t2 string 0}, 3:{t2 string 74}
d1 = 3.5
d3 = -7
test2 = {
        x1 = 4
        foo = {hello \7b there}
        fstring = {blah 1}
        dlen = 12
        dfoo = {q\a9\08z\faO\ca\e3\1d\b2M\88}
        fvalue = APPLE
        next = {
                x1 = 5
                foo = {hello \7b there}
                fstring = {blah 1}
                dlen = 28
                dfoo = {\e8\8f\dc\1c\0e\c7)'\ea\da\07e\ca\042\ce\078?\b0@\ba\ab\90\84\8e\ad6}
                fvalue = APPLE
                next = {
                        x1 = 6
                        foo = {hello \7b there}
                        fstring = {blah 1}
                        dlen = 27
                        dfoo = {5r\c3\c4O\e0\d2\16      \f9\01\e3\01f\ad\05\98\7b^L\d0\bb\bd\11uh\a1\f9}
                        fvalue = APPLE
                        next = {
                                x1 = 7
                                foo = {hello \7b there}
                                fstring = {blah 1}
                                dlen = 14
                                dfoo = {N/\d1\83\a2\94G\f1t\1a\07\7d\13\08}
                                fvalue = APPLE
                        }
                }
        }
}
</programlisting>

<para>
This string representation can then be stored for later use.
</para>
</sect2>
</sect1>

<sect1><title>The other side of the equation</title>
<para>
The only reason you would use a package such as <command>Data::Dumper</command> or <command>genstruct</command> is so that you can read the information back in later. This is done with the <command>eval</command> function in perl. <command>genstruct</command>'s equivalent is <command>gen_parse</command>, which takes your string representation and recreates the data structures as stored. The arguments to <command>gen_parse</command> are:

<programlisting>
int gen_parse(const struct parse_struct *pinfo, 
              char *data, 
              const char *str0);
</programlisting>

<itemizedlist>
<listitem><para><emphasis>const struct parse_struct *pinfo</emphasis>: is the same parse structure that was used in the <command>gen_dump</command> call.</para></listitem>
<listitem><para><emphasis>char *data</emphasis>: is a pointer to the location that the structure should be created at. This memory should already have been allocated (for the main structure).</para></listitem>
<listitem><para><emphasis>const char *str0</emphasis>: the string representation to use.</para></listitem>
<listitem><para><command>Returns</command>: non zero if there was an error.</para></listitem>
</itemizedlist>

A sample usage is:
</para>

<programlisting>
char *s;
struct test1 t1, t2;

// ... we need to populate t1 with data here ...

s = gen_dump(pinfo_test1, (char *) &amp;t1, 0);
memset(&amp;t2, 0, sizeof(t2));

if(gen_parse(pinfo_test1, (char *) &amp;t2, s) != 0){
  printf("Parse failed!\n");
  exit(1);
  }
</programlisting>
</sect1>
<sect1><title>Genstruct pros and cons</title>
<para>
Advantages of the Samba solution to this problem are:
</para>

<orderedlist>
<listitem><para>Fewer database accesses</para></listitem>
<listitem><para>MORE?</para></listitem>
</orderedlist>

<para>
However, the disadvantages of this solution are:
</para>

<orderedlist>
<listitem><para>Requiring pre processing of source code with a perl script</para></listitem>
<listitem><para>The computational effort expended in data serialization</para></listitem>
<listitem><para>MORE?</para></listitem>
</orderedlist>
</sect1>


<sect1><title>Conclusion</title>
<para>
This paper has described <command>trivsql</command>, a SQL engine which can be embedded into your code. This code is still a work in progress, and updates on it's development can be found at http://www.stillhq.com
</para>
</sect1>






<sect1><title>Code listings</title>
<para>
All the code included here is available for download from http://www.stillhq.com.
</para>

<sect2><title>SQL lexer</title>
<para>
The lexer for my SQL implementation is:
</para>

<programlisting>
%{

#include "parser.h"

#undef YY_INPUT
#define YY_INPUT(b, r, ms) (r = trivsql_gettext(b, ms))
%} 

%%

[Ss][Ee][Ll][Ee][Cc][Tt]                   { return SELECT; }
[Cc][Rr][Ee][Aa][Tt][Ee]                   { return CREATE; }
[Ii][Nn][Ss][Ee][Rr][Tt]                   { return INSERT; }
[Vv][Aa][Ll][Uu][Ee][Ss]                   { return VALUES; }
[Ii][Nn][Tt][Oo]                           { return INTO; }
[Tt][Aa][Bb][Ll][Ee]                       { return TABLE; }
[Ff][Rr][Oo][Mm]                           { return FROM; }
[Ww][Hh][Ee][Rr][Ee]                       { return WHERE; }
[Ll][Ii][Kk][Ee]                           { return LIKE; }
[Aa][Ll][Tt][Ee][Rr]                       { return ALTER; }
[Aa][Dd][Dd]                               { return ADD; }
[Cc][Oo][Ll][Uu][Mm][Nn]                   { return COLUMN; }
[Uu][Pp][Dd][Aa][Tt][Ee]                   { return UPDATE; }
[Ss][Ee][Tt]                               { return SET; }
[Aa][Nn][Dd]                               { return AND; }
[Oo][Rr]                                   { return OR; }

[a-zA-Z0-9%\-]+                            { yylval = trivsql_xsnprintf("%s", yytext); return STRING; }
[ \t\r\n]                                  { }
.                                          { return yytext[0]; }

%%
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/lexer.l</emphasis></para>

<para>
I am not completely happy with this implementation. My main objection is the way I have implemented case insensitivity, although I am not aware of a better method.
</para>
</sect2>

<sect2><title>SQL grammar</title>
<para>
The grammar for my SQL implementation is:
</para>

<programlisting>
%{

  #include &lt;stdio.h&gt;
  #include "trivsql.h"

  #define YYERROR_VERBOSE 1

  trivsql_state *gState;
%}

%token CREATE TABLE 
%token INSERT VALUES INTO
%token SELECT FROM STRING WHERE LIKE
%token ALTER ADD COLUMN
%token UPDATE SET
%token AND OR

%%

sql      : create sql | insert sql | sel sql | alt sql | upd sql
         |
         ;



create   : CREATE TABLE STRING '(' colvalspec ')' ';' 
{ gState-&gt;rs = trivsql_makers((char *) $3); trivsql_docreate((char *) $3, (char *) $5); } 
         ;

insert   : INSERT INTO STRING '(' colvalspec ')' VALUES '(' colvalspec ')' ';'
{ gState-&gt;rs = trivsql_makers((char *) $3); trivsql_checktable((char *) $3, gState-&gt;rs); if(gState-&gt;rs-&gt;errno == TRIVSQL_FALSE){trivsql_doinsert((char *) $3, (char *) $5, (char *) $9);}}
         ;

sel      : SELECT cvsaster FROM STRING { gState-&gt;rs = trivsql_makers((char *) $4); trivsql_xfree(gState-&gt;table); gState-&gt;table = trivsql_xsnprintf("%s", $4); } wsel ';'
{ trivsql_checktable((char *) $4, gState-&gt;rs); if(gState-&gt;rs-&gt;errno == TRIVSQL_FALSE){trivsql_doselect((char *) $4, (char *) $2);}}
         ;

alt      : ALTER STRING ADD COLUMN STRING ';'
{ gState-&gt;rs = trivsql_makers((char *) $2); trivsql_checktable((char *) $2, gState-&gt;rs); if(gState-&gt;rs-&gt;errno == TRIVSQL_FALSE){trivsql_doalter((char *) $2, (char *) $5);}}
         ;

upd      : UPDATE STRING SET STRING '=' str { gState-&gt;rs = trivsql_makers((char *) $2); trivsql_xfree(gState-&gt;table); gState-&gt;table = trivsql_xsnprintf("%s", $2); } wsel ';'
{trivsql_checktable((char *) $2, gState-&gt;rs); if(gState-&gt;rs-&gt;errno == TRIVSQL_FALSE){trivsql_doselect((char *) $2, (char *) $4); trivsql_updaters(gState, gState-&gt;rs, (char *) $4, (char *) $6);}}
         ;



cvsaster : colvalspec { $$ = trivsql_xsnprintf("%s", (char *) $1); }
         | '*' { $$ = trivsql_xsnprintf("*"); }
         ;

colvalspec : str ',' colvalspec { $$ = trivsql_xsnprintf("%s;%s", (char *) $1, (char *) $3); } 
         | str { $$ = trivsql_xsnprintf("%s", (char *) $1); }
         ;

wsel     : WHERE selector { gState-&gt;seltree = $2; }
         |
         ;

selector : str '=' str { $$ = trivsql_makesel(trivsql_selequal, $1, $3); }
         | str LIKE str { $$ = trivsql_makesel(trivsql_sellike, $1, $3); }
         | selector AND selector { $$ = trivsql_makeslr(trivsql_seland, $1, $3); }
         | selector OR selector { $$ = trivsql_makeslr(trivsql_seland, $1, $3); }
         | '(' selector ')' { $$ = $2; }
	 | { $$ = NULL; }
         ;

str      : STRING { $$ = $1; } 
         | '\'' STRING '\'' { $$ = $2; }
         ; 

%%

int yyerror(char *s){
  printf("\nsql parsing error: %s\n", s);
  exit(42);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/parser.y</emphasis></para>
</sect2>

<sect2><title>Automake Makefile.am</title>
<para>
The following file is used to automatically generate a Makefile, in conjunction with <command>autoconf</command>.
</para>

<programlisting>
lib_LTLIBRARIES = libtrivsql.la
noinst_PROGRAMS = sample

libtrivsql_la_SOURCES = parser.y lexer.l tdb.c spinlock.c selectors.c interface.c internal.c

include_HEADERS = trivsql.h trivsql_tdb.h trivsql_spinlock.h

sample_SOURCES = example.c
sample_LDADD = -ltrivsql -L.libs

YFLAGS = -d
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/Makefile.am</emphasis></para>
</sect2>


<sect2><title>Autoconf configure.in</title>
<para>
The following file is used to automatically generate a configure script, which will build a Makefile appropriate to the build host.
</para>

<programlisting>
dnl Process this file with autoconf to produce a configure script.
AC_INIT(lexer.l)
AC_CONFIG_AUX_DIR(config)
AC_REVISION
AM_INIT_AUTOMAKE(trivsql, 0.4.1)
AM_MAINTAINER_MODE

dnl Libtool
AC_LIBTOOL_WIN32_DLL
AC_LIBTOOL_DLOPEN

dnl Checks for programs.
AC_PROG_CC
AM_PROG_LEX
AC_PROG_YACC
AC_PROG_INSTALL
AC_PROG_RANLIB
AM_PROG_LIBTOOL

dnl Checks for libraries.
dnl The syntax is library name, function, action if found, action if not found
dnl We just use the default if found action which adds -l&lt;lib&gt; to the LIBS var
dnl and #defined HAVE_LIB&lt;lib&gt;


dnl -lm:
AC_CHECK_LIB(m, atan)

dnl -lfl:
AC_CHECK_LIB(fl, yywrap)

dnl Checks for header files.
dnl STDC checks for stdlib.h stdarg.h string.h and float.h
AC_HEADER_STDC

dnl Checks for typedefs, structures, and compiler characteristics.

dnl Checks for library functions.

AC_OUTPUT(Makefile)




</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/configure.in</emphasis></para>
</sect2>


<sect2><title>C source code</title>
<para>
The following files implement <command>trivsql</command> and <command>tdb</command>...
</para>

<programlisting>

#include "trivsql_tdb.h"
#include "trivsql_spinlock.h"

#ifndef TRIVSQL_HEADER
#define TRIVSQL_HEADER

#ifdef __cplusplus
extern "C"
{
#endif

#define TRIVSQL_FALSE 0
#define TRIVSQL_TRUE 1

#define TRIVSQL_NOSUCHTABLE 2
#define TRIVSQL_BADVALUES 3
#define TRIVSQL_MEMORYERROR 4
#define TRIVSQL_TDBNULLKEY 5
#define TRIVSQL_TDBNULLDATA 6
#define TRIVSQL_TDBSTOREERROR 7
#define TRIVSQL_NOSUCHCOLUMN 8
#define TRIVSQL_NOROWSTOUPDATE 9
#define TRIVSQL_BADSELCOLARG 10
#define TRIVSQL_DBOPENFAIL 11

#define SELTRUE 1
#define SELFALSE 0

typedef int (*trivsql_selectorfunc) (char *arg1, char *arg2);

typedef struct trivsql_internal_seltreenode
{
  char *selArgOne;
  int selColOne;
  char *selArgTwo;
  int selColTwo;
  trivsql_selectorfunc selector;
  struct trivsql_internal_seltreenode *left, *right;
} trivsql_seltreenode;

typedef struct trivsql_internal_col
{
  char *val;
  char *key;
  struct trivsql_internal_col *next;
} trivsql_col;

typedef struct trivsql_internal_row
{
  trivsql_col *cols;
  struct trivsql_internal_row *next, *prev;
} trivsql_row;

typedef struct trivsql_internal_rs
{
  int numCols;
  int numRows;
  trivsql_row *rows;
  trivsql_row *currentRow;

  char *tname;
  char *cols;

  int errno;
  char *errstring;
} trivsql_recordset;

typedef struct trivsql_internal_state
{
  TDB_CONTEXT *db;
  trivsql_recordset *rs;
  trivsql_seltreenode *seltree;
  char *table;
} trivsql_state;

// Internal functions
trivsql_state *trivsql_init(char *);
void trivsql_docreate(char *, char *);
void trivsql_doinsert(char *, char *, char *);
void trivsql_doselect(char *, char *);
void trivsql_doalter(char *, char *);

int *trivsql_parsecols(char *, char *, int *);
int trivsql_findcol(char *, char *, char *);
void trivsql_addrow(trivsql_recordset *, char *, int, int *);
char *trivsql_getallcolumns(char *);
trivsql_recordset *trivsql_makers();
trivsql_seltreenode *trivsql_makest();
trivsql_seltreenode* trivsql_makesel(trivsql_selectorfunc, char *, char *);
trivsql_seltreenode* trivsql_makeslr(trivsql_selectorfunc,
				     trivsql_seltreenode *,
				     trivsql_seltreenode *);
int trivsql_executeselector(trivsql_seltreenode *, int);

void trivsql_checktable(char *, trivsql_recordset *);

void *trivsql_xmalloc(size_t);
void trivsql_dbwrite(trivsql_state *, char *, char *);
char *trivsql_dbread(trivsql_state *, char *);
char *trivsql_xsnprintf(char *, ...);
void trivsql_xfree(void *);
void *trivsql_xrealloc(void *, size_t);
int trivsql_min(int, int);
int trivsql_initok(trivsql_state *);

// Selectors
int trivsql_selequal(char *, char *);
int trivsql_sellike(char *, char *);
int trivsql_selor(int, int);
int trivsql_seland(int, int);

// Interface methods
trivsql_state *trivsql_opendb(char *);
trivsql_recordset *trivsql_execute(trivsql_state *, char *);
int trivsql_gettext(char *, int);
void trivsql_displayrs(trivsql_recordset *);
void trivsql_rsmovefirst(trivsql_recordset *);
void trivsql_rsmovenext(trivsql_recordset *);
int trivsql_rseof(trivsql_recordset *);
int trivsql_rsbof(trivsql_recordset *);
char *trivsql_rsfield(trivsql_recordset *, int);
void trivsql_updaters(trivsql_state *, trivsql_recordset *, char *, char *);
void trivsql_rsupdatefield(trivsql_state *, trivsql_recordset *, 
			   int, char *newval);

#ifdef __cplusplus
}
#endif

#endif
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/trivsql.h</emphasis></para>
<programlisting>

#include "trivsql.h"

char *gTrivData = NULL;
int gTrivInset;

extern trivsql_state *gState;

// Interface to the SQL database
trivsql_state *trivsql_opendb(char *path){
  return trivsql_init(path);
}

trivsql_recordset *trivsql_execute(trivsql_state *state, char *sql){
  trivsql_xfree(gTrivData);
  gTrivData = trivsql_xsnprintf("%s", sql);
  gTrivInset = 0;

  trivsql_xfree(state-&gt;rs);
  state-&gt;rs = NULL;
  gState = state; 
  yyparse();
  return gState-&gt;rs;
}

int trivsql_gettext(char *buffer, int maxlen){
  int size;

  // Determine the maximum size to return
  size = trivsql_min(maxlen, strlen(gTrivData) - gTrivInset);

  if(size &gt; 0){
    memcpy(buffer, gTrivData + gTrivInset, size);
    gTrivInset += size;
  }

  return size;
}

void trivsql_displayrs(trivsql_recordset *rs){
  int i, col;
  char *t, *u, *c, *localCols;

  // Was there an error?
  switch(rs-&gt;errno){
  case TRIVSQL_FALSE:
    printf("This statement produced no results.\n");
    return;

  case TRIVSQL_TRUE:
    break;

  default:
    printf("There was an error processing this statement (%d).\n",
	   rs-&gt;errno);
    if(rs-&gt;errstring != NULL)
      printf("trivsql engine reported: %s\n", rs-&gt;errstring);
    return;
  }

  // Print the header line
  printf("\n=");
  for(i = 0; i &lt; rs-&gt;numCols; i++){
    printf("===============");
  }
  printf("\n|");

  // Print out the column names
  localCols = trivsql_xsnprintf("%s", rs-&gt;cols);
  c = strtok(localCols, ";");
  while(c != NULL){
    printf(" %-12s |", c);
    c = strtok(NULL, ";");
  }
  
  printf("\n=");
  for(i = 0; i &lt; rs-&gt;numCols; i++){
    printf("===============");
  }
  printf("\n");

  // Print out the values we have found
  trivsql_rsmovefirst(rs);
  while(trivsql_rseof(rs) != TRIVSQL_TRUE){
    for(i = 0; i &lt; rs-&gt;numCols; i++)
      printf("| %-12s ", trivsql_rsfield(rs, i));
    printf("|\n-");
    for(i = 0; i &lt; rs-&gt;numCols; i++){
      printf("---------------");
    }
    printf("\n");

    trivsql_rsmovenext(rs);
  }

  printf("\n");
  printf("Select returned %d rows of %d columns\n", 
	 rs-&gt;numRows, rs-&gt;numCols);
}

void trivsql_rsmovefirst(trivsql_recordset *rs){
  rs-&gt;currentRow = rs-&gt;rows;
}

void trivsql_rsmovenext(trivsql_recordset *rs){
  if(rs-&gt;currentRow-&gt;next != NULL)
    rs-&gt;currentRow = rs-&gt;currentRow-&gt;next;
}

int trivsql_rseof(trivsql_recordset *rs){
  if(rs-&gt;errno != TRIVSQL_TRUE) return TRIVSQL_TRUE;
  return rs-&gt;currentRow-&gt;next == NULL ? TRIVSQL_TRUE : TRIVSQL_FALSE;
}

int trivsql_rsbof(trivsql_recordset *rs){
  return rs-&gt;currentRow == rs-&gt;rows ? TRIVSQL_TRUE : TRIVSQL_FALSE;
}

char *trivsql_rsfield(trivsql_recordset *rs, int colnum){
  int count;
  trivsql_col *theCol;

  count = 0;
  theCol = rs-&gt;currentRow-&gt;cols;
  while((theCol-&gt;next != NULL) &amp;&amp; (count &lt; colnum)){
    theCol = theCol-&gt;next;
    count++;
  }

  return theCol-&gt;val;
}

void trivsql_updaters(trivsql_state *state, trivsql_recordset *rs, 
		      char *col, char *newval){
  // Was there an error?
  switch(rs-&gt;errno){
  case TRIVSQL_FALSE:
    gState-&gt;rs-&gt;errno = TRIVSQL_NOROWSTOUPDATE;
    return;

  case TRIVSQL_TRUE:
    break;

  default:
    return;
  }

  // For the moment we assume there is only one column
  trivsql_rsmovefirst(rs);
  while(trivsql_rseof(rs) != TRIVSQL_TRUE){
    trivsql_rsupdatefield(state, rs, 0, newval);
    trivsql_rsmovenext(rs);
  }
}

// NOTE: The existing recordset is not updated -- you need to reselect
void trivsql_rsupdatefield(trivsql_state *state, trivsql_recordset *rs, 
			   int colnum, char *newval){
  int count;
  trivsql_col *theCol;

  count = 0;
  theCol = rs-&gt;currentRow-&gt;cols;
  while((theCol-&gt;next != NULL) &amp;&amp; (count &lt; colnum)){
    theCol = theCol-&gt;next;
    count++;
  }

  trivsql_dbwrite(state, theCol-&gt;key, newval);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/interface.c</emphasis></para>
<programlisting>

#include "trivsql.h"
#include &lt;stdarg.h&gt;

extern trivsql_state *gState;
const char *trivsql_version = VERSION;

trivsql_state *trivsql_init(char *filename){
  trivsql_state *state;

  state = (trivsql_state *) trivsql_xmalloc(sizeof(trivsql_state));
  state-&gt;db = tdb_open(filename, 0, 0, O_RDWR | O_CREAT, 0600);
  state-&gt;rs = NULL;
  state-&gt;seltree = NULL;
  state-&gt;table = NULL;

  // We write the version of trivsql we used into a tag in the tdb for 
  // debugging
  if(state-&gt;db != NULL)
    trivsql_dbwrite(state, "trivsql_lastversion", trivsql_version);  

  return state;
}

void trivsql_docreate(char *tname, char *cols)
{
  char *t;
  char *u;
  int colCount = 0;

  t = trivsql_xsnprintf("trivsql_%s_numrows", tname);
  trivsql_dbwrite(gState, t, "0");
  trivsql_xfree(t);

  u = strtok(cols, ";");
  while(u != NULL){
    t = trivsql_xsnprintf("trivsql_%s_col%d", tname, colCount);
    trivsql_dbwrite(gState, t, u);
    trivsql_xfree(t);

    colCount++;
    u = strtok(NULL, ";");
  }

  t = trivsql_xsnprintf("trivsql_%s_numcols", tname);
  u = trivsql_xsnprintf("%d", colCount);
  trivsql_dbwrite(gState, t, u);
  trivsql_xfree(t);
  trivsql_xfree(u);
} 

void trivsql_doinsert(char *tname, char *cols, char *vals){
  char *t, *u, *c;
  int rowCount, i, col, numCols;
  int *colNumbers;

  if((rowCount = trivsql_getrowcount(tname)) == -1){
    return;
  }
  
  // Get ready for columns
  if((colNumbers = trivsql_parsecols(tname, cols, &amp;numCols)) == NULL){
    return;
  }

  // How we have the right number of values?
  col = 1;
  for(i = 0; i &lt; strlen(vals); i++)
    if(vals[i] == ';')
      col++;
  
  if(col != numCols){
    gState-&gt;rs-&gt;errno = TRIVSQL_BADVALUES;
    return;
  }

  // Save each column value
  c = strtok(vals, ";");
  col = 0;
  while(c != NULL){
    t = trivsql_xsnprintf("trivsql_%s_col%drow%d", tname, colNumbers[col], rowCount);
    trivsql_dbwrite(gState, t, c);
    trivsql_xfree(t);
    
    c = strtok(NULL, ";");
    col++;
  }

  // And we should keep count of how many of the rows are in the table
  t = trivsql_xsnprintf("trivsql_%s_numrows", tname);
  u = trivsql_xsnprintf("%d", rowCount + 1);
  trivsql_dbwrite(gState, t, u);
  trivsql_xfree(t);
  trivsql_xfree(u);
}

void trivsql_doselect(char *tname, char *cols){
  int *colNumbers;
  int row, rowCount, numCols;
  char *t, *u, *localCols;

  // If the columns list is '*', substitute a list of all the columns
  if(strcmp(cols, "*") == 0)
    localCols = trivsql_getallcolumns(tname);
  else
    localCols = cols;

  // Get ready for columns
  if((colNumbers = trivsql_parsecols(tname, localCols, &amp;numCols)) == NULL){
    return;
  }

  // Populate recordset
  gState-&gt;rs-&gt;numCols = numCols;
  gState-&gt;rs-&gt;cols = trivsql_xsnprintf("%s", localCols);
  gState-&gt;rs-&gt;errno = TRIVSQL_TRUE;

  // Decide what rows on the table match the select condition
  if((rowCount = trivsql_getrowcount(tname)) == -1){
    return;
  }

  for(row = 0; row &lt; rowCount; row++){
    if(trivsql_executeselector(gState-&gt;seltree, row) == SELTRUE)
      trivsql_addrow(gState-&gt;rs, tname, row, colNumbers);
  }
}

void trivsql_doalter(char *tname, char *cols)
{
  char *t;
  char *u;
  int colCount = 0;

  t = trivsql_xsnprintf("trivsql_%s_numcols", tname);
  u = trivsql_dbread(gState, t);
  if(u == NULL) colCount = 0;
  else colCount = atoi(u);
  trivsql_xfree(t);
  trivsql_xfree(u);

  // Add the column
  t = trivsql_xsnprintf("trivsql_%s_col%d", tname, colCount);
  trivsql_dbwrite(gState, t, cols);
  trivsql_xfree(t);
  colCount++;

  t = trivsql_xsnprintf("trivsql_%s_numcols", tname);
  u = trivsql_xsnprintf("%d", colCount);
  trivsql_dbwrite(gState, t, u);
  trivsql_xfree(t);
  trivsql_xfree(u);
} 

void *
trivsql_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      // todo_mikal: improve this
      fprintf(stderr, "trivsql memory allocation error");
      exit(42);
    }

  return buffer;
}

void
trivsql_dbwrite (trivsql_state *state, char *key, char *value)
{
  TDB_DATA dbkey, dbdata;

  if (key == NULL){
    gState-&gt;rs-&gt;errno = TRIVSQL_TDBNULLKEY;
    return;
  }

  if (value == NULL){
    gState-&gt;rs-&gt;errno = TRIVSQL_TDBNULLDATA;
    return;
  }

  // We need to build the structures for the TDB call
  dbkey.dptr = key;
  dbkey.dsize = strlen (key) + 1;
  dbdata.dptr = value;
  dbdata.dsize = strlen (value) + 1;

  if (tdb_store (state-&gt;db, dbkey, dbdata, TDB_REPLACE) != 0)
    {
      gState-&gt;rs-&gt;errno = TRIVSQL_TDBSTOREERROR;
      return;
    }
}

char *
trivsql_dbread (trivsql_state *state, char *key)
{
  TDB_DATA dbkey, dbdata;

  if (key == NULL){
    gState-&gt;rs-&gt;errno = TRIVSQL_TDBNULLKEY;
    return NULL;
  }

  // We need to build the structures for the TDB call
  dbkey.dptr = key;
  dbkey.dsize = strlen (key) + 1;

  dbdata = tdb_fetch (state-&gt;db, dbkey);

  return dbdata.dptr;
}

char *
trivsql_xsnprintf (char *format, ...)
{
  char *output = NULL;
  int size, result;
  va_list ap;

  /* We start with the size of the format string as a guess */
  size = strlen (format);
  va_start (ap, format);

  while (1)
    {
      output = (char *) trivsql_xrealloc (output, size);
      result = vsnprintf (output, size, format, ap);

      if (result == -1)
        {
          /* Up to glibc 2.0.6 and Microsoft's implementation */
          size += 100;
        }
      else
        {
          /* Check if we are done */
          if (result &lt; size)
            break;

          /* Glibc from now on */
          size = result + 1;
        }
    }

  va_end (ap);
  return output;
}

void
trivsql_xfree (void *memory)
{
  if (memory != NULL)
    free(memory);
}

void *
trivsql_xrealloc (void *memory, size_t size)
{
  void *buffer;

  if ((buffer = realloc (memory, size)) == NULL)
    {
      fprintf(stderr, "Realloc of memory failed");
      exit(42);
    }

  return buffer;
}

int *trivsql_parsecols(char *tname, char *cols, int *numCols){
  int i, col;
  int *colNumbers = NULL;
  char *t, *u, *coltmp, *c;

  // How many columns do we have?
  *numCols = 1;
  for(i = 0; i &lt; strlen(cols); i++)
    if(cols[i] == ';')
      (*numCols)++;

  coltmp = trivsql_xsnprintf("%s", cols);
  colNumbers = trivsql_xmalloc(sizeof(int) * (*numCols));
  
  // Determine that the named columns exist
  col = 0;
  c = strtok(coltmp, ";");
  while(c != NULL){
    i = 0;
    while(1){
      t = trivsql_xsnprintf("trivsql_%s_col%d", tname, i);
      u = trivsql_dbread(gState, t);

      if(u == NULL){
	trivsql_xfree(t);
	// todo_mikal: this make break if used during a selection...
	gState-&gt;rs-&gt;errno = TRIVSQL_NOSUCHCOLUMN;
	gState-&gt;rs-&gt;errstring = trivsql_xsnprintf("The column \"%s\" does not exist in the table \"%s\" (search inset is %d).", c, tname, i);
	return NULL;
      }
      else if(strcmp(u, c) == 0){
	trivsql_xfree(t);
	trivsql_xfree(u);
	break;
      }

      trivsql_xfree(t);
      trivsql_xfree(u);
      i++;
    }

    colNumbers[col] = i;
    c = strtok(NULL, ";");
    col++;
  }

  return colNumbers;
}

int trivsql_findcol(char *tname, char *cols, char *col){
  char *t, *u, *coltmp, *c;
  int colNum;

  coltmp = trivsql_xsnprintf("%s", cols);
  colNum = 0;

  // Determine that the named columns exist
  c = strtok(coltmp, ";");
  while(c != NULL){
    if(strcmp(c, col) == 0)
      return colNum;

    c = strtok(NULL, ";");
    colNum++;
  }

  return -1;
}

int trivsql_getrowcount(char *tname){
  char *t, *u;
  int rowCount;

  // Determine if the table exists, and if so how many rows it has
  t = trivsql_xsnprintf("trivsql_%s_numrows", tname);
  u = trivsql_dbread(gState, t);
  
  if(u == NULL){
    gState-&gt;rs-&gt;errno = TRIVSQL_NOSUCHTABLE;
    gState-&gt;rs-&gt;errstring = trivsql_xsnprintf("Could not determine the row count for the table \"%s\" because the table does not exist", tname);
    return -1;
  }

  rowCount = atoi(u);
  trivsql_xfree(u);
  trivsql_xfree(t);

  return rowCount;
}

void trivsql_addrow(trivsql_recordset *rs, char *tname, int row, int *cols){
  char *t;
  int colCount;
  trivsql_row *theRow;
  trivsql_col *theCol;

  // Make space for the new row
  rs-&gt;numRows++;
  theRow = rs-&gt;rows;
  while(theRow-&gt;next != NULL)
    theRow = theRow-&gt;next;

  theRow-&gt;next = trivsql_xmalloc(sizeof(trivsql_row));
  theRow-&gt;next-&gt;next = NULL;

  theRow-&gt;cols = trivsql_xmalloc(sizeof(trivsql_col));
  theRow-&gt;cols-&gt;next = NULL;
  theCol = theRow-&gt;cols;

  // Get the row
  for(colCount = 0; colCount &lt; rs-&gt;numCols; colCount++){
    t = trivsql_xsnprintf("trivsql_%s_col%drow%d", tname, cols[colCount], row);

    theCol-&gt;val = trivsql_dbread(gState, t);
    theCol-&gt;key = t;
    theCol-&gt;next = trivsql_xmalloc(sizeof(trivsql_col));
    theCol-&gt;next-&gt;next = NULL;
    theCol = theCol-&gt;next;
  }
}

char *trivsql_getallcolumns(char *tname)
{
  char *t, *u, *retVal, *retVal2;
  int i, maxCols;

  t = trivsql_xsnprintf("trivsql_%s_numcols", tname);
  u = trivsql_dbread(gState, t);
  if(u == NULL) maxCols = 0;
  else maxCols = atoi(u);
  trivsql_xfree(t);
  trivsql_xfree(u);

  retVal = trivsql_xsnprintf("");

  for(i = 0; i &lt; maxCols; i++){
      t = trivsql_xsnprintf("trivsql_%s_col%d", tname, i);
      u = trivsql_dbread(gState, t);

      if(strcmp(retVal, "") != 0)
	retVal2 = trivsql_xsnprintf("%s;%s", retVal, u);
      else
	retVal2 = trivsql_xsnprintf("%s", u);

      trivsql_xfree(t);
      trivsql_xfree(u);
      trivsql_xfree(retVal);
      retVal = retVal2;
  }

  return retVal;
} 

int trivsql_min(int a, int b){
  if(a &gt; b) return b;
  return a;
}

void trivsql_checktable(char *tname, trivsql_recordset *rs){
  char *t, *u;
  
  t = trivsql_xsnprintf("trivsql_%s_numrows", tname);
  u = trivsql_dbread(gState, t);
  trivsql_xfree(t);
 
  if(u == NULL){
    (*rs).errno = TRIVSQL_NOSUCHTABLE;
    (*rs).errstring = trivsql_xsnprintf("Existance check for the table \"%s\" determined that the table does not exist.", tname);
  }
}

trivsql_recordset* trivsql_makers(char *tname){
  trivsql_recordset *rrs;

  // Build the recordset
  rrs = trivsql_xmalloc(sizeof(trivsql_recordset));
  rrs-&gt;rows = trivsql_xmalloc(sizeof(trivsql_row));
  rrs-&gt;rows-&gt;next = NULL;
  rrs-&gt;rows-&gt;cols = NULL;
  rrs-&gt;numCols = 0;
  rrs-&gt;numRows = 0;
  rrs-&gt;tname = trivsql_xsnprintf("%s", tname);
  rrs-&gt;currentRow = rrs-&gt;rows;
  rrs-&gt;errno = TRIVSQL_FALSE;
  rrs-&gt;errstring = NULL;
  rrs-&gt;cols = NULL;

  if(gState-&gt;db == NULL){
    rrs-&gt;errno = TRIVSQL_DBOPENFAIL;
  }

  return rrs;
}

trivsql_seltreenode* trivsql_makest(){
  trivsql_seltreenode *rst;

  // Build the recordset
  rst = trivsql_xmalloc(sizeof(trivsql_seltreenode));
  rst-&gt;selArgOne = NULL;
  rst-&gt;selColOne = -1;
  rst-&gt;selArgTwo = NULL;
  rst-&gt;selColTwo = -1;
  rst-&gt;selector = NULL;
  rst-&gt;left = NULL;
  rst-&gt;right = NULL;

  return rst;
}

trivsql_seltreenode* trivsql_makesel(trivsql_selectorfunc func, char *a1, 
				     char *a2){
  int *colNumbers, numCols;

  trivsql_seltreenode *tst = trivsql_makest(); 
  tst-&gt;selector = func;

  if((colNumbers = trivsql_parsecols(gState-&gt;table, a1, &amp;numCols)) == NULL){
      tst-&gt;selArgOne = a1;
      gState-&gt;rs-&gt;errno = TRIVSQL_FALSE;
  }
  else{
      tst-&gt;selColOne = colNumbers[0];
  }
  trivsql_xfree(colNumbers);

  if((colNumbers = trivsql_parsecols(gState-&gt;table, a2, &amp;numCols)) == NULL){
      tst-&gt;selArgTwo = a2;
      gState-&gt;rs-&gt;errno = TRIVSQL_FALSE;
  }
  else{
      tst-&gt;selColTwo = colNumbers[0];
  }
  trivsql_xfree(colNumbers);

  return tst;
}

trivsql_seltreenode* trivsql_makeslr(trivsql_selectorfunc func,
				     trivsql_seltreenode *left,
				     trivsql_seltreenode *right){
  trivsql_seltreenode* tst = trivsql_makest();
  tst-&gt;selector = func;
  tst-&gt;left = left;
  tst-&gt;right = right;
}

int trivsql_executeselector(trivsql_seltreenode* node, int row){
  char *a1, *a2, *t;

  if(node == NULL)
    return SELTRUE;

  if(((node-&gt;selArgOne != NULL) || (node-&gt;selColOne != -1)) &amp;&amp;
     ((node-&gt;selArgTwo != NULL) || (node-&gt;selColTwo != -1))){
    if(node-&gt;selColOne == -1)
      a1 = node-&gt;selArgOne;
    else{
      t = trivsql_xsnprintf("trivsql_%s_col%drow%d", gState-&gt;table, 
			    node-&gt;selColOne, row);
      a1 = trivsql_dbread(gState, t);
      trivsql_xfree(t);

      if(a1 == NULL)
	return SELFALSE;
    }
    
    if(node-&gt;selColTwo == -1)
      a2 = node-&gt;selArgTwo;
    else{
      t = trivsql_xsnprintf("trivsql_%s_col%drow%d", gState-&gt;table, 
			    node-&gt;selColTwo, row);
      a2 = trivsql_dbread(gState, t);
      trivsql_xfree(t);

      if(a2 == NULL)
	return SELFALSE;
    }
    
    return (node-&gt;selector)(a1, a2);
  }
 
  return (node-&gt;selector)(trivsql_executeselector(node-&gt;left, row),
			  trivsql_executeselector(node-&gt;right, row));
}

int trivsql_initok(trivsql_state *state){
  if(state-&gt;db == NULL)
    return TRIVSQL_FALSE;
  return TRIVSQL_TRUE;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/internal.c</emphasis></para>
<programlisting>

#include "trivsql.h"
#include &lt;string.h&gt;

int trivsql_selequal(char *arg1, char *arg2){
  if(strcmp(arg1, arg2) == 0) return SELTRUE;
  return SELFALSE;
}

// todo: implement %'s
int trivsql_sellike(char *arg1, char *arg2){
  int front = 0, back = 0, ret;
  char *sel, *str;

  sel = strdup(arg2);

  if(arg2[0] == '%'){
    front = 1;
    sel++;
  }

  if(arg2[strlen(arg2) - 1] == '%'){
    back = 1;
    sel[strlen(sel) - 1] = '\0';
  }

  printf("%d %d (%s)\n", front, back, sel);

  if((str = strstr(arg1, sel)) != NULL){
    if((front == 1) &amp;&amp; (str == arg1))
      ret = SELFALSE;
    else
      ret = SELTRUE;
  }
  else ret = SELFALSE;

  //trivsql_xfree(sel);
  return ret;
}

int trivsql_selor(int left, int right){
  if(left == SELTRUE) return SELTRUE;
  if(right == SELTRUE) return SELTRUE;
  return SELFALSE;
}

int trivsql_seland(int left, int right){
  if(left == SELFALSE) return SELFALSE;
  if(right == SELFALSE) return SELFALSE;
  return SELTRUE;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/selectors.c</emphasis></para>
<programlisting>

#include &lt;stdio.h&gt;
#include "trivsql.h"

int main(int argc, char *argv[]){
  trivsql_state *ourState;
  trivsql_recordset *rs;
  char cmd[1000];

  if(argc != 2){
    fprintf(stderr, "Please specify a db file\n");
    exit(42);
  }

  ourState = trivsql_opendb(argv[1]);
  if(trivsql_initok(ourState) != TRIVSQL_TRUE){
    fprintf(stderr, "Database open failed\n");
    exit(42);
  }

  while(fgets(cmd, 1000, stdin) != NULL){
    rs = trivsql_execute(ourState, cmd);
    if(rs != NULL) trivsql_displayrs(rs);
    else printf("NULL recordset\n");
    trivsql_xfree(rs);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/trivsql/example.c</emphasis></para>

<para>
I haven't included the TDB code, as it is not strictly part of <command>trivsql</command>, and may be downloaded from http://www.samba.org
</para>
</sect2>
</sect1>
</article>
