<!--these sections will sit under sect1 - Implementation Issues-->

<sect2><title>Windowing</title>

  <sect3><title>Introduction</title>
  <para></para>
  </sect3> <!--Introduction-->

  <sect3><title>Research</title>
    <para>
      Locating algorithms for the implementation of the initial windowing algorithms was trivial.
      these are all well documented and are easily implemented. Dolph-Chebyshev window algorithm
      was a little more elusive. initial attempts to implement this algorithm were unsuccessful.
      2 different tacks were taken. Initially an attempt was made to implement this purely in the
      timen domain, based on an algorihtm sourced from the speech recognition research at
      the Institute for Signal and Information Processing, ISIP, located at Mississippi State University.
      After many hours spent trying to validate the algorithm to it was decided that this could not be used.
      A second attempt was made using a window generateed int the frequency domain, using code based on the
      orignal 1947 paper by Dolph. This algorithm only supported odd window sizes, and its use of the ifft
      required that its size be 2<superscript>n</superscript>. This was unsatisfactory. The final algorithm 
      that was implemented is based on fortran code published in 1977 by IEEE Acoustics, Speech, and Signal Processing Society,
      <!--TODO put this in the references section-->
    </para>
  </sect3> <!--research-->

  <sect3><title>Implementation</title>
  <para>
    The windowing subsystem is designed to be extensible. Using OO techniques, a general algorithm for generating
    the window is combined with a specialiesed class which generates the individual coefficient. This means that to
    add another algorithm costs as little 10 lines of code, including user interface integration.
  </para>
  <para>
    For all windows, coefficients can be generated for an arbitrary window size. The requirement that
    the windowed data can be converted to the Fourier domain imposes futher limitation in that
    the Fourier libraries we are using will only operate on a data set of size 2^n ( 0 &amp; n &amp; inf);
    This restriction has been implmented at the UI level, maintaining the flexibility of the
    windowing subsystem.
  </para>
  <para>
       The actual algorithms implemented are as follows
    <itemizedlist>
        <listitem><para>Hanning: implemented using the time honoured formula coeff(i) = 0.50 - 0.50*cos( 2*PI*i/(size-1) );</para></listitem>
        <listitem><para>Hamming: implemented using the time honoured formula coeff(i) = 0.54 - 0.46*cos( 2*PI*i/(size-1) );</para></listitem>
        <listitem><para>Blackman: this was added at a simlar time coeff(i) = 0.42 - 0.5*cos( 2*PI*val ) + 0.08*cos(4*PI* i/(size-1));</para></listitem>
        <listitem><para>Dolph-Chebychev
          chebyshev is implemeted as the inverse DFT of the chebyshev polynomial evaluated
          at N equally spaced frequencies on the unit circle the equation for the nth order
          chebyshev equation clculated at x is
          cheb(n,x) = cos(n*acos(x(ind)))</para></listitem>  
        <listitem><para>etc..</para></listitem>  
     </itemizedlist>
   </para>

   <sect4><title>Speed/ Optimisations</title>
   <para>
     <itemizedlist>
	<listitem><para>Calulation of window coefficients are performed only when the algorithm is changed, or paramters
            are altered.</para></listitem>
	<listitem><para>For the simpler algorithms, speed is not an issue. The most expensive of these algorithms [blackman]
            2 cosines and 6 muliplications. this is inexpensive when considering the frequency at which recalulation
            will be required, and the relatively small size of the window required.</para></listitem>
	<listitem><para>Dolph-Chebyshev will be more expensive. The code that is implmented is based on a FORTRAN algorithm. This
            has been implmented as faithfully as possible so as to maintain the integrity of the window coefficients.
            The support the ability of the user to request a window of arbitrary size, this particular window algorithm
            implements is own inverse fourier transform.</para></listitem>

            <!-- TODO - insert an example of the ifft here -->
     </itemizedlist>
    </para>
    </sect4>
    <sect4><title>Assess alternative algorithms</title>
       <para> 
          This has been designed to be easily extensible. A new algorithm can be added by specialising
          the cepWindowAlg class and overriding the getValue method.
          A new windowing algorithm can be added at the expense of less than 10 lines of code (with the
          exception of those such as dolph-chebyshev who require alot more attention)
       </para>
     </sect4>
     
  </sect3> <!--Implementation-->

  <sect3><title>Future Enahncements</title>
  <para>
    <itemizedlist>
    	<listitem><para>- possibility of adding more windowing algorthms</para></listitem>
	<listitem><para>- possible optimisation of the dolph-chebyshev code</para></listitem>
    </itemizedlist>
  </para>

  </sect3> <!--Future Enahncements-->

  <sect3><title>References</title>
  <para>
  <!--
    http://www.maths.tcd.ie/~plynch/Publications/Dolph.pdf
    http://www.isip.msstate.edu/projects/speech/software/documentation/class/algo/Window/
    http://www.octave.org/octave-lists/archive/octave-sources.2002/msg00019.html
    "Programs for Digital Signal Processing", IEEE Acoustics, Speech, and Signal Processing Society, 1977
    dolph
  -->
  </para>
  </sect3>


</sect2> <!--Windowing-->

