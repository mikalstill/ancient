<!--these sections will sit under sect1 - Implementation Issues-->

<sect2><title>User Interface</title>

<sect3><title>Introduction</title>
<para>
The <command>GDMS</command> user interface is the most prominent part of the application. It is the main way in which the user experiences the application. <command>GDMS</command> currently supports two user interface variants:
</para>

<itemizedlist>
<listitem><para>The X windows user interface (the program called <command>gdms</command>)</para></listitem>
<listitem><para>The batch user interface (the program called <command>gdms-batch</command>)</para></listitem>
</itemizedlist>

<para>
This section will mainly discuss the research undertaken for implementing the X windows user interface. This is partially because the scale of implementation required was much greater for this variant, but is also because there were many more alternatives available for this variant.
</para>
</sect3> <!--Introduction-->

<sect3><title>X windows user interface</title>
<para>
wx, qt, gtk, kde, gnome
</para>
</sect3>

<sect3><title>Batch user interface</title>
<para>
There are two common implementation methodologies for scripting languages. Both of these were considered for the <command>GDMS</command> implementation. The most common manner for implementing the parser and grammar for a scripting language is by using the compiler construction tools <command>yacc</command>, and <command>lex</command> (or their free versions, <command>bison</command> and <command>flex</command>). 
</para>

<sect4><title>Compiler construction tools</title>
<para>
<command>lex</command> and <command>flex</command> are parser generation tools. They take a lexical specification file, and generate a LALR finite state machine for matching input strings (Aho, Sethi &amp; Ullman 1986). A sample of a lexical specification is shown below (in this case for the PDF file format):
</para>

<programlisting>
&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { 
  debuglex(yytext, -1, "version");
  yylval.sval.data = (char *) returnStr(yytext, -1);
  yylval.sval.len = yyleng;
  return VERSION;
  }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { 
  debuglex(yytext, -1, "floating point");
  yylval.sval.data = (char *) returnStr(yytext, yyleng);
  yylval.sval.len = yyleng; 
  return FP; 
  }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt; { 
  debuglex(yytext, -1, "floating point");
  yyless(yyleng - 2);
  yylval.sval.data = (char *) returnStr(yytext, yyleng);
  yylval.sval.len = yyleng;
  return FP;
  } 
</programlisting>

<para>
In this example, two tokens are defined, VERSION, and FP. The syntax for these specifications is fairly trivial. The first field, which is wrapped in angled brackets, is the name of the state that the specification should be used in. All of the examples shown here are for the default state, known as INITIAL (Levin, Mason &amp; Brown 1990). What follows this is a posix compliant regular expression to be matched. Finally, within the braces is some c code to execute which a match occurs.
</para>

<para>
In each of these examples, the c code writes a log entry for the match, setups up the data structure symbolizing the match, and then returns the name of the lexicial token which was matched.
</para>

<para>
<command>yacc</command> and <command>bison</command> define the grammer which uses the tokens defined by <command>lex</command> or <command>flex</command>. In effect, this defines valid orders for the tokens to appear in, and what operations should be performed when a set of tokens is matched. Error handling for undefined token combinations is also supplied by the grammar (with hooks for reporting to the user in a manner which is appropriate to that particular application.
</para>

<para>
A sample grammar specification, in this case for SQL (Connolly &amp; Begg 1998) is as follows:
</para>

<programlisting>
sql      : create sql | insert sql | select sql
         |
         ;

create   : CREATE TABLE STRING '(' colvalspec ')' ';' {} 
         ;

insert   : INSERT INTO STRING '(' colvalspec ')' VALUES 
           '(' colvalspec ')' ';' {}
         ;

select   : SELECT cvsaster FROM STRING {} wsel ';' {}
</programlisting>

<para>
A grammar consists of three building blocks. Each of the tokens which can be returned by the lexer is termed a <emphasis>terminal</emphasis>. Examples from above include <emphasis>CREATE</emphasis>, <emphasis>TABLE</emphasis>, <emphasis>STRING</emphasis>, <emphasis>INSERT</emphasis>, <emphasis>INTO</emphasis>, <emphasis>VALUES</emphasis>, and <emphasis>SELECT</emphasis>. These terminals are used by <emphasis>non-terminals</emphasis>, such as <emphasis>sql</emphasis>, <emphasis>create</emphasis>, <emphasis>insert</emphasis>, and <emphasis>select</emphasis> from the example above. The rule which groups a non-terminal with a series of other non-terminals, and terminals, is called a <emphasis>production</emphasis> (Aho, Sethi &amp; Ullman 1986).
</para>

<para>
This grammar defines a language in which a SQL statement can consist of either a <emphasis>create</emphasis>, a <emphasis>insert</emphasis>, or a <emphasis>select</emphasis> statement, as shown by the sql production. The empty non-terminal on the sql production is so that an end of file or empty line is also matched. Because the <emphasis>sql</emphasis> non-terminal
</para>

<para>
It should also be noted that the sql production is recursive, except for this case which matches the empty line or end of file.
</para>
</sect4>

<sect4><title>Hand coded parsers</title>
<para>
The alternative to using the compiler construction tools is to develop a language parser by hand. Depending on the complexity of the grammar to be implemented, this can be quite a realistic alternative. On the other hand, if the grammar is complex, then this can rapdily become a problem with a larger scale than implementing the rest of the application.
</para>

<para>
Because the grammar for the scripting language implemented by the batch version of <command>GDMS</command> is fairly trivial (all commands are parsed based on only one line, and no recursion within productions is required), the <command>GDMS</command> team has selected this option.
</para>
</sect4>
</sect3>

  <sect3><title>Implementation</title>
  <para>
       - How was it done?
       - Speed/ Optimisations
  </para>      
  </sect3> <!--Implementation-->
  
  <sect3><title>Integration</title>
  <para></para>
  </sect3> <!--Integration-->


  <sect3><title>Future Enahncements</title>
  <para>
  </para>
  </sect3> <!--Future Enahncements-->


</sect2> <!--UI-->

