<!--these sections will sit under sect1 - Implementation Issues-->

<sect2><title>User Interface</title>

<sect3><title>Introduction</title>
<para>
The <command>GDMS</command> user interface is the most prominent part of the application. It is the main way in which the user experiences the application. <command>GDMS</command> currently supports two user interface variants:
</para>

<itemizedlist>
<listitem><para>The X windows user interface (the program called <command>gdms</command>)</para></listitem>
<listitem><para>The batch user interface (the program called <command>gdms-batch</command>)</para></listitem>
</itemizedlist>

<para>
This section will mainly discuss the research undertaken for implementing the X windows user interface. This is partially because the scale of implementation required was much greater for this variant, but is also because there were many more alternatives available for this variant.
</para>
</sect3> <!--Introduction-->

<sect3><title>Graphical user interface</title>
<para>
There are a plethora graphical user interface toolkits available today. As each has it's advantages, a small survey of the options considered, and then a discussion of why <emphasis>wxWindows</emphasis> was selected seems appropriate.
</para>

<sect4><title>CDE</title>
<para>
...
</para>
</sect4>

<sect4><title>KDE and QT</title>
<para>
KDE development started in October 1996 (KDE 2002), as a replacement for Sun's CDE. KDE is based on Trolltech's qt widget set (Trolltech 2002).
</para>

<figure><title>The default KDE theme, Konquerer</title>
<execute><cmd>img</cmd><args>kde300-snapshot2-320x240.jpg</args></execute>
</figure>

<para>
...
</para>
</sect4>

<sect4><title>Gnome</title>
<para>
...
</para>

<figure><title>The Solaris version of the GNOME desktop</title>
<execute><cmd>img</cmd><args>gnome.png</args></execute>
</figure>
</sect4>

<sect4><title>GTK</title>
<para>
...
</para>
</sect4>

<sect4><title>Microsoft Windows (MFC)</title>
<para>
...
</para>
</sect4>

<sect4><title>wxWindows</title>
<para>
...
</para>
</sect4>

</sect3>

<sect3><title>Windowing toolkit selection</title>
<para>
...
</para>

<para>
As previously mentioned, all of these toolkits require developers to write in c++, which was one of the determining factors in the development of the application.
</para>
</sect3>

<sect3><title>Batch user interface</title>
<para>
There are two common implementation methodologies for scripting languages. Both of these were considered for the <command>GDMS</command> implementation. The most common manner for implementing the parser and grammar for a scripting language is by using the compiler construction tools <command>yacc</command>, and <command>lex</command> (or their free versions, <command>bison</command> and <command>flex</command>). 
</para>

<sect4><title>Compiler construction tools</title>
<para>
<command>lex</command> and <command>flex</command> are parser generation tools. They take a lexical specification file, and generate a LALR finite state machine for matching input strings (Aho, Sethi &amp; Ullman 1986). A sample of a lexical specification is shown below (in this case for the PDF file format):
</para>

<programlisting>
&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { 
  debuglex(yytext, -1, "version");
  yylval.sval.data = (char *) returnStr(yytext, -1);
  yylval.sval.len = yyleng;
  return VERSION;
  }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { 
  debuglex(yytext, -1, "floating point");
  yylval.sval.data = (char *) returnStr(yytext, yyleng);
  yylval.sval.len = yyleng; 
  return FP; 
  }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt; { 
  debuglex(yytext, -1, "floating point");
  yyless(yyleng - 2);
  yylval.sval.data = (char *) returnStr(yytext, yyleng);
  yylval.sval.len = yyleng;
  return FP;
  } 
</programlisting>

<para>
In this example, two tokens are defined, VERSION, and FP. The syntax for these specifications is fairly trivial. The first field, which is wrapped in angled brackets, is the name of the state that the specification should be used in. All of the examples shown here are for the default state, known as INITIAL (Levin, Mason &amp; Brown 1990). What follows this is a posix compliant regular expression to be matched. Finally, within the braces is some c code to execute which a match occurs.
</para>

<para>
In each of these examples, the c code writes a log entry for the match, setups up the data structure symbolizing the match, and then returns the name of the lexicial token which was matched.
</para>

<para>
<command>yacc</command> and <command>bison</command> define the grammer which uses the tokens defined by <command>lex</command> or <command>flex</command>. In effect, this defines valid orders for the tokens to appear in, and what operations should be performed when a set of tokens is matched. Error handling for undefined token combinations is also supplied by the grammar (with hooks for reporting to the user in a manner which is appropriate to that particular application.
</para>

<para>
A sample grammar specification, in this case for SQL (Connolly &amp; Begg 1998) is as follows:
</para>

<programlisting>
sql      : create sql | insert sql | select sql
         |
         ;

create   : CREATE TABLE STRING '(' colvalspec ')' ';' {} 
         ;

insert   : INSERT INTO STRING '(' colvalspec ')' VALUES 
           '(' colvalspec ')' ';' {}
         ;

select   : SELECT cvsaster FROM STRING {} wsel ';' {}
</programlisting>

<para>
A grammar consists of three building blocks. Each of the tokens which can be returned by the lexer is termed a <emphasis>terminal</emphasis>. Examples from above include <emphasis>CREATE</emphasis>, <emphasis>TABLE</emphasis>, <emphasis>STRING</emphasis>, <emphasis>INSERT</emphasis>, <emphasis>INTO</emphasis>, <emphasis>VALUES</emphasis>, and <emphasis>SELECT</emphasis>. These terminals are used by <emphasis>non-terminals</emphasis>, such as <emphasis>sql</emphasis>, <emphasis>create</emphasis>, <emphasis>insert</emphasis>, and <emphasis>select</emphasis> from the example above. The rule which groups a non-terminal with a series of other non-terminals, and terminals, is called a <emphasis>production</emphasis> (Aho, Sethi &amp; Ullman 1986).
</para>

<para>
This grammar defines a language in which a SQL statement can consist of either a <emphasis>create</emphasis>, a <emphasis>insert</emphasis>, or a <emphasis>select</emphasis> statement, as shown by the sql production. The empty non-terminal on the sql production is so that an end of file or empty line is also matched. Because the <emphasis>sql</emphasis> non-terminal
</para>

<para>
It should also be noted that the sql production is recursive, except for this case which matches the empty line or end of file.
</para>
</sect4>

<sect4><title>Hand coded parsers</title>
<para>
The alternative to using the compiler construction tools is to develop a language parser by hand. Depending on the complexity of the grammar to be implemented, this can be quite a realistic alternative. On the other hand, if the grammar is complex, then this can rapdily become a problem with a larger scale than implementing the rest of the application.
</para>

<para>
Because the grammar for the scripting language implemented by the batch version of <command>GDMS</command> is fairly trivial (all commands are parsed based on only one line, and no recursion within productions is required), the <command>GDMS</command> team has selected this option.
</para>
</sect4>
</sect3>

  <sect3><title>Implementation</title>
  <para>
       - How was it done?
       - Speed/ Optimisations
  </para>      
  </sect3> <!--Implementation-->
  
<sect3><title>Integration</title>
<para>
A large amount of the user interface development has been integrating the graphical user interface to the various pieces of mathematical functionality in <command>GDMS</command>. This integration has been eased by following a standard process for integrating mathematical functionality. The process is as follows:
</para>

<itemizedlist>
<listitem><para><emphasis>All functionality is either accessed from the mouse, or a menu</emphasis>. This leads to a consistent user interface, and minimizes user confusion.</para></listitem>
<listitem><para><emphasis>The output of all mathematical operations is a new dataset</emphasis>, and hence a new tab in the main application window. This has several advantages, including: easing the implementation of the batch interface to the application; allowing ease of comparison of the dataset before and after the application of the mathematical operation; and TODO SOMETHING ELSE HERE.</para></listitem>
</itemizedlist>

<para>
Further documentation of the actual functionality available in the <command>GDMS</command> application is available in the user manual.
</para>
</sect3> <!--Integration-->


  <sect3><title>Future Enahncements</title>
  <para>
  </para>
  </sect3> <!--Future Enahncements-->


</sect2> <!--UI-->

