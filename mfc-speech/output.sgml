<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<article>
<title>Computer Engineering Four Assignment One</title>
   <subtitle>Speech Recognition</subtitle>

<articleinfo>
<author>
  <firstname>Michael</firstname>
  <surname>Still</surname>
  <affiliation>
    <jobtitle>964076</jobtitle>
  </affiliation>
</author>
</articleinfo>

<sect1>
<title>Part A</title>

<sect2><title>Perform time-domain analysis with a frame size of 512</title>
<sect3><title>Input the file, play it back and state what the spoken phrase is</title>
<para>
The spoken phrase is "Human Computer Communication".
</para>
</sect3>

<sect3><title>Compute the energy contour in dB</title>
<para>
The following Matlab script was used to generate the energy contour in dB, including using the first frame as a reference of 0 dB.
</para>

<sect4><title>Code: matlab/econtour.m</title>
<programlisting>
function [energy, edb] = econtour(filename)

framesize = 512;
numsamples = wavread(filename, 'size');

% Read the whole file into one big vector
% Check the wavread doco for a better way of doing this
[samples, fsample, nbits] = wavread(filename, numsamples(1));

% Compute the energy contour
fcount = 1;
while fcount &lt; numsamples(1) / framesize
    temp = samples((fcount - 1) * framesize + 1: fcount * framesize);
    
    % Calculate the energy, and the reference if required. Apply that reference
    energy(fcount) = temp' * temp;
    edb(fcount) = 10 * log10(energy(fcount));
    if(fcount == 1)
        eref = edb(1);
    end
    edb(fcount) = edb(fcount) - eref;
    
    % Next frame
    fcount = fcount + 1;
end
</programlisting>
</sect4>
</sect3>

<sect3><title>Compute the normalised autocorrelation contour</title>
<para>
The following Matlab script was used to calculate the autocorrelation contour:
</para>

<sect4><title>Code: matlab/autocorr.m</title>
<programlisting>
function [acorr, ffreq] = autocorr(filename, energy)

framesize = 512;
numsamples = wavread(filename, 'size');
vthresh = 0.375;

% Read the whole file into one big vector
% Check the wavread doco for a better way of doing this
[samples, fsample, nbits] = wavread(filename, numsamples(1));

% We need to know kmin and kmax before we can continue
kmin = fsample / 200;
kmax = fsample / 80;

% Compute the autocorrelation
fcount = 1;
while fcount &lt; numsamples(1) / framesize
    temp = samples((fcount - 1) * framesize + 1: fcount * framesize);
    
    for count = kmin:kmax
        acalc(count) = temp(1:framesize - count)' * temp(1 + count: framesize);
    end
    
    % Now normalize
    [amax, indexmax] = max(acalc);
    acorr(fcount) = amax / energy(fcount);
    
    if (acorr(fcount) &gt; vthresh)
        ffreq(fcount) = fsample / indexmax;
    end 
    
    % Next frame
    fcount = fcount + 1;
end
</programlisting>
</sect4>
</sect3>

<sect3><title>Set a suitable autocorrelation value for the voiced/unvoiced threshold and compute the fundamental frequency contour</title>
<para>
The fundamental frequency is calculated by the autocorrelation function in the code in the previous section. The values kmin and kmax were derived for the maximum and minimum frequencies for the voice / unvoice threshold as provided by Professor Wagner.
</para>
</sect3>

<sect3><title>Plot all three of the above contours with a common time axis and on that plot mark the phoneme boundaries and label the phonemes</title>
<para>
Please refer the to next page for this graph, with annotation.
</para>
</sect3>

<sect3><title>Documentation</title>
<para>
The two scripts presented earlier in this section to calculate the values required are tied together by the following Matlab script:
</para>

<sect4><title>Code: matlab/questionOne.m</title>
<programlisting>
function [] = questionOne(filename)

% Generate the energy contour (part b)
[en, edb] = econtour(filename);

% Generate the autocorrelation (part c)
[ac, ff] = autocorr(filename, en);




% Plot all of these
subplot(3, 1, 1), plot(edb)
grid on
ylabel('Energy (dB)');
title('Energy, with first frame as reference');

subplot(3, 1, 2), plot(ac)
grid on
title('Normalized autocorrelation');

subplot(3, 1, 3), plot(ff)
grid on
title('Fundamental frequency');
</programlisting>
</sect4>
</sect3>
</sect2>

<sect2><title>Perform frequency-domain analysis on a frame in the centre of the first vowel /u/ and on a frame in the centre of the consonant /sh/</title>
<para>
The following scripts were used to perform these calculations:
</para>

<sect3><title>Code: matlab/questionTwo.m</title>
<programlisting>
function [ ] = questionTwo( filename )

% The framesize is 512
framesize = 512;

% Find the /u/ frame and perform a frequency domain analysis
[sdata, fsample] = ph_u(filename);
[lms, cep, smoothed] = fd_analyse(sdata, fsample, framesize);

% Plot all of this
figure(1);
subplot(3, 1, 1), plot(lms);
grid on
title('Log magnitude spectrum of /u/');

subplot(3, 1, 2), plot(cep);
grid on
title('Cepstrum of /u/');

subplot(3, 1, 3), plot(smoothed);
grid on
title('Smoothed cepstrum of /u/');


% Find the /sh/ frame and perform a frequency domain analysis
[sdata, fsample] = ph_sh(filename);
[lms, cep, smoothed] = fd_analyse(sdata, fsample, framesize);

% Plot all of this
figure(2);
subplot(3, 1, 1), plot(lms);
grid on
title('Log magnitude spectrum of /sh/');

subplot(3, 1, 2), plot(cep);
grid on
title('Cepstrum of /sh/');

subplot(3, 1, 3), plot(smoothed);
grid on
title('Smoothed cepstrum of /sh/');
</programlisting>
</sect3>
<sect3><title>Code: matlab/ph_u.m</title>
<programlisting>
function [ sdata, fsample ] = ph_u( filename )

% The framesize is 512
framesize = 512;

% Read in the wav file again
numsamples = wavread(filename, 'size');
[samples, fsample, nbits] = wavread(filename, numsamples(1));

% I have imperically determined that the following frames are used for /u/
start = 6 * framesize;
finish = (12 * framesize) - 1;

% This can be verified by plotting the /u/ sound. The hints for the assignment say that for /u/
% we should have periodicity of about 100Hz -- therefore I generate a graph with a period of 100Hz
%plot(samples(start:finish))
%grid on

% Therefore, a frame in the center is 8 * 512 to 9 * 512
sdata = samples(start:finish);
</programlisting>
</sect3>
<sect3><title>Code: matlab/ph_sh.m</title>
<programlisting>
function [ sdata, fsample ] = ph_sh( filename )

% The framesize is 512
framesize = 512;

% Read in the wav file again
numsamples = wavread(filename, 'size');
[samples, fsample, nbits] = wavread(filename, numsamples(1));

% I have imperically determined that the following frames are used for /sh/
start = 70 * framesize;
finish = (74 * framesize) - 1;

% This can be verified by plotting the /sh/ sound. The hints for the assignment say that for /sh/
% the plot exhibits non-periodicity and a high-frequency "ragged" waveform
%plot(samples(start:finish))
%grid on

% Therefore, a frame in the center is 8 * 512 to 9 * 512
sdata = samples(start:finish);
</programlisting>
</sect3>
<sect3><title>Code: matlab/fd_analyse.m</title>
<programlisting>
function [ lms, cep, smoothed ] = fd_analyse( sdata, fsample, framesize )

% Generate a hamming window and then apply that window
hwind = hamming(framesize);
fcount = 1;
while fcount &lt; framesize
    hammed(fcount) = sdata(fcount) * hwind(fcount);
    
    % Next frame
    fcount = fcount + 1;
end

% Perform a FFT
fdata = abs(fft(hammed));

% Square each value and then perform a log
fcount = 1;
while fcount &lt; length(fdata)
    lms(fcount) = 20 * log10(fdata(fcount));
    
    % Next frame
    fcount = fcount + 1;
end

cep = real(ifft(lms));

% Now we need the smoothed cepstrum
tcut = fsample / 400;
scep = cep;
for i = tcut:(framesize + 2 - tcut)
    scep(i) = 0;
end

smoothed = real(fft(scep));
</programlisting>
</sect3>

<sect3><title>/u/ plot</title>
<para>
Please refer to the next page for this plot.
</para>
</sect3>

<sect3><title>/sh/ plot</title>
<para>
Please refer to the page following that for the /sh/ plots.
</para>
</sect3>
</sect2>
</sect1>

<sect1><title>Part B</title>
<para>
This part documents the speech recongition experiment.
</para>

<sect2><title>Compute the codebook</title>
<para>
The following code produces a LBG VQ codebook of size 32 from the 9 training MFC files.
</para>

<sect3><title>Code: c++/gencode.cpp</title>
<programlisting>
// Generate a codebook

#include "world.h"

int
main (int argc, char *argv[])
{
  mfc data;
  float delta = 0.01;
  float errTarget = 0.0;

  cout &lt;&lt; "Delta is " &lt;&lt; delta &lt;&lt; endl;
  data.clear ();
  load (data, "s014d001.mfc");
  load (data, "s014d002.mfc");
  load (data, "s014d003.mfc");
  load (data, "s017d001.mfc");
  load (data, "s017d002.mfc");
  load (data, "s017d003.mfc");
  load (data, "s029d001.mfc");
  load (data, "s029d002.mfc");
  load (data, "s029d003.mfc");
  cout &lt;&lt; "Total frame count: " &lt;&lt; data.size () &lt;&lt; endl &lt;&lt; endl;

  // Initialize the codebook
  codebook cb;
  cb.init (data);
  cb.cloud (data);

  // Distortion information
  float distortion (0.0);
  for (size_t i = 0; i &lt; data.size (); i++)
    {
      float closest (2000000.0);
      for (size_t j = 0; j &lt; cb.size (); j++)
	{
	  if (data.getFrame (i) - cb.getLine (j) &lt; closest)
	    closest = data.getFrame (i) - cb.getLine (j);
	}

      distortion += closest;
    }

  cout &lt;&lt; "Distortion for " &lt;&lt; cb.size () &lt;&lt; " entry codebook: " &lt;&lt;
    "total: " &lt;&lt; distortion &lt;&lt; " average: " &lt;&lt;
    (distortion / data.size ()) &lt;&lt; endl &lt;&lt; endl;

  // We fork five times, because we want 32 output codebook entries
  int i;
  for (i = 0; i &lt; 5; i++)
    {
      cout &lt;&lt; "------------------------------------------------------" &lt;&lt;
	endl;
      cout &lt;&lt; "- CALCULATE THE NEXT SEQUENCE OF CODEBOOK VECTORS    -" &lt;&lt;
	endl;
      cout &lt;&lt; "------------------------------------------------------" &lt;&lt;
	endl;
      cb.stats ();

      // Dump the final output of this round
      cout &lt;&lt; "Codebook entries are currently:" &lt;&lt; endl;
      for (size_t i = 0; i &lt; cb.size (); i++)
	{
	  cout &lt;&lt; cb.getLine (i) &lt;&lt; endl;
	}
      cout &lt;&lt; endl;

      cb.fork (delta);
      cb.cloud (data);

      // Recenter whilst the error is outside acceptable bounds
      float err = 42;
      while (err &gt; errTarget)
	{
	  err = cb.recenter ();
	  cb.cloud (data);
	}

      // Donate and recenter again if we have to
      bool needRecenter (false);
      while (cb.emptyCount () &gt; 0)
	{
	  cout &lt;&lt; "Donating" &lt;&lt; endl;
	  cb.donate (delta);
	  cb.cloud (data);
	  needRecenter = true;
	}

      if (needRecenter)
	{
	  cout &lt;&lt; "Recentering because of donations" &lt;&lt; endl;
	  err = 42;
	  while (err &gt; errTarget)
	    {
	      err = cb.recenter ();
	    }
	}

      // Dump the final output of this round
      cout &lt;&lt; endl &lt;&lt; "Final results from round:" &lt;&lt; endl;
      for (size_t i = 0; i &lt; cb.size (); i++)
	{
	  cout &lt;&lt; cb.getLine (i) &lt;&lt; endl;
	}

      // Distortion information
      float distortion (0.0);
      for (size_t i = 0; i &lt; data.size (); i++)
	{
	  float closest (2000000.0);
	  for (size_t j = 0; j &lt; cb.size (); j++)
	    {
	      if (data.getFrame (i) - cb.getLine (j) &lt; closest)
		closest = data.getFrame (i) - cb.getLine (j);
	    }

	  distortion += closest;
	}

      cout &lt;&lt; "Distortion for " &lt;&lt; cb.size () &lt;&lt; " entry codebook: " &lt;&lt;
	"total: " &lt;&lt; distortion &lt;&lt; " average: " &lt;&lt;
	(distortion / data.size ()) &lt;&lt; endl &lt;&lt; endl;
    }

  cout &lt;&lt; "Final codebook size is: " &lt;&lt; cb.size () &lt;&lt; endl;
  cb.stats ();
  cb.cloudSize ();
  cout &lt;&lt; endl;

  cout &lt;&lt; cb;
  cout &lt;&lt; "------------------------------------------------------" &lt;&lt; endl;

  // We need to save the codebook to disc
  cb.save ("codebook.mfc");

  return (0);
}

void
load (mfc &amp; data, string filename)
{
  string result;

  result = data.add (filename);
  if (result != "")
    {
      cout &lt;&lt; "File load error: " &lt;&lt; filename &lt;&lt; ": " &lt;&lt; result &lt;&lt; endl;
      exit (-1);
    }
}
</programlisting>
</sect3>
<sect3><title>Code: c++/lbg.cpp</title>
<programlisting>
// LBG implementation

#include "world.h"

codebook::codebook ():
m_recenters (0), m_donations (0)
{
}

codebook::codebook (mfc &amp; codes):
m_recenters (0), m_donations (0)
{
  unsigned int i;

  m_table.clear ();
  for (i = 0; i &lt; codes.size (); i++)
    {
      m_table.push_back (codes.getFrame (i));
    }
}

size_t
codebook::size ()
{
  return m_table.size ();
}

void
codebook::init (mfc &amp; data)
{
  // If the target size is zero, then it should be one
  // Otherwise, we need to split the current points in twain...
  if (size () == 0)
    {
      m_table.push_back (data.centroid ());
    }
}

void
codebook::fork (float delta)
{
  vector &lt; mfcFrame &gt; oldtable = m_table;
  size_t i;

  m_table.clear ();
  for (i = 0; i &lt; oldtable.size (); i++)
    {
      cout &lt;&lt; "\tForking " &lt;&lt; oldtable[i] &lt;&lt; endl;
      cout &lt;&lt; "\t        " &lt;&lt; mfcFrame (oldtable[i], 1.0 + delta) &lt;&lt; endl;
      cout &lt;&lt; "\t        " &lt;&lt; mfcFrame (oldtable[i],
					1.0 - delta) &lt;&lt; endl &lt;&lt; endl;

      m_table.push_back (mfcFrame (oldtable[i], 1.0 + delta));
      m_table.push_back (mfcFrame (oldtable[i], 1.0 - delta));
    }
}

void
codebook::cloud (mfc &amp; data)
{
  // We now build the clouds around the codebook entries
  cout &lt;&lt; "Build clouds" &lt;&lt; endl;
  size_t i, j;

  // Clear out the old clouds
  m_clouds.resize (size ());
  for (i = 0; i &lt; size (); i++)
    {
      m_clouds[i].clear ();
    }

  for (i = 0; i &lt; data.size (); i++)
    {
      // Find which point this data point is closest to
      size_t found = 0;
      float dist = 2000000;

      for (j = 0; j &lt; size (); j++)
	{
	  float newdist = m_table[j] - data.getFrame (i);

	  if (newdist &lt; dist)
	    {
	      found = j;
	      dist = newdist;
	    }
	}

      // Add the point to that cloud
      m_clouds[found].add (data.getFrame (i));
    }

  cloudSize ();
}

void
codebook::cloudSize ()
{
  // Display information about cloud sizes
  unsigned int i;

  cout &lt;&lt; "Cloud sizes: ";
  for (i = 0; i &lt; size (); i++)
    {
      cout &lt;&lt; m_clouds[i].size () &lt;&lt; " ";
    }
  cout &lt;&lt; endl;
}

// Now we change the table entries to match the centroids of that cloud
float
codebook::recenter ()
{
  m_recenters++;

  float maxerr = 0;
  unsigned int i;

  cout &lt;&lt; "Recentering cloud centroids" &lt;&lt; endl &lt;&lt; endl;

  for (i = 0; i &lt; size (); i++)
    {
      if (m_clouds[i].size () != 0)
	{
	  float err;

	  err = m_table[i] - m_clouds[i].centroid ();
	  cout &lt;&lt; "\tErr: " &lt;&lt; err &lt;&lt; endl;
	  cout &lt;&lt; "\tOld: " &lt;&lt; m_table[i] &lt;&lt; endl;
	  m_table[i] = m_clouds[i].centroid ();
	  cout &lt;&lt; "\tNew: " &lt;&lt; m_table[i] &lt;&lt; endl &lt;&lt; endl;

	  if (err &gt; maxerr)
	    maxerr = err;
	}
      else
	{
	  cout &lt;&lt; "\tSkipping error on zero sized cloud" &lt;&lt; endl &lt;&lt; endl;
	}
    }

  cloudSize ();
  return maxerr;
}

int
codebook::emptyCount ()
{
  unsigned int i;
  int count = 0;

  for (i = 0; i &lt; size (); i++)
    {
      if (m_clouds[i].size () == 0)
	count++;
    }

  return count;
}

void
codebook::donate (float delta)
{
  m_donations++;

  // Find the biggest cloud
  int maxI;
  unsigned int i, maxSize = 0;

  for (i = 0; i &lt; size (); i++)
    {
      if (m_clouds[i].size () &gt; maxSize)
	{
	  maxSize = m_clouds[i].size ();
	  maxI = i;
	}
    }

  // Find the first empty cloud
  for (i = 0; i &lt; size (); i++)
    {
      if (m_clouds[i].size () == 0)
	{
	  cout &lt;&lt; "\tDonate from cloud " &lt;&lt; maxI &lt;&lt; " to cloud " &lt;&lt; i &lt;&lt; endl
	    &lt;&lt; endl;

	  mfcFrame f = m_table[maxI];
	  m_table[maxI] = mfcFrame (f, 1.0 + delta);
	  m_table[i] = mfcFrame (f, 1.0 - delta);
	  return;
	}
    }
}

void
codebook::stats ()
{
  cout &lt;&lt; "Statistics" &lt;&lt; endl;
  cout &lt;&lt; "\tRecenters performed: " &lt;&lt; m_recenters &lt;&lt; endl;
  cout &lt;&lt; "\tDonations performed: " &lt;&lt; m_donations &lt;&lt; endl &lt;&lt; endl;
}

mfcFrame &amp; codebook::getLine (size_t i)
{
  return m_table[i];
}

void
codebook::save (string filename)
{
  fstream file;

  // Open the file
  file.open (filename.c_str (), ios::out);
  if (!file)
    {
      cerr &lt;&lt; "Could not open file to save codebook to" &lt;&lt; endl;
      exit (42);
    }

  // Most of these are dodgy hard coded values
  file &lt;&lt; size () &lt;&lt; " 100000 44 14106" &lt;&lt; endl;

  unsigned int i;
  for (i = 0; i &lt; size (); i++)
    {
      for (int j = 0; j &lt; 9; j++)
	file &lt;&lt; m_table[i].getC (j) &lt;&lt; " ";
      file &lt;&lt; m_table[i].getE () &lt;&lt; endl;
    }
}

vector &lt; int &gt;
codebook::encode (mfc &amp; target)
{
  unsigned int i;
  vector &lt; int &gt;output;

  output.resize (target.size ());
  for (i = 0; i &lt; target.size (); i++)
    {
      // Find the table entry which is closest to this target entry
      float dist = 2000000;
      unsigned int j, tindex;

      for (j = 0; j &lt; size (); j++)
	{
	  if (m_table[j] - target.getFrame (i) &lt; dist)
	    {
	      dist = m_table[j] - target.getFrame (i);
	      tindex = j;
	    }
	}

      output[i] = tindex;
    }

  return output;
}

ostream &amp; operator &lt;&lt; (ostream &amp; stream, codebook cb)
{
  size_t i;

  for (i = 0; i &lt; cb.size (); i++)
    {
      stream &lt;&lt; (i +
		 1) &lt;&lt; " of " &lt;&lt; cb.size () &lt;&lt; ": " &lt;&lt; cb.getLine (i) &lt;&lt; endl;
    }

  return stream;
}
</programlisting>
</sect3>
<sect3><title>Code: c++/lbg.h</title>
<programlisting>
// Header for the LBG implementation

#include "world.h"

#ifndef LBG_H
#define LBG_H

class codebook
{
public:
  codebook ();
  codebook (mfc &amp; codes);

  size_t size ();
    mfcFrame &amp; getLine (size_t i);

  void init (mfc &amp; data);
  void fork (float delta);
  void cloud (mfc &amp; data);
  void cloudSize ();
  float recenter ();
  int emptyCount ();
  void donate (float delta);
  void stats ();
  void save (string filename);
    vector &lt; int &gt;encode (mfc &amp; target);

private:
    vector &lt; mfcFrame &gt; m_table;
    vector &lt; mfc &gt; m_clouds;

  long m_recenters;
  long m_donations;
};

ostream &amp; operator&lt;&lt; (ostream &amp; stream, codebook cb);

#endif
</programlisting>
</sect3>
<sect3><title>Code: c++/mfc.cpp</title>
<programlisting>
// Parse the MFC files into memory

#include "world.h"

mfcFrame::mfcFrame ()
{
}

mfcFrame::mfcFrame (mfcFrame &amp; other, float delta)
{
  int i;

  for (i = 0; i &lt; 10; i++)
    {
      setC (i, other.getC (i) * delta);
    }
  setE (other.getE () * delta);
}

void
mfcFrame::setC (size_t index, float val)
{
  m_c[index] = val;
}

void
mfcFrame::setE (float val)
{
  m_e = val;
}

float
mfcFrame::getC (size_t index)
{
  return m_c[index];
}

float
mfcFrame::getE ()
{
  return m_e;
}

float
mfcFrame::operator- (mfcFrame other)
{
  float dist = 0;
  size_t i;

  for (i = 0; i &lt; 10; i++)
    {
      dist += pow (getC (i) - other.getC (i), 2);
    }
  dist += pow (getE () - other.getE (), 2);

  return sqrt (dist);
}

// Returns a non empty string if there was an error
string
mfc::add (mfcFrame &amp; frame)
{
  m_frames.push_back (frame);
  return string ("");
}

// Returns a non empty string if there was an error
string
mfc::add (string &amp; filename)
{
  fstream file;

  // Open the file
  file.open (filename.c_str (), ios::in);
  if (!file)
    {
      return string ("Failed to open the file " + filename);
    }

  // Read until end of file
  int stage (0), col (0), numframes, timescale, bytes, type;
  char c;
  string line ("");
  mfcFrame f;

  while (!file.eof ())
    {
      file.read (&amp;c, 1);

      if ((c != '\n') &amp;&amp; (c != ' '))
	line += c;
      else if (line.length () &gt; 0)
	{
	  // The first four fields in the file are information about the file
	  switch (stage)
	    {
	    case 0:
	      numframes = atoi (line.c_str ());
	      break;
	    case 1:
	      timescale = atoi (line.c_str ());
	      break;
	    case 2:
	      bytes = atoi (line.c_str ());
	      break;
	    case 3:
	      type = atoi (line.c_str ());
	      break;
	    default:
	      // The rest go in the cycle of ten MFC values, then a log energy
	      if (col &lt; 10)
		{
		  f.setC (col, atof (line.c_str ()));
		  col++;
		}
	      else
		{
		  f.setE (atof (line.c_str ()));
		  m_frames.push_back (f);
		  col = 0;
		}
	      break;
	    }

	  line = "";
	  ++stage;
	}
    }

  // Print out some information about the file...
  cout &lt;&lt; filename &lt;&lt; ": " &lt;&lt; numframes &lt;&lt; " frames" &lt;&lt; endl;
  return string ("");
}

mfcFrame &amp; mfc::getFrame (size_t index)
{
  return m_frames[index];
}

size_t
mfc::size ()
{
  return m_frames.size ();
}

mfcFrame
mfc::centroid ()
{
  mfcFrame cent;
  size_t i;
  int j;

  for (i = 0; i &lt; 10; i++)
    cent.setC (i, 0.0);
  cent.setE (0.0);

  for (i = 0; i &lt; m_frames.size (); i++)
    {
      for (j = 0; j &lt; 10; j++)
	cent.setC (j, cent.getC (j) + m_frames[i].getC (j));
      cent.setE (cent.getE () + m_frames[i].getE ());
    }

  for (i = 0; i &lt; 10; i++)
    cent.setC (i, cent.getC (i) / m_frames.size ());
  cent.setE (cent.getE () / m_frames.size ());

  return cent;
}

void
mfc::clear ()
{
  m_frames.clear ();
}

ostream &amp; operator&lt;&lt; (ostream &amp; stream, mfcFrame frame)
{
  stream &lt;&lt; "Frame: ";

  int i;
  for (i = 0; i &lt; 10; i++)
    stream &lt;&lt; frame.getC (i) &lt;&lt; " ";

  stream &lt;&lt; "energy: " &lt;&lt; frame.getE ();
  return stream;
}
</programlisting>
</sect3>
<sect3><title>Code: c++/mfc.h</title>
<programlisting>
// Header for the MFC file parser

#include "world.h"
#ifndef MFC_H
#define MFC_H

class mfcFrame
{
public:
  mfcFrame ();
  mfcFrame (mfcFrame &amp; other, float delta);

  void setC (size_t index, float val);
  void setE (float val);
  float getC (size_t index);
  float getE ();

  // Returns the "distance" between two frames
  float operator- (mfcFrame other);

private:
  float m_c[10];
  float m_e;
};

class mfc
{
public:
  string add (string &amp; filename);
  string add (mfcFrame &amp; frame);
    mfcFrame &amp; getFrame (size_t index);

  // Returns the number of frames in the data pool
  size_t size ();

  // Return the centroid of this dataset
  mfcFrame centroid ();

  // Clear the data
  void clear ();

private:
    vector &lt; mfcFrame &gt; m_frames;
};

// Allow out stream stuff
ostream &amp; operator&lt;&lt; (ostream &amp; stream, mfcFrame frame);

#endif
</programlisting>
</sect3>
<sect3><title>Code: c++/world.h</title>
<programlisting>
#ifndef WORLD_H
#define WORLD_H

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include "mfc.h"
#include "lbg.h"

void load (mfc &amp; data, string filename);

#endif
</programlisting>
</sect3>

<sect3><title>Code: c++/Makefile</title>
<programlisting>
all: codebook encode

codebook: gencode.o mfc.o lbg.o
	c++ gencode.o mfc.o lbg.o -o codebook

encode:	encode.o mfc.o lbg.o
	c++ encode.o mfc.o lbg.o -o encode

gencode.o: gencode.cpp world.h
	c++ -c -Wall -ggdb gencode.cpp -o gencode.o

encode.o: encode.cpp world.h
	c++ -c -Wall -ggdb encode.cpp -o encode.o

mfc.o: mfc.cpp mfc.h world.h
	c++ -c -Wall -ggdb mfc.cpp -o mfc.o

lbg.o: lbg.cpp lbg.h world.h
	c++ -c -Wall -ggdb lbg.cpp -o lbg.o

clean:
	rm -f *.o codebook encode
</programlisting>
</sect3>

<sect3><title>Output codebook</title>
<para>
The output codebook is as follows:
</para>

<programlisting>
32 100000 44 14106
17.5184 -9.61972 10.9811 12.5487 -20.3334 -13.3807 -14.0741 -21.5065 7.33428 0.97422
12.5844 -1.20952 12.7599 13.1692 -9.94967 -7.91391 -10.9386 -15.8806 3.07113 0.807378
20.5158 -9.7351 3.62021 15.8527 -24.6896 -2.2363 -18.3472 -13.0605 -0.807636 0.969249
21.1208 -7.20986 -6.09996 10.3476 -20.2856 4.05776 -10.0198 -11.3466 3.20897 0.877923
12.7301 -6.21918 16.1583 8.78379 -3.94845 -0.884173 -11.3109 -29.3998 -0.658228 0.953744
17.4091 -2.94272 8.44412 4.90336 -9.91341 5.90885 -4.71809 -15.744 -7.91073 0.787865
24.4306 -4.54745 -13.7423 6.37143 -1.79758 -7.51856 -8.8303 -21.0768 5.84822 0.963372
20.2375 -3.00456 -3.20923 10.8505 -8.9082 -5.12877 -15.1718 -14.5714 -0.96914 0.913506
12.7753 -2.90817 3.44214 21.644 8.59306 -8.61043 -10.8078 -3.65806 -13.1106 0.644082
7.49598 -3.80248 -0.681117 7.12422 6.64038 -7.75067 -12.3045 -8.14882 -6.8389 0.357454
14.3265 1.23288 0.93998 12.1902 -1.74486 -3.24943 -1.53636 -6.63878 -1.68243 0.762487
9.73785 2.76178 -3.26917 9.82138 7.27378 6.89372 0.0347545 -11.515 -0.161303 0.480143
17.1504 10.8616 5.68798 2.52324 -9.59537 -8.08671 -0.787987 -0.12787 -2.41403 0.707007
13.7426 3.82317 7.19483 -1.00011 -10.8809 12.7695 -1.134 -3.28702 -4.06922 0.627633
9.87925 9.02714 5.27229 5.81882 -3.25409 5.50761 9.71562 6.36749 -2.35262 0.501449
4.26506 1.68982 8.98186 0.131684 5.45508 7.18203 -0.586789 1.3915 2.81816 0.45498
19.38 -4.89252 -6.95936 -10.8722 -25.5888 8.79123 8.70056 -5.64287 2.01727 0.956863
19.1046 -12.0034 -7.16167 -5.12748 -19.8278 13.0812 1.49002 -12.9461 4.81698 0.97126
19.7832 -4.90871 2.37965 -11.7441 -16.1058 -7.33486 17.7386 -12.8284 9.30193 0.98171
16.0383 -9.76116 -6.13497 -7.36874 -4.05799 4.88475 -1.10305 -13.1399 12.0321 0.969295
13.4222 -3.7279 19.9909 14.2036 -32.2308 -3.38185 -13.2581 -0.982058 -1.17585 0.842049
16.4038 -13.5475 15.0297 13.9928 -27.922 -6.2536 -14.8237 -3.37106 -0.948236 0.941473
2.49029 7.76125 24.9521 11.7434 -19.848 -1.41258 -2.41829 -3.4535 -3.77819 0.575459
5.15913 -5.33255 3.61373 -0.564554 -20.3849 -1.13483 4.96248 -8.21963 -17.2715 0.104859
-8.04763 -1.96283 -1.69638 -17.3481 2.20104 -0.701295 -6.1682 -3.87097 2.23939 0.46651
-9.46387 -5.03008 -1.72295 -10.2171 -3.26096 -8.83133 -0.602713 -6.10837 7.26646 0.458237
-8.71179 -13.2229 -0.0720176 0.952793 -1.81995 -4.7104 1.21669 0.577704 -3.39437 0.463447
-9.06997 -5.50893 4.08051 -4.84227 -5.47672 -1.5031 -6.38152 -1.35329 3.62614 0.409615
3.92364 -0.625753 -3.69331 -4.94929 -0.22928 -5.23897 -6.88927 -7.48523 -14.2767 0.0335002
3.67109 -3.62674 -3.78139 -12.243 -5.13097 -1.72663 -0.482378 -2.60503 -7.34609 0.249361
4.91593 2.84004 -5.67108 -4.29014 -1.65023 5.66779 4.59955 5.64348 -3.67165 0.161052
-1.31697 2.82501 -4.08869 0.238118 -0.299205 -1.08468 2.61686 4.26842 1.67924 0.0271404
</programlisting>
<para><emphasis>Code: c++/codebook.mfc</emphasis></para>
</sect3>

<sect3><title>Distortion values</title>
<para>
The following distortion values are calculated for the various phases in the codebook generation:
</para>

<programlisting>
Distortion for 1 entry codebook: total: 11519.6 average: 27.758
Distortion for 2 entry codebook: total: 9968.5 average: 24.0205
Distortion for 4 entry codebook: total: 8666.67 average: 20.8835
Distortion for 8 entry codebook: total: 7508.66 average: 18.0932
Distortion for 16 entry codebook: total: 6309.63 average: 15.2039
Distortion for 32 entry codebook: total: 5168.91 average: 12.4552
</programlisting>

</sect3>
</sect2>

<sect2><title>Encoding the nine training files</title>
<para>
This script was used to encode the nine training files:
</para>

<para>
#!/bin/bash

for item in `ls s*.mfc`
do
  ./encode codebook.mfc $item `echo $item | sed 's/mfc$/enc/'`
done</para>

<sect3><title>Encoded files</title>
<para>
These are the encoded files:
</para>

<sect4><title>s014d001</title>
<para>
28 27 27 24 28 22 23 25 27 25 25 25 9 9 9 9 13 13 13 13 13 13 11 11 11 11 11 11 11 5 5 5 5 24 12 27 27 10 12 25 13 13 13 13 13 13 10 10 10 10 10 9 13 25 25 28 28 28 
</para>
</sect4>

<sect4><title>s014d002</title>
<para>
25 25 24 24 24 24 24 24 24 24 27 13 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 25 15 15 25 11 9 14 28 28 28 28 28 
</para>
</sect4>

<sect4><title>s014d003</title>
<para>
24 28 24 21 24 24 28 25 28 28 11 21 11 28 28 21 28 28 8 22 22 22 27 27 27 13 9 10 10 10 10 10 10 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 20 20 28 20 20 28 28 28 28 
</para>
</sect4>

<sect4><title>s017d001</title>
<para>
28 28 11 11 11 11 3 11 5 3 5 5 5 5 11 11 11 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 27 19 27 26 26 27 
</para>
</sect4>

<sect4><title>s017d002</title>
<para>
22 22 24 28 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 28 10 10 28 10 24 26 9 9 
</para>
</sect4>

<sect4><title>s017d003</title>
<para>
28 26 28 21 28 28 28 22 27 27 27 12 12 0 0 0 0 0 0 0 0 0 0 20 20 20 20 20 20 20 20 20 20 20 20 28 11 22 22 22 22 22 22 22 22 26 
</para>
</sect4>

<sect4><title>s029d001</title>
<para>
28 9 9 9 11 11 11 11 11 11 11 5 11 11 11 11 11 12 12 12 0 0 0 0 0 0 0 24 24 24 24 15 24 25 24 25 25 26 26 25 24 22 25 25 26 
</para>
</sect4>

<sect4><title>s029d002</title>
<para>
21 21 21 24 28 28 27 27 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 0 12 24 11 25 25 25 25 25 23 22 22 
</para>
</sect4>

<sect4><title>s029d003</title>
<para>
27 26 27 27 28 26 26 26 26 21 28 22 22 27 25 24 12 12 12 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 20 20 20 20 15 15 9 13 25 25 25 22 25 26 25 
</para>
</sect4>

<sect4><title>s031d00x</title>
<para>
24 24 28 28 28 28 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 24 13 13 13 13 10 25 25 28 
</para>
</sect4>

</sect3>
</sect2>

<sect2><title>Verfication</title>
<para>
The LBG VQ algorithm used in this part was verified by the use of selected dummy MFC files which a much smaller number of samples. This allowed me to manually calculate the correct cloud centroids et cetera, and then verify this against the program.
</para>
</sect2>
</sect1>
</article>
