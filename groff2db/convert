#!/usr/bin/perl

# groff2db. Copyright (c) Michael Still 2001 (mikal@stillhq.com)
# Released under the terms of the GNU GPL. Please submit all patches to mikal@stillhq.com
# Initially developed for Greg Lehey's "The Complete FreeBSD"... Many thanks for his
# sponsorship and support of this project.

# The basic concept of this script to to convert troff marked up input into
# docbook compliant XML. This script is somewhat Greg specific at the moment, but I would
# love to make it more generalised over time...

# Index entries also need work
# Screen is not entirely appropriate for display mapping
# Email address are not properly identified
# Bold is also an emphasis at the moment
# Strip styles out when we are in display state
# There are some section references which need to be manually fixed (search for "Section reference" in the SGML

# Next release:
#  - display text substitution...

use strict;
my($INPUT, $OUTPUT, $outputstyle);
my($parastate, $liststate, $listitemstate, $footnotestate, $sectionstate, $tablestate, $stylestate, $displaystate, $waitstate, $quotestate, $pausedlist, $tablestate, $tablecolcount, $tablecellline, $tablebracestate);
my($length);
my($chapters, $chapter, $chaptercount, $temp, $inputused);
my($linecount, $condlinecount);

# We need to check the command line arguements...
#if( eq "jade"){
    print "Jade output style selected (one big file).\n";
    print "The output will go to output.sgml\n";
    $outputstyle = "jade";
#}
#else{
#    print "Output style is gmat (many docbook files).\n";
#    print "The files will have .sgml extensions...\n";
#    $outputstyle = "gmat";
#}

$chapters = "introduction concepts evolution quickinstall shareinstall install xsetup postinstall ports problems xtheory unixref starting filesys disks tapes printers desktop building current emulate netintro netsetup isp modems ppp slip dns firewall netdebug nfs netbasics email www fax micronet mobile";

$chaptercount = 0;
$linecount = 0;

if($outputstyle eq "jade"){
    open OUTPUT, "> output.sgml";
}

# Print out the prelude
print OUTPUT "<!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook V3.1//EN\">\n";
print OUTPUT "<book><bookinfo><title>The Complete FreeBSD</title><author><firstname>Greg</firstname><surname>Lehey</surname></author><copyright><year>2001</year><holder>Greg Lehey</holder></copyright></bookinfo>\n";

# For each chapter we specified
foreach $chapter (split(/ /, $chapters)){
    if($outputstyle ne "jade"){
	open OUTPUT, "> $chapter.sgml";
    }

    $chaptercount++;
    print "\bProcessing chapter $chapter ($chaptercount)\n ";
    open INPUT, "< $chapter.mm";

    $liststate = 0;
    $listitemstate = 0;
    $parastate = 0;
    $footnotestate = 0;
    $sectionstate = 0;
    $tablestate = 0;
    $displaystate = 0;
    $stylestate = "";
    $quotestate = 0;
    $tablestate = 0;
    $inputused = 0;
    $pausedlist = 0;
    
    # For each line in the file...
    while(<INPUT>){
	$linecount++;
        $inputused = 1;

	# There are some conditional elements used, for instance in xtheory.mm (which is also an
	# article)
	if((/^\.\.if article/i) || (/^\.\.if XXX/i) || (/^\.\.if appropriate/i) || (/^\.\.if complete/i) ||
	   (/^\.\.if finished/i) || (/^\.\.if fixme/i) || (/^\.\.if isdn/i) || (/^\.\.if itworks/i) || (/^\.\.if long/i) ||
	   (/^\.\.if needed/i) || (/^\.\.if netnews/i) || (/^\.\.if network/i) || (/^\.\.if partofthebook/i) ||
	   (/^\.\.if raid5/i) || (/^\.\.if review/i) || (/^\.\.if short/i) || (/^\.\.if sorted/i) || (/^\.\.if verylong/i) ||
	   (/^\.\.if X/i)){
	    $waitstate = 1;
	    $condlinecount = 0;
	    while(($waitstate == 1) && ($_ = <INPUT>)){
		$linecount++;
		$condlinecount++;

		if(/^..else/){
		    $waitstate = 0;
		}
		elsif(/^..endif/){
		    $waitstate = 0;
		}
	    }
	    print "\b  [Conditional was $condlinecount lines]\n ";
	}

	# Ampersands
	s/&/&amp;/g;

	# LT
	s/</&lt;/g;

	# GT
	s/>/&gt;/g;

	# Mu (micro) doesn't work with db2ps (jade)
	s/µ/&mu;/g;

	# Footnote thingie we don't use
	s/\\\*F//g;

	# We run some little conversion rules to deal with things like italics et al
	if($displaystate == 0){
	    $temp = processstyles($_);
	    $_ = $temp;	
	}

	# Table row stuff
#	if(($tablestate == 1) && (/^[^.].*/)){
#	    $_ = "";
#	}
#	elsif($tablestate > 1){
#	    $length = -1;
#	    while($length ne length){
#		$length = length;
#		s/([^T][^\}\#])\#/-$1-FOUND/g;
#	    }
#	}

	##############################################################
	# Comments
	if(/^\.\\\"(.*)/i){
	}

	# Aside start
	elsif(/^\.Aside(.*)/i){
	    endpara();
	    print OUTPUT "<sidebar>\n";
            startpara();
	}

	elsif(/^\.End-aside(.*)/i){
            endpara();
	    print OUTPUT "</sidebar>\n";
            startpara();
	}

	elsif(/^\.br/i){
# No mapping?
	}

	# Defining display strings
	elsif(/^.ds/){
	}
	
	# Display start -- is case sensitive
	elsif((/^\.DS(.*)/) || (/^\.Dx(.*)/i)){
	    endpara();
	    print OUTPUT "<example><title></title><programlisting>\n";
	    $displaystate = 1;
	}

	# Display end
	elsif(/^\.DE(.*)/i){
	    if($displaystate == 1){
		print OUTPUT "</programlisting></example>\n";
		$displaystate = 0;
		startpara();
	    }
	}
	
	# Ifs
	elsif(/^\.\.if/i){
	}

	# Else
	elsif(/^\.\.else/i){
	}

	# Endifs
	elsif(/^\.\.endif/i){
	}

	# Setting the font family
	elsif(/^\.fam/i){
	    # No mapping?
	}

	# Footnote start
	elsif(/^\.FS[ \t]*(.*)/i){
	    print OUTPUT "<footnote>\n";
            startpara();
	    $footnotestate = 1;
	}
	
	# Footnote end
	elsif(/^\.FE[ \t]*(.*)/i){
	    if($footnotestate == 0){
		dblog("{DBLOG: Footnote end for a non-open footnote!}");
	    }
	    
	    endpara();
	    print OUTPUT "</footnote>\n";
	    $footnotestate = 0;
	}

	# Figure headings
	elsif(/^\.Figure-heading [\"]*([^\"]*)[\"]*/i){
	    print OUTPUT "<figure><title>$1</title><graphic format=\"JPEG\" fileref=\"images/missing.jpg\"></graphic></figure>\n";
	}

	# Filenames
	elsif(/^\.File ([ \t]*)(.*)/i){
	    print OUTPUT "<filename>$1</filename>$2\n";
	}
	
	# Headings
	elsif(/^\.H([0-7])[ \t]*(.*)/i){
	    print OUTPUT closeallstates();
	    endpara();
	    
	    while($sectionstate > ($1 - 2)){
		print OUTPUT "</section>\n";
		$sectionstate--;
	    }
	    
	    while($sectionstate < ($1 - 2)){
		print OUTPUT "<section><title></title>\n";
		$sectionstate++;
	    }
	    print OUTPUT "<section>\n";
	    $sectionstate++;

	    $_ = $2;
	    s/\"//g;
	    print OUTPUT "<title>$_</title>\n";
            startpara();
	}
	
	# Headings (Unsupported)
	elsif(/^\.H([8-9])[ \t]*(.*)/i){
	    print OUTPUT closeallstates();
	    endpara();
	    print OUTPUT "<section><title>Title???</title>\n";
	    $sectionstate = 1;
	}

	# Highlights
	elsif(/^\.Highlight(.*)/i){
	    endpara();
	    print OUTPUT "<sidebar>\n";
            startpara();
	}

	elsif(/^\.End-highlight(.*)/i){
            endpara();
	    print OUTPUT "</sidebar>\n";
            startpara();
	}
	
	# List start
	elsif((/^\.LS(.*)/i) || (/^\.LB(.*)/i)){
            liststart();
	}
	
	# List item
	elsif(/^\.LI(.*)/i){
	    if($liststate == 0){
		dblog("{DBLOG: List item for a non-open list!}");
                liststart();
	    }

	    if($pausedlist == 1){
		print OUTPUT "<itemizedlist>\n";
		$pausedlist = 0;
	    }
	    
	    endpara();
	    if($listitemstate == 1){
		print OUTPUT "</listitem>\n";
	    }
	    
	    print OUTPUT "<listitem>\n";
            startpara();
	    $listitemstate = 1;
	}
	
	# List end
	elsif(/^\.LE(.*)/i){
	    if($liststate == 0){
		dblog("{DBLOG: List end for a non-open list!}");
	    }
	    
	    endpara();
	 
	    if($listitemstate > 0){
		print OUTPUT "</listitem>\n";
	    }

	    if($liststate == 1){
		print OUTPUT "</itemizedlist>\n";
                startpara();
	    }
	    else{
		print OUTPUT "</orderedlist>\n";
		$pausedlist = 1;
	    }
	    $liststate--;
	    dblog("{DEBUG DBLOG: listlevel = $liststate}");
	    $listitemstate = 0;

	    if($liststate < 0){
		dblog("{DBLOG: Negative list state entered}");
	    }
	}
	
	elsif(/^\.ne/i){
	    # No mapping to docbook?
	}
	
	# Unknown tag!
#    elsif(/^\.Pn[ \t]+(.*)/i){
#	print "UNKNOWN COMMAND: Pn [Arg $1]\n";
#    }

	# Paragraphs
	elsif(/^\.P[ \t]*([0-9]*)(.*)/i){
	    endpara();
            startpara();
	}

	# Pictures
	elsif(/^\.PIC [\"]*([^\"]*)[\"]*/i){
	    print OUTPUT "<figure><title></title><graphic format=\"PS\" fileref=\"$1\"></graphic></figure>\n";
	}

	# Quotes
	elsif(/^\.Quote(.*)/i){
	    print OUTPUT "<quote>\n";
	    $quotestate = 1;
	}

	elsif((/^\.End-quote(.*)/i) && ($quotestate == 1)){
	    print OUTPUT "</quote>\n";
	}

	elsif(/^.Sref[ \t]*\\\*\[(.*)\]/i){
	    print OUTPUT "...Section reference $1 (edit manually)...\n";
	}

	# Insets are treated as quotes as well
	elsif(/^\in[ \t]\+(.*)/i){
	    print OUTPUT "<quote>\n";
	    $quotestate = 1;
	}

	elsif((/^\.in/i) && ($quotestate == 1)){
	    print OUTPUT "</quote>\n";
	}
	
	# Unknown command
#    elsif(/^\.Sref[ \t]*(.*)/i){
#	print "UNKNOWN COMMAND: Sref [Arg $1]\n";
#    }
	
	# Spacing commands don't map to db
	elsif(/^\.sp(.*)/i){
	}

	# Table title
	elsif(/^\.TB[ \t]*[\"]*([^\"]*)[\"]*/i){
#	    print OUTPUT "<table frame='all'><title>$1</title>\n";
#	    $tablestate = 1;
	}

	# Table start
	elsif(/^\.TS[ \t]*(.*)/i){
	}

	# Table heading
	elsif(/^\.TH(.*)/i){
#	    $tablestate = 2;
	}
	
	# Table end
	elsif(/^\.TE/i){
#	    print OUTPUT "</tbody></tgroup></table>\n";
#	    $tablestate = 0;
#	    $tablecellline = "";
	}

	# Table reference for later
	elsif(/^\.Tn/i){
	}

	# Chapters
	elsif(/^\.Chapter[ \t]([^ \t]*)[ \t]\"(.*)\"/){
	    print OUTPUT "<chapter><title>$2</title>\n";
	    print OUTPUT "<section><title></title>\n";
            startpara();
	    $sectionstate++;
	    }

	elsif(/^\.X[ \t]\"*([^ \"]*)\"*/i){
	    print OUTPUT "<indexterm><primary>$1</primary></indexterm>\n";
	}
	
	# We don't know anything about this command at all
	elsif(/^\.(.*)/i){
	    print "\bDEFAULT COMMAND FOUND: $1\n ";
	}
	
	# A document line?
	else{
	    if($tablestate == 2){
		$tablecolcount = 0;
		$temp = $_;
		while($temp =~ /<entry>/g){ $tablecolcount++ }

		print OUTPUT "<tgroup cols='$tablecolcount' align='left' colsep='1' rowsep='1'><tbody>\n";
		$tablestate = 3;
	    }

	    print OUTPUT "$_";
	    $tablecellline = "";
	}
    }
    
    endpara();
    
    if($liststate == 1){
	dblog("{DBLOG: Not closed list at end of document!}");
    }
    
    if($footnotestate == 1){
	dblog("{DBLOG: Not closed footnote at end of document!}");
    }
    
    while($sectionstate > 0){
	print OUTPUT "</section>\n";
	$sectionstate--;
    }
    
    # Some input files are not used because they don't exist!
    if($inputused > 0){
        print OUTPUT "</chapter>\n";
    }
    else{
        print "  File was empty\n";
    }

    close INPUT;

    if($outputstyle ne "jade"){
	close OUTPUT;
    }
}

print "\bProcessed $chaptercount chapters\n";
print OUTPUT "</book>\n";
exit;

sub liststart(){
    endpara();

    if($liststate == 0){
        print OUTPUT "<itemizedlist>\n";
        }
    else{
        if($listitemstate > 0){
            print OUTPUT "</listitem>\n";
            $listitemstate--;
        }

        print OUTPUT "</itemizedlist>\n";
        print OUTPUT "<orderedlist>\n";
        }

    $liststate++;
    }

sub endpara(){
    if($parastate > 0){
	print OUTPUT "</para>\n";
	$parastate--;
    }
}

sub startpara(){
    if($displaystate == 0){
	print OUTPUT "<para>";
	$parastate++;
    }
    else{
	print OUTPUT "\n\n";
    }
}

sub processstyles(){
    my($line) = @_;
    my($newline, $word, $retStr, $length);
    
    $newline = "";

    # It turns out that a whole bunch of these are actually font change
    # commands...
    foreach $word (split(/ /, $line)){
	$length = 0;

	while($length != length($word)){
	    $length = length($word);

	    $_ = $word;
	    if(/(.*)\\fB(.*)/){
		$word = closeallstates() . "$1<command>$2";
		$stylestate = "$stylestate" . "B";
	    }
	    
	    $_ = $word;
	    if(/(.*)\\fI(.*)/){
		$word = "$1<emphasis>$2";
		$stylestate = "$stylestate" . "I";
	    }
	    
	    $_ = $word;
	    if(/(.*)\\fC(.*)/){
		$word = closeallstates() . "$1<command>$2";
		$stylestate = "$stylestate" . "c";
	    }
	    
	    $_ = $word;
	    if(/(.*)\\f\(CW(.*)/){
		$word = "$1<emphasis>$2";
		$stylestate = "$stylestate" . "W";
	    }
	    
	    $_ = $word;
	    if(/(.*)\\f\(CB(.*)/){
		$word = closeallstates() . "$1<command>$2";
		$stylestate = "$stylestate" . "b";
	    }
	    
	    $_ = $word;
	    if(/(.*)\\f([RP])(.*)/){
		dblog("{$stylestate}");
		
		if($2 eq "R"){
		    $word = "$1" . closeallstates() . "$3";
		}
		else{
		    $retStr = closestate(substr($stylestate, length($stylestate) - 1, 1));
		    if($1 eq ""){
			$word = "$retStr$3";
		    }
		    else{
			$word = "$1$retStr$3";
		    }
		    $stylestate =~ s/[A-Za-z]$//;
		}
	    }

	    # Horizontal spacing (no mapping to docbook)
	    $_ = $word;
	    s/\\\|//g;
	    $word = $_;
	}
	
	$newline = "$newline$word ";
    }
    return $newline;
}

sub closeallstates(){
    my($retStr, $count);

    $retStr = "";
    for($count = length($stylestate) - 1; $count > -1; $count--){
	$retStr = $retStr . 
	    closestate(substr($stylestate, $count, 1));
    }
    
    $stylestate = "";
    return $retStr;
}

sub closestate(){
    my($state) = @_;

    if($state eq "I"){
	return "<\/emphasis>";
    }
    elsif($state eq "B"){
	return "<\/command>";
    }
    elsif($state eq "b"){
	return "<\/command>";
    }
    elsif($state eq "W"){
	return "<\/emphasis>";
    }
    elsif($state eq "c"){
	return "<\/command>";
    }
    else{
	return "";
    }
}

sub dblog(){
    my($string) = @_;
#    print OUTPUT $string;
}
