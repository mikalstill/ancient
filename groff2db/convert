#!/usr/bin/perl

# The basic concept of this script to to convert troff marked up input into
# docbook compliant XML.

# Heading state handling needs some love
# Index entries also need work
# Check for <para></para><para></para>
# Screen is not entirely appropriate for display mapping
# Lists within lists
# Email address are note properly identified

use strict;
my($INPUT, $OUTPUT);
my($parastate, $liststate, $listitemstate, $footnotestate, $sectionstate, $italicstate, $displaystate, $emailstate);
my($length);
my($chapters, $chapter, $chaptercount);

$chapters = "introduction.mm concepts.mm evolution.mm quickinstall.mm shareinstall.mm install.mm xsetup.mm postinstall.mm ports.mm problems.mm xtheory.mm unixref.mm starting.mm filesys.mm disks.mm tapes.mm printers.mm desktop.mm building.mm current.mm emulate.mm netintro.mm netsetup.mm isp.mm modems.mm ppp.mm slip.mm dns.mm firewall.mm netdebug.mm nfs.mm netbasics.mm email.mm www.mm fax.mm micronet.mm mobile.mm";

$chaptercount;

open OUTPUT, "> output.sgml";

# Print out the prelude
#print OUTPUT "<?xml version='1.0'?>\n";
#print OUTPUT "<!DOCTYPE book PUBLIC \"-//Norman Walsh//DTD DocBk XML V3.1.4//EN\"\n";
#print OUTPUT "                         \"http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd\">\n";
print OUTPUT "<!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook V3.1//EN\">\n";
print OUTPUT "<book><bookinfo><title>The Complete FreeBSD</title><author><firstname>Greg</firstname><surname>Lehey</surname></author><copyright><year>2001</year><holder>Greg Lehey</holder></copyright></bookinfo>\n";

# For each chapter we specified
foreach $chapter (split(/ /, $chapters)){
    $chaptercount++;
    print "Processing chapter $chapter ($chaptercount)\n";
    open INPUT, "< $chapter";

    $liststate = 0;
    $listitemstate = 0;
    $parastate = 0;
    $footnotestate = 0;
    $sectionstate = 0;
    $italicstate = 0;
    $displaystate = 0;
    $emailstate = 0;
    
    # For each line in the file...
    while(<INPUT>){
#	print OUTPUT "LlPFSIDE $liststate$listitemstate$parastate$footnotestate$sectionstate$italicstate$displaystate$emailstate\n";

	# We run some little conversion rules to deal with things like italics et al
	
	# Ampersands
	s/&/&amp;/g;

	# LT
	s/</&lt;/g;

	# GT
	s/>/&gt;/g;

	# Footnote thingie we don't use
	s/\\\*F//g;
	
	# Italics
	$length = length $_;
	s/\\fI/<emphasis>/g;
	if($length != length($_)){
	    $italicstate++;
	    dblog($OUTPUT, "DBLOG: Turned italic state on ($italicstate)\n");
	}

   	$length = length $_;
	s/\\f\(CB/<emphasis>/g;
	if($length != length($_)){
	    $italicstate++;
	    dblog($OUTPUT, "DBLOG: Turned italic state on ($italicstate)\n");
	}

	if($italicstate > 0){
	    $length = length($_);
	    s/\\fP[^ \t,.]*/<\/emphasis>/g;
	    if($length != length($_)){
		$italicstate--;
	    }
	    else{
		s/\\fR[^ \t,.]*/<\/emphasis>/g;
		if($length != length($_)){
		    $italicstate--;
		}
	    }
	}

	# Email addresses
	$length = length $_;
	s/\\f\(CW/<emphasis>/g;
	if($length != length($_)){
	    $emailstate++;
	}
	
	if($emailstate == 1){
	    $length = length($_);
	    s/\\fP[^ \t,.]*/<\/emphasis>/g;
	    if($length != length($_)){
		$emailstate--;
	    }
	    else{
		s/\\fR[^ \t,.]*/<\/emphasis>/g;
		if($length != length($_)){
		    $emailstate--;
		}
	    }
	}

	# Prompts
	s/\\fC([^ \t,.]*)/<command>$1<\/command>/g;

	##############################################################
	# Comments
	if(/^\.\\\"(.*)/i){
	}

	# Aside start
	elsif(/^\.Aside(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "<sidebar><para>\n";
	}

	elsif(/^\.End-aside(.*)/i){
	    print OUTPUT "</para></sidebar><para>\n";
	    $parastate++;
	}
	
	# Display start
	elsif(/^\.DS(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "<screen>\n";
	    $displaystate = 1;
	}

	# Display start
	elsif(/^\.Dx(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "<screen>\n";
	    $displaystate = 1;
	}
	
	# Display end
	elsif(/^\.DE(.*)/i){
	    if($displaystate == 1){
		print OUTPUT "</screen><para>\n";
	    }
	    $displaystate = 0;
	    $parastate++;
	}
	
	# Footnote start
	elsif(/^\.FS[ \t]*(.*)/i){
	    print OUTPUT "<footnote><para>\n";
	    $parastate++;
	    $footnotestate = 1;
	}
	
	# Footnote end
	elsif(/^\.FE[ \t]*(.*)/i){
	    if($footnotestate == 0){
		dblog($OUTPUT, "DBLOG: Footnote end for a non-open footnote!\n");
	    }
	    
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "</footnote>\n";
	    $footnotestate = 0;
	}
	
	# Headings
	elsif(/^\.H([0-7])[ \t]*(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    
	    if($sectionstate == 1){
		print OUTPUT "</section>\n";
	    }
	    
	    $_ = $2;
	    s/\"//g;
	    
	    print OUTPUT "<section><title>$_</title>\n";
	    print OUTPUT "<para>\n";
	    $parastate++;
	    $sectionstate = 1;
	}
	
	# Headings (Unsupported)
	elsif(/^\.H([8-9])[ \t]*(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "<section><title>Title???</title>\n";
	    $sectionstate = 1;
	}
	
	# List start
	elsif((/^\.LS(.*)/i) || (/^\.LB(.*)/i)){
	    $parastate = endpara($parastate, $OUTPUT);

	    if($liststate == 0){
		print OUTPUT "<itemizedlist>\n";
	    }
	    else{
		if($listitemstate > 0){
		    print OUTPUT "</listitem>\n";
		    $listitemstate--;
		}

		print OUTPUT "</itemizedlist>\n";
		print OUTPUT "<orderedlist>\n";
	    }
	    $liststate++;
	}
	
	# List item
	elsif(/^\.LI(.*)/i){
	    if($liststate == 0){
		dblog($OUTPUT, "DBLOG: List item for a non-open list!\n");
	    }
	    
	    $parastate = endpara($parastate, $OUTPUT);
	    if($listitemstate == 1){
		print OUTPUT "</listitem>\n";
	    }
	    
	    print OUTPUT "<listitem><para>\n";
	    $parastate++;
	    $listitemstate = 1;
	}
	
	# List end
	elsif(/^\.LE(.*)/i){
	    if($liststate == 0){
		dblog($OUTPUT, "DBLOG: List end for a non-open list!\n");
	    }
	    
	    $parastate = endpara($parastate, $OUTPUT);
	 
	    if($listitemstate > 0){
		print OUTPUT "</listitem>\n";
	    }

	    if($liststate == 1){
		print OUTPUT "</itemizedlist><para>\n";
		$parastate++;
	    }
	    else{
		print OUTPUT "</orderedlist>\n";
		print OUTPUT "<itemizedlist>\n";
	    }
	    $liststate--;
	    dblog($OUTPUT, "DEBUG DBLOG: listlevel = $liststate\n");
	    $listitemstate = 0;

	    if($liststate < 0){
		dblog($OUTPUT, "DBLOG: Negative list state entered\n");
	    }
	}
	
	# Unknown tag!
#    elsif(/^\.Pn[ \t]+(.*)/i){
#	print "UNKNOWN COMMAND: Pn [Arg $1]\n";
#    }
	
	# Paragraphs
	elsif(/^\.P[ \t]*([0-9]*)(.*)/i){
	    $parastate = endpara($parastate, $OUTPUT);
	    print OUTPUT "<para>\n";
	    $parastate++;
	}
	
	# Unknown command
#    elsif(/^\.Sref[ \t]*(.*)/i){
#	print "UNKNOWN COMMAND: Sref [Arg $1]\n";
#    }
	
	# Table start
	elsif(/^\.TS[ \t]*(.*)/i){
	    print OUTPUT "Table start: [Arg $1]\n";
	}
	
	# Table end
	elsif(/^\.TE/i){
	    print OUTPUT "Table end\n";
	}

	# 
	elsif(/^\.Chapter[ \t]([^ \t]*)[ \t]\"(.*)\"/){
	    print OUTPUT "<chapter><title>$2</title>\n";
	    print OUTPUT "<section><title></title>\n";
	    print OUTPUT "<para>\n";
	    $parastate++;
	    $sectionstate = 1;
	    }

	elsif(/^\.X[ \t]\"([^ \"]*)[\"]*/i){
	    print OUTPUT "<indexterm><primary>$1</primary></indexterm>\n";
	}
	
	# We don't know anything about this command at all
	elsif(/^\.(.*)/i){
	    dblog($OUTPUT, "DBLOG: DEFAULT COMMAND FOUND: $1\n");
	}
	
	# A document line?
	else{
	    print OUTPUT "\t\t$_";
	}
    }
    
    $parastate = endpara($parastate, $OUTPUT);
    
    if($liststate == 1){
	dblog($OUTPUT, "DBLOG: Not closed list at end of document!\n");
    }
    
    if($footnotestate == 1){
	dblog($OUTPUT, "DBLOG: Not closed footnote at end of document!\n");
    }
    
    if($sectionstate == 1){
	dblog($OUTPUT, "DBLOG: Not closed section at end of document (closed)!\n");
	print OUTPUT "</section>";
    }
    
    print OUTPUT "</chapter>\n";
    close INPUT;
}

print "Processed $chaptercount chapters\n";
print OUTPUT "</book>\n";
exit;

sub endpara(){
    my($ps, $OUTPUT) = @_;

    if($ps > 0){
	print OUTPUT "</para>\n";
	$ps--;
    }
    else{
	dblog($OUTPUT, "DBLOG: Chose not to close para here (parastate is $ps)\n");
    }

    return $ps;
}

sub dblog(){
    my($OUTPUT, $string) = @_;

#    print OUTPUT $string;
}
