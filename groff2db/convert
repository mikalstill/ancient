#!/usr/bin/perl

# groff2db. Copyright (c) Michael Still 2001
# Released under the terms of the GNU GPL. Please submit all patches to mikal@stillhq.com
# Initially developed for Greg Lehey's "The Complete FreeBSD"...

# The basic concept of this script to to convert troff marked up input into
# docbook compliant XML.

# Heading state handling needs some love
# Index entries also need work
# Check for <para></para><para></para>
# Screen is not entirely appropriate for display mapping
# Lists within lists
# Email address are note properly identified
# Bold is also an emphasis at the moment
# And R'ing of text
# Table formatting

use strict;
my($INPUT, $OUTPUT);
my($parastate, $liststate, $listitemstate, $footnotestate, $sectionstate, $tablestate, $stylestate, $displaystate, $waitstate);
my($length);
my($chapters, $chapter, $chaptercount, $temp, $inputused);
my(@spinner, $linecount, $condlinecount);

$chapters = "introduction.mm concepts.mm evolution.mm quickinstall.mm shareinstall.mm install.mm xsetup.mm postinstall.mm ports.mm problems.mm xtheory.mm unixref.mm starting.mm filesys.mm disks.mm tapes.mm printers.mm desktop.mm building.mm current.mm emulate.mm netintro.mm netsetup.mm isp.mm modems.mm ppp.mm slip.mm dns.mm firewall.mm netdebug.mm nfs.mm netbasics.mm email.mm www.mm fax.mm micronet.mm mobile.mm";
#$chapters = "filesys.mm";
#$chapters = "xtheory.mm";

$spinner[0] = "-";
$spinner[1] = "\\";
$spinner[2] = "|";
$spinner[3] = "/";

$chaptercount = 0;
$linecount = 0;

open OUTPUT, "> output.sgml";

# Print out the prelude
#print OUTPUT "<?xml version='1.0'?>\n";
#print OUTPUT "<!DOCTYPE book PUBLIC \"-//Norman Walsh//DTD DocBk XML V3.1.4//EN\"\n";
#print OUTPUT "                         \"http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd\">\n";
print OUTPUT "<!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook V3.1//EN\">\n";
print OUTPUT "<book><bookinfo><title>The Complete FreeBSD</title><author><firstname>Greg</firstname><surname>Lehey</surname></author><copyright><year>2001</year><holder>Greg Lehey</holder></copyright></bookinfo>\n";

# For each chapter we specified
foreach $chapter (split(/ /, $chapters)){
    $chaptercount++;
    print "Processing chapter $chapter ($chaptercount)\n ";
    open INPUT, "< $chapter";

    $liststate = 0;
    $listitemstate = 0;
    $parastate = 0;
    $footnotestate = 0;
    $sectionstate = 0;
    $tablestate = 0;
    $displaystate = 0;
    $stylestate = "";
    $inputused = 0;
    
    # For each line in the file...
    while(<INPUT>){
	$linecount++;
        $inputused = 1;
	print "\b$spinner[$linecount % 4]";

	# There are some conditional elements used, for instance in xtheory.mm (which is also an
	# article)
	if((/^..if article/) || (/^..if XXX/)){
	    $waitstate = 1;
	    $condlinecount = 0;
	    while(($waitstate == 1) && ($_ = <INPUT>)){
		$linecount++;
		$condlinecount++;

		if(/^..else/){
		    $waitstate = 0;
		}
		elsif(/^..endif/){
		    $waitstate = 0;
		}
	    }
	    print "\b  [Conditional was $condlinecount lines]\n ";
	}

	# Ampersands
	s/&/&amp;/g;

	# LT
	s/</&lt;/g;

	# GT
	s/>/&gt;/g;

	# Mu (micro) doesn't work with db2ps
	s/µ/&mu;/g;

	# Footnote thingie we don't use
	s/\\\*F//g;

	# We run some little conversion rules to deal with things like italics et al
	if($displaystate == 0){
	    $temp = processstyles($_);
	    $_ = $temp;	
	}

	# Prompts
	s/\\fC([^ \t,.]*)/<command>$1<\/command>/g;

	##############################################################
	# Comments
	if(/^\.\\\"(.*)/i){
	}

	# Aside start
	elsif(/^\.Aside(.*)/i){
	    endpara();
	    print OUTPUT "<sidebar>\n";
            startpara();
	}

	elsif(/^\.End-aside(.*)/i){
            endpara();
	    print OUTPUT "</sidebar>\n";
            startpara();
	}
	
	# Display start -- is case sensitive
	elsif(/^\.DS(.*)/){
	    endpara();
	    print OUTPUT "<screen>\n";
	    $displaystate = 1;
	}

	# Display start
	elsif(/^\.Dx(.*)/i){
	    endpara();
	    print OUTPUT "<screen>\n";
	    $displaystate = 1;
	}
	
	# Display end
	elsif(/^\.DE(.*)/i){
	    if($displaystate == 1){
		print OUTPUT "</screen>\n";
                startpara();
	    }
	    $displaystate = 0;
	}
	
	# Footnote start
	elsif(/^\.FS[ \t]*(.*)/i){
	    print OUTPUT "<footnote>\n";
            startpara();
	    $footnotestate = 1;
	}
	
	# Footnote end
	elsif(/^\.FE[ \t]*(.*)/i){
	    if($footnotestate == 0){
		dblog("{DBLOG: Footnote end for a non-open footnote!}");
	    }
	    
	    endpara();
	    print OUTPUT "</footnote>\n";
	    $footnotestate = 0;
	}
	
	# Headings
	elsif(/^\.H([0-7])[ \t]*(.*)/i){
	    endpara();
	    
	    if($sectionstate == 1){
		print OUTPUT "</section>\n";
	    }
	    
	    $_ = $2;
	    s/\"//g;
	    
	    print OUTPUT "<section><title>$_</title>\n";
            startpara();
	    $sectionstate = 1;
	}
	
	# Headings (Unsupported)
	elsif(/^\.H([8-9])[ \t]*(.*)/i){
	    endpara();
	    print OUTPUT "<section><title>Title???</title>\n";
	    $sectionstate = 1;
	}
	
	# List start
	elsif((/^\.LS(.*)/i) || (/^\.LB(.*)/i)){
            liststart();
	}
	
	# List item
	elsif(/^\.LI(.*)/i){
	    if($liststate == 0){
		dblog("{DBLOG: List item for a non-open list!}");
                liststart();
	    }
	    
	    endpara();
	    if($listitemstate == 1){
		print OUTPUT "</listitem>\n";
	    }
	    
	    print OUTPUT "<listitem>\n";
            startpara();
	    $listitemstate = 1;
	}
	
	# List end
	elsif(/^\.LE(.*)/i){
	    if($liststate == 0){
		dblog("{DBLOG: List end for a non-open list!}");
	    }
	    
	    endpara();
	 
	    if($listitemstate > 0){
		print OUTPUT "</listitem>\n";
	    }

	    if($liststate == 1){
		print OUTPUT "</itemizedlist>\n";
                startpara();
	    }
	    else{
		print OUTPUT "</orderedlist>\n";
		print OUTPUT "<itemizedlist>\n";
	    }
	    $liststate--;
	    dblog("{DEBUG DBLOG: listlevel = $liststate}");
	    $listitemstate = 0;

	    if($liststate < 0){
		dblog("{DBLOG: Negative list state entered}");
	    }
	}
	
	# Unknown tag!
#    elsif(/^\.Pn[ \t]+(.*)/i){
#	print "UNKNOWN COMMAND: Pn [Arg $1]\n";
#    }
	
	# Paragraphs
	elsif(/^\.P[ \t]*([0-9]*)(.*)/i){
	    endpara();
            startpara();
	}
	
	# Unknown command
#    elsif(/^\.Sref[ \t]*(.*)/i){
#	print "UNKNOWN COMMAND: Sref [Arg $1]\n";
#    }
	
	# Table start
	elsif(/^\.TS[ \t]*(.*)/i){
	    print OUTPUT "Table start: [Arg $1]\n";
	}
	
	# Table end
	elsif(/^\.TE/i){
	    print OUTPUT "Table end\n";
	}

	# 
	elsif(/^\.Chapter[ \t]([^ \t]*)[ \t]\"(.*)\"/){
	    print OUTPUT "<chapter><title>$2</title>\n";
	    print OUTPUT "<section><title></title>\n";
            startpara();
	    $sectionstate = 1;
	    }

	elsif(/^\.X[ \t]\"([^ \"]*)[\"]*/i){
	    print OUTPUT "<indexterm><primary>$1</primary></indexterm>\n";
	}
	
	# We don't know anything about this command at all
	elsif(/^\.(.*)/i){
	    dblog("{DBLOG: DEFAULT COMMAND FOUND: $1}");
	}
	
	# A document line?
	else{
	    print OUTPUT "\t\t$_";
	}
    }
    
    endpara();
    
    if($liststate == 1){
	dblog("{DBLOG: Not closed list at end of document!}");
    }
    
    if($footnotestate == 1){
	dblog("{DBLOG: Not closed footnote at end of document!}");
    }
    
    if($sectionstate == 1){
	dblog("{DBLOG: Not closed section at end of document (closed)!}");
	print OUTPUT "</section>\n";
    }
    
    # Some input files are not used because they don't exist!
    if($inputused > 0){
        print OUTPUT "</chapter>\n";
    }
    else{
        print "  File was empty\n";
    }

    close INPUT;
}

print "\bProcessed $chaptercount chapters\n";
print OUTPUT "</book>\n";
exit;

sub liststart(){
    endpara();

    if($liststate == 0){
        print OUTPUT "<itemizedlist>\n";
        }
    else{
        if($listitemstate > 0){
            print OUTPUT "</listitem>\n";
            $listitemstate--;
        }

        print OUTPUT "</itemizedlist>\n";
        print OUTPUT "<orderedlist>\n";
        }

    $liststate++;
    }

sub endpara(){
    if($parastate > 0){
	print OUTPUT "$parastate</para>\n";
	$parastate--;
    }
}

sub startpara(){
    print OUTPUT "<para>";
    $parastate++;
}

sub processstyles(){
    my($line) = @_;
    my($newline, $word, $retStr, $count);
    
    $newline = "";

    foreach $word (split(/ /, $line)){
	$_ = $word;
	if(/^(.*)\\fB(.*)/){
	    if($1 eq ""){
		$word = "<command>$2";
	    }
	    else{
		$word = "$1<command>$2";
	    }
	    $stylestate = "$stylestate" . "B";
	}
	
	$_ = $word;
	if(/^(.*)\\fI(.*)/){
	    if($1 eq ""){
		$word = "<emphasis>$2";
	    }
	    else{
		$word = "$1<emphasis>$2";
	    }
	    $stylestate = "$stylestate" . "I";
	}

	$_ = $word;
	if(/^(.*)\\f\(CW(.*)/){
	    if($1 eq ""){
		$word = "<emphasis>$2";
	    }
	    else{
		$word = "$1<emphasis>$2";
	    }
	    $stylestate = "$stylestate" . "W";
	}

	$_ = $word;
	if(/^(.*)\\f\(CB(.*)/){
	    if($1 eq ""){
		$word = "<command>$2";
	    }
	    else{
		$word = "$1<command>$2";
	    }
	    $stylestate = "$stylestate" . "b";
	}

	$_ = $word;
	if(/^(.*)\\f([RP])(.*)/){
	    dblog("{$stylestate}");

	    if($2 eq "R"){
		for($count = length($stylestate) - 1; $count > -1; $count--){
		    $retStr = closestate(substr($stylestate, $count, 1));
	       
		    if($1 eq ""){
			$word = "$retStr$3";
		    }
		    else{
			$word = "$1$retStr$3";
		    }
		}
		$stylestate = "";
	    }
	    else{
		$retStr = closestate(substr($stylestate, length($stylestate) - 1, 1));
		if($1 eq ""){
		    $word = "$retStr$3";
		}
		else{
		    $word = "$1$retStr$3";
		}
		$stylestate =~ s/[A-Za-z]$//;
	    }
	}
	
	$newline = "$newline$word ";
    }
    return $newline;
}

sub closestate(){
    my($state) = @_;

    if($state eq "I"){
	return "<\/emphasis>";
    }
    elsif($state eq "B"){
	return "<\/command>";
    }
    elsif($state eq "b"){
	return "<\/command>";
    }
    elsif($state eq "W"){
	return "<\/emphasis>";
    }
    else{
	return "";
    }
}

sub dblog(){
    my($string) = @_;
#    print OUTPUT $string;
}
