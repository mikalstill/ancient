<chapter id="chap-gif"><title>GIF</title>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>

<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>








<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
<para>

<sidebar><title>Data streams?</title>
<para>
It should be noted that the GIF specification doesn't speak of files as such. Instead it uses the term <quote>Data Stream</quote>, which is a concept which embraces files, as well as in memory buffers, and other interesting forms of data storage. It doesn't really make any difference to the discussion of the format here though.
</para>
</sidebar>

<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>
</sect2>

<sect2><title>The header</title>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>

<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>

<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>
</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>

<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</para>

<sect3><title>Formula for global color table size</title>
<para>
The determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</empasis>, or 255 items.
</para>

<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>

<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>

<sect3><title>Image descriptors</title>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>

<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
The packed field byte stores the following information:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>
</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>

<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>

<execute><cmd>nextedition</cmd><input>Perhaps we should talk about compression algorithms?</input></execute>

<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>

<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>

<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>

</sect4>
</sect3>
</sect2>

<sect2><title>Special purpose blocks</title>
<para>
The other thing which can be stored in the data area of the data stream of a GIF file is special purpose blocks. These are outside the scope of this tutorial, and wont be discussed here.
</para>

<execute><cmd>nextedition</cmd><input>Discuss them</input><execute>
</sect2>

<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>
</sect2>

<execute><cmd>nextedition</cmd><input>It would be cool to present grammars for all the image formats to help people understand them</input></execute>

<sect2><title>Interlaced images</title>
<para>
GIF supports the interlacing of images, which is where are the image is loaded, progressively better representations of the image are displayed. Discussing the inner workings of this within the file format is out of the scope of this tutorial however.
</para>

<execute><cmd>nextedition</cmd><input>Discuss</input></execute>
</sect2>
</sect1>


















<sect1><title>giflib</title>
<para>
This library was originally written by Gershon Elbor and Eric Raymond. In the words of the history in the documentation for giflib:
</para>

<programlisting>
This package was originally written by Gershon Elber in 1990 on an IBM PC under MS-DOS using Borland Turbo C. He made it portable to several UNIX environments.

The 2.1 version featured substantial changes and additions by Eric S. Raymond . These included the DGifSlurp/EGifSpew function pair for enabling non-sequential operations on GIF images and
the tools icon2gif, gifovly, gifburst, and gifcompose.

The 2.4 version converted all the docs from an idiosyncratic plain-text formal to to HTML.
</programlisting>

<para>
It is now maintained by Toshio Kuratomi (badger@prtr-13.ucsc.edu), and the website for giflib is at http://prtr-13.ucsc.edu/~badger/software/giflib.shtml. It should be noted that the download link for giflib on this site is broken, and that I had to dig a little to find a copy of giflib. I have therefore included it in the contrib directory of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
Installing giflib is fairly trivial. Simply follow the steps below...
</para>

<sect3><title>Unix</title>
<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the giflib directory</para></listitem>
<listitem><para>As shipped, the directory includes a few files which might cause you build problems. Delete config.cache and config.log manually</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>
</sect3>

<sect3><title>win32</title>
<para>
As far as I am aware, giflib is not currently supported on win32. I have not personally verified this though.
</para>

<execute><cmd>nextedition</cmd><input>Verify</input></command>
</sect3>
</sect2>

<sect2><title>Man pages</title>
<para>
giflib doesn't ship with man pages. It does however come with a large amount of documentation in HTML format, which I have included here for your reference.
</para>

<sect2><title>gif2bgi</title>
<programlisting>

   Go to [1]index page.

                                  gif2bgi

   A  program  to  display  images  saved  as GIF files on IBM PC display
   devices using the BGI (Borland) driver interface.

   The program operates as follows:

    1. Reads the GIF file header and determines the image size.
    2. Dynamically   allocates  enough  memory  to  hold  all  the  image
       internally.  One  byte  per pixel is always allocated, so a little
       bit  more  than  width*height  (of  screen,  not  image) bytes are
       required.
    3. Reads  all  the image in. Interlaced images are read in correctly,
       although they are displayed sequentially.
    4. Display  first image using the defaults as set by the command line
       option.
    5. Goes   to   interactive  mode.  For  a  full  description  of  the
       interactive mode see below.

                                    Usage:

gif2bgi [-q] [-d BGI dir] [-u driver] [-z zoom] [-b] [-h] gif-file

   If no GIF is given, gif2bgi will try to read a GIF file from stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d BGI Directory]
          Where  we  should  look  for  default  drivers  (as supplied by
          Borland). For example '-d c:/tc/bgi'.

   [-u driver]
          Specifies  a user-defined BGI driver. If for example you have a
          BGI  driver  for your special vga called MYVGA.BGI and you want
          to run it in mode 2, then type '-u c:/tc/bgi/myvga.2'. Note the
          absolute  path  to the driver must be specified. Also note that
          we use '/' and not '\' so they won't be treated as options.

   [-z zoom]
          Sets  zoom factor of the view. Zoom factor should be power of 2
          up to 256. Default is 1 (no zoom).

   [-h]
          Print one line of command-line help, similar to Usage above.

                               Interactive mode:

   Once the image is displayed, the gif2bgi program goes into interactive
   mode which recognizes the following commands:

   C - get Color and position
          In this submenu, a cursor appears and the location and color of
          the  pixel  underneath it are printed. The 4 arrows may be used
          (shifted for faster movement) to move the cursor. Any other key
          will abort this submode.

   D - zoom Down
          Zoom down by factor of 2 unless current zoom factor is 1.

   R - Redraw
          Redraw the image.

   S - print Status
          Print status of image and program.

   U - zoom Up
          Zoom up by factor of 2 unless current zoom factor is 256.

   arrow keys
          The  4  arrow keys can be used to pan in the desired direction,
          if  the  image  overflows  in that direction. If the image fits
          into  the screen, arrow keys are ignored. The panning steps are
          1/2 screen if not on image end.

   SPC - abort
          Space bar may be used to abort current image drawing.

   ESC - abort
          Escape may be used to abort current image drawing.

                                    Notes:

   This  program  is  useless  in  a Unix environment and is not normally
   built there.

   No  color  quantization  is used in this program; thus, if a GIF image
   has more colors than the BGI driver support, this program will abort.

   This  driver  is  optimized  for  drivers with one byte per pixel (256
   colors) and will run MUCH faster on such drivers.

                                     Bugs:

   For some reason I could not figure out, on my ATI wonder card, int 10h
   call  10h  (AH = AL = 10h) to set the color registers sometimes result
   with  wrong  colors. Direct access of the card registers gives correct
   results.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2epsn</title>
<programlisting>

   Go to [1]index page.

                                  gif2epsn

   A program to dump images saved as GIF files on Epson type printers.

                                    Usage:

gif2epsn [-q] [-d dither] [-t bw] [-m map] [-i] [-n] [-p printer] [-h] gif-file

   If  no  gif-file  is  given, Gif2Epsn will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d dither]
          Sets size of dithering matrix, where DitherSize can be 2,3 or 4
          only  (for  2x2, 3x3 and 4x4 dithering matrices). Default is 2.
          Note  image  will be displayed in this mode only if the mapping
          option (see -m) selected this mode.

   [-t bw]
          Sets threshold level for B&W mapping in percent. This threshold
          level  is  used  in  the different mappings as selected via -m.
          Default is 19%.

   [-m map]
          Select method to map colors to B&W. Mapping can be:

        0
                Every  none  background  color  is  considered foreground
                (white  color but is drawn as black by printer, unless -i
                is specified).

        1
                If  0.3  *  RED  +  0.59 * GREEN + 0.11 * YELLOW > BW the
                pixel is considered white color.

        2
                Colors  are  mapped as in 1, and use dithering of size as
                defined  using  -d  option.  BWthreshold  is used here as
                scaler.

          The default is option 0.

   [-i]
          Invert the image, i.e. black -> white, white -> black.

   [-n]
          Nicer image. Uses double-density feature of Epson printer. This
          takes  more  time  (and kills your ink cartridge faster...) but
          results are usually better.

   [-p printer]
          Under  Unix,  output  goes to stdout by default; under DOS, the
          default  is  LPT1:. With this switch you can specify the output
          target.

   [-h]
          print one line of command line help, similar to Usage above.

                                    Notes:

   The  output has an aspect ratio of 1, so a square image will be square
   in hardcopy as well.

   The  widest  image  can be printed is 640 pixels, on 8 inch paper. You
   probably  will need to flip wider images, if height is less than that:
   `[2]gifflip -r x29.gif | gif2epsn'. Wider images will be clipped.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [3]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
   3. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2herc</title>
<programlisting>

   Go to [1]index page.

                                  gif2herc

   A  program  to display images saved as GIF files on an IBM PC Hercules
   graphic card. The program operates as follows:

    1. Read GIF file header and determine size of the image.
    2. Dynamically   allocate   enough  memory  to  hold  all  the  image
       internally.  One  byte  per pixel is always allocated, so a little
       bit  more  than  width*height  (of  screen,  not  image) bytes are
       required.
    3. Reads the image in. Interlaced images are read correctly, although
       they are displayed sequentially.
    4. Display  first image using the defaults as set by the command line
       option.
    5. Goes  to interactive mode. For full description of the interactive
       mode see below.

                                    Usage:

gif2herc [-q] [-d dither] [-z zoom] [-t bw] [-m map] [-i] [-b] [-h] gif-file

   If  no  gif-file  is  given, gif2herc will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
   Quiet mode. Defaults off on MSDOS, on under UNIX. Controls printout of
   running scan lines. Use -q- to invert.

   [-d dither]
   Sets  size of dithering matrix, where dither can be 2,3 or 4 only (for
   2x2,  3x3  and  4x4 dithering matrices). Default is 2. Note: the image
   will be dithered only if the mapping (see -m) selected dithering mode.

   [-z zoom]
   Sets  zoom factor of the image. Zoom factor should be power of 2 up to
   256. Default is 1 (no zoom).

   [-t bw]
   Sets  threshold level for B&W mapping in percent. This threshold level
   is used in the different mappings as selected via -m. Default is 19%.

   [-m map]
   Select method to map colors to B&W. Mapping can be:

   0
          Every non-background color is considered foreground (white).

   1
          0.3  *  RED  +  0.59  *  GREEN + 0.11 * YELLOW > BWThreshold is
          considered white.

   2
          Colors are mapped as in 1, and use dithering of size as defined
          using -d option. BWthreshold is used here as scaler.

   Default is option 0, which is much faster than the other two.

   [-i]
   Invert the image, i.e. black -> white, white -> black.

   [-b]
   Disable  beeps.  Every  time the image is complete, or a wrong key was
   presses, sound is generated. The -b option disables that.

   [-h]
   Print one line of command line help, similar to Usage above.

                               Interactive mode:

   Once the image is displayed, the program goes into an interactive mode
   which recognizes the following commands:

   C - get Color and position
          In this submenu, a cursor appears and the location and color of
          the  pixel  underneath it are printed. The 4 arrows may be used
          (shifted for faster movement) to move the cursor. Any other key
          will abort this submode.

   D - zoom Down
          Zoom down by factor of 2 unless current zoom factor is 1.

   H - Increase dither matrix size
          ...unless  current  size  is maximum (4), in which case size is
          set to minimum (2).

   I - Invert
          Invert the image, i.e. white -> black, black -> white.

   M - Method
          Increment  color -> BW mapping method, unless current method is
          maximum (2), in which case method is set to minimum (0).

   R - Redraw
          Redraw the image.

   S - print Status
          Print status of image and program.

   U - zoom Up
          Zoom up by factor of 2 unless current zoom factor is 256.

   arrow keys
          The  4  arrow keys can be used to pan in the desired direction,
          if  the  image  overflows  in that direction. If the image fits
          into  the screen, arrow keys are ignored. The panning steps are
          1/2 screen if not on image end.

   SPC - abort
          Space bar may be used to abort current image drawing.

   ESC - abort
          Escape may be used to abort current image drawing.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2iris</title>
<programlisting>

   Go to [1]index page.

                                  gif2iris

   A  program  to  display  images  saved as GIF files under the SGI NeWs
   window system.

                                    Usage:

Gif2Iris [-q] [-f] [-p PosX PosY] [-f] [-h] gif-file

   If no gif-file is given, Gif2Iris will try to read a GIF from stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-f]
          Force Gif2Iris to stay in foreground.

   [-p PosX PosY]
          Defines  position  of  image  on screen. By default the program
          will prompt for position.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2ps</title>
<programlisting>

   Go to [1]index page.

                                   gif2ps

   GIF-to-PostScript conversion.

                                    Usage:

gif2ps [-q] [-x] [-y] [-s sx sy] [-p px py] [-i] [-n copies] [-h] gif-file

   If  no  gif-file  is  given,  Gif2PS  will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-x]
          Force  image  to  be  horizontal (`landscape mode'). By default
          image  will  be  positioned so it will be the biggest. If -x is
          given image will be scaled to be biggest possible horizontally.

   [-y]
          Force vertical (`portrait mode'); analogous to -x.

   [-s sx sy]
          Force image size to be sx by sy inches. If image will exit page
          dimensions,  it will scream and die. Page dimensions are 8.5 by
          11.0 inches but only 7.5 by 9.0 are assumed to be printable.

   [-p pc py]
          Force  image  lower  left  corner to be as px py. If this would
          overrun the page's dimensions, it will scream and die.

   [-i]
          Image will be inverted (Black -> White and vice versa). Mapping
          from  colors  is done by 0.3 * RED + 0.59 * GREEN + 0.11 * BLUE
          and sometimes inverting the image will look better.

   [-n copies]
          Number of copies to print. 1 by default.

   [-h]
          Print one line of command help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2rgb</title>
<programlisting>

   Go to [1]index page.

                                  gif2rgb

   A program to convert images saved as GIF to 24-bit RGB image(s).

                                    Usage:

gif2rgb [-q] [-1] [-o OutFileName] [-h] gif-file

   If  no  gif-file  is  given,  Gif2RGB will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-1]
          Only  one  file in the format of RGBRGB... triplets (Each of R,
          G, B is a byte) is being written. This file size is 3 * Width *
          Height. If stdout is used for output, this option is implicitly
          applied.  The  default  (if not `-1') is 3 files with the names
          OutFileName.R,  OutFileName.G,  OutFileName.B, each of which is
          Width * Height bytes.

   [-o OutFileName]
          specifies the name of the out file (see also `-1' above).

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2rle</title>
<programlisting>

   Go to [1]index page.

                                  gif2rle

   A  program to convert images saved as GIF to RLE (Utah raster toolkit)
   format.

                                    Usage:

gif2rle [-q] [-a] [-h] gif-file

   If  no  gif-file  is  given,  Gif2Rle will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-a]
          Add alpha channel (see rle document) to the output data file.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Notes:

   This  routine must be linked with the RLE toolkit library librle.a and
   is  not  built by the normal distribution make. If you want to convert
   images to RLE format, it is reasonable to assume you have this library
   available.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif2x11</title>
<programlisting>

   Go to [1]index page.

                                  gif2x11

   A program to display images saved as GIF files under X window system.

   Usage:
gif2x11 [-q] [-p PosX PosY] [-d Display] [-f] [-h] gif-file

   If  no  gif-file  is  given,  Gif2X11 will try to read a GIF file from
   stdin. Note: this program does not read the X resource data base.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-p PosX PosY]
          Set  the  position  of  image on screen. By default the program
          will prompt for position.

   [-d Display]
          What X server should be connected to.

   [-f]
          Force  attempt  to  allocate  exact  colors.  This usually will
          result  in  a  very  muddled  image if not enough colors can be
          allocated; the rest of them will be approximated by the closest
          one. By default the least bits of the colors are stripped until
          success (in allocation) which looks much better.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifasm</title>
<programlisting>

   Go to [1]index page.

                                   gifasm

   A  program  to  assemble multiple GIF files into one, or disassemble a
   single GIF file with multiple images into single image files.

                                    Usage:

gifasm [-q] [-a] [-d OutFileName] [-h] gif-file...

   If  no  gif-file  is  given,  GifAsm  will try to read a GIF file from
   stdin, if in disassembly mode only (-d).

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-a]
          Assemble. This is the default, and the GifFile(s) are assembled
          to  stdout.  Note the screen descriptor (including screen color
          map)   is  taken  from  the  first  file,  while  other  screen
          descriptors  are  ignored. As this tool requires at least 2 GIF
          files  as  input, no attempt will be made to read stdin if none
          specified on command line.

   [-d OutFileName]
          Disassemble  GifFile  (if  specified on command line) or stdin,
          into  several files of the form OutFileNameXX, where XX are two
          decimal digits. Obviously up to 100 files can be generated this
          way. Note: in this mode nothing is sent to stdout.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifbg</title>
<programlisting>

   Go to [1]index page.

                                   gifbg

   A  program  to generate a single-color test pattern GIF with gradually
   changing intensity in any of the basic 8 directions.

                                    Usage:

gifbg [-q] [-d Dir] [-l #Lvls] [-c R G B] [-m MinI] [-M MaxI] [-s W H] [-h]

   The  gifbg  program reads no input, and will dump the created GIF file
   to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d Dir]
          Select   direction  the  intensity  of  the  background  should
          increase. Direction can be one of the 8 principal directions:

   "T" - for Top                "TR" - for Top Right
   "R" - for Right              "BR" - for Bottom Right
   "B" - for Bottom             "BL" - for Bottom Left
   "L" - for left               "TL" - for Top Left

          The  compass  directions  may  be use as synonyms for the above
          directions, so for example "NE" is equal to "TR".

          Direction  is  case  insensitive.  The default direction is Top
          (North).

   [-l #Lvls]
          Number of levels the color will be scaled to. Default is 16.

   [-c R G B]
          What  to  use  as  the  primary background color to scale. This
          color  is  scaled  between  the  minimum  intensity  (MinI) and
          maximum  intensity  (MaxI)  from  one  end of the screen to the
          other  as  defined by Dir. See below (-m & -M) for MinI & MaxI.
          Default is Blue (0, 0, 255).

   [-m MinI]
          Minimum intensity (in percent) to scale color. Default 10%

   [-M MaxI]
          Maximum intensity (in percent) to scale color. Default 100%

   [-s W H]
          Size of image to create. Default 640 by 350.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Notes:

   If  MinI  ==  MaxI = 100 (%) and #Lvls == 2 then boolean mask image of
   specified size will be created - all foreground. This can be used as a
   square mask for the gifcomb utility.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   Visible links
   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com

   Hidden links:
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcomb.html
</programlisting>
</sect2>

<sect2><title>gifburst</title>
<programlisting>

   Go to [1]index page.

                                  gifburst

   The  gifburst  program  takes  a  named  GIF  file  and breaks it into
   equal-sized  tiles.  This  is  useful  if  a GIF is too large for your
   viewer, so you have to look at it in sections.

                                    Usage:

gifburst [-s n] [-p b] gif-file

                               Memory required:

   Proportional to the size of the largest pasted image.

                                   Options:

   [-s nnn]
   Specify the number of pieces. Valid values are presently 4 (2x2) and 6
   (2x3). Default is 4.

   [-p nnn]
   Specify the number of pixels of overlap between interior boundaries of
   pieces. Default 20.

                                     Note:

   The  gifburst  program  is written on Perl, using the C utilities. You
   must have both the giflib utilities and Perl installed to run it.

                                    Author:

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifclip</title>
<programlisting>

   Go to [1]index page.

                                  gifclip

   A  program  to  clip images in GIF files. Only one image in a GIF file
   can  be  modified  at a time. Neither the image position on screen nor
   the screen size is modified (use [2]gifpos for that).

                                    Usage:

gifclip [-q] [-i Xmin Ymin Xmax Ymax] [-n n Xmin Ymin Xmax Ymax] [-c] [-h] gif-
file

   If  no  gif-file  is  given,  GifClip will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-i Xmin Ymin Xmax Ymax]
          Clip  first  image  to  the  dimensions  as  specified by the 4
          coordinates (Xmin Ymin Xmax Ymax) of a box clipping region.

          For  example:  '-i 11 22 33 44' will crop the box from top left
          [11,22] to bottom right [33,44] out of the first image.

          If  the  first parameter is bigger than third one (Xmin > Xmax)
          they are swapped. Same for Y.

          The  dimensions  of  the  clipped  image  must  be  confined to
          original  image  width  and  height.  Note  the  clipped  image
          includes  both  the min & max boundary; an image of width W can
          have coordinates 0 to W-1 (zero based).

          Only one of -i or -n can be specified.

   [-n n Xmin Ymin Xmax Ymax]
          Same  as  -i above but for the nth image: `-n 1 11 22 33 44' is
          exactly the same as the example in -i. Only one of -i or -n can
          be specified.

   [-c]
          Complement.  This  removes  horizontal and/or vertical bands of
          the  image.  For  example  `-c  -i 638 3 658 13' would remove a
          horizontal  band 11 pixels deep beginning at raster line 3, and
          a vertical band 21 pixels right beginning at pixel 658.

   [-h]
          Print one line of command line help, similar to Usage above.

   Note: all coordinates are 0-based --- the top left corner is (0, 0).

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [3]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
   3. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifclrmp</title>
<programlisting>

   Go to [1]index page.

                                  gifclrmp

   A  program  to modify GIF image colormaps. Any local colormap in a GIF
   file can be modified at a time, or the global screen one.

                                    Usage:

gifclrmap [-q] [-s] [-t trans] [-l map] [-g Gamma] [-i image] [-h] gif-file

   If  no  gif-file  is  given,  GifClip will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s]
          Select the global screen color map.

   [-l map]
          Load color map from this file instead of selected color map.

   [-t trans]
          Change  color  index  values.  The  change  is made to both the
          selected color table and the raster bits of the selected image.
          A  translation  file is a list of pairs of `before' and `after'
          index  values. At present, the `before' index values must be in
          ascending order starting from 0.

   [-g Gamma]
          Apply gamma correction to selected color map.

   [-i image]
          Select the color map of the numbered image.

   [-h]
          Print one command line help, similar to Usage above.

                                    Notes:

     * The  default  operation  is  to dump out the selected color map in
       text format.
     * The file to load/dump is simply one color map entry per line. Each
       such  entry  line  has four integers: "ColorIndex Red Green Blue",
       where color index is in ascending order starting from 1.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifcolor</title>
<programlisting>

   Go to [1]index page.

                                  gifcolor

   A  program  to  generate color test patterns. Feed it a color map file
   (as  generated, say, by the -s otion of GifClrMp) and it will generate
   a GIF containing lines of the form
        Color %-3d: [%-3d, %-3d, %-3d]:

   where  the  first number is the zero-based color index, and the triple
   is  the  index's [Red, Green, Blue] value. There will be one such line
   for  each  color.  Each  line  will be set in a simple 8x8 font in the
   color  it  describes;  thus,  any  lines  corresponding  to  the GIF's
   background color will be blank.

                                    Usage:

gifcolor [-q] [-b Background] [-h] &ltColorMapFile

   As  gifcolor  can  generate huge amounts of data, ^C will kill it, but
   'q'  will  stop  only  the printing (of one of -e, -z, -p), while file
   integrity will still be checked.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-b]
          Set the image's backround color to a given numeric index.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifcomb</title>
<programlisting>

   Go to [1]index page.

                                  gifcomb

   A  program  to combine 2 GIF images of exactly the same size into one.
   The color maps are merged, but the result may not exceed 256 colors. A
   boolean  mask  GIF file can be used to set which pixel from two images
   to  use  at  each  location. Otherwise any background color from first
   image is converted to second image color at that point. Only the first
   image of each file is combined; again, all files' first images must be
   of exactly the same size.

                                    Usage:

gifcomb [-q] [-m MaskGIFFile] [-h] gif-file...

   Two GIF files must be specified; a third mask GIF file is optional.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-m MaskGIFFile]
          the  MaskGIFfile  can be regular GIF file whose first image has
          same  dimensions  as  the  combined  images. Any non-background
          color  in  it  will  select  Image 1 Pixel to output, otherwise
          Image2  pixel  will  be  selected.  Usually  this image will be
          boolean (two colors only) but it does not have to be.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifcompose</title>
<programlisting>

   Go to [1]index page.

                                 gifcompose

   The  gifcompose  program  uses  the  GIFLIB utility tools to support a
   minilanguage for describing GIF pasteup sequences.

                                    Usage:

gifcompose [-v] <specfile

                             Specification Syntax

   The  gifcompose  tool takes a series of text lines and interprets them
   as commands to do pasteup operations. The commands are:

                                 Generators

   gif <name>
          Paste in <name>.gif

   raw <name> <width> <height>
          Paste  in  the  given raw-format file (no suffix supplied). Raw
          format  is  a  stream  of 8-bit indices into the EGA color map.
          Accordingly,  the  width  and height must be specified, and the
          source must be exactly width times height bytes long.

   rgb <name> <width> <height>
          Paste  in  the  given RGB-format file (no suffix supplied). Raw
          format  is  a  stream  of 24-bit color values. Accordingly, the
          width  and  height  must  be  specified, and the source must be
          exactly 3 times width times height bytes long.

   rle <name>
          Paste  in  the given RLE-format file (no suffix supplied). This
          converts the Utah Raster Kit format to GIF.

   text <text> [foreground <index>] [color <r> <g> <b>]
          Copy  8x8 monospace font, with transparent background and index
          1  as foreground. If the text string contains whitespaces, they
          must   be   escaped   or  the  string  must  be  quoted  (shell
          conventions).

          The  optional suffix `foreground <n>' sets the foreground color
          index.  The  optional  suffix  `color <r> <g> <b>' sets the RGB
          color to be used for the foreground index.

   Each  generator  operation  may  be followed by any combination of the
   following suffixes:

                                 Modifiers

   at <x> <y>
   Place  the  image at the given (upper-left-hand-corner) coordinates in
   the pasted-up result.

   clip <name> <top-x> <top-y> <bottom-x> <bottom-y>
   Clip image using the given rectange, paste it onto.

   xflip
   Flip the image around the X axis before placing it.

   yflip
   Flip the image around the Y axis before placing it.

   left
   Rotate the image 90 degrees counterclockwise before placing it.

   right
   Rotate the image 90 degrees clockwise before placing it.

                             Target Operations

   screen size <x-size> <y-size>
   Set the global screen size of the final image.

   screen position <x> <y>
   Set the global screen position of the final image.

                                  Comments

   Comments  or  comment  lines  may  be  preceded  with  `#' and will be
   ignored.

                               Memory required:

   Proportional to the size of the largest pasted image.

                                   Options:

   [-v]
          Emit  a  report  on  each  composition  action  to stderr as it
          happens.

                                     Bugs:

   The  suffix sequence `left left' sometimes mysteriously fails to work,
   probably due to some restriction in [2]gifflip.

   No support for resizing or odd-angle rotations yet.

   The  `color' suffix of text is a no-op, because the present version of
   [3]gifovly throws away color tables.

   Error checking is rudimentary.

                                    Author:

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [4]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifovly.html
   4. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>giffiltr</title>
<programlisting>

   Go to [1]index page.

                                  giffiltr

   This  is  an  expensive way to copy a GIF. The source is included as a
   skeleton  for  more  sophisticated filters. See the source in the util
   directory for details.

   I  suppose this does have some utility as a test of the sequential GIF
   record  I/O  routines.  The output should be bytewise identical to the
   input.

                                    Usage:

giffiltr <GifFile >GifCopy

                               Memory required:

   Line.

                                   Options:

   None.

                                    Author

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>giffix</title>
<programlisting>

   Go to [1]index page.

                                   giffix

   A program that attempts to fix broken GIF images. Currently will "fix"
   images  terminated  prematurely  by filling the rest of the image with
   the darkest color found in image.

                                    Usage:

giffix [-q] [-h] gif-file

   If  no  gif-file  is  given,  GifFix  will try to read a GIF file from
   stdin. The fixed file is dumped to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifflip</title>
<programlisting>

   Go to [1]index page.

                                  gifflip

   A  program  to flip (mirror) GIF file along X or Y axes, or rotate the
   GIF file 90 degrees to the left or to the right.

                                    Usage:

gifflip [-q] [-r] [-l] [-x] [-y] [-h] gif-file

   If  no  gif-file  is  given,  GifFlip will try to read a GIF file from
   stdin.

                               Memory required:

   Image.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-r]
          Rotate the GIF file to the right.

   [-l]
          Rotate the GIF file to the left.

   [-x]
          Mirror  the  GIF file along the X axis. Very useful if GIF file
          was  created  from  another format in with the first line in at
          image bottom. Effectively exchanges first row with last.

   [-y]
          Mirror  the  GIF file along Y axis. Effectively exchanges first
          column with last.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifhisto</title>
<programlisting>

   Go to [1]index page.

                                  gifhisto

   A  program  to  create histogram of number of pixels using each color.
   The output can be formatted into a GIF histogram file, or as text file
   - both go to stdout.

                                    Usage:

gifhisto [-q] [-t] [-s Width Height] [-n ImageNumber] [-b] [-h] gif-file

   If  no  gif-file  is  given, GifHisto will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-t]
          Force  output  to be text file of the following form: (colormap
          size) lines each containing two integers: number of times color
          appeared,  and color index. Lines are in increasing color index
          order.  This  output  can  be fed directly to a sort program if
          ordering by color frequency is desired.

          The  colrmap  picked  is  the  one  to be used for the image to
          generate histogram for, as defined in GIF format.

   [-s Width Height]
          Size  of GIF histogram file. The Height of the histogram should
          be power of 2 dividable by number of colors in colormap.

          Width  sets  the  resolution  (accuracy  if  you  like)  of the
          histogram as the maximum histogram bar is scaled to fit it.

   [-n ImageNumber]
          Image number to test. Default is one.

   [-b]
          Zeros the background color count. As only linear scale bars are
          supported  and  usually  the background appears much more often
          then  other  colors, deleting the background count will improve
          the scaling of other colors.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifinter</title>
<programlisting>

   Go to [1]index page.

                                  gifinter

   A program to convert between interlaced and non-interlaced GIF images.

                                    Usage:

gifinter [-q] [-i] [-s] [-h] gif-file

   If  no  gif-file  is  given, GifInter will try to read a GIF file from
   stdin.

                               Memory required:

   Image.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-i]
          Force all images in GIF file be interlaced.

   [-s]
          Force all images in GIF file be sequential (default).

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifinto</title>
<programlisting>

   Go to [1]index page.

                                  gifinto

   A  program  to  save stdin into a file with given name, iff the result
   file  has  size bigger than specified (see below). This can be used to
   save result in same files name we started a chain of pipes.

                                    Usage:

gifinto [-q] [-s MinFileSize] [-h] gif-file

   Gifinto always reads a GIF file from stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s MinFileSize]
          If file is less than MinFileSize, it is deleted and not renamed
          to  given  name.  This will prevent killing the file we started
          with  if  the  result is an empty file, or the pipeline did not
          complete.

          The  default  file threshold size is 14 bytes which is 1 bigger
          than GIF file stamp (6 bytes) and GIF file screen descriptor (7
          bytes), so a GIF file with only GIF stamp and screen descriptor
          will not be renamed.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gif_lib</title>
<programlisting>

   Go to [1]index page.

                             The GIFLIB Library

     Gershon Elber, May 1991
     Eric S. Raymond, Sep 1992

   The  Graphics  Interchange  Format(c)  is  the  Copyright  property of
   CompuServe  Incorporated.  GIF(sm)  is  a  Service  Mark  property  of
   CompuServe Incorporated.

   Gershon  wrote:  "This  library  was  written  because I couldn't find
   anything similar and I wanted one. I was inspired by the RLE Utah tool
   kit,  which  I  hoped  to  port  to  an IBM PC, but found it to be too
   machine  specific, and its compression ratio too low. I compromised on
   the  GIF  format,  but I am not sure how long 8 bits per pixel will be
   enough."

   This  document  explains  the GIF library code in directory `lib'. The
   code  is collected into libgif.a which is used in all the utilities in
   `util'.  It can be used in any application needs to read/write the GIF
   file format. This document does
   not  explain  the GIF file format and assumes you know it, at least to
   the level of the GIF file structure.

   When a GIF file is opened, a GIF file descriptor is created which is a
   pointer to GifFileType structure as follows:

typedef struct GifFileType {
    int SWidth, SHeight,                               /* Screen dimensions. */
        SColorResolution,                /* How many colors can we generate? */
        SBackGroundColor;               /* I hope you understand this one... */
    ColorMapObject *SColorMap;                        /* NULL if not exists. */
    int ImageCount;                               /* Number of current image */
    GifImageDesc Image;                    /* Block describing current image */
    struct SavedImage *SavedImages;     /* Use this to accumulate file state */
    VoidPtr Private;      /* The regular user should not mess with this one! */
} GifFileType;

   This structure was copied from gif_lib.h - the header file for the GIF
   library. Any application program that uses the libgif.a library should
   include  it. Members beginning with S refer to GIF Screen; others hold
   properties  of  the  current  image (a GIF file may have more than one
   image) or point to allocated store used by various routines.

   The  user  almost  never writes into this structure (exception: it may
   occasionally useful to alter things in the SavedImages array), but can
   read  any of these items at any time it is valid (image information is
   invalid until first image was read/write).

   As  the library needs to keep its own internal data, a Private pointer
   to hidden data is included. Applications should ignore this item.

   The  library has no static data. This means that it is fully reentrant
   and  any  number  of GIF files (up to memory limits) can be opened for
   read/write.  Instead of the static data, internal structure pointed by
   the Private pointer is used.

   The library allocates its own memory dynamically, on opening of files,
   and  releases that once closed. The user is never required to allocate
   any  memory  for any of the functions of this library nor to free them
   directly.

   In  order  to  reduce  disk  access,  the  file buffer is increased to
   FILE_BUFFER_SIZE  (defined  in gif_lib.h). The library was compiled in
   large  model  on the PC as the memory allocated per file is quite big:
   about   17k   for   decoding   (DGIF_LIB.C),   and  32k  for  encoding
   (EGIF_LIB.C), excluding the FILE_BUFFER_SIZE.

   Here is a module summary:

   egif_lib.c
          Encoding routines, all prefixed with E.

   dgif_lib.c
          Decoding routines, all prefixed with D.

   dev2gif.c
          Routines to convert specific device buffers into GIF files.

   gifalloc.c
          Routines for colormap handling and GIF record allocation.

   gif_font.c
          The 8x8 font table for the GIF utility font.

   gif_err.c
          Error handler for the library.

   The  library  includes  a  sixth  file  of hash-function code which is
   accessed internally only.

   Most  of  the  routines  return GIF_ERROR (see gif_lib.h) if something
   went  wrong,  GIF_OK otherwise. After an error return, the code in the
   gif_err.c module can be used to do something about it.

   In  addition,  a  module  to parse command line arguments is supplied.
   This  module  is  called getarg.c and its headers are in getarg.h. See
   the header of getarg.c for details on its usage.

                             Decoding (dgif_lib.c)

   The following functions are used to set up input from a GIF:

GifFileType *DGifOpenFileName(char *GifFileName)

   Open  a  new GIF file using the given GifFileName, and read its Screen
   information.  If  any  error  occurs,  NULL  is returned and the error
   handler  can  be used to get the exact error (see gif_err.c). The file
   is   opened   in   binary   mode,  and  its  buffer  size  is  set  to
   FILE_BUFFER_SIZE bytes.
GifFileType *DGifOpenFileHandle(int GifFileHandle)

   Open a new GIF file using the given GifFileHandle, and read its Screen
   information.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

   Once  you  have acquired a handle on a GIF, there are two ways to read
   it in. The high-level function
int DGifSlurp(GifFileType)

   reads  the rest of a complete (possibly multi-image) GIF file from the
   indicated  file  handle  into in-core allocated structures. It returns
   GIF_OK on success, GIF_ERROR on failure.

   Once  you  have done this, all image, raster, and extension-block data
   in the GIF is accessable in the SavedImages member (see the structures
   in fif_lib.h). When you have modified the image to taste, write it out
   with EGifSpew().

   If  you are handling large images on a memory-limited machine, you may
   need to use the following functions for sequential read.

int DGifGetScreenDesc(GifFileType *GifFile)

   Reads  the  screen  information  into the GifFile structure. Note this
   routine  is  automatically called once a file is opened, and therefore
   usually need not be called explicitly.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetRecordType(GifFileType *GifFile, GifRecordType *GifType)

   As  the  GIF  file can have different records in arbitrary order, this
   routine  should  be  called  once the file was open to detect the next
   record type, and act upon it. It can return these types in GifType:

   1. UndefinedRecordType
          something is wrong!

   2. ScreenDescRecordType
          screen information. As the screen info is automatically read in
          when the file is open, this should not happen.

   3. ImageDescRecordType
          next record is an image descriptor.

   4. ExtensionRecordType
          next record is extension block.

   5. TerminateRecordType
          last record reached, can close the file.

   The  first  two  types  can  usually  be ignored. The function returns
   GIF_ERROR if something went wrong, GIF_OK otherwise.
int DGifGetImageDesc(GifFileType *GifFile)

   Reads  image information into the GifFile structure. Returns GIF_ERROR
   if something went wrong, GIF_OK otherwise.

int DGifGetLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)

   Load  a  block  of  pixels  from  the GIF file. The line can be of any
   length.   More  than  that,  this  routine  may  be  interleaved  with
   DGifGetPixel until all pixels have been read.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.
int DGifGetPixel(GifFileType *GifFile, PixelType GifPixel)

   Loads  one  pixel  from  the GIF file. This routine may be interleaved
   with  [2]DGifGetLine,  until  all  pixels  are  read.  Because  of the
   overhead per each call, use of this routine is not recommended.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetComment(GifFileType *GifFile, char *GifComment)

   Load  a comment from the GIF file. Because DGifGetRecordType will only
   tell if the record is of type extension, this routine should be called
   iff it is known %100 that is must be a comment.

   For  the  definition  of  a  comment,  see  [3]EGifPutComment. Returns
   GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetExtension(
        GifFileType *GifFile,
        int *GifExtCode,
        ByteType **GifExtension)

   Loads  an  extension  block  from  the  GIF file. Extension blocks are
   optional   in   GIF   files.   This  routine  should  be  followed  by
   [4]DGifGetExtensionNext.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetExtensionNext(GifFileType *GifFile, ByteType **GifExtension)


   As  extensions  may  contain  more than one block, use this routine to
   continue after DGifGetExtension, until *GifExtension is NULL.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetCode(
        GifFileType *GifFile,
        int *GifCodeSize, ByteType **GifCodeBlock)

   It  sometimes may be desired to read the compressed code as is without
   decoding  it.  This  routine does exactly that (with DGifGetCodeNext),
   and can be used instead of DGifGetLine.

   This  compressed  code  information  can  be  written  out  using  the
   EGifPutCode/EGifPutCodeNext   sequence  (see  gifpos.c  for  example).
   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)

   See DGifGetCode above.

int DGifGetLZCodes(GifFileType *GifFile, int *GifCode)

   This  routine  can  be  called  instead of DGifGetLine/DGifGetPixel or
   DGifGetCode/DGifGetCodeNext to get the 12 bits LZ codes of the images.
   It  will  be  used  mainly  for  debugging purposes (see GifText.c for
   example).

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifCloseFile(GifFileType *GifFile)

   Close  GIF  file  and free all memory allocated for it. GifFile should
   not be used after this routine has been called.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

                             Encoding (egif_lib.c)

   There are two ways to write out a GIF. The high-level function

int EGifSpew(GifFileType *GifFile, int GifFileHandle)

   Writes  a  complete  (possibly  multi-image) GIF file to the indicated
   file  handle  from  in-core allocated structures created by a previous
   DGifSlurp()  or  equivalent  operations.  Its arguments are a GIF file
   descriptor (as above) and an ordinary output file descriptor.

   The  file  is written with a GIF87 stamp unless it contains one of the
   four  special  extension  blocks defined in GIF89, in which case it is
   written with a GIF89 stamp.

   If  you are handling large images on a memory-limited machine, you may
   need to use the following functions for sequential write.

GifFileType *EGifOpenFileName(char *GifFileName, int GifTestExistance)

   Open  a  new GIF file using the given GifFileName. If GifTestExistance
   is  TRUE,  and  file  exists,  the  file  is  not  destroyed, and NULL
   returned.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

GifFileType *EGifOpenFileHandle(int GifFileHandle)

   Open a new GIF file using the given GifFileHandle.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

void EGifSetGifVersion(char *Version)

   Sets  the  GIF version of all files opened, until another call to this
   routine is made. Version is a 3 characters string of the form "87a" or
   "89a". No test is made to validate this string.

int EGifPutScreenDesc(GifFileType *GifFile,
        int GifWidth, int GifHeight,
        int GifColorRes, int GifBackGround,
        ColorMapObject *GifColorMap)

   Update  the GifFile Screen parameters, in GifFile structure and in the
   real  file.  If  error  occurs,  returns  GIF_ERROR  (see  gif_lib.h),
   otherwise GIF_OK.

   This  routine  should  be  called  immediately  after the GIF file was
   opened.

int EGifPutImageDesc(GifFileType *GifFile,
        int GifLeft, int GifTop,
        int Width, int GifHeight,
        int GifInterlace,
        ColorMapObject *GifColorMap)

   Update  GifFile Image parameters, in GifFile structure and in the real
   file.  if  error  occurs  returns GIF_ERROR (see gif_lib.h), otherwise
   GIF_OK.

   This  routine should be called each time a new image must be dumped to
   the file.

int EGifPutLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)


   Dumps  a  block  of pixels out to the GIF file. The slab can be of any
   length.  More  than that, this routine may be interleaved with , until
   all pixels have been sent.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutPixel(GifFileType *GifFile, PixelType GifPixel)

   Dumps  one pixel to the GIF file. This routine may be interleaved with
   [5]EGifPutLine,  until  all  pixels were sent. Because of the overhead
   for each call, use of this routine is not recommended.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutComment(GifFileType *GifFile, char *GifComment)

   Uses  extension GIF records to save a string as a comment is the file.
   The extension code is 'C' (for Comment).

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutExtension(
        GifFileType *GifFile,
        int GifExtCode,
        int GifExtLen,
        void *GifExtension)

   Dumps  the  given  extension block into the GIF file. Extension blocks
   are  optional  in GIF file. Extension blocks of more than 255 bytes or
   more than one block are not supported.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutCode(
        GifFileType *GifFile,
        int *GifCodeSize,
        ByteType **GifCodeBlock)

   It sometimes may be desired to write the compressed code as is without
   decoding  it.  For  example  a  filter for a GIF file that change only
   screen size (GifPos), does not need the exact pixel values. Piping out
   the compressed image as is makes this process much faster.

   This routine does exactly that (with EGifPutCodeNext), and can be used
   instead   of   EGifPutLine.   You'll   usually   use   this  with  the
   DGifGetCode/DgifGetCodeNext routines, which reads the compressed code,
   while  EGifPutCode/EGifPutCodeNext  write  it  out.  See  gifpos.c for
   example.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)

   See EGifPutCode above.

int EGifCloseFile(GifFileType *GifFile)

   Close  a  GIF  file  and  free  all memory allocated for it. gif-file$
   should not be used, once this routine was called.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

                  Color map handling and allocation routines

ColorMapObject *MakeMapObject(int ColorCount, GifColorType *ColorMap)

   Allocate  storage  for a color map object with the given number of RGB
   triplet  slots.  If  the  second  argument is non-NULL, initialize the
   color  table portion of the new map from it. Returns NULL if memory is
   exhausted or if the size is not a power of 2 <= 256.

void FreeMapObject(ColorMapObject *Object)

   Free  the  storage  occupied  by  a  ColorMapObject  that is no longer
   needed.

ColorMapObject *UnionColorMap(
        ColorMapObject *ColorIn1, ColorMapObject *ColorIn2,
        GifPixelType ColorTransIn2[])

   Create  the union of two given color maps and return it. If the result
   won't  fit  into  256  colors,  NULL  is returned, the allocated union
   otherwise.  ColorIn1  is copied as it to ColorUnion, while colors from
   ColorIn2  are  copied iff they didn't exist before. ColorTransIn2 maps
   the old ColorIn2 into ColorUnion color map table.

SavedImage *GifAttachImage(GifFileType *GifFile)

   Add  an  image  block  to  the  SavedImages  array. The image block is
   initially  zeroed  out. This image block will be seen by any following
   EGifSpew() calls.

                             The GIF Utility Font

   The  8x8  utility  font  used  in  text2gif  and gifcolor lives in the
   library  module  gif_font.c, in a table called AsciiTable. The library
   header file includes suitable externs and defines.

   The GIF utility font support includes entry points for drawing legends
   on  in-core  images,  drawing  boxes  and rectangles, and boxing text.
   These entry points are as follows:

void DrawText(
        SavedImage *Image,
        const int x, const int y,
        const char *legend,
        const int color)

   Draw  text  using  the 8x8 utility font on the saved image. Upper left
   corner  of  the text is at image pixel (x, y). Use the specified color
   index.

void DrawBox(SavedImage *Image,
        const int x, const int y,
        const int w, const int h,
        const int color)

   Draw  a  box  on  the  saved image. Upper left corner of the box is at
   image  pixels (x, y), width is w, height is h. Use the specified color
   index.

void DrawRectangle(SavedImage *Image,
        const int x, const int y,
        const int w, const int h,
        const int color)

   Draw a (filled) rectangle on the saved image. Upper left corner of the
   box  is  at  image  pixels  (x,  y),  width is w, height is h. Use the
   specified color index.

void DrawBoxedText(SavedImage *Image,
        const int x, const int y,
        const char *legend,
        const int border,
        const int bg, const int fg)

   Draw  text  on  a filled rectangle. The rectangle will be sized to fit
   the  text,  with  upper left hand corner at (x, y) on the saved image.
   The  `border'  argument  specifies a pixel margin around the text. The
   `bg'  argument  is  the  color table index to fill the rectangle with;
   `fg' is the color table index to draw the text with.

   This   function  interprets  some  characters  in  the  legend  string
   specially.  A  tab  (\t)  is  interpreted  as  a command to center the
   following  text in the box. A carriage return (\r) is interpreted as a
   request for a line break.

                          Error Handling (egif_lib.c)

void PrintGifError(void)

   Print a one-line diagnostic on the last giflib error to stderr.

int GifLastError(void)

   Return  the  number of the last giflib error, and clear the error. The
   error types are defined in gif_lib.h.

   Note it is the user's responsibility to call the file closing routine,
   so  the file will be closed (if was opened), and allocated memory will
   be released.

                          Device Specific (XXX2gif.c)

int DumpScreen2Gif(char *FileName, int ReqGraphDriver, int ReqGraphMode1,
                                                       int ReqGraphMode2)

   Dumps  the  whole  device  buffer  as  specified  by  GraphDriver  and
   GraphMode (as defined in TC 2.0 graphics.h) into FileName as GIF file.
   Current devices supported:

        1. Hercules.

        2. EGA, EGA64, EGAMONO (all modes - see TC graphics.h).

        3. VGA (all modes - see TC graphics.h).

        4. SVGA_SPECIAL. This mode is special and not supported by Borland
           graphics.h. ReqGraphDriver must be equal to 999, and ReqGraphMode
           is ignored. This modes assumes 800 by 600 in 16 colors.
          Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

        5. SGI 4D using gl graphic library - window dump.

        6. X11 window dump.

                             Command Line Parsing

int GAGetArgs(int argc, char **argv, char *CtrlStr, ...)

   Main routine of this module. Given argc & argv as received by the main
   procedure,  the  command  line  CtrlStr,  and  the  addresses  of  all
   parameters, parse the command line, and update the parameters.

   The CtrlStr defines what types of variables should follow. Look at the
   beginning of getarg.c for exact usage.

   Returns  0  if  successful,  error  number  (as  defined  by getarg.h)
   otherwise.

void GAPrintErrMsg(int Error)

   If  an  error occurred in GAGetARgs, this routine may be used to print
   one line diagnostic to stderr.

void GAPrintHowTo(char *CtrlStr)

   Given  the  same  CtrlStr as for GAGetArgs, can be used to print a one
   line 'how to use'.

                           Skeletons of GIF filters

   If  you  are developing on a virtual-memory OS such as most flavors of
   UNIX,  or  are  otherwise  sure of having enough memory to keep all of
   GIFs you need to operate in core, writing a filter is trivial. See the
   file gifspnge.c in util.

   A  sequential  filter skeleton will usually look like the example file
   giffiltr.c in util.

   Please look at the utilities in the util directory for more ideas once
   you  feel  comfortable  with  these  skeletons. Also try to follow the
   coding  standards  of  this  package  if  you  want  the maintainer to
   officially add your new utility to it.
     _________________________________________________________________


    Eric S. Raymond [6]<esr@snark.thyrsus.com>

References

   Visible links
   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#DGifGetLine
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutComment
   4. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#DGifGetExtensionNext
   5. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutLine
   6. mailto:esr@thyrsus.com

   Hidden links:
   7. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutPixel
</programlisting>
</sect2>

<sect2><title>gifovly</title>
<programlisting>

   Go to [1]index page.

                                  gifovly

   This  program  takes a multi-image GIF file and generates a single GIF
   consisting  of  all the images overlayed. Each image's screen position
   is  used. Thus, you can use this together with [2]gifpos and [3]gifasm
   to paste together images.

                                    Usage:

gifovly [-s TransparentColor] [-h]

   The  GIF  to  be  operated  is  read  in from stdin. The result GIF is
   written to stdout.

                               Memory required:

   Proportional to the size of the input file.

                                   Options:

   [-t num]
          If  this  index  is  given, any pixel in images after the first
          that has this value is not copied.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [4]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifasm.html
   4. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifpos</title>
<programlisting>

   Go to [1]index page.

                                   gifpos

   A  program to change GIF screen size and/or reposition images. No test
   is  made  to  make  sure  changes  will generate valid GIF files (i.e.
   images are still confined to screen etc.)

                                    Usage:

gifpos [-q] [-s Width Height] [-i Left Top] [-n n Left Top] [-h] gif-file

   If  no  gif-file  is  given,  GifPos  will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s Width Height]
          Set  the  new  screen  dimensions, so for example `-s 1000 800'
          will set screen to width of 1000 and height of 800.

   [-i Left Top]
          set  image  relative to screen position, so for example `-i 100
          80' will set image left position to 100 and top position to 80.
          This sets the position of the first image only.

   [-n n Left Top]
          set  image  n relative to screen position, so for example '-n 3
          100 80' will set the third image position as in 2.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifrotat</title>
<programlisting>

   Go to [1]index page.

                                  gifrotat

   A program to rotate a GIF image by a specified angle.

                                    Usage:

gifrotat -a Angle [-q] [-s Width Height] [-h] gif-file

   If  no  gif-file  is  given, GifRotat will try to read a GIF file from
   stdin.

                               Memory required:

   Screen (of source image).

                                   Options:

   -a Angle
          Specifies  the angle to rotate in degrees with respect to the X
          (horizontal) axis.

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s Width Height]
          Since  the  rotated  image will have the same image size as the
          original, some parts of the image will by clipped out and lost.
          By  specifing a (bigger) size explicitly using the `-s' option,
          these parts may be saved.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Notes:

   The  image  is rotated around its center. No filtering is performed on
   the output, which have the same color map as the input. This is mainly
   since  filtering  would  require  color  quantization  which  is  very
   memory/time  intensive  and  out of MSDOS memory limits even for small
   images.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifrsize</title>
<programlisting>

   Go to [1]index page.

                                  gifrsize

   A  program  to  resize  image size by an integer factor, deleting bits
   when scaling down and duplicating bits when scaling up.

                                    Usage:

gifrsize [-q] [-S X Y] [-s Scale] [-x XScale] [-y YScale] [-h] gif-file

   If  no  gif-file  is  given, GifRSize will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-S X Y]
          specifies the exact screen dimension of the output GIF.

   [-s Scale]
          Set  scaling  factor for both x & y direction to Scale. Default
          is 0.5. Note this is a floating point number.

   [-x XScale]
          Set  scaling  factor  for x direction to Scale. Default is 0.5.
          Note: this is a floating point number.

   [-y YScale]
          Set  scaling  factor  for y direction to Scale. Default is 0.5.
          Note: this is a floating point number.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifspnge</title>
<programlisting>

   Go to [1]index page.

                                  gifspnge

   This  is  an  expensive way to copy a GIF. The source is included as a
   skeleton   for   more  sophisticated  filters  using  DGifSlurp()  and
   EGifSpew(). See the source in the util directory for details.

   I  suppose  this  does  have some utility as a test of DGifSlurp() and
   EGifSpew(). The output should be bytewise identical to the input.

                                    Usage:

gifspnge <GifFile >GifCopy

                               Memory required:

   The size of the input GIF, plus malloc overhead.

                                   Options:

   None.

                                    Author:

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>giftext</title>
<programlisting>

   Go to [1]index page.

                                  giftext

   A program to dump (text only) general information about GIF file.

                                    Usage:

giftext [-q] [-c] [-e] [-z] [-p] [-r] [-h] gif-file

   If  no  gif-file  is  given,  GifText will try to read a GIF file from
   stdin.

   As giftext can generate huge amounts of data, ^C will kill it, but 'q'
   will  stop  only  the  printing  (of  one  of  -e, -z, -p), while file
   integrity will still be checked.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c]
          Dumps the color maps.

   [-e]
          Dumps  encoded  bytes  -  the  pixels after compressed using LZ
          algorithm  and chained to form bytes. This is the form the data
          is saved in the GIF file. Dumps in hex - 2 digit per byte.

   [-z]
          Dumps  the  LZ  codes of the image. Dumps in hex - 3 digits per
          code (as we are limited to 12 bits).

   [-p]
          Dumps the pixels of the image. Dumps in hex - 2 digit per pixel
          (<=byte).

   [-r]
          Dumps  raw  pixels  as one byte per pixel. This option inhibits
          all  other  options and only the pixels are dumped. This option
          may be used to convert GIF files into raw data. Note: the color
          map  can  be  extracted  by  gifclrmp utility. If more than one
          image  is  included  in  the file, all images will be dumped in
          order.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>gifwedge</title>
<programlisting>

   Go to [1]index page.

                                  gifwedge

   A  program to create a test GIF image with intensity levels of the RGB
   colors YCM colors and white.

                                    Usage:

gifwedge [-q] [-l #Lvls] [-s SizeX SizeY] [-h]

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-l #Lvls]
          Set  number  of intensity levels per color. This number must be
          power  of  two  up to 32, as Gif format can only have 256 color
          simultanuously and 7 basic colors are to be displayed.

   [-s SizeX SizeY]
          Force  image  size to be SizeX by SizeY pixels. Image size will
          be  rounded  down  to  be  a  multiple of number of intensities
          horizontally, and 7 (colors) vertically.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>icon2gif</title>
<programlisting>

   Go to [1]index page.

                                  icon2gif

   A program to convert a series of editable text GIF icon specifications
   and  named  GIF  files  into  a  multi-image  GIF, usable as a graphic
   resource file. It can also dump existing GIFs in this format.

                                    Usage:

icon2gif [-q] [-a] [-d] [t TranslationTable] [-h] gif-file...

   If  no  gif-file is given, icon2gif will try to read a text input from
   stdin.

                             Specification Syntax

   Here  is a syntax summary in informal BNF. The token `NL' represents a
   required newline.

<gif-spec> ::= <header-block> <image-block>...

<header-block> ::= <header-declaration>...

<header-declaration ::=
                | screen width <digits> NL
                | screen height <digits> NL
                | screen colors <digits> NL
                | screen background <digits> NL
                | screen map <color-table> NL

<color-table> ::= <color-declaration>... end NL

<color-declaration> ::= rgb <digits> <digits> <digits> is <key> NL

<image-block> ::= include <file-name> NL
                | image NL
                        <image-declaration>...
                        <raster-picture>
                        [ <extension> ]

<image-declarations> ::= image top <digits> NL
                        | image left <digits> NL
                        | image interlaced NL
                        | image map <color-table> NL
                        | image bits <digits> by <digits> NL <raster-block>

<extension> := <comment> NL <extension-block> NL end NL
                | <plaintext> NL <extension-block> NL end NL
                | extension <hex-digits> NL <extension-block> NL end NL

   If  the  semantics  of  the  `screen  height', `screen width', `screen
   background',  `image top', `image left' declarations aren't obvious to
   you, what are you doing with this software?

   A  color  table declares color indices (in ascending order from 0) and
   assiciates  them  with  key  characters. These characters can later be
   used  in raster blocks. As these must be printable and non-whitespace,
   you can only specify 94 colors per icon. Life is like that sometimes.

   A  raster  block is just a block of key characters. It should be sized
   correctly for the `image bits' declaration that leads it.

   The  `comment'  or  `plaintext'  keywords lead defined GIF89 extension
   record   data  (the  other  two  GIF89  types,  graphics  control  and
   application   block,   are  not  yet  supported).  You  can  also  say
   `extension'  followed  by  a  hexadecimal  record  type.  All of these
   extension  declarations  must be followed by an extension block, which
   is terminated by the keyword `end' on its own line.

   An  extension  block  is a series of text lines, each interpreted as a
   string  of bytes to fill an argument block (the terminating newline is
   stripped).  Text  may  include  standard C-style octal and hex escapes
   preceded by a backslash.

   All tokens are interpreted as decimal numerals; tokens are interpreted
   as  two  hex digits (a byte). All coordinates are zero-origin with the
   top  left corner (0,0). Range checking is weak and signedness checking
   nonexistent; caveat hacker!

   In  general, the amount of whitespace and order of declarations within
   a  header  or  image  block  is  not significant, except that a raster
   picture must immediately follow its `image bits' bits declaration.

   The  `include' declaration includes a named GIF as the next image. The
   global  color  maps  of  included  GIFs are merged with the base table
   defined  by  any `screen color' declaration. All images of an included
   multi-image GIF will be included in order.

   Comments may be preceded with `#' and will be ignored.

                               Memory required:

   For  the compilation mode, proportional to the size of the input file.
   For dumping, proportional to the line size of the widest GIF.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d]
          Dump the input GIF file(s) into the text form described above.

   [-t]
          Specify name characters to use when dumping raster blocks. Only
          valid with -d option.

   [-h]
          Print one line of command line help, similar to Usage above.

                                     Bugs:

   Because  there  are only 94 characters unambiguously usable for raster
   blocks, an attempt to dump a GIF with a larger color map will fail.

   Error checking is rudimentary.

                                   Example:

   A  sample  icon  file  called  `sample.ico'  is  included  in  the pic
   directory.

                                    Author:

   Eric S. Raymond <esr@snark.thyrsus.com>
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>index</title>
<programlisting>

                           Introduction to GIFLIB

   GIFLIB is a package of portable tools and library routines for working
   with  GIF  images.  You can find the latest version at the GIFLIB home
   page [1]http://www.ccil.org/~esr/giflib.

   The  Graphics  Interchange  Format(c) specification is the copyrighted
   property  of  CompuServe  Incorporated.  GIF(sm)  is  a  service  mark
   property  of  CompuServe  Incorporated. As this package existed before
   UniSys's lawyeritis attack of New Years' Day 1995, it is grandfathered
   in under their license terms and you do not have to pay fees for using
   it.

   This  package  has  been  released under an X Consortium-life freeware
   license.  Use and copy as you see fit. If you make useful changes, add
   new  tools,  or  find  and  fix  bugs,  please  send  your mods to the
   maintainers for general distribution.
   The  util  directory  includes  programs  to  clip, rotate, scale, and
   position  GIF  images. It includes an X11 viewer, code to dump GIFs to
   an  Epson-compatible  printer  in  graphics  mode, and many conversion
   utilities.  These  are  no  replacement  for  an  interactive graphics
   editor,  but  they can be very useful for scripted image generation or
   transformation.

   The  library  includes  program-callable  entry points for reading and
   writing GIF files, an 8x8 utility font for embedding text in GIFs, and
   an  error  handler.  GIF  manipulation can be done at a relatively low
   level   by  sequential  I/O  (which  automatically  does/undoes  image
   compression)  or  at  a  higher  level  by slurping an entire GIF into
   allocated core.

   This  library  speaks  both  GIF87a and GIF89. The differences between
   GIF87  and  GIF89 are minor: in the latter, the interpretation of some
   extension  block types is defined. The library never needs to actually
   interpret these, but [2]giftext notices them.

                                   Utilities

   Here  is a summary of the utilities in this package. If you're looking
   at  this  page  through  a  web browser, each utility name should be a
   hotlink to HTML documentation.

Conversion Utilities

   [3]gif2bgi
          display GIFs on IBM PC displays using the BGI (Borland) driver

   [4]gif2epsn
          dump images saved as GIF files on Epson type printers

   [5]gif2herc
          display GIFs on IBM PC displays using the Hercules graphic card

   [6]gif2iris
          display GIFs under SGI NeWs window system

   [7]gif2ps
          print GIF file on laser printers supporting PostScript

   [8]gif2rgb
          convert images saved as GIF to 24-bit RGB image(s)

   [9]gif2rle
          convert images saved as GIF to RLE (Utah raster toolkit) format

   [10]gif2x11
          display images saved as GIF files under X window system

   [11]raw2gif
          convert raw 8-bit image data into GIF files

   [12]rgb2gif
          convert 24 bit images to a GIF image using color quantization

   [13]rle2gif
          convert images saved as RLE (Utah raster toolkit) to GIF format

Test Pattern Generators

   [14]gifbg
          generate a single-color test pattern GIF

   [15]gifcolor
          generate color test patterns

   [16]gifwedge
          create a test GIF image resembling a color monitor test pattern

Image Manipulation Components

   [17]gifasm
          assemble multiple GIFs into one, or burst a multiple-mage GIF

   [18]gifclip
          clip or crop a GIF image

   [19]gifclrmp
          modify GIF image colormaps

   [20]gifcomb
          combine 2 GIF images of exactly the same size into one

   [21]giffix
          clumsily attempts to fix truncated GIF images

   [22]gifflip
          flip GIF image along X or Y axis or rotate by 90 degrees

   [23]gifinter
          convert between interlaced and non interlaced images

   [24]gifovly
          generate one composite GIF from a multiple-image GIF

   [25]gifpos
          change a GIF's screen size or recondition it.

   [26]gifrotat
          rotate a GIF through any desired angle

   [27]gifrsize
          resize a GIF by deletion or duplication of bits

   [28]gifburst
          burst a GIF image into subrectangles.

Report Generators

   [29]giftext
          print (text only) general information about a GIF

   [30]gifhisto
          generate color-frequency histogram from a GIF

GIF Composition Tools

   [31]icon2gif
          converter/deconverter to/from an editable text format

   [32]text2gif
          generate GIF images out of regular text in 8x8 font

   [33]gifinto
          end-of-pipe fitting for GIF-processing pipelines

   [34]gifcompose
          use giflib tools to compose images

C Code Templates

   [35]giffiltr
          template code for filtering a GIF sequentially

   [36]gifspnge
          template code for filtering a GIF with in-core operations

   Under  MS-DOS,  most  filters  will  print the current input scan line
   number  (counting  up)  whenever they read image input, and will print
   output  image  line  number  (counting  down)  when  they dump output.
   Utilities  that  only  read or write always print in increasing order.
   Utilities (like GifPos that only change positions) that copy the image
   as  a  block  of  compressed  data  will print nothing --- they cannot
   identify  a  scan line number, and are enough faster that the feedback
   to the user doesn't seem necessary.

   Some of the utilities require memory on the order of the whole screen,
   while  others read one scan line at a time. Each utility HTML file has
   entry called Memory Usage which will be one of:

   Line
          memory required is on the order of one scan line

   Image
          proportional to the size of the biggest image in GIF file

   Screen
          proportional to GIF screen size

   In  all cases a byte is allocated per pixel, so an image of 320 by 200
   pixels will requires approximately 64k bytes of main memory.

                               Library Functions

   The  library  contains  two  groups  of  C  functions.  One group does
   sequential  I/O  on the stream-oriented GIF format. The other supports
   grabbing  an  entire GIF into allocated core, operating on it in core,
   and then writing the modified in-core GIF out to disk.

   Unless  you  are  on  a  286 or some other very memory-limited machine
   running under DOS, you probably want to use the second group.

   Detailed   documentation   on   the   library   entry   points  is  in
   [37]gif_lib.html.    Library    error    codes    are   described   in
   [38]liberror.html

                               The GIF Standard

   The  doc  subdurector  includes  flat-ASCII  descriptions of [39]GIF89
   format and [40]Lempel-Ziv Compression.

                                    History

   This package was originally written by Gershon Elber in 1990 on an IBM
   PC  under MS-DOS using Borland Turbo C. He made it portable to several
   UNIX environments.

   The  2.1 version featured substantial changes and additions by Eric S.
   Raymond  .  These  included  the  DGifSlurp/EGifSpew function pair for
   enabling  non-sequential  operations  on  GIF  images  and  the  tools
   icon2gif, gifovly, gifburst, and gifcompose.

   The   2.4  version  converted  all  the  docs  from  an  idiosyncratic
   plain-text formal to to HTML.

                                Package Status

   GIFLIB's  current maintainer is Eric S. Raymond. You can find his home
   page at [41]http://www.ccil.org/esr.

   GIFLIB  is  not  under  active  development,  but  bug fixes are being
   accepted.
     _________________________________________________________________


    Eric S. Raymond [42]<esr@snark.thyrsus.com>

References

   1. http://www.ccil.org/~esr/giflib
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giftext.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2bgi.html
   4. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2epsn.html
   5. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2herc.html
   6. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2iris.html
   7. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2ps.html
   8. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2rgb.html
   9. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2rle.html
  10. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2x11.html
  11. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/raw2gif.html
  12. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/rgb2gif.html
  13. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/rle2gif.html
  14. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifbg.html
  15. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcolor.html
  16. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifwedge.html
  17. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifasm.html
  18. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifclip.html
  19. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifclrmp.html
  20. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcomb.html
  21. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giffix.html
  22. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
  23. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifinter.html
  24. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifovly.html
  25. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
  26. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifrotat.html
  27. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifrsize.html
  28. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifburst.html
  29. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giftext.html
  30. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifhisto.html
  31. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/icon2gif.html
  32. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/text2gif.html
  33. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifinto.html
  34. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcompose.html
  35. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giffiltr.html
  36. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifspnge.html
  37. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html
  38. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/liberror.html
  39. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif89.txt
  40. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/lzgif.txt
  41. http://www.ccil.org/esr
  42. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>liberror</title>
<programlisting>

   Go to [1]index page.

                             GIFLIB error codes

   Errors  as  reported from the GIF_LIB library are divided to two major
   categoriess:  the  encoder  (errors  prefixed  by  E_GIF_ERR), and the
   decoder  (errors  prefixed  by D_GIF_ERR). This document explains them
   briefly:

                               Encoding errors:

   E_GIF_ERR_OpenFailed
          Message  printed  using  PrintGifError:  "Failed  to open given
          file" IO error result when attempt to open the given GIF file.

   E_GIF_ERR_WriteFailed
          Message  printed using PrintGifError: "Failed to Write to given
          file"  IO  error  result when attempt to write to the given GIF
          file.

   E_GIF_ERR_HasScrnDscr
          Message printed using PrintGifError: "Screen Descriptor already
          been set" Attempt to write second screen descriptor to same GIF
          file.  GIF file should have exactly one screen descriptor which
          should be set directly after the file is opened.

   E_GIF_ERR_HasImagDscr
          Message printed using PrintGifError: "Image Descriptor is still
          active"  Image descriptor should be sent before and image dump,
          and  no  second  image descriptor should be sent before current
          image  dump ended. This error occurred probably because current
          image was not complete.

   E_GIF_ERR_NoColorMap
          Message  printed using PrintGifError: "Neither Global Nor Local
          color  map"  An image must have either global (screen) or local
          (image) color map. Neither were given in this case.

   E_GIF_ERR_DataTooBig
          Message printed using PrintGifError: "#Pixels bigger than Width
          *  Height" The number of pixels dumped for this image is bigger
          than specified by image Height times image Width.

   E_GIF_ERR_NotEnoughMem
          Message printed using PrintGifError: "Fail to allocate required
          memory"  Once  an  attemp  is  made  to  open GIF file, special
          structures  are  allocated  to  hold  internal  data for it. If
          allocation fails this error is returned.

   E_GIF_ERR_DiskIsFull
          Message   printed  using  PrintGifError:  "Write  failed  (disk
          full?)" Writing encoded data failed.

   E_GIF_ERR_CloseFailed
          Message  printed  using  PrintGifError:  "Failed to close given
          file" Closing file failed.

   E_GIF_ERR_NotWriteable
          Message printed using PrintGifError: "Given file was not opened
          for  write" GIF files can be opened both for read (DGIF part of
          library)  and  write  (EGIF part of library). This error occurs
          when  a file is opened for read (using DGIF) is given to one of
          the encoding (EGIF) routines.

                               Encoding errors:

   D_GIF_ERR_OpenFailed
          Message  printed  using  PrintGifError:  "Failed  to open given
          file" IO error result when attempt to open the given GIF file.

   D_GIF_ERR_ReadFailed
          Message printed using PrintGifError: "Failed to Read from given
          file"  IO  error  result when attempt to write to the given GIF
          file.

   D_GIF_ERR_Notgif-file$
          Message  printed  using  PrintGifError:  "Given file is NOT GIF
          file"  GIF  files  should have special stamp identifies them as
          such, If that stamp is not found, this error is issued.

   D_GIF_ERR_NoScrnDscr
          Message  printed  using  PrintGifError:  "No  Screen Descriptor
          detected"  Each  GIF  file should have screen descriptor in its
          header.  This error will be generated if no such descriptor was
          found.

   D_GIF_ERR_NoImagDscr
          Message  printed  using  PrintGifError:  "No  Image  Descriptor
          detected"  Each  image  should  have  image  descriptor  in its
          header.  This error will be generated if no such descriptor was
          found.

   D_GIF_ERR_NoColorMap
          Message  printed using PrintGifError: "Neither Global Nor Local
          color  map"  An image must have either global (screen) or local
          (image) color map. Neither were given in this case.

   D_GIF_ERR_WrongRecord
          Message   printed   using  PrintGifError:  "Wrong  record  type
          detected"  Each  record  in GIF file has special identifier, in
          its  header.  If the record has wrong identifier, this error is
          generated.

   D_GIF_ERR_DataTooBig
          Message printed using PrintGifError: "#Pixels bigger than Width
          *  Height" The number of pixels dumped for this image is bigger
          than specified by image Height times image Width.

   D_GIF_ERR_NotEnoughMem
          Message printed using PrintGifError: "Fail to allocate required
          memory"  Once  an  attemp  is  made  to  open GIF file, special
          structures  are  allocated  to  hold  internal  data for it. If
          allocation fails this error is returned.

   D_GIF_ERR_CloseFailed
          Message  printed  using  PrintGifError:  "Failed to close given
          file" Closing file failed.

   D_GIF_ERR_NotReadable
          Message printed using PrintGifError: "Given file was not opened
          for  read"  GIF files can be opened both for read (DGIF part of
          library)  and  write  (EGIF part of library). This error occurs
          when a file is opened for write (using EGIF) is given to one of
          the decoding (DGIF) routines.

   D_GIF_ERR_ImageDefect
          Message  printed  using  PrintGifError:  "Image  is  defective,
          decoding  aborted"  This  error is generated, once the decoding
          failed - probably image is defect.

   D_GIF_ERR_EOFTooSoon
          Message  printed  using  PrintGifError:  "Image  EOF  detected,
          before image complete" This error is generated once EOF code is
          detected  in  encoded  image  before  all  the  pixels (Width *
          Height) has be decoded.
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>raw2gif</title>
<programlisting>

   Go to [1]index page.

                                  raw2gif

   A program to convert RAW image data into GIF files. Only one image can
   be  handled.  The RAW image file is assumed to hold one pixel color in
   one  byte,  and  therefore the file size must be Width times Height as
   specified by the -s option below.

                                    Usage:

raw2gif [-q] -s Width Height [-p ColorMapFile] [-h] RawFile

   If  no RawFile is given, Raw2Gif will try to read RAW data from stdin.
   The generated GIF File is dumped to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   -s Width Height
          the  dimensions  of  the image MUST be specified in the command
          line.  The  RAW  image  file  size  must be exactly Width times
          Height bytes (each byte is one pixel color).

   [-p ColorMapFile]
          Color map to load for given RAW image. This file has 4 integers
          in  line  (ColorIndex Red Green Blue), and the ColorIndex is in
          order  starting from 1. See GifClrMp, which can also use/create
          these  bitmap files. If no color map is specified, uses the EGA
          16 color pallete as default color map.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>rgb2gif</title>
<programlisting>

   Go to [1]index page.

                                  rgb2gif

   A  program  to  convert  24  bit  images  to  a  GIF image using color
   quantization.

                                    Usage:

rgb2gif [-q] [-c #Colors] [-1] -s Width Height [-h] RGBFile

   If  no  RGBFile  is  given,  RGB2Gif  will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaulte  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c #Colors]
          Specifies  number  of colors to use, in bits per pixels, so '-c
          8' specifies actually 256 colors (maximum and default).

   [-1]
          Only  one  file in the format of RGBRGB... triplets (Each of R,
          G, B is a byte) is read from input. This file size is 3 * Width
          *  Height  (see  '-s'  below.  If stdin is used for input, this
          option  is  implicitly  applied. The default (if not '-1') is 3
          files  with  the names RGBFile.R, RGBFile.G, RGBFile.B, each of
          which is Width * Height bytes.

   [-s Width Height]
          Specifies the size of the image to read.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>rle2gif</title>
<programlisting>

   Go to [1]index page.

                                  rle2gif

   A  program to convert images saved as RLE (Utah raster toolkit) to GIF
   format.

                                    Usage:

rle2Gif [-q] [-c #Colors] [-h] RleFile

   If  no  RleFile  is  given,  Rle2Gif will try to read an Rle file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c #Colors]
          Select size of color map in the output Gif file. #Colors should
          be  given  as the based 2 log of number of colors. Default is 8
          which is 256 colors, and which is also the maximum.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Notes:

   As  the RLE format allows full 24 bits per pixel (8 per primary color)
   Colors  must  be  quantized to the number of colors as set by the [-c]
   option,  above. This process is quite slow. See the quantize.c file in
   the lib directory for the code for this quantization algorithm (median
   cut).

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>

<sect2><title>text2gif</title>
<programlisting>

   Go to [1]index page.

                                  text2gif

   A  program to generate GIF images out of regular text. Text can be one
   line or multi-line, and is converted using 8 by 8 fixed font.

                                    Usage:

text2gif [-q] [-s ClrMapSize] [-f FGClr] [-c R G B] [-t "Text"] [-h]

   This  program  reads  stdin if no text is provided on the command line
   (-t), and will dump the created GIF file to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
   Quiet mode. Defaults off on MSDOS, on under UNIX. Controls printout of
   running scan lines. Use -q- to invert.

   [-s ClrMapSize]
   Explicitly  defines  the  size  of  the color map of the resulting gif
   image.  Usually  the  image will be bicolor with fg as color 1, unless
   [-f] is explicitly given in case the color map size will be big enough
   to  hold  it.  However it is sometimes convenient to set the color map
   size  to certain size while the fg color is small mainly so this image
   may be merged with another (images must match color map size).

   [-f FG]
   Select foreground index (background is always 0). By default it is one
   and  therefore  the  image result is bicolored. if FG is set to n then
   color  map  will be created with 2^k entries where 2^k > n for minimum
   k,  assuming  k  <=  8.  This  color map will be all zeros except this
   forground  index.  This  option is useful if this text image should be
   integrated into other image colormap using their colors.

   [-c R G B]
   The color to use as the foreground color. White by default.

   [-t "Text"]
   One  line  of  text can be provided on the command line. Note you must
   encapsulate  the  Text  within  quotes  if  it  has spaces (The quotes
   themselves  are  not  treated as part of the text). If no -t option is
   provided, stdin is read until end of file.

   [-h]
   Print one line command line help, similar to Usage above.

                                    Notes:

   There is a hardcoded limit of 100 the number of lines.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]<esr@snark.thyrsus.com>

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
</sect2>


</sect1>

<sect1><title>libungif</title>
<para>

</para>
</sect1>


<sect1><title>Rescuing your GIF data</title>
<para>

</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following websites might be of use if you want to research the GIF format further.
</para>

<itemizedlist>
<listitem><para>http://prtr-13.ucsc.edu/~badger/software/libungif/giflib.shtml: The giflib (sometimes called libgif) website.</para></listitem>
<listitem><para>http://prtr-13.ucsc.edu/~badger/software/libungif/index.shtml: The libungif website. This library is enough of the libgif library to rescue your data out of the GIF format and into a less patent bound format.</para></listitem>
<listitem><para>http://www.cloanto.com/users/mcb/19950127giflzw.html: Entitled <quote>
The GIF Controversy: A Software Developer's Perspective</quote>, this site discusses the history of the GIF format, and Unisys' recent licensing requirements.</para></listitem>
<listitem><para>http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/GIF89a.txt: the GIF specification</para></listitem>
<listitem><para>http://www.geocities.co.jp/SiliconValley/3453/gif_info/spec/GIF89M.htm: a HTML version of the GIF 89a specification</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>

</sect1>

</chapter>
