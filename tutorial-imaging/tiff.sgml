<chapter id="chap-tiff"><title>TIFF</title>
<slideinclude>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>
</slideinclude>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>

<slidetext>
<li><b>T</b>agged <b>I</b>mage <b>F</b>ile <b>F</b>ormat
<li>Developed by Aldus (remember them?) and Microsoft
<li>Aldus was acquired by Adobe, who still administer the TIFF specification
<li>Download the spec from:

  <a href="http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf">http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf</a>

<li>Technical implementation notes can be found at:

  <a href="http://partners.adobe.com/asn/developer/technotes/main.html">http://partners.adobe.com/asn/developer/technotes/main.html</a>
</slidetext>

<slidebreak>

<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>

<slidetext>
<li>Libtiff is an open implementation of the TIFF specification
<li>It is not GPL
<li>More like a BSD license
<li>There is documentation in the manual on how to install libtiff
</slidetext>
</sect1>

<noslide>
<sect1><title>Installation</title>
<para>
The source for libtiff can be downloaded from http://www.libtiff.org/ -- the current version of the library being version 3.5.7 at the time of writing. This version can be downloaded from ftp://ftp.remotesensing.org/pub/libtiff, look for the files named either tiff-v3.5.7.tar.gz or tiff-v3.5.7.zip.
</para>

<sect2><title>Unix</title>
<para>
Once you have downloaded the tarball for the library as described above, then you need to follow the steps below to install libtiff
  <footnote><para>Please note that there are binary packages for libtiff for most operating systems, so you might be best off installing one of those.</para></footnote>.

<orderedlist>
<listitem><para>tar xvzf tiff-v3.5.7.tar.gz</para></listitem>
<listitem><para>cd tiff-v3.5.7</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</orderedlist>
</para>

<para>
Not too hard at all...
</para>
</sect2>

<sect2><title>win32</title>
<para>
The instructions for how to compile the library are as follows:
</para>

<itemizedlist>
<listitem><para>Uncompress the libtiff distribution</para></listitem>
<listitem><para>Change directory into the libtiff directory inside the distribution</para></listitem>
<listitem><para>Copy ..\contrib\winnt\fax3sm.c to fax3sm_winnt.c</para></listitem>
<listitem><para>Copy ..\contrib\winnt\libtiff.def to libtiff.def</para></listitem>
<listitem><para>Remove the line for TIFFModeCCITTFax3 from the libtiff.def file</para></listitem>
<listitem><para>Change the line for TIFFFlushdata1 in the libtiff.def file to TIFFFlushData1</para></listitem>
<listitem><para>nmake /f makefile.vc all</para></listitem>
<listitem><para>Done!</para></listitem>
</itemizedlist>

<para>
To compile the tools once you have the library, just change into the tools directory and do a nmake /f makefile.vc 
</para>

<para>
For the Visual Studio challenged, there is a precompiled version of libtiff for win32 available from http://www.stillhq.com. Have a look at the Panda documentation page...
</para>
</sect2>
</sect1>
</noslide>

<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>

<slidetext>
<li>We should talk about how TIFF images are laid out on disc
<li>This will help us understand the inner workings of the format better
<li>There are more details on this in the TIFF specification if you need them
</slidetext>

<sect2><title>File header</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>




<sect2><title>Image File Directory</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>




<sect2><title>Image File Directory Entries</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>

<para>
These entries have a type associated with them, possible types are:
</para>

<slidebreak>

<slidetext>
<li>These entries have a type
<li>Options are:
  <br>
  <ul>
</slidetext>

<slideinclude>
<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>
</slideinclude>

<para>
TIFF version 6 added the following fields:
</para>

<slideinclude>
<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>
</slideinclude>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>

<slidetext>
<br><br>
<li>Sign is implemented using 2's complement
<li>Adobe reserve the right to add new types later
</slidetext>
</sect2>

<noslide>
<sect2><title>Possible field entries</title>
<para>
Discussing the many different possible field entries is out of the scope of this document. Refer to tiff.h and the TIFF specification for more information.
</para>
</sect2>
</noslide>

<sect2><title>So where's the image data?</title>
<slideinclude>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</slideinclude>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:

<slidetext>
<li>Most file formats lay down basic rules covering:
  <ul>
</slidetext>

<slideinclude>
<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</slideinclude>
</para>

<slidetext>
  </ul>
<li>TIFF doesn't
</slidetext>

<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	
<slidetext>
<li>This makes it very easy to create TIFFs
<li>Your current internal format is probably good enough
<li>Very hard to read in TIFF files well however
</slidetext>

<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>

<slidetext>
<br><br>
<li><i>Try to avoid making assumptions...</i>
</slidetext>
</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>

<slidetext>
<li>It must be time to see some code by now...
</slidetext>
	
<noslide>
<sect2><title>Infrastructure for writing</title>
<para>
It is traditional for bitmaps to be represented inside your code with an array of chars. This is because on most operating systems, a char maps well to one byte. In the block of code below, we will setup libtiff, and create a simple buffer which contains an image which we can then write out to disc.
</para>
</noslide>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-bw-write/write-infrastructure.c</input></execute>
</slideinclude>

<slidetext>
<BR><BR>
<li>Is this the most boring code example <b>every</b> or what?
</slidetext>

<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-bw-write/write-nohex.c</input></execute>
</slideinclude>

<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>

<noslide>
<sidebar><title>Problems with xview</title>
<para>
Xview is part of the xloadimage package written by Jim Frost, which comes with X windows.
</para>

<para>
It's a good example of how hard it can be to handle TIFF images well. If you have trouble viewing the output of the sample code, then try using some other program, like the GIMP.
</para>
</sidebar>
</noslide>

<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>

<slidebreak>
<slidetext>
<li>Things to note from this example:
  <ul>
</slidetext>

<slideinclude>
<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>
</slideinclude>

<slidetext>
  </ul>
</slidetext>

<noslide>
<sidebar><title>More information about the libtiff function calls</title>
<para>
If you need more information about any of the libtiff function calls mentioned in this chapter, then checkout the extensive man pages which come with the library. Remember that case is important with man pages, so you need to get the case in the function names right -- it's TIFFOpen, not tiffopen.
</para>
</sidebar>
</noslide>

<slidebreak>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, by Michael Still</title>
<execute><cmd>img</cmd><args>tiff-figure1.jpg</args></execute>
</figure>
</slideinclude>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>

<slidetext>
<li>As I said before, reliable reading is much harder than writing
<li>First let's talk about stripping, and tiling of images...
</slidetext>

<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>

<slidetext>
<li>Single strip is where all the image data is in one block (a strip)
<li>This can be unreliable if the strip is bigger than 8kb
</slidetext>

<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>

<slidetext>
<BR><BR>
<li>Multiple strip images have many horizontal strips
</slidetext>

<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, in strips</title>
<execute><cmd>img</cmd><args>tiff-figure2.jpg</args></execute>
</figure>
</slideinclude>

<slidebreak>

<slidetext>
<li>A tiled image is like your bathroom wall...
<li>This is often used for extremely large images such as maps
</slidetext>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, in tiles</title>
<execute><cmd>img</cmd><args>tiff-figure3.jpg</args></execute>
</figure>
</slideinclude>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>

<slidetext>
<li>Tiled images are not very common
<li>So we'll focus on stripped images
</slidetext>

<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>

<slidetext>
<li>We need to remember to be flexible in the input that we accept
<BR><BR>
<li>Be flexible about:
  <ul>
  <li>Stipping / tiling
  <li>Strip sizes
  <li>Photometric interpretation
  </ul>
</slidetext>

<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (PHOTOMETRIC_MINISBLACK), whilst you might find black being 1 (PHOTOMETRIC_MINISWHITE) more convenient. TIFF allows both (in the TIFFTAG_PHOTOMETRIC tag), so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in PHOTOMETRIC_MINISWHITE so we will convert images which are in PHOTOMETRIC_MINISBLACK.
</para>

<slidebreak>
<slidetext>
<li>What is photometric interpretation?
<li>It's the representation of the image in the raster
<BR><BR>
<li>For example, I might code my bitmaps so black is represented by 1
<li>... you might use 0 for black
<li>TIFF allows both in the TIFFTAG_PHOTOMETRIC tag
  <ul>
  <li>PHOTOMETRIC_MINISWHITE
  <li>PHOTOMETRIC_MINISBLACK
  </ul>
<BR><BR>
<li>In the examples here I have assumed we need PHOTOMETRIC_MINISWHITE, so we will convert PHOTOMETRIC_MINISBLACK as required.

<BR><BR>
<i>Note that some versions of this tutorial had the tag names wrong...</i>
</slidetext>

<execute><cmd>nextedition</cmd><input>Remove note above</input></execute>

<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>

<slidebreak>
<slidetext>
<li>The other thing to bear in mind is the fill order of the bytes
<li>This is whether the first bit in the byte has the highest value or the lowest
<li>This is subtly different from endianness
<BR><BR>
<li>Libtiff deals with endian issues for us automatically
</slidetext>

<slidebreak>
<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-bw-read/read.c</input></execute>
</slideinclude>

<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>

<slidebreak>
<slidetext>
<li>This code works by opening an image
<li>Checking that it is one that we support
<li>Reading in all the strips and appending them together
<li>Twiddling bits if required
<li>Output the hex representation of the image
</slidetext>
</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>. The compression option is stored in the tag TIFFTAG_COMPRESSION.
</para>

<slidetext>
<li>Stored in TIFFTAG_COMPRESSION
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>COMPRESSION</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>
Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.
</para>

<slidetext>
<li>JPEG compression can be a bad choice for some forms of data
<li>This is because it is lossy
<li>This loss accumulates through repeated compression and decompression
</slidetext>

<para>
Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.
</para>

<slidebreak>
<slideinclude>
<figure><title>The picture before we compressed it</title>
<execute><cmd>img</cmd><args>tiff-figure4.jpg</args></execute>
</figure>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>The sample text before we compressed it</title>
<execute><cmd>img</cmd><args>tiff-figure5.jpg</args></execute>
</figure>
</slideinclude>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<slidebreak>
<slideinclude>
<figure><title>The picture after it has been recompressed 200 times</title>
<execute><cmd>img</cmd><args>tiff-figure6.jpg</args></execute>
</figure>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>The text after it has been recompressed 200 times</title>
<execute><cmd>img</cmd><args>tiff-figure7.jpg</args></execute>
</figure>
</slideinclude>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>

<slidebreak>
<slidetext>
<li>I cheated here, and had a quality of 25% set on the JPEG compression
<li>The default is 75%
<BR><BR>
<li>The code for repeated compression is the the printed manual
</slidetext>
</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>

<slidetext>
<li>It's time to show you a color example
</slidetext>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-color-write/write.c</input></execute>
</slideinclude>

<slidebreak>

<para>
You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.
</para>

<slidetext>
<li>There are some things we should pay attention to in this code:
  <ul>
  <li>The image has three (red, green and blue) samples per pixel
  <li>Each of these samples is 8 bits
  <li>This is therefore a 24 bit color image
  </ul>
</slidetext>

<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>

<slidetext>
<li>Now is probably as good a time as any to tell you that you're not limited to three samples per pixel
<li>You can have an arbitary number
<li>For instance, this is where alpha channel information is stored in almost all image formats
<li>Having more than three samples per pixel can break viewers which make ugly assumptions
</slidetext>
</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>

<slidebreak>
<slidetext>
<li>The other interesting thing we should talk about now is planar configuration
<li>You don't have to have your image data grouped like:

<pre>
RGBRGBRGBRGBRGB
</pre>

<li>Grouping all the red samples together is equally valid, for instance:

<pre>
RRRRRGGGGGBBBBB
</pre>

<li>Have a look at the libtiff documentation on TIFFTAG_PLANARCONFIG for more details
</slidetext>
</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>

<slidetext>
<li>Writing a paletted image with libtiff is really easy...
<li>Just change TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE
</slidetext>
</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>

<slidetext>
<li>Now we just need to work out how to read color images in
<li>Here's why I'm not telling you about TIFFReadRGBAStrip() and TIFFReadRGBATile()
</slidetext>

<slideinclude>
<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<slidebreak>
<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>
</slideinclude>

<slidebreak>
<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>

<slidetext>
<li>So what's wrong with this function?
  <ul>
  <li>It defines the origin (0,0) in a different way from <b>all</b> the other libtiff calls
  <li>Not all valid values for bits per sample are handled
  </ul>

<BR><BR>

<li>We're going to use it anyway, because it makes the code clearer...
<li>Remember that you can always use TIFFReadEncodedStrip() like we did for the black and white images -- although you then have to interpret the image data yourself
</slidetext>

<slidebreak>
<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-color-read/read.c</input></execute>
</slideinclude>
</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>

<slidetext>
<li>There are times when it isn't appropriate to store your image data in files
<li>There are lots of examples of when you might want to put the data in a database instead
<li>Perhaps the image data is going to be embedded into another file format
</slidetext>

<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>

<slidetext>
<BR><BR>
<li>The example I am most familiar with is the PDF specification
<li>The PDF format is basically ASCII (as we will see later)
<li>But has embedded binary "streams" such as TIFF data
<li>So we would like to be able to create these streams with libtiff
<li>...instead of having to implement our own TIFF library
</slidetext>

<noslide>
<sidebar><title>An expanded example</title>
<para>If you need more information about hooking the file input and output functions within libtiff than this chapter allows, then have a look at the images.c file in Panda, my PDF library. The web pages for Panda can be found at http://www.stillhq.com
  <footnote><para>http://www.stillhq.com/cgi-bin/getpage?area=panda&lt;page=index.htm to be exact.</para></footnote>
.
</para>
</sidebar>
</noslide>

<slidebreak>
<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>

<slidetext>
<li>Use the TIFFClientOpen() function...
</slidetext>

<execute><cmd>nextedition</cmd><input>Make this example better</input></execute>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-client/client.c</input></execute>
</slideinclude>
</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>

<slidetext>
<li>People commonly want to be able to store more than one image in a TIFF file
<li>TIFF and libtiff support this
<li>This is called multipage / multidirectory TIFF
<li>Multidirectory because there is more than one IFD
<li>There is in fact one per image
</slidetext>

<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>

<slidetext>
<BR><BR>
<li><i>Before writing heaps of code for multipage TIFFs, remember that the specification doesn't require viewers to support this feature, so you might end up with a whole heap of data that no-one can look at...</i>
</slidetext>

<slidebreak>
<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>

<slidetext>
<li>Actually doing it is quite easy...
<li>Just use the TIFFWriteDirectory() call between the images
</slidetext>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-directories/create.c</input></execute>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>Four pictures of my son Andrew</title>
<execute><cmd>img</cmd><args>tiff-figure8.jpg</args></execute>
</figure>
</slideinclude>

<execute><cmd>nextedition</cmd><input>quality_of_picture</input></execute>
</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
This example below demonstrates how to do this.
</para>

<execute><cmd>nextedition</cmd><input>convert_will_create_multiple_files</input></execute>
<execute><cmd>nextedition</cmd><input>more!</input></execute>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-directories/read.c</input></execute>
</slideinclude>

<execute><cmd>nextedition</cmd><input>This doesn't work at the moment</input></execute>
</sect1>

<noslide>
<sect1><title>Man pages</title>
<para>
I have included the man pages to some of the more useful libtiff commands, so that you have them for reference when you need them.
</para>

<sect2><title>tiff2bw</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiff2bw.1</input><args>-s 3</args>></execute>
</sect2>

<sect2><title>tiff2ps</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiff2ps.1</input><args>-s 3</args></execute>
</sect2>


<sect2><title>tiffcmp</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffcmp.1</input><args>-s 3</args></execute>

<sect3><title>Sample output</title>
<para>
<command>tiffcmp</command> shows the differences in tags between images, for example, when I compare the input and output images from the pixel example in this chapter:
</para>

<programlisting>
[mikal@localhost tiff-pixels]$ tiffcmp input.tif output.tif 
ImageWidth: 256 520
[mikal@localhost tiff-pixels]$ 
</programlisting>
</sect3>
</sect2>
</noslide>

<sect2><title>tiffcp</title>
<slideinclude>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffcp.1</input><args>-s 3</args></execute>
</slideinclude>
</sect2>


<sect2><title>tiffdither</title>
<slideinclude>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffdither.1</input><args>-s 3</args></execute>
</slideinclude>

<noslide>
<sect3><title>Sample output</title>
</noslide>
<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<slidebreak>
<slideinclude>
<figure><title>The gray scale input image</title>
<execute><cmd>img</cmd><args>tiff-figure9.tif</args></execute>
</figure>
</slideinclude>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<slidebreak>
<slideinclude>
<figure><title>The dithered output image</title>
<execute><cmd>img</cmd><args>tiff-figure10.tif</args></execute>
</slideinclude>
</figure>
</sect3>
</sect2>

<sect2><title>tiffdump</title>
<slideinclude>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffdump.1</input><args>-s 3</args></execute>
</slideinclude>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</slideinclude>
</sect3>
</sect2>

<noslide>
<sect2><title>tiffgt</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffgt.1</input><args>-s 3</args></execute>
</sect2>
</noslide>

<sect2><title>tiffinfo</title>
<slideinclude>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffinfo.1</input><args>-s 3</args></execute>
</slideinclude>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</slideinclude>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<slidebreak>
<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</slideinclude>
</sect3>
</sect2>

<noslide>
<sect2><title>tiffmedian</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffmedian.1</input><args>-s 3</args></execute>
</sect2>
</noslide>

<noslide>
<sect2><title>tiffsplit</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffsplit.1</input><args>-s 3</args></execute>
</sect2>
</noslide>

<noslide>
<sect2><title>tiffsv</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tiffsv.1</input><args>-s 3</args></execute>
</sect2>
</noslide>

<noslide>
<sect2><title>tifftopnm</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/tifftopnm.1</input><args>-s 3</args></execute>
</sect2>
</noslide>
</sect1>






<sect1><title>API Man Pages</title>
<para>
It is also useful to have the man pages for the libtiff API man pages to refer to...
</para>

<slidetext>
<li>There are also extensive man pages for the API -- check yout manual
</slidetext>

<noslide>
<sect2><title>TIFFbuffer</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFbuffer.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFCheckTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFCheckTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFClientOpen</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFClientOpen.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFClose</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFClose.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFcodec</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFcodec.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFComputeStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFComputeStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFComputeTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFComputeTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFCurrentDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFCurrentDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFCurrentRow</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFCurrentRow.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFCurrentStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFCurrentStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFCurrentTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFCurrentTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFDefaultStripSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFDefaultStripSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFDefaultTileSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFDefaultTileSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFError</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFError.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFdOpen</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFdOpen.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFileName</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFileName.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFileno</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFileno.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFindCODEC</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFindCODEC.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFlush</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFlush.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFFlushData</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFFlushData.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFfree</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFfree.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFGetField</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFGetField.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFGetMode</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFGetMode.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFIsByteSwapped</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFIsByteSwapped.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFIsMSB2LSB</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFIsMSB2LSB.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFIsTiled</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFIsTiled.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFIsUpSampled</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFIsUpSampled.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFLastDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFLastDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFmalloc</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFmalloc.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFmemcmp</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFmemcmp.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFmemcpy</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFmemcpy.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFmemory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFmemory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFmemset</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFmemset.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFNumberOfStrips</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFNumberOfStrips.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFNumberOfTiles</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFNumberOfTiles.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFOpen</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFOpen.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFPrintDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFPrintDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFquery</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFquery.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadBufferSetup</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadBufferSetup.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadEncodedStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadEncodedStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadEncodedTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadEncodedTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadRawStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadRawStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadRawTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadRawTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadRGBAImage</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadRGBAImage.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadRGBAStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadRGBAStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadRGBATile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadRGBATile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadScanline</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadScanline.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReadTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReadTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFrealloc</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFrealloc.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRegisterCODEC</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRegisterCODEC.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFReverseBits</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFReverseBits.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRewriteDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRewriteDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRGBAImage</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRGBAImage.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRGBAImageBegin</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRGBAImageBegin.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRGBAImageEnd</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRGBAImageEnd.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRGBAImageGet</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRGBAImageGet.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFRGBAImageOK</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFRGBAImageOK.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFScanlineSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFScanlineSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSetDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSetDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSetErrorHandler</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSetErrorHandler.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSetField</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSetField.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSetSubDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSetSubDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSetWarningHandler</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSetWarningHandler.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFsize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFsize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFstrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFstrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFStripSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFStripSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFswab</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFswab.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSwabArrayOfLong</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSwabArrayOfLong.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSwabArrayOfShort</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSwabArrayOfShort.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSwabLong</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSwabLong.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFSwabShort</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFSwabShort.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFtile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFtile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFTileRowSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFTileRowSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFTileSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFTileSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFUnRegisterCODEC</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFUnRegisterCODEC.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFVGetField</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFVGetField.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFVSetField</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFVSetField.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFVStripSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFVStripSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFVTileSize</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFVTileSize.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWarning</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWarning.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteBufferSetup</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteBufferSetup.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteDirectory</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteDirectory.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteEncodedStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteEncodedStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteEncodedTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteEncodedTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteRawStrip</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteRawStrip.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteRawTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteRawTile.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteScanline</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteScanline.3t</input><args>-s 3</args></execute>
</sect2>


<sect2><title>TIFFWriteTile</title>
<execute><cmd>~mikal/opensource/groff2db/convert</cmd><input>source/tiff/man/TIFFWriteTile.3t</input><args>-s 3</args></execute>
</sect2>
</sect1>
</noslide>









<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>

<slidetext>
<li>In the early stages of this tutorial I showed you a pixel enlargement...
<li>Here's the code that did that
</slidetext>

<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-pixels/pixel.c</input></execute>
</slideinclude>
</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>

<slidetext>
<li>Earlier on I also promised some grayscale conversion code...
</slidetext>

<sect2><title>A broken algorithm</title>
<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-grayscale/gray-wrong.c</input></execute>
</slideinclude>

<para>
Which produces:
</para>

<figure><title>An average of the color values for each pixel</title>
<execute><cmd>img</cmd><args>grayscale-figure2.jpg</args></execute>
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>
<slideinclude>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-grayscale/gray-good.c</input></execute>
</slideinclude>

<para>
Which gives us:
</para>

<figure><title>A correct conversion to gray scale</title>
<execute><cmd>img</cmd><args>grayscale-figure3.jpg</args></execute>
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>

<noslide>
<sect1><title>Example: Repeated compression</title>
<para>
Earlier in this chapter I promised that I would include the code for the repeated compression loss example, so here it is. The example is made up of a simple (and quite ugly) shell script, and a c program to actually compress the images...
</para>

<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-recompress/recompress.sh</input></execute>
<execute><cmd>code2db</cmd><input>~mikal/opensource/tiff-recompress/recompress.c</input></execute>
</sect1>
</noslide>

<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed the TIFF file format, how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>

<slidetext>
<li>So what have we learnt?
  <ul>
  <li>Something about the TIFF file format
  <li>Black and white images with libtiff
  <li>Color images with libtiff
  <li>You should now have enough information to at least start to use libtiff...
  </ul>
</slidetext>
</sect1>

<noslide>
<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libtiff.org: The libtiff website is a good place to download the libtiff source. It is also quite likely there is a binary package for your chosen operating system.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: If all else fails, then the Adobe TIFF Specification can be useful.</para></listitem>

<listitem><para>http://gopher.std.com/homepages/jimf/xloadimage.html: The xloadimage web page might be of interest.</para></listitem>

<listitem><para>http://www.ee.cooper.edu/courses/course_pages/past_courses/EE458/TIFF/index.html: The Cooper Union for the Advancement of Science and Art has some notes from a previous course dealing with libtiff online.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/graphics/graphics.html: The Adobe Graphics technical notes page is quite useful.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: The current version of the TIFF specification can be found here.</para></listitem>

<listitem><para>http://home.earthlink.net/~ritter/tiff/: The unofficial TIFF site contains some useful resources.</para></listitem>

<listitem><para>http://www.inforamp.net/~poynton/notes/colour_and_gamma/ColorFAQ.html: a FAQ document discussion of converting to gray scale</para></listitem>
</itemizedlist>
</para>
</sect1>
</noslide>

<sect1><title>Portions first published by IBM DeveloperWorks</title>
<slideinclude>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</slideinclude>
</sect1>
</chapter>
