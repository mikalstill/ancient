<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>
</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>

<sect1>
<title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>
</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>
</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<sect2><title>C</title>
<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not nessesarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>
</sect2>

<sect2><title>How to compile and link on your chosen operating system</title>
<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The makefiles included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>
</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.

%todo: picture of Andrew and Catherine%
</para>
</sect1>

<sect1><title>License</title>
<para>
This document is covered by two licenses -- the license for the text of this document, and the license for the included source code. The license terms are set out below.
</para>

<sect2><title>License for text (OPL)</title>
<para>
%text2db.pl:OPL%
</para>
</sect2>

<sect2><title>License for source code (GPL)</title>
<para>
%text2db.pl:GPL%
</para>
</sect2>
</sect1>
</chapter>

































<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day.
</para>

<sect1><title>Rasters</title>
<para>
     <indexterm><primary>Raster</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>raster</secondary></indexterm>
The most common image format (and the focus of the majority of this tutorial) is raster image formats. Raster image formats are those which store the picture as a bitmap
     <footnote><para>You can think of a bitmap as being simply an array of pixels. We'll talk more about this later</para></footnote>
describing the state of pixels, as opposed to recording the length and locations of primatives such as lines and curves. Common examples include the output of photoshop, the gimp, scanners and digital cameras. Effectively, your monitor and printer are raster output devices.
</para>

<figure>
<title>A sample raster image</title>
<graphic format="EPS" fileref="raster-figure1.eps"></graphic>
</figure>

<para>
Raster image formats include TIFF, GIF, PNG, and most of the other formats in this tutorial. If in doubt, assume that it's a raster format unless I tell you otherwise.
</para>

<para>
If we zoom in enough on a portion of this image, we can see that it is made up of descrete elements -- the pixels. %todo: falls off page%
</para>

<figure>
<title>Zooming in on a portion of the raster image</title>
<graphic format="EPS" fileref="raster-figure2.eps"></graphic>
</figure>

<para>
The code to produce this zoomed image is presented in the TIFF chapter of this tutorial.
</para>

</sect1>

<sect1><title>Vector</title>
<para>
     <indexterm><primary>Vector</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>vector</secondary></indexterm>
Some images aren't raster images. These images are normally composed of primative drawing commands, such as draw a line, draw a circle, et cetera. The advantage of vector formats is that it is an exact representation of the image, they also scale much better. Examples of vector formats include Scalar Vector Graphics (SVG), Adobe Illustrator files, Windows Meta Files, and to a certain extent PDF documents. A plotter is a vector output device.
</para>
</sect1>

<sect1><title>Pixel</title>
<para>
     <indexterm><primary>Pixel</primary></indexterm>
A pixel is the lowest unit of raster image description -- in other words, a raster image is defined in terms of pixels. Example pixels can be seen in the discussion of rasters, elsewhere in this chapter.
</para>
</sect1>

<sect1><title>Converting color to grayscale</title>
<para>
How do you convert color images to grayscale? Well, my instant answer when I first had to do this was to just average the red, green and blue values. That answer is wrong. The reality is that the human eye is much better at seeing some colors than others. To get an accurate grayscale representation, you need to apply different coefficients to the color samples. Appropraite coefficients are 0.299 for red, 0.587 for green and 0.114 for blue.</para>
</sect1>


<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>
</chapter>


<chapter id="chap-imagetheory"><title>Imaging theory</title>
<sect1><title>Theory of color and grayscale storage</title>
<para>
The first thing that we need to understand to be able to support color and grayscale images is the format of the image data within memory. There are two main representations for color and grayscale images. I'll explain these by describing grayscale, and then extend it to color.
</para>

<sect2><title>Direct storage of pixel data</title>
<para>
If you think back to the way pixel information was stored in the black and white images from the previous article, the information was just in the strips. You can also do this with grayscale and color images. This representation of image data is quite inefficient, because for the scenario when the image has a solid background (for example), there are many pixels with the same value. If the pixel data is stored in the strips, then this value will waste a large amount of space.
</para>

<para>
Thankfully, there is a more efficient way to store image data. Imagine a simple four color 24 bit per pixel image. If we build a lookup table of the four color values (the 24 bit values which represent those colors), then we just need to store the relevant entry number of the color in the image strip itself. This can be done in only two bits, instead of the full 24. The maths looks something like this:
</para>

<para>
A 24 bit color image which is 1,000 by 1,000 pixels will take 24 million bits to store. The same image, if it was a four color image, would take 4,000,000 bits for the strip data, and 98 bits for the color table. Neither of these numbers includes header and footer information for the file format, and the numbers are for uncompressed bitmaps. The advantages of the lookup table should be obvious. There is a name for this style of lookup table, it is called a <emphasis>palette</emphasis> -- probably because of those things painters carry around.
</para>

<para>
This concept works for grayscale images as well. The only difference is that the colors in the palette are not just shades of gray.
</para>
</sect2>
</chapter>

%builddb.pl:tiff.sgml%

<chapter id="chap-png"><title>PNG</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-jpeg"><title>JPEG</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-gif"><title>GIF</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-svg"><title>SVG</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-others"><title>Other raster image formats</title>
<para>
...
</para>
<sect1><title>Further reading</title>

<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-pdf"><title>PDF</title>
<para>
...
</para>

<sect1><title>ClibPDF</title>
<para>
...
</para>
</sect1>

<sect1><title>PDFlib</title>
<para>
...
</para>
</sect1>

<sect1><title>Panda</title>
<para>
...
</para>
</sect1>

<sect1><title>Adobe products</title>
<para>
...
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-opengl"><title>OpenGL</title>
<para>
...
</para>
<sect1><title>Further reading</title>

<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-random"><title>Random important topics</title>
<para>
There are also a few topics which are important enough to be mentioned here, but haven't found their way into the discussions in any other place. They therefore get a chapter of their own here at the end.
</para>

<sect1><title>Encrypting images can have unexpected effects</title>
<para>
DES in Electronic Code Book (ECB) mode is a particularly poor choice of cryptography for image files. This is because ECB mode implements a lookup table between the unencrypted value and the encrypted value. This results in a known input value turning into the same output value over and over. This can have some interesting bluring effects, but wont obscure the image contents. An example will help this make more sense -- figure 1 is the logo for the company I am currently working for. I took this image, and ran it through some DES ECB code and produced figure 2.
</para>

<figure>
<title>The TOWER corporate logo</title>
<graphic format="EPS" fileref="desecb-figure1.eps"></graphic>
</figure>

<figure>
<title>After ECB encryption</title>
<graphic format="EPS" fileref="desecb-figure2.eps"></graphic>
</figure>

<para>
You can see that whilst the image has certainly changed, the contents of the image has not really been obscured. %todo: more%
</para>

<para>
For those who have an excessive interest in code, I encrypted the TIFF image which is the TOWER logo with the code below:
</para>

<programlisting>
...
</programlisting>

<para>
What about encrypting an image of text? %todo: more%
</para>

<para>
We should note that ECB mode is not commonly used anyway. If you use something like PGP or blowfish, then you should be much happier... %todo: check this%
</para>
</sect1>

<sect1><title>ImageMagick</title>
<para>
Available from: xxx
Installation steps; ./configure; make; make install
</para>

<para>
%todo: I'm only really talking about convert here -- what about the others?%
</para>

<para>
ImageMagick provides a series of convenient tools for converting and manipulating images. This includes converting between formats, changing the color space attributes, downsampling, scaling, rotation and text annotation. It should be noted that ImageMagick doesn't implement an API -- in other words it is a command line tool, which isn't really suited to being built into applications. ImageMagick also depends on many other packages (such as libtiff) being available for all it's functionality to work. These required helper packages are called "delegates".
</para>

<sect2><title>Example: Converting between image formats</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Scaling an image</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Rotating an image</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Inserting text annotations onto an image</title>
<para>
...
</para>
</sect2>

<sect2><title>A sample script -- generating a history of CVS commits to a repository</title>
<para>
Now it's time to provide an example of how the ImageMagick commands can be used to create something quite useful. This example is a script I wrote a few months ago to generate a graphical history of a CVS repository. The script takes the output of the <command>cvs log</command> command, and parses this. The <command>cvs log</command> output looks something like this:
</para>

<para>
%todo: should this be cut down a little%
</para>

<programlisting>
%code2db.pl:source/imagemagick/cvsreport/sample.log%
</programlisting>

<para>
The following perl script parses this log file to produce a HTML description of the activity described by the log:
</para>

<programlisting>
%code2db.pl:source/imagemagick/cvsreport/cvsreport.pl%
</programlisting>

<para>
The output of the script looks something like this:
</para>

<para>
%todo: figure%
</para>
</sect2>
</sect1>

<sect1><title>Imlib</title>
<para>
...
</para>
</sect1>

<sect1><title>AA</title>
<para>
Available from: xxx
Installation steps; ./configure; make; make install
</para>

<para>
aalib is a library which renders images into black and white ASCII art. This can be quite useful for previewing images on consoles which don't have graphics capabilities (although these are becoming quite rare these days).
</para>

<para>
I imagine that it's also probably one of the ways things like ASCII art versions of Star Wars are generated.
</para>

<para>
There are sample images generated by allib available at aa... Some of the more interesting ones are:
..
%todo: insert images%
..
and
..
</para>

<para>
%todo: more%
</para>
</sect1>







<sect1><title>RasterMaster</title>
<para>
...
</para>
</sect1>








<sect1><title>FreeType</title>
<para>
...
</para>
</sect1>

<sect1><title>The GNU autotools</title>
<para>
...
</para>
</sect1>

<sect1><title>SVGAlib</title>
<para>
...
</para>
</sect1>
</chapter>























<chapter id="chap-resources"><title>Resources</title>
<para>
There are a few resources which will make your life much easier. Here are some of my favourites:
</para>

<para>
%todo: This biblio entry is crap and broken and should be fixed...%
</para>

<bibliography><title>References</title>
<bibliomixed>
  <bibliomset relation='article'>
    <surname>Foley</surname>, <firstname>James D</firstname>.
    <surname>van Dam</surname>, <firstname>Andries</firstname>.
    <surname>Feiner</surname>, <firstname>Steven K</firstname>.
    <surname>Hughes</surname>, <firstname>John F</firstname>.
    <title role='article'>Computer Graphics: Principles and Practise</title>.
  </bibliomset>
  <bibliomset relation='journal'>
    <title>The World Wide Web Journal</title> 
    <volumenum>2</volumenum><issuenum>1</issuenum>.
    <publishername>O'Reilly &amp; Associates, Inc.</publishername> and
    <corpname>The World Wide Web Consortium</corpname>.
    <pubdate>Winter, 1996</pubdate></bibliomset>.
</bibliomixed>
</bibliography>



</chapter>


















<chapter id="chap-conclusion"><title>Conclusion</title>
<para>
...
</para>
</chapter>





<chapter><title>TODO</title>
<para>
Finish conversion of article 1
Convert article 2
DES code cleanup
Comparison chart for image formats
</para>
</chapter>

</book>
