<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>
</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>

<sect1>
<title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>
</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>
</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<sect2><title>C</title>
<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not nessesarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>
</sect2>

<sect2><title>How to compile and link on your chosen operating system</title>
<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The makefiles included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>
</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.
</para>

<figure>
<title>Catherine and Andrew</title>
<graphic format="EPS" fileref="introduction-figure1.eps">
</figure>


<para>
I should also thank the following people:
</para>

<itemizedlist>
<listitem><para>Doug Jackson (doug_jackson@citadel.com.au), for proof reading and getting me interested in this whole topic to start with</para></listitem>
<listitem><para>Tony Green (greeno@bandcamp.tv), for occassional docbook wrangling</para></listitem>
<listitem><para>Michael Smith (smith@xml-doc.org), for docbook hints</para></listitem>
</itemizedlist>
</sect1>

<sect1><title>How this document was produced</title>
<para>
This tutorial was written in Docbook SGML using xemacs. This was then converted into PDF using the jade SGML tools. Diagrams were developed in a combination of the gimp, Adobe Illustrator, and custom developed code. Diagrams were converted to EPS as required by jade using ImageMagick.
</para>

<para>
A series of docbook generation scripts we also used to automate some of the generation of this document. These scripts can be found in my online CVS repository at: http://www.stillhq.com/cgi-bin/cvsweb/docbooktools/
</para>

<para>
The source for this tutorial is available at: http://www.stillhq.com/cgi-bin/cvsweb/tutorial-imaging/
</para>
</sect1>

<sect1><title>License</title>
<para>
This document is covered by two licenses -- the license for the text of this document, and the license for the included source code. The license terms are set out below.
</para>

<sect2><title>License for text (OPL)</title>
<para>
</para>
</sect2>

<sect2><title>License for source code (GPL)</title>
<para>
</para>
</sect2>

<sect2><title>License for the libtiff man pages</title>
<para>
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.
</para>

<para>
Permission to use, copy, modify, distribute, and sell this software and 
its documentation for any purpose is hereby granted without fee, provided
that (i) the above copyright notices and this permission notice appear in
all copies of the software and related documentation, and (ii) the names of
Sam Leffler and Silicon Graphics may not be used in any advertising or
publicity relating to the software without the specific, prior written
permission of Sam Leffler and Silicon Graphics.
</para>

<para>
THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
</para>

<para>
IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
OF THIS SOFTWARE.
</para>
</sect2>

<sect2><title>License for some ClibPDF examples</title>
<para>
Some ClibPDF examples are subject to the ClibPDF license, which is included in the PDF chapter of this tutorial.
</para>
</sect2>
</sect1>
</chapter>
<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day. This section presents these things in alphabetical order, for ease of reference.
</para>

<sect1>
<title>Terminology</title>
<para>	
We need to get some terminology out of the way before we can discuss much. Images are made up of pixels. In black and white imaging, the pixel has one of two values -- 0 or 1. This can be represented in a single bit. For grayscale and color images however, the pixel needs to be able to store a much greater range of values -- if a pixel was to have 255 levels of gray, then we would need 8 bits to store that pixel. Each of these values is called a sample. TIFF expresses the size of the value in a tag called TIFFTAG_BITSPERSAMPLE. This will be 1 for black and white, and some larger number for grayscale.
</para>

<para>
For color images, we need to store even more information. For each pixel we will need to store a red, green, and blue value. Each of these values are stored in a separate 'sample'. Therefore, we will need to define TIFFTAG_SAMPLESPERPIXEL -- this will be 1 for black and white or grayscale, but will normally be 3 for color images. We also need to define the size of each sample, so you'll still need to set a value for TIFFTAG_BITSPERSAMPLE.
</para>
</sect1>

<sect1><title>Anti-aliasing</title>
<figure>
<title>decribe</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect1>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>
</chapter>
<chapter id="chap-imagetheory"><title>Imaging theory</title>
<sect1><title>Theory of color and grayscale storage</title>
<para>
The first thing that we need to understand to be able to support color and grayscale images is the format of the image data within memory. There are two main representations for color and grayscale images. I'll explain these by describing grayscale, and then extend it to color.
</para>

<sect2><title>Direct storage of pixel data</title>
<para>
If you think back to the way pixel information was stored in the black and white images from the previous article, the information was just in the strips. You can also do this with grayscale and color images. This representation of image data is quite inefficient, because for the scenario when the image has a solid background (for example), there are many pixels with the same value. If the pixel data is stored in the strips, then this value will waste a large amount of space.
</para>

<para>
Thankfully, there is a more efficient way to store image data. Imagine a simple four color 24 bit per pixel image. If we build a lookup table of the four color values (the 24 bit values which represent those colors), then we just need to store the relevant entry number of the color in the image strip itself. This can be done in only two bits, instead of the full 24. The maths looks something like this:
</para>

<para>
A 24 bit color image which is 1,000 by 1,000 pixels will take 24 million bits to store. The same image, if it was a four color image, would take 4,000,000 bits for the strip data, and 98 bits for the color table. Neither of these numbers includes header and footer information for the file format, and the numbers are for uncompressed bitmaps. The advantages of the lookup table should be obvious. There is a name for this style of lookup table, it is called a <emphasis>palette</emphasis> -- probably because of those things painters carry around.
</para>

<para>
This concept works for grayscale images as well. The only difference is that the colors in the palette are not just shades of gray.
</para>
</sect2>
</sect1>
</chapter>
<chapter id="chap-tiff"><title>TIFF</title>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>

<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>
</sect1>

<sect1><title>Installation</title>
<para>
The source for libtiff can be downloaded from http://www.libtiff.org/ -- the current version of the library being version 3.5.7 at the time of writing. This version can be downloaded from ftp://ftp.remotesensing.org/pub/libtiff, look for the files named either tiff-v3.5.7.tar.gz or tiff-v3.5.7.zip.
</para>

<sect2><title>Unix</title>
<para>
Once you have downloaded the tarball for the library as described above, then you need to follow the steps below to install libtiff
  <footnote><para>Please note that there are binary packages for libtiff for most operating systems, so you might be best off installing one of those.</para></footnote>.

<orderedlist>
<listitem><para>tar xvzf tiff-v3.5.7.tar.gz</para></listitem>
<listitem><para>cd tiff-v3.5.7</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</orderedlist>
</para>

<para>
Not too hard at all...
</para>
</sect2>

<sect2><title>win32</title>
<para>
<figure>
<title>windows_install_details</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<para>
For the Visual Studio challenged, there is a precompiled version of libtiff for win32 available from http://www.stillhq.com. 
<figure>
<title>make it so</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>
</sect1>


<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>

<sect2><title>File header</title>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory</title>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory Entries</title>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
These entries have a type associated with them, possible types are:
</para>

<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>

<para>
TIFF version 6 added the following fields:
</para>

<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>
</sect2>

<sect2><title>Possible field entries</title>
<para>
Discussing the many different possible field entries is out of the scope of this document. Refer to tiff.h and the TIFF specification for more information.
</para>
</sect2>

<sect2><title>So where's the image data?</title>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:

<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</para>

<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	
<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>
</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>
	
<sect2><title>Infrastructure for writing</title>
<para>
It is traditional for bitmaps to be represented inside your code with an array of chars. This is because on most operating systems, a char maps well to one byte. In the block of code below, we will setup libtiff, and create a simple buffer which contains an image which we can then write out to disc.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int
main (int argc, char *argv[])
{
  char buffer[32 * 9];
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-infrastructure.c</emphasis></para>

<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  // Define an image -- this is 32 pixels by 9 pixels
  char buffer[25 * 144] = { ...boring hex omitted... };

  TIFF *image;

  // Open the TIFF file
  if((image = TIFFOpen("output.tif", "w")) == NULL){
    printf("Could not open output.tif for writing\n");
    exit(42);
  }

  // We need to set some values for basic tags before we can add any data
  TIFFSetField(image, TIFFTAG_IMAGEWIDTH, 25 * 8);
  TIFFSetField(image, TIFFTAG_IMAGELENGTH, 144);
  TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 1);
  TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);
  TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 144);

  TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
  TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);
  TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
  TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);

  TIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
  
  // Write the information to the file
  TIFFWriteEncodedStrip(image, 0, buffer, 25 * 144);

  // Close the file
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-nohex.c</emphasis></para>

<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>

<sidebar>
<title>Problems with xview</title>
<para>
Xview is part of the xloadimage package written by Jim Frost, which comes with X windows.
</para>

<para>
It's a good example of how hard it can be to handle TIFF images well. If you have trouble viewing the output of the sample code, then try using some other program, like the GIMP.
</para>
</sidebar>

<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>

<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>

<sidebar>
<title>More information about the libtiff function calls</title>
<para>
If you need more information about any of the libtiff function calls mentioned in this chapter, then checkout the extensive man pages which come with the library. Remember that case is important with man pages, so you need to get the case in the function names right -- it's TIFFOpen, not tiffopen.
</para>
</sidebar>

<figure>
<title>The Sydney Harbor Bridge, by Michael Still</title>
<graphic format="EPS" fileref="tiff-figure1.eps">
</figure>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>

<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>

<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>

<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<figure>
<title>The Sydney Harbor Bridge, in strips</title>
<graphic format="EPS" fileref="tiff-figure2.eps">
</figure>

<figure>
<title>The Sydney Harbor Bridge, in tiles</title>
<graphic format="EPS" fileref="tiff-figure3.eps">
</figure>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>

<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>

<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (TIFFTAG_MINISBLACK), whilst you might find black being 1 (TIFFTAG_MINISWHITE) more convenient. TIFF allows both, so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in MINISWHITE, so we will convert images which are in MINISBLACK.
</para>

<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint16 photo, bps, spp, fillorder;
  uint32 width;
  tsize_t stripSize;
  unsigned long imageOffset, result;
  int stripMax, stripCount;
  char *buffer, tempbyte;
  unsigned long bufferSize, count;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Check that it is of a type that we support
  if((TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &amp;bps) == 0) || (bps != 1)){
    fprintf(stderr, "Either undefined or unsupported number of bits per sample\n");
    exit(42);
  }

  if((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &amp;spp) == 0) || (spp != 1)){
    fprintf(stderr, "Either undefined or unsupported number of samples per pixel\n");
    exit(42);
  }

  // Read in the possibly multile strips
  stripSize = TIFFStripSize (image);
  stripMax = TIFFNumberOfStrips (image);
  imageOffset = 0;
  
  bufferSize = TIFFNumberOfStrips (image) * stripSize;
  if((buffer = (char *) malloc(bufferSize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory for the uncompressed image\n");
    exit(42);
  }
  
  for (stripCount = 0; stripCount &lt; stripMax; stripCount++){
    if((result = TIFFReadEncodedStrip (image, stripCount,
				      buffer + imageOffset,
				      stripSize)) == -1){
      fprintf(stderr, "Read error on input strip number %d\n", stripCount);
      exit(42);
    }

    imageOffset += result;
  }

  // Deal with photometric interpretations
  if(TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &amp;photo) == 0){
    fprintf(stderr, "Image has an undefined photometric interpretation\n");
    exit(42);
  }
  
  if(photo != PHOTOMETRIC_MINISWHITE){
    // Flip bits
    printf("Fixing the photometric interpretation\n");

    for(count = 0; count &lt; bufferSize; count++)
      buffer[count] = ~buffer[count];
  }

  // Deal with fillorder
  if(TIFFGetField(image, TIFFTAG_FILLORDER, &amp;fillorder) == 0){
    fprintf(stderr, "Image has an undefined fillorder\n");
    exit(42);
  }
  
  if(fillorder != FILLORDER_MSB2LSB){
    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA
    printf("Fixing the fillorder\n");

    for(count = 0; count &lt; bufferSize; count++){
      tempbyte = 0;
      if(buffer[count] &amp; 128) tempbyte += 1;
      if(buffer[count] &amp; 64) tempbyte += 2;
      if(buffer[count] &amp; 32) tempbyte += 4;
      if(buffer[count] &amp; 16) tempbyte += 8;
      if(buffer[count] &amp; 8) tempbyte += 16;
      if(buffer[count] &amp; 4) tempbyte += 32;
      if(buffer[count] &amp; 2) tempbyte += 64;
      if(buffer[count] &amp; 1) tempbyte += 128;
      buffer[count] = tempbyte;
    }
  }
     
  // Do whatever it is we do with the buffer -- we dump it in hex
  if(TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width) == 0){
    fprintf(stderr, "Image does not define its width\n");
    exit(42);
  }
  
  for(count = 0; count &lt; bufferSize; count++){
    printf("%02x", (unsigned char) buffer[count]);
    if((count + 1) % (width / 8) == 0) printf("\n");
    else printf(" ");
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-read/read.c</emphasis></para>

<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>
</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>
</para>

<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>TIFFTAG</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.</para>

<para>Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.</para>

<figure>
<title>The picture before we compressed it</title>
<graphic format="EPS" fileref="tiff-figure4.eps">
</figure>

<figure>
<title>The sample text before we compressed it</title>
<graphic format="EPS" fileref="tiff-figure5.eps">
</figure>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<figure>
<title>The picture after it has been recompressed 200 times</title>
<graphic format="EPS" fileref="tiff-figure6.eps">
</figure>

<figure>
<title>The text after it has been recompressed 200 times</title>
<graphic format="EPS" fileref="tiff-figure7.eps">
</figure>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>
</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>

<programlisting>
#include &lt;tiffio.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]){
  TIFF *output;
  uint32 width, height;
  char *raster;

  // Open the output image
  if((output = TIFFOpen("output.tif", "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // We need to know the width and the height before we can malloc
  width = 42;
  height = 42;

  if((raster = (char *) malloc(sizeof(char) * width * height * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Magical stuff for creating the image
  // ...

  // Write the tiff tags to the file
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster, width * height * 3) == 0){
    fprintf(stderr, "Could not write image\n");
    exit(42);
  }

  TIFFClose(output);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-write/write.c</emphasis></para>

<para>You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.</para>

<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>
</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>
</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>
</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>

<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>

<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  // Here I fix the reversal of the image (vertically) and show you how to get the color values from each pixel
  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      // Red = TIFFGetR(raster[e * width + c]);
      // Green = TIFFGetG(raster[e * width + c]);
      // Blue = TIFFGetB(raster[e * width + c]);
    }
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-read/read.c</emphasis></para>
</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>

<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>

<sidebar><title>An expanded example</title>
<para>If you need more information about hooking the file input and output functions within libtiff than this chapter allows, then have a look at the images.c file in Panda, my PDF library. The web pages for Panda can be found at http://www.stillhq.com
  <footnote><para>http://www.stillhq.com/cgi-bin/getpage?area=panda&lt;page=index.htm to be exact.</para></footnote>
.
</para>
</sidebar>

<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>

<figure>
<title>make_this_example_better</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
<programlisting>
// Please note that this code wont compile, and is intended to only show you 
// the sturcture of TIFFClient* calls

#include &lt;tiffio.h&gt;
#include &lt;pthread.h&gt;

// Function prototypes
static tsize_t libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size);
static tsize_t libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size);
static toff_t libtiffDummySeekProc (thandle_t fd, toff_t off, int i);
static int libtiffDummyCloseProc (thandle_t fd);

// We need globals because of the callbacks (they don't allow us to pass state)
char *globalImageBuffer;
unsigned long globalImageBufferOffset;

// This mutex keeps the globals safe by ensuring only one user at a time
pthread_mutex_t convMutex = PTHREAD_MUTEX_INITIALIZER;

TIFF *conv;

// Lock the mutex
pthread_mutex_lock (&amp;convMutex);

globalImageBuffer = NULL;
globalImageBufferOffset = 0;

// Open the dummy document (which actually only exists in memory)
conv = TIFFClientOpen ("dummy", "w", (thandle_t) - 1, libtiffDummyReadProc,
            libtiffDummyWriteProc, libtiffDummySeekProc,
            libtiffDummyCloseProc, NULL, NULL, NULL);

// Setup the image as if it was any other tiff image here, including setting tags


// Actually do the client open
TIFFWriteEncodedStrip (conv, 0, stripBuffer, imageOffset);

// Unlock the mutex
pthread_mutex_unlock (&amp;convMutex);

//...

/////////////////// Callbacks to libtiff

static tsize_t
libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // Return the amount of data read, which we will always set as 0 because
  // we only need to be able to write to these in-memory tiffs
  return 0;
}

static tsize_t
libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // libtiff will try to write an 8 byte header into the tiff file. We need
  // to ignore this because PDF does not use it...
  if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'I') &amp;&amp; (((char *) buf)[1] == 'I')
     &amp;&amp; (((char *) buf)[2] == 42))
    {
    // Skip the header -- little endian
    }
  else if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'M') &amp;&amp;
       (((char *) buf)[1] == 'M') &amp;&amp;y (((char *) buf)[2] == 42))
    {
    // Skip the header -- big endian
    }
  else
    {
    // Have we done anything yet?
    if (globalImageBuffer == NULL)
    if((globalImageBuffer = (char *) malloc (size * sizeof (char))) == NULL)
        {
          fprintf(stderr, "Memory allocation error\n");
          exit(42);
        }

    // Otherwise, we need to grow the memory buffer
    else
    {
      if ((globalImageBuffer = (char *) realloc (globalImageBuffer,
                             (size * sizeof (char)) +
                             globalImageBufferOffset)) == NULL)
        fprintf(stderr, "Could not grow the tiff conversion memory buffer\n");
            exit(42);
    }

    // Now move the image data into the buffer
    memcpy (globalImageBuffer + globalImageBufferOffset, buf, size);
    globalImageBufferOffset += size;
    }

  return (size);
}

static toff_t
libtiffDummySeekProc (thandle_t fd, toff_t off, int i)
{
  // This appears to return the location that it went to
  return off;
}

static int
libtiffDummyCloseProc (thandle_t fd)
{
  // Return a zero meaning all is well
  return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-client/client.c</emphasis></para>
</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>

<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>

<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff, optchar;
  int count = 4, i;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:c:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'c':
	  count = atoi(optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file, we do this c times
  for(i = 0; i &lt; count; i++){
    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    

    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    // Flush this subfile and move onto the next one
    if(TIFFWriteDirectory(output) == 0){
      fprintf(stderr, "Error writing subfile %d\n", i);
      exit(44);
    }
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/create.c</emphasis></para>

<figure>
<title>Four pictures of my son Andrew</title>
<graphic format="EPS" fileref="tiff-figure8.eps">
</figure>
<figure>
<title>quality_of_picture</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
</para>

<figure>
<title>convert_will_create_multiple_files</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
<figure>
<title>more!</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, 
    outputFilenameActual[200], *raster, *roff, optchar;
  int count;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Check the output parent name
  if(outputFilename == NULL){
    fprintf(stderr, \
	    "You need to specify a name for the series of output files\n");
    usage(argv[0], 42);
  }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Grab a sub file from the input image and move it to a separate file. We do
  // this forever (until we break down below)...
  for(count = 0;; count++){
    // Find the width and height of the input
    TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
    TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

    ///////////////////////////////////////////////////////////////////////////
    // Grab some memory
    if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == 
	NULL)
      {
	fprintf (stderr, 
		 "Could not allocate enough memory for input raster\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Read the input into the memory buffer
    // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
    stripSize = TIFFStripSize (input);
    roff = raster;
    for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
	 stripNumber++)
      {
	roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
      }
    
    ///////////////////////////////////////////////////////////////////////////
    // Open the output TIFF
    snprintf(outputFilenameActual, 200, "%s-%d.tif", outputFilename, count);
    if ((output = TIFFOpen (outputFilenameActual, "w")) == NULL)
      {
	fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
	usage (argv[0], 42);
      }

    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    
    // Copy the subfile to a output location
    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Flush this subfile and move onto the next one
    if(TIFFReadDirectory(input) == 0){
      printf(" No more subfiles");
      break;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Doing correct cleanup with a loop like this is important...
    free(raster);
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/read.c</emphasis></para>
<figure>
<title>This doesn't work at the moment</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect1>


<sect1><title>Man pages</title>
<para>
...
</para>

<sect2><title>tiff2bw</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2bw - convert a color
<emphasis>TIFF</emphasis>
image to greyscale
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2bw</command>
[
options
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiff2bw</emphasis>
converts an
<emphasis>RGB</emphasis>
or Palette color
<emphasis>TIFF</emphasis>
image to a greyscale image by
combining percentages of the red, green, and blue channels.
By default, output samples are created by taking
28% of the red channel, 59% of the green channel, and 11% of
the blue channel.
To alter these percentages, the
and
options may be used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify a compression scheme to use when writing image data:
<command>"-c none"</command>
for no compression,
<command>"-c packbits"</command>
for the PackBits compression algorithm,
<command>"-c zip</command>
for the Deflate compression algorithm,
<command>"-c g3</command>
for the CCITT Group 3 compression algorithm,
<command>"-c g4</command>
for the CCITT Group 4 compression algorithm,
and
<command>"-c lzw"</command>
for Lempel-Ziv &amp; Welch (the default).
</para>
</listitem>
<listitem>

<para><command>-r</command>
Write data with a specified number of rows per strip;
by default the number of rows/strip is selected so that each strip
is approximately 8 kilobytes.
</para>
</listitem>
<listitem>

<para><command>-R</command>
Specify the percentage of the red channel to use (default 28).
</para>
</listitem>
<listitem>

<para><command>-G</command>
Specify the percentage of the green channel to use (default 59).
</para>
</listitem>
<listitem>

<para><command>-B</command>
Specify the percentage of the blue channel to use (default 11).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>

<sect2><title>tiff2ps</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2ps - convert a
<emphasis>TIFF</emphasis>
image to \*(Ps\(tm
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2ps</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiff2ps</emphasis>
reads
<emphasis>TIFF</emphasis>
images and writes \*(Ps or Encapsulated \*(Ps (EPS)
on the standard output.
By default,
<emphasis>tiff2ps</emphasis>
writes Encapsulated \*(Ps for the first image in the specified
<emphasis>TIFF</emphasis>
image file.
</para>

<para>By default,
<emphasis>tiff2ps</emphasis>
will generate \*(Ps that fills a printed area specified
by the
<emphasis>TIFF</emphasis>
tags in the input file.
If the file does not contain
<emphasis>XResolution</emphasis>
or
<emphasis>YResolution</emphasis>
tags, then the printed area is set according to the image dimensions.
The
<command>-w</command>
and
<command>-h</command>
options (see below)
can be used to set the dimensions of the printed area in inches;
overriding any relevant
<emphasis>TIFF</emphasis>
tags.
</para>

<para>The \*(Ps generated for
<emphasis>RGB,</emphasis>
palette, and
<emphasis>CMYK</emphasis>
images uses the
<emphasis>colorimage</emphasis>
operator.
The \*(Ps generated for
greyscale and bilevel images
uses the
<emphasis>image</emphasis>
operator.
When the
<emphasis>colorimage</emphasis>
operator is used, \*(Ps code to emulate this operator
on older \*(Ps printers is also generated.
Note that this emulation code can be very slow.
</para>

<para>Color images with associated alpha data are composited over
a white background.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-1</command>
Generate \*(Ps Level I (the default).
</para>
</listitem>
<listitem>

<para><command>-2</command>
Generate \*(Ps Level II.
</para>
</listitem>
<listitem>

<para><command>-a</command>
Generate output for all IFDs (pages) in the input file.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the specified directory number.
(NB: directories are numbered starting at zero.)
This option is useful for selecting individual pages in a
multi-page (e.g. facsimile) file.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Force the generation of Encapsulated \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-h</command>
Specify the vertical size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the
<emphasis>IFD</emphasis>
at the specified file offset.
This option is useful for selecting thumbnail images and the
like which are hidden using the SubIFD tag.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Force the generation of (non-Encapsulated) \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Generate output for a single IFD (page) in the input file.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the horizontal size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-z</command>
When generating \*(Ps Level II, data is scaled so that it does not
image into the
<emphasis>deadzone</emphasis>
on a page (the outer margin that the printing device is unable to mark).
This option suppresses this behaviour.
When \*(Ps Level I is generated, data is imaged to the entire printed
page and this option has no affect.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following generates \*(Ps Level II for all pages of a facsimile:
tiff2ps -a2 fax.tif | lpr
Note also that if you have version 2.6.1 or newer of Ghostscript then you
can efficiently preview facsimile generated with the above command.
</para>

<para>To generate Encapsulated \*(Ps for a the image at directory 2
of an image use:
tiff2ps -d 1 foo.tif
(notice that directories are numbered starting at zero.)
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Because \*(Ps does not support the notion of a colormap,
8-bit palette images produce 24-bit \*(Ps images.
This conversion results in output that is six times
bigger than the original image and which takes a long time
to send to a printer over a serial line.
Matters are even worse for 4-, 2-, and 1-bit palette images.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Does not handle tiled images when generating PS Level I output.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>tiffsv (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffcmp</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcmp - compare two
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcmp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"file1.tif file2.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffcmp</emphasis>
compares the tags and data in two files created according
to the Tagged Image File Format, Revision 6.0.
The schemes used for compressing data in each file
are immaterial when data are compared-data are compared on
a scanline-by-scanline basis after decompression.
Most directory tags are checked; notable exceptions are:
<emphasis>GrayResponseCurve ,</emphasis>
<emphasis>ColorResponseCurve ,</emphasis>
and
<emphasis>ColorMap</emphasis>
tags.
Data will not be compared if any of the
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
or
<emphasis>ImageWidth</emphasis>
values are not equal.
By default,
<emphasis>tiffcmp</emphasis>
will terminate if it encounters any difference.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-l</command>
List each byte of image data that differs between the files.
</para>
</listitem>
<listitem>

<para><command>-t</command>
Ignore any differences in directory tags.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Tags that are not recognized by the library are not
compared; they may also generate spurious diagnostics.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffcmp</command> shows the differences in tags between images, for example, when I compare the input and output images from the pixel example in this chapter:
</para>

<programlisting>
[mikal@localhost tiff-pixels]$ tiffcmp input.tif output.tif 
ImageWidth: 256 520
[mikal@localhost tiff-pixels]$ 
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffcp</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcp - copy (and possibly convert) a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"src1.tif ... srcN.tif dst.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffcp</emphasis>
combines one or more files created according
to the Tag Image File Format, Revision 6.0
into a single
<emphasis>TIFF</emphasis>
file.
Because the output file may be compressed using a different
algorithm than the input files,
<emphasis>tiffcp</emphasis>
is most often used to convert between different compression
schemes.
</para>

<para>By default,
<emphasis>tiffcp</emphasis>
will copy all the understood tags in a
<emphasis>TIFF</emphasis>
directory of an input
file to the associated directory in the output file.
</para>

<para><emphasis>tiffcp</emphasis>
can be used to reorganize the storage characteristics of data
in a file, but it is explicitly intended to not alter or convert
the image data content in any way.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-B</command>
Force output to be written with Big-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Suppress the use of ``strip chopping'' when reading images
that have a single strip/tile of uncompressed data.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffcp</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-l</command>
Specify the length of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-L</command>
Force output to be written with Little-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-M</command>
Suppress the use of memory-mapped files when reading images.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data
that has one 8-bit sample per pixel.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same planar configuration as
the original.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffcp</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Force the output file to be written with data organized in strips
(rather than tiles).
</para>
</listitem>
<listitem>

<para><command>-t</command>
Force the output file to be written wtih data organized in tiles
(rather than strips).
options can be used to force the resultant image to be written
as strips or tiles of data, respectively.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the width of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following concatenates two files and writes the result using
<emphasis>LZW</emphasis>
encoding:
tiffcp -c lzw a.tif b.tif result.tif
</para>

<para>To convert a G3 1d-encoded
<emphasis>TIFF</emphasis>
to a single strip of G4-encoded data the following might be used:
tiffcp -c g4 -r 10000 g3.tif g4.tif
(1000 is just a number that is larger than the number of rows in
the source file.)
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiffsplit (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffdither</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdither - convert a greyscale image to bilevel using dithering
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdither</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdither</emphasis>
converts a single channel 8-bit greyscale image to a bilevel image
using Floyd-Steinberg error propagation with threholding.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffdither</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffdither</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB ,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-t</command>
Set the threshold value for dithering.
By default the threshold value is 128.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>The dither algorithm is taken from the
<emphasis>tiffmedian (1)</emphasis>
program (written by Paul Heckbert).
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>fax2tiff (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<figure>
<title>The gray scale input image</title>
<graphic format="EPS" fileref="tiff-figure9.eps">
</figure>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<figure>
<title>The dithered output image</title>
<graphic format="EPS" fileref="tiff-figure10.eps">
</figure>
</sect3>
</sect2>


<sect2><title>tiffdump</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdump - print verbatim information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdump</command>
[
<emphasis>options</emphasis>
]
<emphasis>"name ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdump</emphasis>
displays directory information from files created according
to the Tag Image File Format, Revision 6.0.
The header of each
<emphasis>TIFF</emphasis>
file (magic number, version, and first directory offset)
is displayed, followed by the tag contents of each directory in the file.
For each tag, the name, datatype, count, and value(s) is displayed.
When the symbolic name for a tag or datatype is known, the symbolic
name is displayed followed by it's numeric (decimal) value.
Tag values are displayed enclosed in ``&lt;&gt;'' characters immediately
preceded by the value of the count field.
For example, an
<emphasis>ImageWidth</emphasis>
tag might be displayed as ``ImageWidth (256) SHORT (3) 1&lt;800&gt;''.
</para>

<para><emphasis>tiffdump</emphasis>
is particularly useful for investigating the contents of
<emphasis>TIFF</emphasis>
files that
<emphasis>libtiff</emphasis>
does not understand.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-h</command>
Force numeric data to be printed in hexadecimal rather than the
default decimal.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Dump the contents of the
<emphasis>IFD</emphasis>
at the a particular file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffgt</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffgt - display an image stored in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffgt</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffgt</emphasis>
displays one or more images stored using the
Tag Image File Format, Revision 6.0.
Each image is placed in a fixed size window that the
user must position on the display (unless configured
otherwise through X defaults).
If the display has fewer than 24 bitplanes, or if the
image does not warrant full color, then
<emphasis>RGB</emphasis>
color values are mapped to the closest values that exist in
the colormap (this is done using the
<emphasis>rgbi</emphasis>
routine found in the graphics utility library
</para>

<para><emphasis>tiffgt</emphasis>
correctly handles files with any of the following characteristics:
BitsPerSample	1, 2, 4, 8, 16
SamplesPerPixel	1, 3, 4 (the 4th sample is ignored)
PhotometricInterpretation	0 (min-is-white), 1 (min-is-black), 2 (RGB), 3 (palette), 6 (YCbCr)
PlanarConfiguration	1 (contiguous), 2 (separate)
Orientation	1 (top-left), 4 (bottom-left)
Data may be organized as strips or tiles and may be
compressed with any of the compression algorithms supported
by the
<emphasis>libtiff (3)</emphasis>
library.
</para>

<para>For palette images (\c
<emphasis>PhotomatricInterpretation =3),</emphasis>
<emphasis>tiffgt</emphasis>
inspects the colormap values and assumes either 16-bit
or 8-bit values according to the maximum value.
That is, if no colormap entry greater than 255 is found,
<emphasis>tiffgt</emphasis>
assumes the colormap has only 8-bit values; otherwise
it assumes 16-bit values.
This inspection is done to handle old images written by
previous (incorrect) versions of
<emphasis>libtiff .</emphasis>
</para>

<para><emphasis>tiffgt</emphasis>
can be used to display multiple images one-at-a-time.
The left mouse button switches the display to the first image in the
<emphasis>next</emphasis>
file in the list of files specified on the command line.
The right mouse button switches to the first image in the
<emphasis>previous</emphasis>
file in the list.
The middle mouse button causes the first image in the first file
specified on the command line to be displayed.
In addition the following keyboard commands are recognized:
</para>
<itemizedlist>
<listitem>

<para><command>b</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsBlack in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>l</command>
Use a
<emphasis>FillOrder</emphasis>
of lsb-to-msb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>m</command>
Use a
<emphasis>FillOrder</emphasis>
of msb-tolmsb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>c</command>
Use a colormap visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>r</command>
Use a true color (24-bit RGB) visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>w</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsWhite in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>W</command>
Toggle (enable/disable) display of warning messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>E</command>
Toggle (enable/disable) display of error messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>z</command>
Reset all parameters to their default settings (\c
<emphasis>FillOrder ,</emphasis>
<emphasis>PhotometricInterpretation ,</emphasis>
handling of warnings and errors).
</para>
</listitem>
<listitem>

<para><command>PageUp</command>
Display the previous image in the current file or the last
image in the previous file.
</para>
</listitem>
<listitem>

<para><command>PageDown</command>
Display the next image in the current file or the first image
in the next file.
</para>
</listitem>
<listitem>

<para><command>Home</command>
Display the first image in the current file.
</para>
</listitem>
<listitem>

<para><command>End</command>
Display the last image in the current file (unimplemented).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Force image display in a colormap window.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Specify an image to display by directory number.
By default the first image in the file is displayed.
Directories are numbered starting at zero.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Enable reporting of error messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
silently ignores images that cannot be read.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Force
<emphasis>tiffgt</emphasis>
to run as a foreground process.
By default
<emphasis>tiffgt</emphasis>
will place itself in the background once it has opened the
requested image file.
</para>
</listitem>
<listitem>

<para><command>-l</command>
Force the presumed bit ordering to be
<emphasis>LSB</emphasis>
to
<emphasis>MSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-m</command>
Force the presumed bit ordering to be
<emphasis>MSB</emphasis>
to
<emphasis>LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-o</command>
Specify an image to display by directory offset.
By default the first image in the file is displayed.
Directories offsets may be specified using C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Override the value of the
<emphasis>PhotometricInterpretation</emphasis>
tag; the parameter may be one of:
<emphasis>miniswhite ,</emphasis>
<emphasis>minisblack ,</emphasis>
<emphasis>rgb ,</emphasis>
<emphasis>palette ,</emphasis>
<emphasis>mask ,</emphasis>
<emphasis>separated ,</emphasis>
<emphasis>ycbcr ,</emphasis>
and
<emphasis>cielab .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-r</command>
Force image display in a full color window.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Stop on the first read error.
By default all errors in the input data are ignored and
<emphasis>tiffgt</emphasis>
does it's best to display as much of an image as possible.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Enable reporting of warning messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
ignores warning messages generated when reading an image.
</para>
</listitem>
<listitem>

<para><command>-v</command>
Place information in the title bar describing
what type of window (full color or colormap) is being
used, the name of the input file, and the directory
index of the image (if non-zero).
By default, the window type is not shown in the title bar.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Images wider and taller than the display are silently truncated to avoid
crashing old versions of the window manager.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffdump (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffinfo</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffinfo - print information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffinfo</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffinfo</emphasis>
displays information about files created according
to the Tag Image File Format, Revision 6.0.
By default, the contents of each
<emphasis>TIFF</emphasis>
directory in each file
is displayed, with the value of each tag shown symbolically
(where sensible).
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Display the colormap and color/gray response curves, if present.
</para>
</listitem>
<listitem>

<para><command>-D</command>
In addition to displaying the directory tags,
read and decompress all the data in each image (but not display it).
</para>
</listitem>
<listitem>

<para><command>-d</command>
In addition to displaying the directory tags,
print each byte of decompressed data in hexadecimal.
</para>
</listitem>
<listitem>

<para><command>-j</command>
Display any \s-2JPEG\s0-related tags that are present.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory according to the specified file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Display the offsets and byte counts for each data strip in a directory.
</para>
</listitem>
<listitem>

<para><command>-z</command>
Enable strip chopping when reading image data.
</para>
</listitem>
<listitem>

<para><command>-#</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to
<emphasis># .</emphasis>
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffmedian</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffmedian - apply the median cut algorithm to data in a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffmedian</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffmedian</emphasis>
applys the median cut algorithm to an
<emphasis>RGB</emphasis>
image in
<emphasis>input.tif</emphasis>
to generate a palette image that is written to
<emphasis>output.tif .</emphasis>
The generated colormap has, by default, 256 entries.
The image data is quantized by mapping each
pixel to the closest color values in the colormap.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
and
<command>zip</command>
for Deflate compression.
By default
<emphasis>tiffmedian</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Specify the number of entries to use in the generated colormap.
By default all 256 entries/colors are used.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Apply Floyd-Steinberg dithering before selecting a colormap entry.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffmedian</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>This program is derived from Paul Heckbert's
<emphasis>median</emphasis>
program.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>

<para>"Color Image Quantization for Frame Buffer Display", Paul
Heckbert, SIGGRAPH proceedings, 1982, pp. 297-307.
</para>
</sect3>

<sect3><title>Sample output</title>
<figure>
<title>Sample output</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect3>
</sect2>


<sect2><title>tiffsplit</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1992-1997 Sam Leffler -->
<!--  Copyright (c) 1992-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsplit - split a multi-image
<emphasis>TIFF</emphasis>
into single-image
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsplit</command>
<emphasis>src.tif</emphasis>
[
<emphasis>prefix</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsplit</emphasis>
takes a multi-directory (page)
<emphasis>TIFF</emphasis>
file and creates one or more single-directory (page)
<emphasis>TIFF</emphasis>
files from it.
The output files are given names created by concatenating
a prefix, a lexically ordered
suffix in the range [<emphasis>aa</emphasis>-<emphasis>zz</emphasis>], the suffix
<emphasis>.tif </emphasis>
(e.g.
<emphasis>xaa.tif ,</emphasis>
<emphasis>xab.tif ,</emphasis>
\...
<emphasis>xzz.tif ).</emphasis>
If a prefix is not specified on the command line,
the default prefix of
<emphasis>x</emphasis>
is used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para>None.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Only a select set of ``known tags'' is copied when spliting.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffcp (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
<sect3><title>Sample output</title>
<figure>
<title>Sample output</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect3>
</sect2>


<sect2><title>tiffsv</title>
<para>
...
</para>

<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.36 2002-07-11 04:33:40 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsv - save an image from the framebuffer in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsv</command>
[
<emphasis>options</emphasis>
]
<emphasis>output.tif</emphasis>
[
<emphasis>"x1 x2 y1 y2"</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsv</emphasis>
saves all or part of the framebuffer in a file using the
Tag Image File Format, Revision 6.0.
By default, the image is saved with data samples packed (\c
<emphasis>PlanarConfiguration =1),</emphasis>
compressed with the Lempel-Ziv &amp; Welch algorithm (\c
<emphasis>Compression =5),</emphasis>
and with each strip no more than 8 kilobytes.
These characteristics can be overriden, or explicitly specified
with the options described below.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-b</command>
Save the image as a greyscale image
as if it were processed by
<emphasis>tiff2bw (1).</emphasis>
This option is included for compatibility with the standard
<emphasis>scrsave (6D)</emphasis>
program.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
and
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression (default).
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data.
By default,
<emphasis>tiffsv</emphasis>
will create a new file with the data samples packed contiguously.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffsv</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTE</title>

<para>Except for the use of
<emphasis>TIFF,</emphasis>
this program is equivalent to the standard
<emphasis>scrsave</emphasis>
program.
This means, for example, that you can use it in conjunction with
the standard
<emphasis>icut</emphasis>
program simply by creating a link called
<emphasis>scrsave ,</emphasis>
or by creating a shell script called
<emphasis>scrsave</emphasis>
that invokes
<emphasis>tiffgt</emphasis>
with the appropriate options.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>If data are saved compressed and in separate planes, then the
rows in each strip is silently set to one to avoid limitations
in the
<emphasis>libtiff (3)</emphasis>
library.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>scrsave (6D)</emphasis>
<emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffdump (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
<sect3><title>Sample output</title>
<figure>
<title>Sample output</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect3>
</sect2>

<sect2><title>tifftopnm</title>
<para>
...
</para>

<sect3><title>NAME</title>

<para>tifftopnm - convert a TIFF file into a portable anymap
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tifftopnm</command>
[
={alpha-filename,-}]  [
<command>--headerdump</command>
]
<emphasis>tiff-filename</emphasis>

</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Reads a TIFF file as input.
Produces a portable anymap as output.
The type of the output file depends on the input file - if it's
black &amp; white, generates a
<emphasis>pbm</emphasis>
file;
if it's grayscale, generates a
<emphasis>pgm</emphasis>
file; otherwise, a
<emphasis>ppm</emphasis>
file.  The program tells you which type it is writing.
</para>

<para>This program cannot read every possible TIFF file -- there are myriad
variations of the TIFF format.  However, it does understand monochrome
and gray scale, RGB, RGBA (red/green/blue with alpha channel), CMYK
(Cyan-Magenta-Yellow-Black ink color separation), and color palette
TIFF files.  An RGB file can have either single plane (interleaved)
color or multiple plane format.  The program reads 1-8 and 16
bit-per-sample input, the latter in either bigendian or littlendian
encoding.  Tiff directory information may also be either bigendian or
littendian.
</para>

<para>One reason this program isn't as general as TIFF programs often are is
that it does not use the TIFFRGBAImageGet() function of the TIFF
library to read TIFF files.  Rather, it uses the more primitive
TIFFReadScanLine() function and decodes it itself.
</para>

<para>There is no fundamental reason that this program could not read other
kinds of TIFF files; the existing limitations are mainly because no one
has asked for more.

The PNM output has the same maxval as the Tiff input, except that if
the Tiff input is colormapped (which implies a maxval of 65535) the
PNM output has a maxval of 255.  Though this may result in lost
information, such input images hardly ever actually have more color
resolution than a maxval of 255 provides and people often cannot deal
with PNM files that have maxval &gt; 255.  By contrast, a non-colormapped
Tiff image that doesn't need a maxval &gt; 255 doesn't
<emphasis>have</emphasis>
a maxval &gt; 255, so when we see a non-colormapped maxval &gt; 255, we take
it seriously and produce a matching output maxval.

The
<emphasis>tiff-filename</emphasis>
argument names the regular file that contains the Tiff image.  You
cannot use Standard Input or any other special file because the Tiff
library must be able to perform seeks on it.

</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>tifftopnm </command>
creates a PGM (portable graymap) file containing the alpha channel
values in the input image.  If the input image doesn't contain an
alpha channel, the
<emphasis>alpha-filename</emphasis>
file contains all zero (transparent) alpha values.  If you don't specify
<command>tifftopnm</command>
does not generate an alpha file, and if the input image has an alpha channel,
<command>tifftopnm</command>
simply discards it.

If you specify
<command>-</command>
as the filename,
<command>tifftopnm</command>
writes the alpha output to Standard Output and discards the image.

See
for one way to use the alpha output file.
</para>
</listitem>
<listitem>

<para><command>--headerdump</command>
Dump TIFF file information to stderr.  This information may be useful
in debugging TIFF file conversion problems.
</para>

<para>All options can be abbreviated to their shortest unique prefix.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para></para>
</sect3>
<sect3><title>AUTHOR</title>

<para>Derived by Jef Poskanzer from tif2ras.c, which is
Copyright (c) 1990 by Sun Microsystems, Inc.
Author: Patrick J. Naughton (naughton@wind.sun.com).
<!--  Permission to use, copy, modify, and distribute this software and its -->
<!--  documentation for any purpose and without fee is hereby granted, -->
<!--  provided that the above copyright notice appear in all copies and that -->
<!--  both that copyright notice and this permission notice appear in -->
<!--  supporting documentation. -->
<!--   -->
<!--  This file is provided AS IS with no warranties of any kind.  The author -->
<!--  shall have no liability with respect to the infringement of copyrights, -->
<!--  trade secrets or any patents by this file or any part thereof.  In no -->
<!--  event will the author be liable for any lost revenue or profits or -->
<!--  other special, indirect and consequential damages. -->
</para>
</sect3>

<sect3><title>Sample output</title>
<figure>
<title>Sample output</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect3>
</sect2>
</sect1>

<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2, xs = 0, ys = 0, xe = -1, ye = -1;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    *enlarged, *rout, optchar;
  int xrep, yrep;
  float m;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'x':
	  xs = atoi (optarg);
	  break;

	case 'y':
	  ys = atoi (optarg);
	  break;

	case 'w':
	  xe = xs + atoi (optarg);
	  break;

	case 'l':
	  ye = ys + atoi (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Make sure we have reasonable defaults
  if (xe == -1)
    xe = xs + 10;

  if (ye == -1)
    ye = ys + 10;

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  // Sanity check some of our arguements
  if (xe &gt; width)
    {
      fprintf (stderr,
	       "You choice of starting x position, or width, results in the enlargement falling off the edge of the input image\n");
      usage (argv[0], 43);
    }

  if (ye &gt; height)
    {
      fprintf (stderr,
	       "You choice of starting y position, or length, results in the enlargement falling off the end of the input image\n");
      usage (argv[0], 43);
    }

  printf ("Enlarging a %d by %d portion of the image\n", xe - xs, ye - ys);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  // todo: crap assumption about the data being 8 bps, 3 spp
  if ((enlarged = (char *) malloc (sizeof (char) * (xe - xs) * (ye - ys) * 3 *
				   121)) == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  if ((rout = (char *) malloc (sizeof (char) * (width + 200) * height * 3))
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for output raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width + 200);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Actually do the enlargement of the portion of the image specified
  offset = offset2 = 0;
  for (y = ys; y &lt; ye; y++)
    {
      for (yrep = 0; yrep &lt; 10; yrep++)
	{
	  for (x = xs; x &lt; xe; x++)
	    {
	      offset = (x + (y * width)) * 3;
	      for (xrep = 0; xrep &lt; 10; xrep++)
		{
		  memcpy (enlarged + offset2, raster + offset, 3);
		  offset2 += 3;
		}

	      // The white border to the left of the pixel
	      memset (enlarged + offset2, 255, 3);
	      offset2 += 3;
	    }
	}

      // The white line at the bottom of these pixels
      memset (enlarged + offset2, 255, (ye - ys) * 3 * 11);
      offset2 += (ye - ys) * 3 * 11;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Now we assemble the two parts of the image together into a big output
  // raster
  memset (rout, 255, sizeof (char) * (width + 200) * height * 3);

  // The original image
  offset = 0;
  offset2 = 0;
  for (y = 0; y &lt; height; y++)
    {
      memcpy (rout + offset2, raster + offset, width * 3);
      offset += width * 3;
      offset2 += (width + 200) * 3;
    }

  // Box the bit that was enlarged in the original image, can't use memset here
  // Top line
  offset = (((width + 200) * (ys - 1)) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Bottom line
  offset = (((width + 200) * ye) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Vertical lines
  offset = (((width + 200) * ys) + xs - 1) * 3;
  for (y = 0; y &lt; ye - ys + 1; y++)
    {
      rout[offset] = 255;
      rout[offset + 1] = 0;
      rout[offset + 2] = 0;

      rout[offset + ((ye - ys + 1) * 3)] = 255;
      rout[offset + ((ye - ys + 1) * 3) + 1] = 0;
      rout[offset + ((ye - ys + 1) * 3) + 2] = 0;

      offset += (width + 200) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Box the enlarged portion of the image

  /////////////////////////////////////////////////////////////////////////////
  // Draw the two diagonal lines between the original and the enlarged
  //    this bit is based on the premis that y = mx + b
  //    and m = (y2 - y1) / (x2 - x1) and that geometry hasn't significantly
  //    changed since my high school days
  //
  //    if we assume that the first point is the origin, then the maths is
  //    even easier
  // 
  //    which I think is probably a fairly safe set of assumptions at this
  //    stage...
  // todo
  //  printf("ye = %d, xe = %d\n", ye, xe);
  //  m = (ye - ys) / (xe - xs);
  //  for(x = 0; x &lt; (xe - xs); x++){
  //    y = m * x;
  //    
  //    printf("%d, %d (%f = %f)\n", x, y, m, ye / xe);
  //  }

  /////////////////////////////////////////////////////////////////////////////
  // Copy the enlarged portion across

  offset = 0;
  // todo: I'm too tired to understand the placement of this in maths land
  offset2 = (((((height / 2) - ((ye - ys) * 11 / 2)) *
	       (width + 200)) + width + 50) * 3);
  for (y = 0; y &lt; (ye - ys) * 11; y++)
    {
      memcpy (rout + offset2, enlarged + offset, (ye - ys) * 11 * 3);
      offset += (ye - ys) * 11 * 3;
      offset2 += (width + 200) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     (width + 200) * height * 3 * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (enlarged);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -x &lt;start x&gt; -y &lt;start y&gt; -w &lt;width&gt; -l &lt;length&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-pixels/pixel.c</emphasis></para>
</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>

<sect2><title>A broken algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.333 + 
		       (unsigned char) (raster[offset + 1]) * 0.333 + 
		       (unsigned char) (raster[offset + 2]) * 0.333);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-wrong.c</emphasis></para>

<para>
Which produces:
</para>

<figure>
<title>An average of the color values for each pixel</title>
<graphic format="EPS" fileref="grayscale-figure2.eps">
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.299 + 
		       (unsigned char) (raster[offset + 1]) * 0.587 + 
		       (unsigned char) (raster[offset + 2]) * 0.114);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-good.c</emphasis></para>

<para>
Which gives us:
</para>

<figure>
<title>A correct conversion to gray scale</title>
<graphic format="EPS" fileref="grayscale-figure3.eps">
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>

<sect1><title>Example: Repeated compression</title>
<para>
Earlier in this chapter I promised that I would include the code for the repeated compression loss example, so here it is. The example is made up of a simple (and quite ugly) shell script, and a c program to actually compress the images...
</para>

<programlisting>
#!/bin/bash

count=1
cp $1 $1-0.tif

while [ $count -lt 200 ]
do
  ./read $1-$(( $count -1 )).tif $1-$count.tif
  count=$(( $count + 1 ))
done
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.sh</emphasis></para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image, *output;
  uint16 photo, bps, spp, fillorder;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;
  char *raster2;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Open the output image
  if((output = TIFFOpen(argv[2], "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  if((raster2 = (char *) malloc(sizeof(char) * imagesize * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      raster2[d++] = TIFFGetR(raster[e * width + c]);
      raster2[d++] = TIFFGetG(raster[e * width + c]);
      raster2[d++] = TIFFGetB(raster[e * width + c]);
    }
  }

  // Recompress it straight away -- set the tags we require
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);
  TIFFSetField(output, TIFFTAG_JPEGQUALITY, 25);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster2, imagesize * 3) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  TIFFClose(output);
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.c</emphasis></para>
</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>
</sect1>


<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libtiff.org: The libtiff website is a good place to download the libtiff source. It is also quite likely there is a binary package for your chosen operating system.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: If all else fails, then the Adobe TIFF Specification can be useful.</para></listitem>

<listitem><para>http://gopher.std.com/homepages/jimf/xloadimage.html: The xloadimage web page might be of interest.</para></listitem>

<listitem><para>http://www.ee.cooper.edu/courses/course_pages/past_courses/EE458/TIFF/index.html: The Cooper Union for the Advancement of Science and Art has some notes from a previous course dealing with libtiff online.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/graphics/graphics.html: The Adobe Graphics technical notes page is quite useful.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: The current version of the TIFF specification can be found here.</para></listitem>

<listitem><para>http://home.earthlink.net/~ritter/tiff/: The unofficial TIFF site contains some useful resources.</para></listitem>

<listitem><para>http://www.inforamp.net/~poynton/notes/colour_and_gamma/ColorFAQ.html: a FAQ document discussion of converting to gray scale</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>Portions first published by IBM DeveloperWorks</title>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</sect1>
</chapter>
<chapter id="chap-gif"><title>GIF</title>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>

<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>








<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
<para>

<sidebar><title>Data streams?</title>
<para>
It should be noted that the GIF specification doesn't speak of files as such. Instead it uses the term <quote>Data Stream</quote>, which is a concept which embraces files, as well as in memory buffers, and other interesting forms of data storage. It doesn't really make any difference to the discussion of the format here though.
</para>
</sidebar>

<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>
</sect2>

<sect2><title>The header</title>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>

<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>

<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>
</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>

<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</para>

<sect3><title>Formula for global color table size</title>
<para>
The determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</empasis>, or 255 items.
</para>

<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>

<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>

<sect3><title>Image descriptors</title>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>

<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
The packed field byte stores the following information:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>
</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>

<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>


<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>

<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>

<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>

</sect4>
</sect3>
</sect2>

<sect2><title>Special purpose blocks</title>
<para>
The other thing which can be stored in the data area of the data stream of a GIF file is special purpose blocks. These are outside the scope of this tutorial, and wont be discussed here.
</para>

<execute><cmd>nextedition</cmd><input>Discuss them</input><execute>
</sect2>

<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>
</sect2>


<sect2><title>Interlaced images</title>
<para>
GIF supports the interlacing of images, which is where are the image is loaded, progressively better representations of the image are displayed. Discussing the inner workings of this within the file format is out of the scope of this tutorial however.
</para>

</sect2>
</sect1>


















<sect1><title>giflib</title>
<para>
This library was originally written by Gershon Elbor and Eric Raymond. In the words of the history in the documentation for giflib:
</para>

<programlisting>
This package was originally written by Gershon Elber in 1990 on an IBM PC under MS-DOS using Borland Turbo C. He made it portable to several UNIX environments.

The 2.1 version featured substantial changes and additions by Eric S. Raymond . These included the DGifSlurp/EGifSpew function pair for enabling non-sequential operations on GIF images and
the tools icon2gif, gifovly, gifburst, and gifcompose.

The 2.4 version converted all the docs from an idiosyncratic plain-text formal to to HTML.
</programlisting>

<para>
It is now maintained by Toshio Kuratomi (badger@prtr-13.ucsc.edu), and the website for giflib is at http://prtr-13.ucsc.edu/~badger/software/giflib.shtml. It should be noted that the download link for giflib on this site is broken, and that I had to dig a little to find a copy of giflib. I have therefore included it in the contrib directory of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
Installing giflib is fairly trivial. Simply follow the steps below...
</para>

<sect3><title>Unix</title>
<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the giflib directory</para></listitem>
<listitem><para>As shipped, the directory includes a few files which might cause you build problems. Delete config.cache and config.log manually</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>
</sect3>

<sect3><title>win32</title>
<para>
As far as I am aware, giflib is not currently supported on win32. I have not personally verified this though.
</para>

<execute><cmd>nextedition</cmd><input>Verify</input></command>
</sect3>
</sect2>




















<sect2><title>Man pages</title>
<para>
giflib doesn't ship with man pages. It does however come with a large amount of documentation in HTML format, which I have included here for your reference.
</para>


<sect2><title>gif2bgi</title>
<programlisting>

   Go to [1]index page.

                                  gif2bgi

   A  program  to  display  images  saved  as GIF files on IBM PC display
   devices using the BGI (Borland) driver interface.

   The program operates as follows:

    1. Reads the GIF file header and determines the image size.
    2. Dynamically   allocates  enough  memory  to  hold  all  the  image
       internally.  One  byte  per pixel is always allocated, so a little
       bit  more  than  width*height  (of  screen,  not  image) bytes are
       required.
    3. Reads  all  the image in. Interlaced images are read in correctly,
       although they are displayed sequentially.
    4. Display  first image using the defaults as set by the command line
       option.
    5. Goes   to   interactive  mode.  For  a  full  description  of  the
       interactive mode see below.

                                    Usage:

gif2bgi [-q] [-d BGI dir] [-u driver] [-z zoom] [-b] [-h] gif-file

   If no GIF is given, gif2bgi will try to read a GIF file from stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d BGI Directory]
          Where  we  should  look  for  default  drivers  (as supplied by
          Borland). For example '-d c:/tc/bgi'.

   [-u driver]
          Specifies  a user-defined BGI driver. If for example you have a
          BGI  driver  for your special vga called MYVGA.BGI and you want
          to run it in mode 2, then type '-u c:/tc/bgi/myvga.2'. Note the
          absolute  path  to the driver must be specified. Also note that
          we use '/' and not '\' so they won't be treated as options.

   [-z zoom]
          Sets  zoom factor of the view. Zoom factor should be power of 2
          up to 256. Default is 1 (no zoom).

   [-h]
          Print one line of command-line help, similar to Usage above.

                               Interactive mode:

   Once the image is displayed, the gif2bgi program goes into interactive
   mode which recognizes the following commands:

   C - get Color and position
          In this submenu, a cursor appears and the location and color of
          the  pixel  underneath it are printed. The 4 arrows may be used
          (shifted for faster movement) to move the cursor. Any other key
          will abort this submode.

   D - zoom Down
          Zoom down by factor of 2 unless current zoom factor is 1.

   R - Redraw
          Redraw the image.

   S - print Status
          Print status of image and program.

   U - zoom Up
          Zoom up by factor of 2 unless current zoom factor is 256.

   arrow keys
          The  4  arrow keys can be used to pan in the desired direction,
          if  the  image  overflows  in that direction. If the image fits
          into  the screen, arrow keys are ignored. The panning steps are
          1/2 screen if not on image end.

   SPC - abort
          Space bar may be used to abort current image drawing.

   ESC - abort
          Escape may be used to abort current image drawing.

                                    Notes:

   This  program  is  useless  in  a Unix environment and is not normally
   built there.

   No  color  quantization  is used in this program; thus, if a GIF image
   has more colors than the BGI driver support, this program will abort.

   This  driver  is  optimized  for  drivers with one byte per pixel (256
   colors) and will run MUCH faster on such drivers.

                                     Bugs:

   For some reason I could not figure out, on my ATI wonder card, int 10h
   call  10h  (AH = AL = 10h) to set the color registers sometimes result
   with  wrong  colors. Direct access of the card registers gives correct
   results.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2bgi.html</emphasis></para>
</sect2>

<sect2><title>gif2epsn</title>
<programlisting>

   Go to [1]index page.

                                  gif2epsn

   A program to dump images saved as GIF files on Epson type printers.

                                    Usage:

gif2epsn [-q] [-d dither] [-t bw] [-m map] [-i] [-n] [-p printer] [-h] gif-file

   If  no  gif-file  is  given, Gif2Epsn will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d dither]
          Sets size of dithering matrix, where DitherSize can be 2,3 or 4
          only  (for  2x2, 3x3 and 4x4 dithering matrices). Default is 2.
          Note  image  will be displayed in this mode only if the mapping
          option (see -m) selected this mode.

   [-t bw]
          Sets threshold level for B&amp;W mapping in percent. This threshold
          level  is  used  in  the different mappings as selected via -m.
          Default is 19%.

   [-m map]
          Select method to map colors to B&amp;W. Mapping can be:

        0
                Every  none  background  color  is  considered foreground
                (white  color but is drawn as black by printer, unless -i
                is specified).

        1
                If  0.3  *  RED  +  0.59 * GREEN + 0.11 * YELLOW &gt; BW the
                pixel is considered white color.

        2
                Colors  are  mapped as in 1, and use dithering of size as
                defined  using  -d  option.  BWthreshold  is used here as
                scaler.

          The default is option 0.

   [-i]
          Invert the image, i.e. black -&gt; white, white -&gt; black.

   [-n]
          Nicer image. Uses double-density feature of Epson printer. This
          takes  more  time  (and kills your ink cartridge faster...) but
          results are usually better.

   [-p printer]
          Under  Unix,  output  goes to stdout by default; under DOS, the
          default  is  LPT1:. With this switch you can specify the output
          target.

   [-h]
          print one line of command line help, similar to Usage above.

                                    Notes:

   The  output has an aspect ratio of 1, so a square image will be square
   in hardcopy as well.

   The  widest  image  can be printed is 640 pixels, on 8 inch paper. You
   probably  will need to flip wider images, if height is less than that:
   `[2]gifflip -r x29.gif | gif2epsn'. Wider images will be clipped.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [3]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
   3. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2epsn.html</emphasis></para>
</sect2>

<sect2><title>gif2herc</title>
<programlisting>

   Go to [1]index page.

                                  gif2herc

   A  program  to display images saved as GIF files on an IBM PC Hercules
   graphic card. The program operates as follows:

    1. Read GIF file header and determine size of the image.
    2. Dynamically   allocate   enough  memory  to  hold  all  the  image
       internally.  One  byte  per pixel is always allocated, so a little
       bit  more  than  width*height  (of  screen,  not  image) bytes are
       required.
    3. Reads the image in. Interlaced images are read correctly, although
       they are displayed sequentially.
    4. Display  first image using the defaults as set by the command line
       option.
    5. Goes  to interactive mode. For full description of the interactive
       mode see below.

                                    Usage:

gif2herc [-q] [-d dither] [-z zoom] [-t bw] [-m map] [-i] [-b] [-h] gif-file

   If  no  gif-file  is  given, gif2herc will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
   Quiet mode. Defaults off on MSDOS, on under UNIX. Controls printout of
   running scan lines. Use -q- to invert.

   [-d dither]
   Sets  size of dithering matrix, where dither can be 2,3 or 4 only (for
   2x2,  3x3  and  4x4 dithering matrices). Default is 2. Note: the image
   will be dithered only if the mapping (see -m) selected dithering mode.

   [-z zoom]
   Sets  zoom factor of the image. Zoom factor should be power of 2 up to
   256. Default is 1 (no zoom).

   [-t bw]
   Sets  threshold level for B&amp;W mapping in percent. This threshold level
   is used in the different mappings as selected via -m. Default is 19%.

   [-m map]
   Select method to map colors to B&amp;W. Mapping can be:

   0
          Every non-background color is considered foreground (white).

   1
          0.3  *  RED  +  0.59  *  GREEN + 0.11 * YELLOW &gt; BWThreshold is
          considered white.

   2
          Colors are mapped as in 1, and use dithering of size as defined
          using -d option. BWthreshold is used here as scaler.

   Default is option 0, which is much faster than the other two.

   [-i]
   Invert the image, i.e. black -&gt; white, white -&gt; black.

   [-b]
   Disable  beeps.  Every  time the image is complete, or a wrong key was
   presses, sound is generated. The -b option disables that.

   [-h]
   Print one line of command line help, similar to Usage above.

                               Interactive mode:

   Once the image is displayed, the program goes into an interactive mode
   which recognizes the following commands:

   C - get Color and position
          In this submenu, a cursor appears and the location and color of
          the  pixel  underneath it are printed. The 4 arrows may be used
          (shifted for faster movement) to move the cursor. Any other key
          will abort this submode.

   D - zoom Down
          Zoom down by factor of 2 unless current zoom factor is 1.

   H - Increase dither matrix size
          ...unless  current  size  is maximum (4), in which case size is
          set to minimum (2).

   I - Invert
          Invert the image, i.e. white -&gt; black, black -&gt; white.

   M - Method
          Increment  color -&gt; BW mapping method, unless current method is
          maximum (2), in which case method is set to minimum (0).

   R - Redraw
          Redraw the image.

   S - print Status
          Print status of image and program.

   U - zoom Up
          Zoom up by factor of 2 unless current zoom factor is 256.

   arrow keys
          The  4  arrow keys can be used to pan in the desired direction,
          if  the  image  overflows  in that direction. If the image fits
          into  the screen, arrow keys are ignored. The panning steps are
          1/2 screen if not on image end.

   SPC - abort
          Space bar may be used to abort current image drawing.

   ESC - abort
          Escape may be used to abort current image drawing.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2herc.html</emphasis></para>
</sect2>

<sect2><title>gif2iris</title>
<programlisting>

   Go to [1]index page.

                                  gif2iris

   A  program  to  display  images  saved as GIF files under the SGI NeWs
   window system.

                                    Usage:

Gif2Iris [-q] [-f] [-p PosX PosY] [-f] [-h] gif-file

   If no gif-file is given, Gif2Iris will try to read a GIF from stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-f]
          Force Gif2Iris to stay in foreground.

   [-p PosX PosY]
          Defines  position  of  image  on screen. By default the program
          will prompt for position.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2iris.html</emphasis></para>
</sect2>

<sect2><title>gif2ps</title>
<programlisting>

   Go to [1]index page.

                                   gif2ps

   GIF-to-PostScript conversion.

                                    Usage:

gif2ps [-q] [-x] [-y] [-s sx sy] [-p px py] [-i] [-n copies] [-h] gif-file

   If  no  gif-file  is  given,  Gif2PS  will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-x]
          Force  image  to  be  horizontal (`landscape mode'). By default
          image  will  be  positioned so it will be the biggest. If -x is
          given image will be scaled to be biggest possible horizontally.

   [-y]
          Force vertical (`portrait mode'); analogous to -x.

   [-s sx sy]
          Force image size to be sx by sy inches. If image will exit page
          dimensions,  it will scream and die. Page dimensions are 8.5 by
          11.0 inches but only 7.5 by 9.0 are assumed to be printable.

   [-p pc py]
          Force  image  lower  left  corner to be as px py. If this would
          overrun the page's dimensions, it will scream and die.

   [-i]
          Image will be inverted (Black -&gt; White and vice versa). Mapping
          from  colors  is done by 0.3 * RED + 0.59 * GREEN + 0.11 * BLUE
          and sometimes inverting the image will look better.

   [-n copies]
          Number of copies to print. 1 by default.

   [-h]
          Print one line of command help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2ps.html</emphasis></para>
</sect2>

<sect2><title>gif2rgb</title>
<programlisting>

   Go to [1]index page.

                                  gif2rgb

   A program to convert images saved as GIF to 24-bit RGB image(s).

                                    Usage:

gif2rgb [-q] [-1] [-o OutFileName] [-h] gif-file

   If  no  gif-file  is  given,  Gif2RGB will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-1]
          Only  one  file in the format of RGBRGB... triplets (Each of R,
          G, B is a byte) is being written. This file size is 3 * Width *
          Height. If stdout is used for output, this option is implicitly
          applied.  The  default  (if not `-1') is 3 files with the names
          OutFileName.R,  OutFileName.G,  OutFileName.B, each of which is
          Width * Height bytes.

   [-o OutFileName]
          specifies the name of the out file (see also `-1' above).

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2rgb.html</emphasis></para>
</sect2>

<sect2><title>gif2rle</title>
<programlisting>

   Go to [1]index page.

                                  gif2rle

   A  program to convert images saved as GIF to RLE (Utah raster toolkit)
   format.

                                    Usage:

gif2rle [-q] [-a] [-h] gif-file

   If  no  gif-file  is  given,  Gif2Rle will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-a]
          Add alpha channel (see rle document) to the output data file.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Notes:

   This  routine must be linked with the RLE toolkit library librle.a and
   is  not  built by the normal distribution make. If you want to convert
   images to RLE format, it is reasonable to assume you have this library
   available.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2rle.html</emphasis></para>
</sect2>

<sect2><title>gif2x11</title>
<programlisting>

   Go to [1]index page.

                                  gif2x11

   A program to display images saved as GIF files under X window system.

   Usage:
gif2x11 [-q] [-p PosX PosY] [-d Display] [-f] [-h] gif-file

   If  no  gif-file  is  given,  Gif2X11 will try to read a GIF file from
   stdin. Note: this program does not read the X resource data base.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-p PosX PosY]
          Set  the  position  of  image on screen. By default the program
          will prompt for position.

   [-d Display]
          What X server should be connected to.

   [-f]
          Force  attempt  to  allocate  exact  colors.  This usually will
          result  in  a  very  muddled  image if not enough colors can be
          allocated; the rest of them will be approximated by the closest
          one. By default the least bits of the colors are stripped until
          success (in allocation) which looks much better.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gif2x11.html</emphasis></para>
</sect2>

<sect2><title>gifasm</title>
<programlisting>

   Go to [1]index page.

                                   gifasm

   A  program  to  assemble multiple GIF files into one, or disassemble a
   single GIF file with multiple images into single image files.

                                    Usage:

gifasm [-q] [-a] [-d OutFileName] [-h] gif-file...

   If  no  gif-file  is  given,  GifAsm  will try to read a GIF file from
   stdin, if in disassembly mode only (-d).

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-a]
          Assemble. This is the default, and the GifFile(s) are assembled
          to  stdout.  Note the screen descriptor (including screen color
          map)   is  taken  from  the  first  file,  while  other  screen
          descriptors  are  ignored. As this tool requires at least 2 GIF
          files  as  input, no attempt will be made to read stdin if none
          specified on command line.

   [-d OutFileName]
          Disassemble  GifFile  (if  specified on command line) or stdin,
          into  several files of the form OutFileNameXX, where XX are two
          decimal digits. Obviously up to 100 files can be generated this
          way. Note: in this mode nothing is sent to stdout.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifasm.html</emphasis></para>
</sect2>

<sect2><title>gifbg</title>
<programlisting>

   Go to [1]index page.

                                   gifbg

   A  program  to generate a single-color test pattern GIF with gradually
   changing intensity in any of the basic 8 directions.

                                    Usage:

gifbg [-q] [-d Dir] [-l #Lvls] [-c R G B] [-m MinI] [-M MaxI] [-s W H] [-h]

   The  gifbg  program reads no input, and will dump the created GIF file
   to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d Dir]
          Select   direction  the  intensity  of  the  background  should
          increase. Direction can be one of the 8 principal directions:

   "T" - for Top                "TR" - for Top Right
   "R" - for Right              "BR" - for Bottom Right
   "B" - for Bottom             "BL" - for Bottom Left
   "L" - for left               "TL" - for Top Left

          The  compass  directions  may  be use as synonyms for the above
          directions, so for example "NE" is equal to "TR".

          Direction  is  case  insensitive.  The default direction is Top
          (North).

   [-l #Lvls]
          Number of levels the color will be scaled to. Default is 16.

   [-c R G B]
          What  to  use  as  the  primary background color to scale. This
          color  is  scaled  between  the  minimum  intensity  (MinI) and
          maximum  intensity  (MaxI)  from  one  end of the screen to the
          other  as  defined by Dir. See below (-m &amp; -M) for MinI &amp; MaxI.
          Default is Blue (0, 0, 255).

   [-m MinI]
          Minimum intensity (in percent) to scale color. Default 10%

   [-M MaxI]
          Maximum intensity (in percent) to scale color. Default 100%

   [-s W H]
          Size of image to create. Default 640 by 350.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Notes:

   If  MinI  ==  MaxI = 100 (%) and #Lvls == 2 then boolean mask image of
   specified size will be created - all foreground. This can be used as a
   square mask for the gifcomb utility.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   Visible links
   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com

   Hidden links:
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcomb.html
</programlisting>
<para><emphasis>Code: gifbg.html</emphasis></para>
</sect2>

<sect2><title>gifburst</title>
<programlisting>

   Go to [1]index page.

                                  gifburst

   The  gifburst  program  takes  a  named  GIF  file  and breaks it into
   equal-sized  tiles.  This  is  useful  if  a GIF is too large for your
   viewer, so you have to look at it in sections.

                                    Usage:

gifburst [-s n] [-p b] gif-file

                               Memory required:

   Proportional to the size of the largest pasted image.

                                   Options:

   [-s nnn]
   Specify the number of pieces. Valid values are presently 4 (2x2) and 6
   (2x3). Default is 4.

   [-p nnn]
   Specify the number of pixels of overlap between interior boundaries of
   pieces. Default 20.

                                     Note:

   The  gifburst  program  is written on Perl, using the C utilities. You
   must have both the giflib utilities and Perl installed to run it.

                                    Author:

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifburst.html</emphasis></para>
</sect2>

<sect2><title>gifclip</title>
<programlisting>

   Go to [1]index page.

                                  gifclip

   A  program  to  clip images in GIF files. Only one image in a GIF file
   can  be  modified  at a time. Neither the image position on screen nor
   the screen size is modified (use [2]gifpos for that).

                                    Usage:

gifclip [-q] [-i Xmin Ymin Xmax Ymax] [-n n Xmin Ymin Xmax Ymax] [-c] [-h] gif-
file

   If  no  gif-file  is  given,  GifClip will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-i Xmin Ymin Xmax Ymax]
          Clip  first  image  to  the  dimensions  as  specified by the 4
          coordinates (Xmin Ymin Xmax Ymax) of a box clipping region.

          For  example:  '-i 11 22 33 44' will crop the box from top left
          [11,22] to bottom right [33,44] out of the first image.

          If  the  first parameter is bigger than third one (Xmin &gt; Xmax)
          they are swapped. Same for Y.

          The  dimensions  of  the  clipped  image  must  be  confined to
          original  image  width  and  height.  Note  the  clipped  image
          includes  both  the min &amp; max boundary; an image of width W can
          have coordinates 0 to W-1 (zero based).

          Only one of -i or -n can be specified.

   [-n n Xmin Ymin Xmax Ymax]
          Same  as  -i above but for the nth image: `-n 1 11 22 33 44' is
          exactly the same as the example in -i. Only one of -i or -n can
          be specified.

   [-c]
          Complement.  This  removes  horizontal and/or vertical bands of
          the  image.  For  example  `-c  -i 638 3 658 13' would remove a
          horizontal  band 11 pixels deep beginning at raster line 3, and
          a vertical band 21 pixels right beginning at pixel 658.

   [-h]
          Print one line of command line help, similar to Usage above.

   Note: all coordinates are 0-based --- the top left corner is (0, 0).

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [3]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
   3. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifclip.html</emphasis></para>
</sect2>

<sect2><title>gifclrmp</title>
<programlisting>

   Go to [1]index page.

                                  gifclrmp

   A  program  to modify GIF image colormaps. Any local colormap in a GIF
   file can be modified at a time, or the global screen one.

                                    Usage:

gifclrmap [-q] [-s] [-t trans] [-l map] [-g Gamma] [-i image] [-h] gif-file

   If  no  gif-file  is  given,  GifClip will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s]
          Select the global screen color map.

   [-l map]
          Load color map from this file instead of selected color map.

   [-t trans]
          Change  color  index  values.  The  change  is made to both the
          selected color table and the raster bits of the selected image.
          A  translation  file is a list of pairs of `before' and `after'
          index  values. At present, the `before' index values must be in
          ascending order starting from 0.

   [-g Gamma]
          Apply gamma correction to selected color map.

   [-i image]
          Select the color map of the numbered image.

   [-h]
          Print one command line help, similar to Usage above.

                                    Notes:

     * The  default  operation  is  to dump out the selected color map in
       text format.
     * The file to load/dump is simply one color map entry per line. Each
       such  entry  line  has four integers: "ColorIndex Red Green Blue",
       where color index is in ascending order starting from 1.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifclrmp.html</emphasis></para>
</sect2>

<sect2><title>gifcolor</title>
<programlisting>

   Go to [1]index page.

                                  gifcolor

   A  program  to  generate color test patterns. Feed it a color map file
   (as  generated, say, by the -s otion of GifClrMp) and it will generate
   a GIF containing lines of the form
        Color %-3d: [%-3d, %-3d, %-3d]:

   where  the  first number is the zero-based color index, and the triple
   is  the  index's [Red, Green, Blue] value. There will be one such line
   for  each  color.  Each  line  will be set in a simple 8x8 font in the
   color  it  describes;  thus,  any  lines  corresponding  to  the GIF's
   background color will be blank.

                                    Usage:

gifcolor [-q] [-b Background] [-h] &amp;ltColorMapFile

   As  gifcolor  can  generate huge amounts of data, ^C will kill it, but
   'q'  will  stop  only  the printing (of one of -e, -z, -p), while file
   integrity will still be checked.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-b]
          Set the image's backround color to a given numeric index.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifcolor.html</emphasis></para>
</sect2>

<sect2><title>gifcomb</title>
<programlisting>

   Go to [1]index page.

                                  gifcomb

   A  program  to combine 2 GIF images of exactly the same size into one.
   The color maps are merged, but the result may not exceed 256 colors. A
   boolean  mask  GIF file can be used to set which pixel from two images
   to  use  at  each  location. Otherwise any background color from first
   image is converted to second image color at that point. Only the first
   image of each file is combined; again, all files' first images must be
   of exactly the same size.

                                    Usage:

gifcomb [-q] [-m MaskGIFFile] [-h] gif-file...

   Two GIF files must be specified; a third mask GIF file is optional.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-m MaskGIFFile]
          the  MaskGIFfile  can be regular GIF file whose first image has
          same  dimensions  as  the  combined  images. Any non-background
          color  in  it  will  select  Image 1 Pixel to output, otherwise
          Image2  pixel  will  be  selected.  Usually  this image will be
          boolean (two colors only) but it does not have to be.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifcomb.html</emphasis></para>
</sect2>

<sect2><title>gifcompose</title>
<programlisting>

   Go to [1]index page.

                                 gifcompose

   The  gifcompose  program  uses  the  GIFLIB utility tools to support a
   minilanguage for describing GIF pasteup sequences.

                                    Usage:

gifcompose [-v] &lt;specfile

                             Specification Syntax

   The  gifcompose  tool takes a series of text lines and interprets them
   as commands to do pasteup operations. The commands are:

                                 Generators

   gif &lt;name&gt;
          Paste in &lt;name&gt;.gif

   raw &lt;name&gt; &lt;width&gt; &lt;height&gt;
          Paste  in  the  given raw-format file (no suffix supplied). Raw
          format  is  a  stream  of 8-bit indices into the EGA color map.
          Accordingly,  the  width  and height must be specified, and the
          source must be exactly width times height bytes long.

   rgb &lt;name&gt; &lt;width&gt; &lt;height&gt;
          Paste  in  the  given RGB-format file (no suffix supplied). Raw
          format  is  a  stream  of 24-bit color values. Accordingly, the
          width  and  height  must  be  specified, and the source must be
          exactly 3 times width times height bytes long.

   rle &lt;name&gt;
          Paste  in  the given RLE-format file (no suffix supplied). This
          converts the Utah Raster Kit format to GIF.

   text &lt;text&gt; [foreground &lt;index&gt;] [color &lt;r&gt; &lt;g&gt; &lt;b&gt;]
          Copy  8x8 monospace font, with transparent background and index
          1  as foreground. If the text string contains whitespaces, they
          must   be   escaped   or  the  string  must  be  quoted  (shell
          conventions).

          The  optional suffix `foreground &lt;n&gt;' sets the foreground color
          index.  The  optional  suffix  `color &lt;r&gt; &lt;g&gt; &lt;b&gt;' sets the RGB
          color to be used for the foreground index.

   Each  generator  operation  may  be followed by any combination of the
   following suffixes:

                                 Modifiers

   at &lt;x&gt; &lt;y&gt;
   Place  the  image at the given (upper-left-hand-corner) coordinates in
   the pasted-up result.

   clip &lt;name&gt; &lt;top-x&gt; &lt;top-y&gt; &lt;bottom-x&gt; &lt;bottom-y&gt;
   Clip image using the given rectange, paste it onto.

   xflip
   Flip the image around the X axis before placing it.

   yflip
   Flip the image around the Y axis before placing it.

   left
   Rotate the image 90 degrees counterclockwise before placing it.

   right
   Rotate the image 90 degrees clockwise before placing it.

                             Target Operations

   screen size &lt;x-size&gt; &lt;y-size&gt;
   Set the global screen size of the final image.

   screen position &lt;x&gt; &lt;y&gt;
   Set the global screen position of the final image.

                                  Comments

   Comments  or  comment  lines  may  be  preceded  with  `#' and will be
   ignored.

                               Memory required:

   Proportional to the size of the largest pasted image.

                                   Options:

   [-v]
          Emit  a  report  on  each  composition  action  to stderr as it
          happens.

                                     Bugs:

   The  suffix sequence `left left' sometimes mysteriously fails to work,
   probably due to some restriction in [2]gifflip.

   No support for resizing or odd-angle rotations yet.

   The  `color' suffix of text is a no-op, because the present version of
   [3]gifovly throws away color tables.

   Error checking is rudimentary.

                                    Author:

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [4]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifovly.html
   4. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifcompose.html</emphasis></para>
</sect2>

<sect2><title>giffiltr</title>
<programlisting>

   Go to [1]index page.

                                  giffiltr

   This  is  an  expensive way to copy a GIF. The source is included as a
   skeleton  for  more  sophisticated filters. See the source in the util
   directory for details.

   I  suppose this does have some utility as a test of the sequential GIF
   record  I/O  routines.  The output should be bytewise identical to the
   input.

                                    Usage:

giffiltr &lt;GifFile &gt;GifCopy

                               Memory required:

   Line.

                                   Options:

   None.

                                    Author

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: giffiltr.html</emphasis></para>
</sect2>

<sect2><title>giffix</title>
<programlisting>

   Go to [1]index page.

                                   giffix

   A program that attempts to fix broken GIF images. Currently will "fix"
   images  terminated  prematurely  by filling the rest of the image with
   the darkest color found in image.

                                    Usage:

giffix [-q] [-h] gif-file

   If  no  gif-file  is  given,  GifFix  will try to read a GIF file from
   stdin. The fixed file is dumped to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: giffix.html</emphasis></para>
</sect2>

<sect2><title>gifflip</title>
<programlisting>

   Go to [1]index page.

                                  gifflip

   A  program  to flip (mirror) GIF file along X or Y axes, or rotate the
   GIF file 90 degrees to the left or to the right.

                                    Usage:

gifflip [-q] [-r] [-l] [-x] [-y] [-h] gif-file

   If  no  gif-file  is  given,  GifFlip will try to read a GIF file from
   stdin.

                               Memory required:

   Image.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-r]
          Rotate the GIF file to the right.

   [-l]
          Rotate the GIF file to the left.

   [-x]
          Mirror  the  GIF file along the X axis. Very useful if GIF file
          was  created  from  another format in with the first line in at
          image bottom. Effectively exchanges first row with last.

   [-y]
          Mirror  the  GIF file along Y axis. Effectively exchanges first
          column with last.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifflip.html</emphasis></para>
</sect2>

<sect2><title>gifhisto</title>
<programlisting>

   Go to [1]index page.

                                  gifhisto

   A  program  to  create histogram of number of pixels using each color.
   The output can be formatted into a GIF histogram file, or as text file
   - both go to stdout.

                                    Usage:

gifhisto [-q] [-t] [-s Width Height] [-n ImageNumber] [-b] [-h] gif-file

   If  no  gif-file  is  given, GifHisto will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-t]
          Force  output  to be text file of the following form: (colormap
          size) lines each containing two integers: number of times color
          appeared,  and color index. Lines are in increasing color index
          order.  This  output  can  be fed directly to a sort program if
          ordering by color frequency is desired.

          The  colrmap  picked  is  the  one  to be used for the image to
          generate histogram for, as defined in GIF format.

   [-s Width Height]
          Size  of GIF histogram file. The Height of the histogram should
          be power of 2 dividable by number of colors in colormap.

          Width  sets  the  resolution  (accuracy  if  you  like)  of the
          histogram as the maximum histogram bar is scaled to fit it.

   [-n ImageNumber]
          Image number to test. Default is one.

   [-b]
          Zeros the background color count. As only linear scale bars are
          supported  and  usually  the background appears much more often
          then  other  colors, deleting the background count will improve
          the scaling of other colors.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifhisto.html</emphasis></para>
</sect2>

<sect2><title>gifinter</title>
<programlisting>

   Go to [1]index page.

                                  gifinter

   A program to convert between interlaced and non-interlaced GIF images.

                                    Usage:

gifinter [-q] [-i] [-s] [-h] gif-file

   If  no  gif-file  is  given, GifInter will try to read a GIF file from
   stdin.

                               Memory required:

   Image.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-i]
          Force all images in GIF file be interlaced.

   [-s]
          Force all images in GIF file be sequential (default).

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifinter.html</emphasis></para>
</sect2>

<sect2><title>gifinto</title>
<programlisting>

   Go to [1]index page.

                                  gifinto

   A  program  to  save stdin into a file with given name, iff the result
   file  has  size bigger than specified (see below). This can be used to
   save result in same files name we started a chain of pipes.

                                    Usage:

gifinto [-q] [-s MinFileSize] [-h] gif-file

   Gifinto always reads a GIF file from stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s MinFileSize]
          If file is less than MinFileSize, it is deleted and not renamed
          to  given  name.  This will prevent killing the file we started
          with  if  the  result is an empty file, or the pipeline did not
          complete.

          The  default  file threshold size is 14 bytes which is 1 bigger
          than GIF file stamp (6 bytes) and GIF file screen descriptor (7
          bytes), so a GIF file with only GIF stamp and screen descriptor
          will not be renamed.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifinto.html</emphasis></para>
</sect2>

<sect2><title>gif_lib</title>
<programlisting>

   Go to [1]index page.

                             The GIFLIB Library

     Gershon Elber, May 1991
     Eric S. Raymond, Sep 1992

   The  Graphics  Interchange  Format(c)  is  the  Copyright  property of
   CompuServe  Incorporated.  GIF(sm)  is  a  Service  Mark  property  of
   CompuServe Incorporated.

   Gershon  wrote:  "This  library  was  written  because I couldn't find
   anything similar and I wanted one. I was inspired by the RLE Utah tool
   kit,  which  I  hoped  to  port  to  an IBM PC, but found it to be too
   machine  specific, and its compression ratio too low. I compromised on
   the  GIF  format,  but I am not sure how long 8 bits per pixel will be
   enough."

   This  document  explains  the GIF library code in directory `lib'. The
   code  is collected into libgif.a which is used in all the utilities in
   `util'.  It can be used in any application needs to read/write the GIF
   file format. This document does
   not  explain  the GIF file format and assumes you know it, at least to
   the level of the GIF file structure.

   When a GIF file is opened, a GIF file descriptor is created which is a
   pointer to GifFileType structure as follows:

typedef struct GifFileType {
    int SWidth, SHeight,                               /* Screen dimensions. */
        SColorResolution,                /* How many colors can we generate? */
        SBackGroundColor;               /* I hope you understand this one... */
    ColorMapObject *SColorMap;                        /* NULL if not exists. */
    int ImageCount;                               /* Number of current image */
    GifImageDesc Image;                    /* Block describing current image */
    struct SavedImage *SavedImages;     /* Use this to accumulate file state */
    VoidPtr Private;      /* The regular user should not mess with this one! */
} GifFileType;

   This structure was copied from gif_lib.h - the header file for the GIF
   library. Any application program that uses the libgif.a library should
   include  it. Members beginning with S refer to GIF Screen; others hold
   properties  of  the  current  image (a GIF file may have more than one
   image) or point to allocated store used by various routines.

   The  user  almost  never writes into this structure (exception: it may
   occasionally useful to alter things in the SavedImages array), but can
   read  any of these items at any time it is valid (image information is
   invalid until first image was read/write).

   As  the library needs to keep its own internal data, a Private pointer
   to hidden data is included. Applications should ignore this item.

   The  library has no static data. This means that it is fully reentrant
   and  any  number  of GIF files (up to memory limits) can be opened for
   read/write.  Instead of the static data, internal structure pointed by
   the Private pointer is used.

   The library allocates its own memory dynamically, on opening of files,
   and  releases that once closed. The user is never required to allocate
   any  memory  for any of the functions of this library nor to free them
   directly.

   In  order  to  reduce  disk  access,  the  file buffer is increased to
   FILE_BUFFER_SIZE  (defined  in gif_lib.h). The library was compiled in
   large  model  on the PC as the memory allocated per file is quite big:
   about   17k   for   decoding   (DGIF_LIB.C),   and  32k  for  encoding
   (EGIF_LIB.C), excluding the FILE_BUFFER_SIZE.

   Here is a module summary:

   egif_lib.c
          Encoding routines, all prefixed with E.

   dgif_lib.c
          Decoding routines, all prefixed with D.

   dev2gif.c
          Routines to convert specific device buffers into GIF files.

   gifalloc.c
          Routines for colormap handling and GIF record allocation.

   gif_font.c
          The 8x8 font table for the GIF utility font.

   gif_err.c
          Error handler for the library.

   The  library  includes  a  sixth  file  of hash-function code which is
   accessed internally only.

   Most  of  the  routines  return GIF_ERROR (see gif_lib.h) if something
   went  wrong,  GIF_OK otherwise. After an error return, the code in the
   gif_err.c module can be used to do something about it.

   In  addition,  a  module  to parse command line arguments is supplied.
   This  module  is  called getarg.c and its headers are in getarg.h. See
   the header of getarg.c for details on its usage.

                             Decoding (dgif_lib.c)

   The following functions are used to set up input from a GIF:

GifFileType *DGifOpenFileName(char *GifFileName)

   Open  a  new GIF file using the given GifFileName, and read its Screen
   information.  If  any  error  occurs,  NULL  is returned and the error
   handler  can  be used to get the exact error (see gif_err.c). The file
   is   opened   in   binary   mode,  and  its  buffer  size  is  set  to
   FILE_BUFFER_SIZE bytes.
GifFileType *DGifOpenFileHandle(int GifFileHandle)

   Open a new GIF file using the given GifFileHandle, and read its Screen
   information.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

   Once  you  have acquired a handle on a GIF, there are two ways to read
   it in. The high-level function
int DGifSlurp(GifFileType)

   reads  the rest of a complete (possibly multi-image) GIF file from the
   indicated  file  handle  into in-core allocated structures. It returns
   GIF_OK on success, GIF_ERROR on failure.

   Once  you  have done this, all image, raster, and extension-block data
   in the GIF is accessable in the SavedImages member (see the structures
   in fif_lib.h). When you have modified the image to taste, write it out
   with EGifSpew().

   If  you are handling large images on a memory-limited machine, you may
   need to use the following functions for sequential read.

int DGifGetScreenDesc(GifFileType *GifFile)

   Reads  the  screen  information  into the GifFile structure. Note this
   routine  is  automatically called once a file is opened, and therefore
   usually need not be called explicitly.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetRecordType(GifFileType *GifFile, GifRecordType *GifType)

   As  the  GIF  file can have different records in arbitrary order, this
   routine  should  be  called  once the file was open to detect the next
   record type, and act upon it. It can return these types in GifType:

   1. UndefinedRecordType
          something is wrong!

   2. ScreenDescRecordType
          screen information. As the screen info is automatically read in
          when the file is open, this should not happen.

   3. ImageDescRecordType
          next record is an image descriptor.

   4. ExtensionRecordType
          next record is extension block.

   5. TerminateRecordType
          last record reached, can close the file.

   The  first  two  types  can  usually  be ignored. The function returns
   GIF_ERROR if something went wrong, GIF_OK otherwise.
int DGifGetImageDesc(GifFileType *GifFile)

   Reads  image information into the GifFile structure. Returns GIF_ERROR
   if something went wrong, GIF_OK otherwise.

int DGifGetLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)

   Load  a  block  of  pixels  from  the GIF file. The line can be of any
   length.   More  than  that,  this  routine  may  be  interleaved  with
   DGifGetPixel until all pixels have been read.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.
int DGifGetPixel(GifFileType *GifFile, PixelType GifPixel)

   Loads  one  pixel  from  the GIF file. This routine may be interleaved
   with  [2]DGifGetLine,  until  all  pixels  are  read.  Because  of the
   overhead per each call, use of this routine is not recommended.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetComment(GifFileType *GifFile, char *GifComment)

   Load  a comment from the GIF file. Because DGifGetRecordType will only
   tell if the record is of type extension, this routine should be called
   iff it is known %100 that is must be a comment.

   For  the  definition  of  a  comment,  see  [3]EGifPutComment. Returns
   GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetExtension(
        GifFileType *GifFile,
        int *GifExtCode,
        ByteType **GifExtension)

   Loads  an  extension  block  from  the  GIF file. Extension blocks are
   optional   in   GIF   files.   This  routine  should  be  followed  by
   [4]DGifGetExtensionNext.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetExtensionNext(GifFileType *GifFile, ByteType **GifExtension)


   As  extensions  may  contain  more than one block, use this routine to
   continue after DGifGetExtension, until *GifExtension is NULL.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetCode(
        GifFileType *GifFile,
        int *GifCodeSize, ByteType **GifCodeBlock)

   It  sometimes may be desired to read the compressed code as is without
   decoding  it.  This  routine does exactly that (with DGifGetCodeNext),
   and can be used instead of DGifGetLine.

   This  compressed  code  information  can  be  written  out  using  the
   EGifPutCode/EGifPutCodeNext   sequence  (see  gifpos.c  for  example).
   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifGetCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)

   See DGifGetCode above.

int DGifGetLZCodes(GifFileType *GifFile, int *GifCode)

   This  routine  can  be  called  instead of DGifGetLine/DGifGetPixel or
   DGifGetCode/DGifGetCodeNext to get the 12 bits LZ codes of the images.
   It  will  be  used  mainly  for  debugging purposes (see GifText.c for
   example).

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int DGifCloseFile(GifFileType *GifFile)

   Close  GIF  file  and free all memory allocated for it. GifFile should
   not be used after this routine has been called.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

                             Encoding (egif_lib.c)

   There are two ways to write out a GIF. The high-level function

int EGifSpew(GifFileType *GifFile, int GifFileHandle)

   Writes  a  complete  (possibly  multi-image) GIF file to the indicated
   file  handle  from  in-core allocated structures created by a previous
   DGifSlurp()  or  equivalent  operations.  Its arguments are a GIF file
   descriptor (as above) and an ordinary output file descriptor.

   The  file  is written with a GIF87 stamp unless it contains one of the
   four  special  extension  blocks defined in GIF89, in which case it is
   written with a GIF89 stamp.

   If  you are handling large images on a memory-limited machine, you may
   need to use the following functions for sequential write.

GifFileType *EGifOpenFileName(char *GifFileName, int GifTestExistance)

   Open  a  new GIF file using the given GifFileName. If GifTestExistance
   is  TRUE,  and  file  exists,  the  file  is  not  destroyed, and NULL
   returned.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

GifFileType *EGifOpenFileHandle(int GifFileHandle)

   Open a new GIF file using the given GifFileHandle.

   If  any  error  occurs,  NULL is returned and the error handler can be
   used to get the exact error (see gif_err.c).

   The  file  is  opened  in  binary  mode, and its buffer size is set to
   FILE_BUFFER_SIZE bytes.

void EGifSetGifVersion(char *Version)

   Sets  the  GIF version of all files opened, until another call to this
   routine is made. Version is a 3 characters string of the form "87a" or
   "89a". No test is made to validate this string.

int EGifPutScreenDesc(GifFileType *GifFile,
        int GifWidth, int GifHeight,
        int GifColorRes, int GifBackGround,
        ColorMapObject *GifColorMap)

   Update  the GifFile Screen parameters, in GifFile structure and in the
   real  file.  If  error  occurs,  returns  GIF_ERROR  (see  gif_lib.h),
   otherwise GIF_OK.

   This  routine  should  be  called  immediately  after the GIF file was
   opened.

int EGifPutImageDesc(GifFileType *GifFile,
        int GifLeft, int GifTop,
        int Width, int GifHeight,
        int GifInterlace,
        ColorMapObject *GifColorMap)

   Update  GifFile Image parameters, in GifFile structure and in the real
   file.  if  error  occurs  returns GIF_ERROR (see gif_lib.h), otherwise
   GIF_OK.

   This  routine should be called each time a new image must be dumped to
   the file.

int EGifPutLine(GifFileType *GifFile, PixelType *GifLine, int GifLineLen)


   Dumps  a  block  of pixels out to the GIF file. The slab can be of any
   length.  More  than that, this routine may be interleaved with , until
   all pixels have been sent.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutPixel(GifFileType *GifFile, PixelType GifPixel)

   Dumps  one pixel to the GIF file. This routine may be interleaved with
   [5]EGifPutLine,  until  all  pixels were sent. Because of the overhead
   for each call, use of this routine is not recommended.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutComment(GifFileType *GifFile, char *GifComment)

   Uses  extension GIF records to save a string as a comment is the file.
   The extension code is 'C' (for Comment).

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutExtension(
        GifFileType *GifFile,
        int GifExtCode,
        int GifExtLen,
        void *GifExtension)

   Dumps  the  given  extension block into the GIF file. Extension blocks
   are  optional  in GIF file. Extension blocks of more than 255 bytes or
   more than one block are not supported.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutCode(
        GifFileType *GifFile,
        int *GifCodeSize,
        ByteType **GifCodeBlock)

   It sometimes may be desired to write the compressed code as is without
   decoding  it.  For  example  a  filter for a GIF file that change only
   screen size (GifPos), does not need the exact pixel values. Piping out
   the compressed image as is makes this process much faster.

   This routine does exactly that (with EGifPutCodeNext), and can be used
   instead   of   EGifPutLine.   You'll   usually   use   this  with  the
   DGifGetCode/DgifGetCodeNext routines, which reads the compressed code,
   while  EGifPutCode/EGifPutCodeNext  write  it  out.  See  gifpos.c for
   example.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

int EGifPutCodeNext(GifFileType *GifFile, ByteType **GifCodeBlock)

   See EGifPutCode above.

int EGifCloseFile(GifFileType *GifFile)

   Close  a  GIF  file  and  free  all memory allocated for it. gif-file$
   should not be used, once this routine was called.

   Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

                  Color map handling and allocation routines

ColorMapObject *MakeMapObject(int ColorCount, GifColorType *ColorMap)

   Allocate  storage  for a color map object with the given number of RGB
   triplet  slots.  If  the  second  argument is non-NULL, initialize the
   color  table portion of the new map from it. Returns NULL if memory is
   exhausted or if the size is not a power of 2 &lt;= 256.

void FreeMapObject(ColorMapObject *Object)

   Free  the  storage  occupied  by  a  ColorMapObject  that is no longer
   needed.

ColorMapObject *UnionColorMap(
        ColorMapObject *ColorIn1, ColorMapObject *ColorIn2,
        GifPixelType ColorTransIn2[])

   Create  the union of two given color maps and return it. If the result
   won't  fit  into  256  colors,  NULL  is returned, the allocated union
   otherwise.  ColorIn1  is copied as it to ColorUnion, while colors from
   ColorIn2  are  copied iff they didn't exist before. ColorTransIn2 maps
   the old ColorIn2 into ColorUnion color map table.

SavedImage *GifAttachImage(GifFileType *GifFile)

   Add  an  image  block  to  the  SavedImages  array. The image block is
   initially  zeroed  out. This image block will be seen by any following
   EGifSpew() calls.

                             The GIF Utility Font

   The  8x8  utility  font  used  in  text2gif  and gifcolor lives in the
   library  module  gif_font.c, in a table called AsciiTable. The library
   header file includes suitable externs and defines.

   The GIF utility font support includes entry points for drawing legends
   on  in-core  images,  drawing  boxes  and rectangles, and boxing text.
   These entry points are as follows:

void DrawText(
        SavedImage *Image,
        const int x, const int y,
        const char *legend,
        const int color)

   Draw  text  using  the 8x8 utility font on the saved image. Upper left
   corner  of  the text is at image pixel (x, y). Use the specified color
   index.

void DrawBox(SavedImage *Image,
        const int x, const int y,
        const int w, const int h,
        const int color)

   Draw  a  box  on  the  saved image. Upper left corner of the box is at
   image  pixels (x, y), width is w, height is h. Use the specified color
   index.

void DrawRectangle(SavedImage *Image,
        const int x, const int y,
        const int w, const int h,
        const int color)

   Draw a (filled) rectangle on the saved image. Upper left corner of the
   box  is  at  image  pixels  (x,  y),  width is w, height is h. Use the
   specified color index.

void DrawBoxedText(SavedImage *Image,
        const int x, const int y,
        const char *legend,
        const int border,
        const int bg, const int fg)

   Draw  text  on  a filled rectangle. The rectangle will be sized to fit
   the  text,  with  upper left hand corner at (x, y) on the saved image.
   The  `border'  argument  specifies a pixel margin around the text. The
   `bg'  argument  is  the  color table index to fill the rectangle with;
   `fg' is the color table index to draw the text with.

   This   function  interprets  some  characters  in  the  legend  string
   specially.  A  tab  (\t)  is  interpreted  as  a command to center the
   following  text in the box. A carriage return (\r) is interpreted as a
   request for a line break.

                          Error Handling (egif_lib.c)

void PrintGifError(void)

   Print a one-line diagnostic on the last giflib error to stderr.

int GifLastError(void)

   Return  the  number of the last giflib error, and clear the error. The
   error types are defined in gif_lib.h.

   Note it is the user's responsibility to call the file closing routine,
   so  the file will be closed (if was opened), and allocated memory will
   be released.

                          Device Specific (XXX2gif.c)

int DumpScreen2Gif(char *FileName, int ReqGraphDriver, int ReqGraphMode1,
                                                       int ReqGraphMode2)

   Dumps  the  whole  device  buffer  as  specified  by  GraphDriver  and
   GraphMode (as defined in TC 2.0 graphics.h) into FileName as GIF file.
   Current devices supported:

        1. Hercules.

        2. EGA, EGA64, EGAMONO (all modes - see TC graphics.h).

        3. VGA (all modes - see TC graphics.h).

        4. SVGA_SPECIAL. This mode is special and not supported by Borland
           graphics.h. ReqGraphDriver must be equal to 999, and ReqGraphMode
           is ignored. This modes assumes 800 by 600 in 16 colors.
          Returns GIF_ERROR if something went wrong, GIF_OK otherwise.

        5. SGI 4D using gl graphic library - window dump.

        6. X11 window dump.

                             Command Line Parsing

int GAGetArgs(int argc, char **argv, char *CtrlStr, ...)

   Main routine of this module. Given argc &amp; argv as received by the main
   procedure,  the  command  line  CtrlStr,  and  the  addresses  of  all
   parameters, parse the command line, and update the parameters.

   The CtrlStr defines what types of variables should follow. Look at the
   beginning of getarg.c for exact usage.

   Returns  0  if  successful,  error  number  (as  defined  by getarg.h)
   otherwise.

void GAPrintErrMsg(int Error)

   If  an  error occurred in GAGetARgs, this routine may be used to print
   one line diagnostic to stderr.

void GAPrintHowTo(char *CtrlStr)

   Given  the  same  CtrlStr as for GAGetArgs, can be used to print a one
   line 'how to use'.

                           Skeletons of GIF filters

   If  you  are developing on a virtual-memory OS such as most flavors of
   UNIX,  or  are  otherwise  sure of having enough memory to keep all of
   GIFs you need to operate in core, writing a filter is trivial. See the
   file gifspnge.c in util.

   A  sequential  filter skeleton will usually look like the example file
   giffiltr.c in util.

   Please look at the utilities in the util directory for more ideas once
   you  feel  comfortable  with  these  skeletons. Also try to follow the
   coding  standards  of  this  package  if  you  want  the maintainer to
   officially add your new utility to it.
     _________________________________________________________________


    Eric S. Raymond [6]&lt;esr@snark.thyrsus.com&gt;

References

   Visible links
   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#DGifGetLine
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutComment
   4. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#DGifGetExtensionNext
   5. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutLine
   6. mailto:esr@thyrsus.com

   Hidden links:
   7. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html#EGifPutPixel
</programlisting>
<para><emphasis>Code: gif_lib.html</emphasis></para>
</sect2>

<sect2><title>gifovly</title>
<programlisting>

   Go to [1]index page.

                                  gifovly

   This  program  takes a multi-image GIF file and generates a single GIF
   consisting  of  all the images overlayed. Each image's screen position
   is  used. Thus, you can use this together with [2]gifpos and [3]gifasm
   to paste together images.

                                    Usage:

gifovly [-s TransparentColor] [-h]

   The  GIF  to  be  operated  is  read  in from stdin. The result GIF is
   written to stdout.

                               Memory required:

   Proportional to the size of the input file.

                                   Options:

   [-t num]
          If  this  index  is  given, any pixel in images after the first
          that has this value is not copied.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Author:

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [4]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifasm.html
   4. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifovly.html</emphasis></para>
</sect2>

<sect2><title>gifpos</title>
<programlisting>

   Go to [1]index page.

                                   gifpos

   A  program to change GIF screen size and/or reposition images. No test
   is  made  to  make  sure  changes  will generate valid GIF files (i.e.
   images are still confined to screen etc.)

                                    Usage:

gifpos [-q] [-s Width Height] [-i Left Top] [-n n Left Top] [-h] gif-file

   If  no  gif-file  is  given,  GifPos  will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Default  off  on  MSDOS,  on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s Width Height]
          Set  the  new  screen  dimensions, so for example `-s 1000 800'
          will set screen to width of 1000 and height of 800.

   [-i Left Top]
          set  image  relative to screen position, so for example `-i 100
          80' will set image left position to 100 and top position to 80.
          This sets the position of the first image only.

   [-n n Left Top]
          set  image  n relative to screen position, so for example '-n 3
          100 80' will set the third image position as in 2.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifpos.html</emphasis></para>
</sect2>

<sect2><title>gifrotat</title>
<programlisting>

   Go to [1]index page.

                                  gifrotat

   A program to rotate a GIF image by a specified angle.

                                    Usage:

gifrotat -a Angle [-q] [-s Width Height] [-h] gif-file

   If  no  gif-file  is  given, GifRotat will try to read a GIF file from
   stdin.

                               Memory required:

   Screen (of source image).

                                   Options:

   -a Angle
          Specifies  the angle to rotate in degrees with respect to the X
          (horizontal) axis.

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-s Width Height]
          Since  the  rotated  image will have the same image size as the
          original, some parts of the image will by clipped out and lost.
          By  specifing a (bigger) size explicitly using the `-s' option,
          these parts may be saved.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Notes:

   The  image  is rotated around its center. No filtering is performed on
   the output, which have the same color map as the input. This is mainly
   since  filtering  would  require  color  quantization  which  is  very
   memory/time  intensive  and  out of MSDOS memory limits even for small
   images.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifrotat.html</emphasis></para>
</sect2>

<sect2><title>gifrsize</title>
<programlisting>

   Go to [1]index page.

                                  gifrsize

   A  program  to  resize  image size by an integer factor, deleting bits
   when scaling down and duplicating bits when scaling up.

                                    Usage:

gifrsize [-q] [-S X Y] [-s Scale] [-x XScale] [-y YScale] [-h] gif-file

   If  no  gif-file  is  given, GifRSize will try to read a GIF file from
   stdin.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-S X Y]
          specifies the exact screen dimension of the output GIF.

   [-s Scale]
          Set  scaling  factor for both x &amp; y direction to Scale. Default
          is 0.5. Note this is a floating point number.

   [-x XScale]
          Set  scaling  factor  for x direction to Scale. Default is 0.5.
          Note: this is a floating point number.

   [-y YScale]
          Set  scaling  factor  for y direction to Scale. Default is 0.5.
          Note: this is a floating point number.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifrsize.html</emphasis></para>
</sect2>

<sect2><title>gifspnge</title>
<programlisting>

   Go to [1]index page.

                                  gifspnge

   This  is  an  expensive way to copy a GIF. The source is included as a
   skeleton   for   more  sophisticated  filters  using  DGifSlurp()  and
   EGifSpew(). See the source in the util directory for details.

   I  suppose  this  does  have some utility as a test of DGifSlurp() and
   EGifSpew(). The output should be bytewise identical to the input.

                                    Usage:

gifspnge &lt;GifFile &gt;GifCopy

                               Memory required:

   The size of the input GIF, plus malloc overhead.

                                   Options:

   None.

                                    Author:

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifspnge.html</emphasis></para>
</sect2>

<sect2><title>giftext</title>
<programlisting>

   Go to [1]index page.

                                  giftext

   A program to dump (text only) general information about GIF file.

                                    Usage:

giftext [-q] [-c] [-e] [-z] [-p] [-r] [-h] gif-file

   If  no  gif-file  is  given,  GifText will try to read a GIF file from
   stdin.

   As giftext can generate huge amounts of data, ^C will kill it, but 'q'
   will  stop  only  the  printing  (of  one  of  -e, -z, -p), while file
   integrity will still be checked.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c]
          Dumps the color maps.

   [-e]
          Dumps  encoded  bytes  -  the  pixels after compressed using LZ
          algorithm  and chained to form bytes. This is the form the data
          is saved in the GIF file. Dumps in hex - 2 digit per byte.

   [-z]
          Dumps  the  LZ  codes of the image. Dumps in hex - 3 digits per
          code (as we are limited to 12 bits).

   [-p]
          Dumps the pixels of the image. Dumps in hex - 2 digit per pixel
          (&lt;=byte).

   [-r]
          Dumps  raw  pixels  as one byte per pixel. This option inhibits
          all  other  options and only the pixels are dumped. This option
          may be used to convert GIF files into raw data. Note: the color
          map  can  be  extracted  by  gifclrmp utility. If more than one
          image  is  included  in  the file, all images will be dumped in
          order.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: giftext.html</emphasis></para>
</sect2>

<sect2><title>gifwedge</title>
<programlisting>

   Go to [1]index page.

                                  gifwedge

   A  program to create a test GIF image with intensity levels of the RGB
   colors YCM colors and white.

                                    Usage:

gifwedge [-q] [-l #Lvls] [-s SizeX SizeY] [-h]

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-l #Lvls]
          Set  number  of intensity levels per color. This number must be
          power  of  two  up to 32, as Gif format can only have 256 color
          simultanuously and 7 basic colors are to be displayed.

   [-s SizeX SizeY]
          Force  image  size to be SizeX by SizeY pixels. Image size will
          be  rounded  down  to  be  a  multiple of number of intensities
          horizontally, and 7 (colors) vertically.

   [-h]
          Print one line command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: gifwedge.html</emphasis></para>
</sect2>

<sect2><title>icon2gif</title>
<programlisting>

   Go to [1]index page.

                                  icon2gif

   A program to convert a series of editable text GIF icon specifications
   and  named  GIF  files  into  a  multi-image  GIF, usable as a graphic
   resource file. It can also dump existing GIFs in this format.

                                    Usage:

icon2gif [-q] [-a] [-d] [t TranslationTable] [-h] gif-file...

   If  no  gif-file is given, icon2gif will try to read a text input from
   stdin.

                             Specification Syntax

   Here  is a syntax summary in informal BNF. The token `NL' represents a
   required newline.

&lt;gif-spec&gt; ::= &lt;header-block&gt; &lt;image-block&gt;...

&lt;header-block&gt; ::= &lt;header-declaration&gt;...

&lt;header-declaration ::=
                | screen width &lt;digits&gt; NL
                | screen height &lt;digits&gt; NL
                | screen colors &lt;digits&gt; NL
                | screen background &lt;digits&gt; NL
                | screen map &lt;color-table&gt; NL

&lt;color-table&gt; ::= &lt;color-declaration&gt;... end NL

&lt;color-declaration&gt; ::= rgb &lt;digits&gt; &lt;digits&gt; &lt;digits&gt; is &lt;key&gt; NL

&lt;image-block&gt; ::= include &lt;file-name&gt; NL
                | image NL
                        &lt;image-declaration&gt;...
                        &lt;raster-picture&gt;
                        [ &lt;extension&gt; ]

&lt;image-declarations&gt; ::= image top &lt;digits&gt; NL
                        | image left &lt;digits&gt; NL
                        | image interlaced NL
                        | image map &lt;color-table&gt; NL
                        | image bits &lt;digits&gt; by &lt;digits&gt; NL &lt;raster-block&gt;

&lt;extension&gt; := &lt;comment&gt; NL &lt;extension-block&gt; NL end NL
                | &lt;plaintext&gt; NL &lt;extension-block&gt; NL end NL
                | extension &lt;hex-digits&gt; NL &lt;extension-block&gt; NL end NL

   If  the  semantics  of  the  `screen  height', `screen width', `screen
   background',  `image top', `image left' declarations aren't obvious to
   you, what are you doing with this software?

   A  color  table declares color indices (in ascending order from 0) and
   assiciates  them  with  key  characters. These characters can later be
   used  in raster blocks. As these must be printable and non-whitespace,
   you can only specify 94 colors per icon. Life is like that sometimes.

   A  raster  block is just a block of key characters. It should be sized
   correctly for the `image bits' declaration that leads it.

   The  `comment'  or  `plaintext'  keywords lead defined GIF89 extension
   record   data  (the  other  two  GIF89  types,  graphics  control  and
   application   block,   are  not  yet  supported).  You  can  also  say
   `extension'  followed  by  a  hexadecimal  record  type.  All of these
   extension  declarations  must be followed by an extension block, which
   is terminated by the keyword `end' on its own line.

   An  extension  block  is a series of text lines, each interpreted as a
   string  of bytes to fill an argument block (the terminating newline is
   stripped).  Text  may  include  standard C-style octal and hex escapes
   preceded by a backslash.

   All tokens are interpreted as decimal numerals; tokens are interpreted
   as  two  hex digits (a byte). All coordinates are zero-origin with the
   top  left corner (0,0). Range checking is weak and signedness checking
   nonexistent; caveat hacker!

   In  general, the amount of whitespace and order of declarations within
   a  header  or  image  block  is  not significant, except that a raster
   picture must immediately follow its `image bits' bits declaration.

   The  `include' declaration includes a named GIF as the next image. The
   global  color  maps  of  included  GIFs are merged with the base table
   defined  by  any `screen color' declaration. All images of an included
   multi-image GIF will be included in order.

   Comments may be preceded with `#' and will be ignored.

                               Memory required:

   For  the compilation mode, proportional to the size of the input file.
   For dumping, proportional to the line size of the widest GIF.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-d]
          Dump the input GIF file(s) into the text form described above.

   [-t]
          Specify name characters to use when dumping raster blocks. Only
          valid with -d option.

   [-h]
          Print one line of command line help, similar to Usage above.

                                     Bugs:

   Because  there  are only 94 characters unambiguously usable for raster
   blocks, an attempt to dump a GIF with a larger color map will fail.

   Error checking is rudimentary.

                                   Example:

   A  sample  icon  file  called  `sample.ico'  is  included  in  the pic
   directory.

                                    Author:

   Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: icon2gif.html</emphasis></para>
</sect2>

<sect2><title>index</title>
<programlisting>

                           Introduction to GIFLIB

   GIFLIB is a package of portable tools and library routines for working
   with  GIF  images.  You can find the latest version at the GIFLIB home
   page [1]http://www.ccil.org/~esr/giflib.

   The  Graphics  Interchange  Format(c) specification is the copyrighted
   property  of  CompuServe  Incorporated.  GIF(sm)  is  a  service  mark
   property  of  CompuServe  Incorporated. As this package existed before
   UniSys's lawyeritis attack of New Years' Day 1995, it is grandfathered
   in under their license terms and you do not have to pay fees for using
   it.

   This  package  has  been  released under an X Consortium-life freeware
   license.  Use and copy as you see fit. If you make useful changes, add
   new  tools,  or  find  and  fix  bugs,  please  send  your mods to the
   maintainers for general distribution.
   The  util  directory  includes  programs  to  clip, rotate, scale, and
   position  GIF  images. It includes an X11 viewer, code to dump GIFs to
   an  Epson-compatible  printer  in  graphics  mode, and many conversion
   utilities.  These  are  no  replacement  for  an  interactive graphics
   editor,  but  they can be very useful for scripted image generation or
   transformation.

   The  library  includes  program-callable  entry points for reading and
   writing GIF files, an 8x8 utility font for embedding text in GIFs, and
   an  error  handler.  GIF  manipulation can be done at a relatively low
   level   by  sequential  I/O  (which  automatically  does/undoes  image
   compression)  or  at  a  higher  level  by slurping an entire GIF into
   allocated core.

   This  library  speaks  both  GIF87a and GIF89. The differences between
   GIF87  and  GIF89 are minor: in the latter, the interpretation of some
   extension  block types is defined. The library never needs to actually
   interpret these, but [2]giftext notices them.

                                   Utilities

   Here  is a summary of the utilities in this package. If you're looking
   at  this  page  through  a  web browser, each utility name should be a
   hotlink to HTML documentation.

Conversion Utilities

   [3]gif2bgi
          display GIFs on IBM PC displays using the BGI (Borland) driver

   [4]gif2epsn
          dump images saved as GIF files on Epson type printers

   [5]gif2herc
          display GIFs on IBM PC displays using the Hercules graphic card

   [6]gif2iris
          display GIFs under SGI NeWs window system

   [7]gif2ps
          print GIF file on laser printers supporting PostScript

   [8]gif2rgb
          convert images saved as GIF to 24-bit RGB image(s)

   [9]gif2rle
          convert images saved as GIF to RLE (Utah raster toolkit) format

   [10]gif2x11
          display images saved as GIF files under X window system

   [11]raw2gif
          convert raw 8-bit image data into GIF files

   [12]rgb2gif
          convert 24 bit images to a GIF image using color quantization

   [13]rle2gif
          convert images saved as RLE (Utah raster toolkit) to GIF format

Test Pattern Generators

   [14]gifbg
          generate a single-color test pattern GIF

   [15]gifcolor
          generate color test patterns

   [16]gifwedge
          create a test GIF image resembling a color monitor test pattern

Image Manipulation Components

   [17]gifasm
          assemble multiple GIFs into one, or burst a multiple-mage GIF

   [18]gifclip
          clip or crop a GIF image

   [19]gifclrmp
          modify GIF image colormaps

   [20]gifcomb
          combine 2 GIF images of exactly the same size into one

   [21]giffix
          clumsily attempts to fix truncated GIF images

   [22]gifflip
          flip GIF image along X or Y axis or rotate by 90 degrees

   [23]gifinter
          convert between interlaced and non interlaced images

   [24]gifovly
          generate one composite GIF from a multiple-image GIF

   [25]gifpos
          change a GIF's screen size or recondition it.

   [26]gifrotat
          rotate a GIF through any desired angle

   [27]gifrsize
          resize a GIF by deletion or duplication of bits

   [28]gifburst
          burst a GIF image into subrectangles.

Report Generators

   [29]giftext
          print (text only) general information about a GIF

   [30]gifhisto
          generate color-frequency histogram from a GIF

GIF Composition Tools

   [31]icon2gif
          converter/deconverter to/from an editable text format

   [32]text2gif
          generate GIF images out of regular text in 8x8 font

   [33]gifinto
          end-of-pipe fitting for GIF-processing pipelines

   [34]gifcompose
          use giflib tools to compose images

C Code Templates

   [35]giffiltr
          template code for filtering a GIF sequentially

   [36]gifspnge
          template code for filtering a GIF with in-core operations

   Under  MS-DOS,  most  filters  will  print the current input scan line
   number  (counting  up)  whenever they read image input, and will print
   output  image  line  number  (counting  down)  when  they dump output.
   Utilities  that  only  read or write always print in increasing order.
   Utilities (like GifPos that only change positions) that copy the image
   as  a  block  of  compressed  data  will print nothing --- they cannot
   identify  a  scan line number, and are enough faster that the feedback
   to the user doesn't seem necessary.

   Some of the utilities require memory on the order of the whole screen,
   while  others read one scan line at a time. Each utility HTML file has
   entry called Memory Usage which will be one of:

   Line
          memory required is on the order of one scan line

   Image
          proportional to the size of the biggest image in GIF file

   Screen
          proportional to GIF screen size

   In  all cases a byte is allocated per pixel, so an image of 320 by 200
   pixels will requires approximately 64k bytes of main memory.

                               Library Functions

   The  library  contains  two  groups  of  C  functions.  One group does
   sequential  I/O  on the stream-oriented GIF format. The other supports
   grabbing  an  entire GIF into allocated core, operating on it in core,
   and then writing the modified in-core GIF out to disk.

   Unless  you  are  on  a  286 or some other very memory-limited machine
   running under DOS, you probably want to use the second group.

   Detailed   documentation   on   the   library   entry   points  is  in
   [37]gif_lib.html.    Library    error    codes    are   described   in
   [38]liberror.html

                               The GIF Standard

   The  doc  subdurector  includes  flat-ASCII  descriptions of [39]GIF89
   format and [40]Lempel-Ziv Compression.

                                    History

   This package was originally written by Gershon Elber in 1990 on an IBM
   PC  under MS-DOS using Borland Turbo C. He made it portable to several
   UNIX environments.

   The  2.1 version featured substantial changes and additions by Eric S.
   Raymond  .  These  included  the  DGifSlurp/EGifSpew function pair for
   enabling  non-sequential  operations  on  GIF  images  and  the  tools
   icon2gif, gifovly, gifburst, and gifcompose.

   The   2.4  version  converted  all  the  docs  from  an  idiosyncratic
   plain-text formal to to HTML.

                                Package Status

   GIFLIB's  current maintainer is Eric S. Raymond. You can find his home
   page at [41]http://www.ccil.org/esr.

   GIFLIB  is  not  under  active  development,  but  bug fixes are being
   accepted.
     _________________________________________________________________


    Eric S. Raymond [42]&lt;esr@snark.thyrsus.com&gt;

References

   1. http://www.ccil.org/~esr/giflib
   2. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giftext.html
   3. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2bgi.html
   4. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2epsn.html
   5. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2herc.html
   6. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2iris.html
   7. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2ps.html
   8. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2rgb.html
   9. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2rle.html
  10. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif2x11.html
  11. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/raw2gif.html
  12. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/rgb2gif.html
  13. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/rle2gif.html
  14. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifbg.html
  15. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcolor.html
  16. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifwedge.html
  17. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifasm.html
  18. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifclip.html
  19. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifclrmp.html
  20. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcomb.html
  21. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giffix.html
  22. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifflip.html
  23. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifinter.html
  24. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifovly.html
  25. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifpos.html
  26. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifrotat.html
  27. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifrsize.html
  28. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifburst.html
  29. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giftext.html
  30. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifhisto.html
  31. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/icon2gif.html
  32. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/text2gif.html
  33. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifinto.html
  34. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifcompose.html
  35. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/giffiltr.html
  36. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gifspnge.html
  37. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif_lib.html
  38. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/liberror.html
  39. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/gif89.txt
  40. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/lzgif.txt
  41. http://www.ccil.org/esr
  42. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: index.html</emphasis></para>
</sect2>

<sect2><title>liberror</title>
<programlisting>

   Go to [1]index page.

                             GIFLIB error codes

   Errors  as  reported from the GIF_LIB library are divided to two major
   categoriess:  the  encoder  (errors  prefixed  by  E_GIF_ERR), and the
   decoder  (errors  prefixed  by D_GIF_ERR). This document explains them
   briefly:

                               Encoding errors:

   E_GIF_ERR_OpenFailed
          Message  printed  using  PrintGifError:  "Failed  to open given
          file" IO error result when attempt to open the given GIF file.

   E_GIF_ERR_WriteFailed
          Message  printed using PrintGifError: "Failed to Write to given
          file"  IO  error  result when attempt to write to the given GIF
          file.

   E_GIF_ERR_HasScrnDscr
          Message printed using PrintGifError: "Screen Descriptor already
          been set" Attempt to write second screen descriptor to same GIF
          file.  GIF file should have exactly one screen descriptor which
          should be set directly after the file is opened.

   E_GIF_ERR_HasImagDscr
          Message printed using PrintGifError: "Image Descriptor is still
          active"  Image descriptor should be sent before and image dump,
          and  no  second  image descriptor should be sent before current
          image  dump ended. This error occurred probably because current
          image was not complete.

   E_GIF_ERR_NoColorMap
          Message  printed using PrintGifError: "Neither Global Nor Local
          color  map"  An image must have either global (screen) or local
          (image) color map. Neither were given in this case.

   E_GIF_ERR_DataTooBig
          Message printed using PrintGifError: "#Pixels bigger than Width
          *  Height" The number of pixels dumped for this image is bigger
          than specified by image Height times image Width.

   E_GIF_ERR_NotEnoughMem
          Message printed using PrintGifError: "Fail to allocate required
          memory"  Once  an  attemp  is  made  to  open GIF file, special
          structures  are  allocated  to  hold  internal  data for it. If
          allocation fails this error is returned.

   E_GIF_ERR_DiskIsFull
          Message   printed  using  PrintGifError:  "Write  failed  (disk
          full?)" Writing encoded data failed.

   E_GIF_ERR_CloseFailed
          Message  printed  using  PrintGifError:  "Failed to close given
          file" Closing file failed.

   E_GIF_ERR_NotWriteable
          Message printed using PrintGifError: "Given file was not opened
          for  write" GIF files can be opened both for read (DGIF part of
          library)  and  write  (EGIF part of library). This error occurs
          when  a file is opened for read (using DGIF) is given to one of
          the encoding (EGIF) routines.

                               Encoding errors:

   D_GIF_ERR_OpenFailed
          Message  printed  using  PrintGifError:  "Failed  to open given
          file" IO error result when attempt to open the given GIF file.

   D_GIF_ERR_ReadFailed
          Message printed using PrintGifError: "Failed to Read from given
          file"  IO  error  result when attempt to write to the given GIF
          file.

   D_GIF_ERR_Notgif-file$
          Message  printed  using  PrintGifError:  "Given file is NOT GIF
          file"  GIF  files  should have special stamp identifies them as
          such, If that stamp is not found, this error is issued.

   D_GIF_ERR_NoScrnDscr
          Message  printed  using  PrintGifError:  "No  Screen Descriptor
          detected"  Each  GIF  file should have screen descriptor in its
          header.  This error will be generated if no such descriptor was
          found.

   D_GIF_ERR_NoImagDscr
          Message  printed  using  PrintGifError:  "No  Image  Descriptor
          detected"  Each  image  should  have  image  descriptor  in its
          header.  This error will be generated if no such descriptor was
          found.

   D_GIF_ERR_NoColorMap
          Message  printed using PrintGifError: "Neither Global Nor Local
          color  map"  An image must have either global (screen) or local
          (image) color map. Neither were given in this case.

   D_GIF_ERR_WrongRecord
          Message   printed   using  PrintGifError:  "Wrong  record  type
          detected"  Each  record  in GIF file has special identifier, in
          its  header.  If the record has wrong identifier, this error is
          generated.

   D_GIF_ERR_DataTooBig
          Message printed using PrintGifError: "#Pixels bigger than Width
          *  Height" The number of pixels dumped for this image is bigger
          than specified by image Height times image Width.

   D_GIF_ERR_NotEnoughMem
          Message printed using PrintGifError: "Fail to allocate required
          memory"  Once  an  attemp  is  made  to  open GIF file, special
          structures  are  allocated  to  hold  internal  data for it. If
          allocation fails this error is returned.

   D_GIF_ERR_CloseFailed
          Message  printed  using  PrintGifError:  "Failed to close given
          file" Closing file failed.

   D_GIF_ERR_NotReadable
          Message printed using PrintGifError: "Given file was not opened
          for  read"  GIF files can be opened both for read (DGIF part of
          library)  and  write  (EGIF part of library). This error occurs
          when a file is opened for write (using EGIF) is given to one of
          the decoding (DGIF) routines.

   D_GIF_ERR_ImageDefect
          Message  printed  using  PrintGifError:  "Image  is  defective,
          decoding  aborted"  This  error is generated, once the decoding
          failed - probably image is defect.

   D_GIF_ERR_EOFTooSoon
          Message  printed  using  PrintGifError:  "Image  EOF  detected,
          before image complete" This error is generated once EOF code is
          detected  in  encoded  image  before  all  the  pixels (Width *
          Height) has be decoded.
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: liberror.html</emphasis></para>
</sect2>

<sect2><title>raw2gif</title>
<programlisting>

   Go to [1]index page.

                                  raw2gif

   A program to convert RAW image data into GIF files. Only one image can
   be  handled.  The RAW image file is assumed to hold one pixel color in
   one  byte,  and  therefore the file size must be Width times Height as
   specified by the -s option below.

                                    Usage:

raw2gif [-q] -s Width Height [-p ColorMapFile] [-h] RawFile

   If  no RawFile is given, Raw2Gif will try to read RAW data from stdin.
   The generated GIF File is dumped to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   -s Width Height
          the  dimensions  of  the image MUST be specified in the command
          line.  The  RAW  image  file  size  must be exactly Width times
          Height bytes (each byte is one pixel color).

   [-p ColorMapFile]
          Color map to load for given RAW image. This file has 4 integers
          in  line  (ColorIndex Red Green Blue), and the ColorIndex is in
          order  starting from 1. See GifClrMp, which can also use/create
          these  bitmap files. If no color map is specified, uses the EGA
          16 color pallete as default color map.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: raw2gif.html</emphasis></para>
</sect2>

<sect2><title>rgb2gif</title>
<programlisting>

   Go to [1]index page.

                                  rgb2gif

   A  program  to  convert  24  bit  images  to  a  GIF image using color
   quantization.

                                    Usage:

rgb2gif [-q] [-c #Colors] [-1] -s Width Height [-h] RGBFile

   If  no  RGBFile  is  given,  RGB2Gif  will try to read a GIF file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaulte  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c #Colors]
          Specifies  number  of colors to use, in bits per pixels, so '-c
          8' specifies actually 256 colors (maximum and default).

   [-1]
          Only  one  file in the format of RGBRGB... triplets (Each of R,
          G, B is a byte) is read from input. This file size is 3 * Width
          *  Height  (see  '-s'  below.  If stdin is used for input, this
          option  is  implicitly  applied. The default (if not '-1') is 3
          files  with  the names RGBFile.R, RGBFile.G, RGBFile.B, each of
          which is Width * Height bytes.

   [-s Width Height]
          Specifies the size of the image to read.

   [-h]
          Print one line of command line help, similar to Usage above.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: rgb2gif.html</emphasis></para>
</sect2>

<sect2><title>rle2gif</title>
<programlisting>

   Go to [1]index page.

                                  rle2gif

   A  program to convert images saved as RLE (Utah raster toolkit) to GIF
   format.

                                    Usage:

rle2Gif [-q] [-c #Colors] [-h] RleFile

   If  no  RleFile  is  given,  Rle2Gif will try to read an Rle file from
   stdin.

                               Memory required:

   Screen.

                                   Options:

   [-q]
          Quiet  mode.  Defaults  off  on  MSDOS, on under UNIX. Controls
          printout of running scan lines. Use -q- to invert.

   [-c #Colors]
          Select size of color map in the output Gif file. #Colors should
          be  given  as the based 2 log of number of colors. Default is 8
          which is 256 colors, and which is also the maximum.

   [-h]
          Print one line of command line help, similar to Usage above..

                                    Notes:

   As  the RLE format allows full 24 bits per pixel (8 per primary color)
   Colors  must  be  quantized to the number of colors as set by the [-c]
   option,  above. This process is quite slow. See the quantize.c file in
   the lib directory for the code for this quantization algorithm (median
   cut).

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: rle2gif.html</emphasis></para>
</sect2>

<sect2><title>text2gif</title>
<programlisting>

   Go to [1]index page.

                                  text2gif

   A  program to generate GIF images out of regular text. Text can be one
   line or multi-line, and is converted using 8 by 8 fixed font.

                                    Usage:

text2gif [-q] [-s ClrMapSize] [-f FGClr] [-c R G B] [-t "Text"] [-h]

   This  program  reads  stdin if no text is provided on the command line
   (-t), and will dump the created GIF file to stdout.

                               Memory required:

   Line.

                                   Options:

   [-q]
   Quiet mode. Defaults off on MSDOS, on under UNIX. Controls printout of
   running scan lines. Use -q- to invert.

   [-s ClrMapSize]
   Explicitly  defines  the  size  of  the color map of the resulting gif
   image.  Usually  the  image will be bicolor with fg as color 1, unless
   [-f] is explicitly given in case the color map size will be big enough
   to  hold  it.  However it is sometimes convenient to set the color map
   size  to certain size while the fg color is small mainly so this image
   may be merged with another (images must match color map size).

   [-f FG]
   Select foreground index (background is always 0). By default it is one
   and  therefore  the  image result is bicolored. if FG is set to n then
   color  map  will be created with 2^k entries where 2^k &gt; n for minimum
   k,  assuming  k  &lt;=  8.  This  color map will be all zeros except this
   forground  index.  This  option is useful if this text image should be
   integrated into other image colormap using their colors.

   [-c R G B]
   The color to use as the foreground color. White by default.

   [-t "Text"]
   One  line  of  text can be provided on the command line. Note you must
   encapsulate  the  Text  within  quotes  if  it  has spaces (The quotes
   themselves  are  not  treated as part of the text). If no -t option is
   provided, stdin is read until end of file.

   [-h]
   Print one line command line help, similar to Usage above.

                                    Notes:

   There is a hardcoded limit of 100 the number of lines.

                                    Author:

   Gershon Elber
     _________________________________________________________________


    Eric S. Raymond [2]&lt;esr@snark.thyrsus.com&gt;

References

   1. file://localhost/home/mikal/opensource/tutorial-imaging/contrib/giflib-4.1.0/doc/index.html
   2. mailto:esr@thyrsus.com
</programlisting>
<para><emphasis>Code: text2gif.html</emphasis></para>
</sect2>




</sect2>




</sect1>

<sect1><title>libungif</title>
<para>

</para>
</sect1>


<sect1><title>Rescuing your GIF data</title>
<para>

</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following websites might be of use if you want to research the GIF format further.
</para>

<itemizedlist>
<listitem><para>http://prtr-13.ucsc.edu/~badger/software/libungif/giflib.shtml: The giflib (sometimes called libgif) website.</para></listitem>
<listitem><para>http://prtr-13.ucsc.edu/~badger/software/libungif/index.shtml: The libungif website. This library is enough of the libgif library to rescue your data out of the GIF format and into a less patent bound format.</para></listitem>
<listitem><para>http://www.cloanto.com/users/mcb/19950127giflzw.html: Entitled <quote>
The GIF Controversy: A Software Developer's Perspective</quote>, this site discusses the history of the GIF format, and Unisys' recent licensing requirements.</para></listitem>
<listitem><para>http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/GIF89a.txt: the GIF specification</para></listitem>
<listitem><para>http://www.geocities.co.jp/SiliconValley/3453/gif_info/spec/GIF89M.htm: a HTML version of the GIF 89a specification</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>

</sect1>

</chapter>
<chapter id="chap-png"><title>PNG</title>
<para><quote>
A Turbo-Studly Image Format with Lossless Compression
(Not Related to Papua New Guinea, the Pawnee National Grassland,
the Professional Numismatists Guild or the ``Pack 'N' Go'' format)
</quote> -- libpng.org</para>

<figure>
<title>Put chunk info in here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<para>
PNG
  <footnote><para>Short for Portable Network Graphics.</para></footnote>
is my favorite image format after TIFF. It is well conceived, well implemented, and very powerful. It also has some interesting features, mainly aimed at Internet use, which TIFF lacks. It is also usable in modern web browsers
  <footnote><para>For instance Netscape 4 and Internet Explorer 4 and later.</para></footnote>
, unlike TIFF. PNG is also much simpler in many respects than TIFF.
</para>

<para>
This chapter will focus on the libpng library. This isn't really a limitation, as the people behind libpng are also the people who write the PNG specification, so you're pretty safe in assuming that if it's useful and PNG does it, then libpng implements it.
</para>

<sect1><title>Introduction</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

A bunch of the examples in this chapter are based on the pngtools code I wrote a while ago, which I have updated as part of writing this chapter.
</para>

<sidebar><title>Refer to the TIFF chapter</title>
<para>
Much of the discussion in this chapter will make a whole bunch more sense if you've read the TIFF chapter. Off you go, I'll wait for you to come back...
</para>
</sidebar>
</sect1>

<sect1><title>Installation</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>Unix</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>

<sect2><title>win32</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>
</sect1>

<sect1><title>The PNG on disc format</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Opening a PNG file</title>
<para>
The first step to learning how to use libpng is probably to understand how to open a PNG file and get some data out of it. Below is a minimal example of how to open a PNG file, not including actually reading the image data...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]){
  FILE *image;
  unsigned long width, height;
  int bitdepth, colourtype;
  png_uint_32 i, j;
  png_structp png;
  png_infop info;
  unsigned char sig[8];

  // Open the file
  if ((image = fopen (argv[1], "rb")) == NULL){
    fprintf(stderr, "Could not open the specified PNG file.");
    exit(0);
  }

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL){
    fprintf(stderr, "Could not create a PNG read structure (out of memory?)");
    exit(0);
  }

  if((info = png_create_info_struct(png)) == NULL){
    fprintf(stderr, "Could not create PNG info structure (out of memory?)");
    exit(0);
  }

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct
  if(setjmp(png_jmpbuf(png))){
    fprintf(stderr, "Could not set PNG jump value");
    exit(0);
  }

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

  // This cleans things up for us in the PNG library
  fclose(image);
  png_destroy_read_struct(&amp;png, &amp;info, NULL);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-open/read-infrastructure.c</emphasis></para>

<para>
In this example, we do everything we need to open a PNG image, without actually reading the image data. The steps to getting to the image data are:
</para>

<itemizedlist>
<listitem><para>Open the file ready for reading. For this we just use the c standard library's <command>FILE *</command>, unlike the libtiff examples, in which we used a <command>TIFF *</command>
  <footnote><para>In reality, the libtiff could just use the <command>FILE *</command> method internally, although they don't always, as shown by the TIFFClientOpen examples in the TIFF chapter.</para></footnote>
. I'm not aware of whether we can fake out a <command>FILE *</command> if we wanted to pull a PNG out of something other than a file, one day when I have infinite free time I really should look more into this.</para></listitem>

<listitem><para>Another thing we need to do which libtiff does for us and libpng doesn't is check that the file really is a PNG file. We do this with the <command>png_check_sig</command>() call. This expects the first 8 bytes of the file to be handed to it, which is what the <command>fread</command>() function call gets for us.</para></listitem>

<listitem><para></para></listitem>
</itemizedlist>
</sect1>

<sect1><title>PNG tags</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>pnginfo</title>
<para>
The <command>pnginfo</command> command implemented here is modeled on the <command>tiffinfo</command>, which was discussed in the TIFF chapter earlier in this tutorial. In fact, the output text is written to be as close to the <command>tiffinfo</command> command as possible.
</para>

<programlisting>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

void pnginfo_displayfile(char *, int, int);
void pnginfo_error(char *);
void *pnginfo_xmalloc(size_t);
void usage(void);

#define pnginfo_true 1
#define pnginfo_false 0

int main(int argc, char *argv[]){
  int i, optchar, extractBitmap = pnginfo_false, displayBitmap = pnginfo_false;

  // Initialise the argument that filenames start at
  i = 1;
  
  // Use getopt to determine what we have been asked to do
  while((optchar = getopt(argc, argv, "Dd")) != -1){
    switch(optchar){
    case 'd':
      displayBitmap = pnginfo_true;
      extractBitmap = pnginfo_true;
      i++;
      break;

    case 'D':
      extractBitmap = pnginfo_true;
      i++;
      break;

    case '?':
    default:
      usage();
      break;
    }
  }

  // Determine if we were given a filename on the command line
  if(argc &lt; 2)
    usage();

  // For each filename that we have:
  for(; i &lt; argc; i++)
    pnginfo_displayfile(argv[i], extractBitmap, displayBitmap);
}

void pnginfo_displayfile(char *filename, int extractBitmap, int displayBitmap){
  FILE *image;
  unsigned long imageBufSize, width, height, runlen;
  unsigned char signature;
  int bitdepth, colourtype;
  png_uint_32 i, j, rowbytes;
  png_structp png;
  png_infop info;
  unsigned char sig[8];
  png_bytepp row_pointers = NULL;
  char *bitmap;

  printf("%s...\n", filename);

  // Open the file
  if ((image = fopen (filename, "rb")) == NULL)
    pnginfo_error ("Could not open the specified PNG file.");

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("  This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL)
    pnginfo_error("Could not create a PNG read structure (out of memory?)");

  if((info = png_create_info_struct(png)) == NULL)
    pnginfo_error("Could not create PNG info structure (out of memory?)");
  
  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct

  if(setjmp(png_jmpbuf(png)))
    pnginfo_error("Could not set PNG jump value");

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

  ///////////////////////////////////////////////////////////////////////////
  // Start displaying information
  //
  // Can't fight the moonlight...
  ///////////////////////////////////////////////////////////////////////////
  
  printf("  Image Width: %d Image Length: %d\n", width, height);
  printf("  Bits/Sample: %d\n", bitdepth);
  printf("  Samples/Pixel: %d\n", info-&gt;channels);
  printf("  Pixel Depth: %d\n", info-&gt;pixel_depth);  // Does this add value?

  // Photometric interp packs a lot of information
  printf("  Colour Type (Photometric Interpretation): ");

  switch(colourtype){
  case PNG_COLOR_TYPE_GRAY:
    printf("GRAYSCALE ");
    break;

  case PNG_COLOR_TYPE_PALETTE:
    printf("PALETTED COLOUR ");
    if(info-&gt;num_trans &gt; 0) printf("with alpha ");
    printf("(%d colours, %d transparent) ", 
	   info-&gt;num_palette, info-&gt;num_trans);
    break;

  case PNG_COLOR_TYPE_RGB:
    printf("RGB ");
    break;

  case PNG_COLOR_TYPE_RGB_ALPHA:
    printf("RGB with alpha channel ");
    break;

  case PNG_COLOR_TYPE_GRAY_ALPHA:
    printf("GRAYSCALE with alpha channel ");
    break;

  default:
    printf("Unknown photometric interpretation!");
    break;
  }
  printf("\n");

  printf("  Image filter: ");
  switch(info-&gt;filter_type){
  case PNG_FILTER_TYPE_BASE:
    printf("Single row per byte filter ");
    break;

  case PNG_INTRAPIXEL_DIFFERENCING:
    printf("Intrapixel differencing (MNG only) ");
    break;

  default:
    printf("Unknown filter! ");
    break;
  }
  printf("\n");

  printf("  Interlacing: ");
  switch(info-&gt;interlace_type){
  case PNG_INTERLACE_NONE:
    printf("No interlacing ");
    break;

  case PNG_INTERLACE_ADAM7:
    printf("Adam7 interlacing ");
    break;

  default:
    printf("Unknown interlacing ");
    break;
  }
  printf("\n");

  printf("  Compression Scheme: ");
  switch(info-&gt;compression_type){
  case PNG_COMPRESSION_TYPE_BASE:
    printf("Deflate method 8, 32k window");
    break;

  default:
    printf("Unknown compression scheme!");
    break;
  }
  printf("\n");

  printf("  Resolution: %d, %d ", 
	 info-&gt;x_pixels_per_unit, info-&gt;y_pixels_per_unit);
  switch(info-&gt;phys_unit_type){
  case PNG_RESOLUTION_UNKNOWN:
    printf("(unit unknown)");
    break;

  case PNG_RESOLUTION_METER:
    printf("(pixels per meter)");
    break;

  default:
    printf("(Unknown value for unit stored)");
    break;
  }
  printf("\n");

  // FillOrder is always msb-to-lsb, big endian
  printf("  FillOrder: msb-to-lsb\n  Byte Order: Network (Big Endian)\n");

  // Text comments
  printf("  Number of text strings: %d of %d\n", 
	 info-&gt;num_text, info-&gt;max_text);

  for(i = 0; i &lt; info-&gt;num_text; i++){
    printf("    %s ", info-&gt;text[i].key);

    switch(info-&gt;text[1].compression){
    case -1:
      printf("(tEXt uncompressed)");
      break;

    case 0:
      printf("(xTXt deflate compressed)");
      break;

    case 1:
      printf("(iTXt uncompressed)");
      break;

    case 2:
      printf("(iTXt deflate compressed)");
      break;

    default:
      printf("(unknown compression)");
      break;
    }

    printf(": ");
    j = 0;
    while(info-&gt;text[i].text[j] != '\0'){
      if(info-&gt;text[i].text[j] == '\n') printf("\\n");
      else fputc(info-&gt;text[i].text[j], stdout);

      j++;
    }

    printf("\n");
  }

  // Print a blank line
  printf("\n");

  // Do we want to extract the image data? We are meant to tell the user if
  // there are errors, but we don't currently trap any errors here -- I need
  // to look into this
  if(extractBitmap == pnginfo_true){
    if (colourtype == PNG_COLOR_TYPE_PALETTE)
      png_set_expand (png);

    png_set_strip_alpha (png);
    png_read_update_info (png, info);
    
    rowbytes = png_get_rowbytes (png, info);
    bitmap =
      (unsigned char *) pnginfo_xmalloc ((rowbytes * height) + 1);
    row_pointers = pnginfo_xmalloc (height * sizeof (png_bytep));
    
    // Get the image bitmap
    for (i = 0; i &lt; height; ++i)
      row_pointers[i] = bitmap + (i * rowbytes);
    png_read_image (png, row_pointers);
    free(row_pointers);
    png_read_end (png, NULL);
    
    // Do we want to display this bitmap?
    if(displayBitmap == pnginfo_true){
      printf("Dumping the bitmap for this image:\n");

      runlen = 0;
      for(i = 0; i &lt; rowbytes * height / 3; i+=3){
	if((runlen != 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
	   &amp;&amp; (bitmap[i] == 0)) runlen++;
	else if(runlen != 0){
	  if(runlen &gt; 1) printf("* %d ", runlen);
	  runlen = 0;
	}

	if((runlen == 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
	   &amp;&amp; (bitmap[i] == 0)){
	  printf("[0, 0, 0] ");
	  runlen++;
	}
	
	if(runlen == 0)
	  printf("[%02x %02x %02x] ", (unsigned char) bitmap[i],
		 (unsigned char) bitmap[i + 1],
		 (unsigned char) bitmap[i + 2]);
      }
    }
  }

  // This cleans things up for us in the PNG library
  fclose(image);
  png_destroy_read_struct(&amp;png, &amp;info, NULL);
}

// You can bang or head or you can drown in a hole
//                                                    -- Vanessa Amarosi, Shine
void
pnginfo_error (char *message)
{
  fprintf (stderr, "%s\n", message);
  exit (42);
}

// Allocate some memory
void *
pnginfo_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pnginfo_error ("pnginfo_xmalloc failed to allocate memory");
    }

  return buffer;
}

void usage(){
  pnginfo_error("Usage: pnginfo [-d] [-D] &lt;filenames&gt;");
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pngtools/pnginfo.c</emphasis></para>
</sect2>
</sect1>

<sect1><title>Man pages</title>
<para>
To be honest, the libtiff man pages are much better than the documentation which comes with libpng. libpng has one main man page, which is included for ease of reference below.
</para>

<sect2><title>libpng</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<figure>
<title>source/png/man/libpng.3</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect2>

<sect2><title>libpng.txt</title>
<para>
<figure>
<title>More content here and make text2db work</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

</sect2>
</sect1>

<sect1><title>Conclusion</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

</chapter>

<chapter id="chap-jpeg"><title>JPEG</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>
<chapter id="chap-svg"><title>SVG</title>
<para>
SVG
  <footnote><para>Short for Scalar Vector Graphics.</para></footnote>
is a recent newcomer on the image format scene. The standard is under development by the w3c, and can be found at http://www.w3.org/TR/SVG. SVG is an interesting change from the other image formats in this tutorial for a couple of reasons, not least being that it is not a raster format like the vast majority of the others discussed in these pages. The other interesting thing about SVG is that the images are not stored in a binary form, they are stored as XML documents, which makes them very easy to edit.
</para>

<para>
This chapter will focus on the libpng library.
</para>

<sect1><title>Introduction</title>
<para>
...
</para>
</sect1>

<sect1><title>Installation</title>
<para>
...
</para>

<sect2><title>Unix</title>
<para>
...
</para>
</sect2>

<sect2><title>win32</title>
<para>
...
</para>
</sect2>
</sect1>

<sect1><title>The PNG on disc format</title>
<para>
...
</para>
</sect1>

<sect1><title>Conclusion</title>
<para>
...
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>

<chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<para>
This chapter is broken into five major sections. These are:

<itemizedlist>
<listitem><para>Discussion of the PDF format itself</para></listitem>
<listitem><para>An introduction to ClibPDF</para></listitem>
<listitem><para>An introduction to PDFLib</para></listitem>
<listitem><para>An introduction to Panda</para></listitem>
<listitem><para>Discussion of the Adobe PDF tools</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 <9F><92><9C><9F>
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis><9F><92><9C><9F></emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a lookup table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<figure>
<title>Do these</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
<sect4><title>Boolean</title>
<para>
Boolean values are represented with the words <command>true</command> and <command>false</command>.
</para>

<sect5><title>Examples</title>
<programlisting>
/ExplodeOnOpening true
/Rotate false
</programlisting>
</sect5>
</sect4>

<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 


The other type of information which can be stored in a stream is arbitary information such as the content of images (which would normally be raster information). 


An indepth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<figure>
<title>Do these</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

</sect3>
</sect2>

<sect2><title>Object structure</title>
<figure>
<title>Detail here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft PowerPoint presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>On with the libraries</title>
<para>
Now that we've discussed the format of the PDF file format, we can talk about the different options for building PDF files. The three main options are ClibPDF, PDFlib, and Panda. Adobe also sells a PDf library, but it has a reputation for being extremely expensive.
</para>

<para>
In our discussion of the three libraries, we will work through the same set of programs, to give you an opportunity to compare the three libraries. After all, they all have their own strengths, and weaknesses.
</para>
</sect1>

<sect1><title>ClibPDF</title>
<para>
ClibPDF was my first introduction to PDF generation APIs. It is available from http://www.fastio.com, and was last updated in December 1999, so it is starting to get a little old. There are still many people who use ClibPDF however.
</para>

<para>
Note that ClibPDF is not free software. The license is included below for your reference:
</para>

<figure>
<title>ClibPDF license page 1</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.0.eps">
</figure>

<figure>
<title>ClibPDF license page 2</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.1.eps">
</figure>

<figure>
<title>ClibPDF license page 3</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.2.eps">
</figure>

<figure>
<title>ClibPDF license page 4</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.3.eps">
</figure>

<figure>
<title>ClibPDF license page 5</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.4.eps">
</figure>

<figure>
<title>ClibPDF license page 6</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.5.eps">
</figure>

<figure>
<title>ClibPDF license page 7</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.6.eps">
</figure>

<figure>
<title>ClibPDF license page 8</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.7.eps">
</figure>

<figure>
<title>ClibPDF license page 9</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.8.eps">
</figure>


<para>
To summarise the license, this quote from the ClibPDF README page sums it up:
</para>

<programlisting>
This package is released under:
FastIO ClibPDF Software License 1.30, January 27, 2000.

ClibPDF and Premium ClibPDF are not public-domain or free software.
</programlisting>

<para>
This almost certainly limits what you can do with the library, and means that using the library will cost you money.
</para>

<sect2><title>Installation</title>
<para>
The first step to installing ClibPDF is to download the source from http://www.fastio.com. At the time of writing the source download is on the front page, about half way down. I can't guarantee that this wont have changed by the time you come to download the library, but then again the page hasn't changed in several years now, so it doesn't strike me a likely.
</para>

<sect3><title>Unix</title>
<para>
ClibPDF does not use configure scripts. The first step of the installation is to therefore copy your operating system's Makefile over the top of the sample Makefile. The various distributed Makefiles are:
</para>

<itemizedlist>
<listitem><para>Makefile.AIX42</para></listitem>
<listitem><para>Makefile.BSDI</para></listitem>
<listitem><para>Makefile.Cygwin</para></listitem>
<listitem><para>Makefile.FreeBSD</para></listitem>
<listitem><para>Makefile.HPUX</para></listitem>
<listitem><para>Makefile.irix62gcc</para></listitem>
<listitem><para>Makefile.MacOSX</para></listitem>
<listitem><para>Makefile.NetBSD</para></listitem>
<listitem><para>Makefile.NEXTSTEP</para></listitem>
<listitem><para>Makefile.SolarisGCC</para></listitem>
<listitem><para>Makefile.SolarisSunCC</para></listitem>
<listitem><para>Makefile.SunOS5x</para></listitem>
</itemizedlist>

<para>
If your operating system isn't listed in the available Makefiles, you'll need to copy the closest one and then edit it until the compile works.
</para>

<para>
Once you have copied your Makefile to the file named <emphasis>Makefile</emphasis>, then follow these steps to install ClibPDF...
</para>

<itemizedlist>
<listitem><para>make</para></listitem>
<listitem><para>make lib</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
You might need to edit parts of the Makefile to make the install work properly for your system.
</para>
</sect3>

<sect3><title>win32</title>
<para>
ClibPDF doesn't support win32 directly. It is however written in ANSI C, so a port shouldn't be very hard at all.

<figure>
<title>Port ClibPDF</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the ClibPDF iteration:
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cpdflib.h&gt;

int
main (int argc, char *argv[])
{
  CPDFdoc *pdf;

  // Open the document
  pdf = cpdf_open (0, NULL);
  cpdf_init (pdf);
  
  // Create a page
  cpdf_pageInit (pdf, 1, PORTRAIT, LETTER, LETTER);

  // Put some text on that page
  cpdf_beginText (pdf, 0);
  cpdf_setFont (pdf, "Times-Italic", "WinAnsiEncoding", 48.0);
  cpdf_text (pdf, 1.0, 8.0, 0.0, "Hello World");
  cpdf_endText (pdf);

  // Write the PDF out to disc
  cpdf_finalizeAll (pdf);
  cpdf_savePDFmemoryStreamToFile (pdf, "hello.pdf");
  cpdf_close (pdf);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/clibpdf/hello/hello.c</emphasis></para>

<para>
This produces a PDF which looks like (somewhat reduced from it's real size)...
</para>

<figure>
<title>ClibPDF hello world</title>
<graphic format="EPS" fileref="source/pdf/clibpdf/hello/hello.pdf.eps">
</figure>


<para>
The first block initializes ClibPDF, then we create a page, put some text on it, and then close the document.
</para>
</sect2>

<sect2><title>Initialization</title>
<programlisting>
CPDFdoc *cpdf_open(int pspdf, CPDFdocLimits *docLimits);
void cpdf_init(CPDFdoc *pdf);

char  *cpdf_getOutputFilename(CPDFdoc *pdf);
void cpdf_setOutputFilename(CPDFdoc *pdf, const char *file);
</programlisting>

<para>
ClibPDF requires multiple initialization calls. As seen in the hello world example above, we needed to call <command>cpdf_open</command> and <command>cpdf_init</command> at the start of our application. <command>cpdf_open</command> initializes ClibPDF itself, and returns a pointer to a <command>CPDFdoc</command>, which will represent our document. This pointer must then be initialized with a call to <command>cpdf_init</command>. The <command>*OutputFilename</command> functions are used to get and set the filename that the PDF document will be written to when finalized.
</para>

<figure>
<title>Can you be creating multiple PDF files at once?</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect2>

<sect2><title>Creating pages</title>
<programlisting>
int cpdf_pageInit(CPDFdoc *pdf, int pagenum, int rot, const char *mediaboxstr, const char *cropboxstr);
int cpdf_setCurrentPage(CPDFdoc *pdf, int page);
</programlisting>

<para>
Creating pages in ClibPDF is done with the <command>cpdf_pageInit</command> function. This function takes some arguements:
</para>

<itemizedlist>
<listitem><para><emphasis>CPDFdoc *pdf</emphasis>: the PDF document to add the page to</para></listitem>
<listitem><para><emphasis>int pagenum</emphasis>: the page number for the new page (the first page of a PDF is page 1)</para></listitem>
<listitem><para><emphasis>int rot</emphasis>: whether the page is PORTRAIT or LANDSCAPE (defined in the cpdflib header)</para></listitem>
<listitem><para><emphasis>const char *mediaboxstr</emphasis>: the page size string, see below</para></listitem>
<listitem><para><emphasis>const char *cropboxstr</emphasis>: the crop box for the page</para></listitem>
</itemizedlist>

<figure>
<title>Define crop box in the PDF intro</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<para>
There are some default page size strings provided by ClibPDF, although it is possible to use your own as well. The sizes provided by ClibPDF are:
</para>

<itemizedlist>
<listitem><para>LETTER</para></listitem>
<listitem><para>LEGAL</para></listitem>
<listitem><para>A4</para></listitem>
<listitem><para>B5</para></listitem>
<listitem><para>C5</para></listitem>
</itemizedlist>

<para>
There are also the following other page sizes, which for some reason aren't documented in the manual...
</para>

<itemizedlist>
<listitem><para>DL</para></listitem>
<listitem><para>EXECUTIVE</para></listitem>
<listitem><para>COMM10</para></listitem>
<listitem><para>MONARCH</para></listitem>
<listitem><para>FILM35MM</para></listitem>
</itemizedlist>

<para>
Page size strings are as embedded into the PDF document (which matches how Panda uses these strings as well). The format of the string is left, top, right, bottom. For example:
</para>

<programlisting>
0 0 612 792
</programlisting>

<para>
You can also be working on multiple pages at once. Use the <command>cpdf_setCurrentPage</command> function to switch between pages (compare this with how PDFlib and Panda implement this).
</para>
</sect2>

<sect2><title>Finalization</title>
<programlisting>
void cpdf_finalizePage(CPDFdoc *pdf, int page);
void cpdf_finalizeAll(CPDFdoc *pdf);
int cpdf_savePDFmemoryStreamToFile(CPDFdoc *pdf, const char *file);
char *cpdf_getBufferForPDF(CPDFdoc *pdf, int *length);
</programlisting>

<para>
These functions are used to finalize the PDF document. Use the <command>cpdf_finalizePage</command> function to force a page to be generated immediately. This may decrease resource usage for the PDF document. This function call is optional. <command>cpdf_finalizeAll</command> is called to write the PDF document out to the memory stream or the file on disc. If this function is not called, then the PDF file will be empty. You cannot add items to the PDF file once it has been finalized. <command>cpdf_close</command> closes the PDF file and deallocates resources which were consumed by the file.
</para>


</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<programlisting>
void cpdf_setPageDuration(CPDFdoc *pdf, float seconds);
int cpdf_setPageTransition(CPDFdoc *pdf, int type, float duration, float direction, int HV, int IO);
</programlisting>

<para>
<command>cpdf_setPageDuration</command> is self explainatory. The arguements to the <command>cpdf_setPageTransition</command> are not as obvious. They are:
</para>

<itemizedlist>
<listitem><para><empahsis>CPDFdoc *pdf</emphasis>: </para></listitem>
<listitem><para><empahsis>int type</emphasis>: </para></listitem>
<listitem><para><empahsis>float duration</emphasis>: </para></listitem>
<listitem><para><empahsis>float direction</emphasis>: </para></listitem>
<listitem><para><empahsis>int HV</emphasis>: </para></listitem>
<listitem><para><empahsis>int IO</emphasis>: </para></listitem>
</itemizedlist>

</sect2>

<sect2><title>Cool features</title>
<para>
ClibPDF has some cool features which aren't available in the other PDF generation libraries discussed in this tutorial. In brief, these are:
</para>

<itemizedlist>
<listitem><para>ClibPDF allows you to write the PDF to a memory stream, or a file, which would work well if you were byte serving the PDF on the web, or if you wanted to embed it into something like a database.</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>

<programlisting>
CPDFerrorHandler cpdf_setErrorHandler(CPDFdoc *pdf, CPDFerrorHandler handler);
void cpdf_Error(CPDFdoc *pdf, int level, const char* module, const char* fmt, ...);
CPDFglobalErrorHandler cpdf_setGlobalErrorHandler(CPDFglobalErrorHandler handler);
void cpdf_GlobalError(int level, const char* module, const char* fmt, ...);
</programlisting>

<para>
Error handling
</para>

<programlisting>
void cpdf_enableCompression(CPDFdoc *pdf, int cmpON);
</programlisting>

<para>
This function will enable compression of page descriptions, which can quite significantly reduce the size of the PDF document. This function simply enables a Flate filter on these page description streams.
</para>

<programlisting>
void cpdf_setDefaultDomainUnit(CPDFdoc *pdf, float defunit);
... and a variety of other domain function calls ...
</programlisting>

<para>
Explain domains
</para>

<programlisting>
void cpdf_useContentMemStream(CPDFdoc *pdf, int flag);
</programlisting>

<para>
This function call can be called if you want to use temporary files instead of memory buffers. This can be useful for machines which don't have much memory, but it is quite slow. You might find that you are better off simply increasing the amount of swap space allocated on the system. The ClibPDF documentation also implies that this function call is not thread safe.
</para>
</sect2>

<sect2><title>Room for improvement</title>
<programlisting>
void cpdf_setGlobalDocumentLimits(int maxPages, int maxFonts, int maxImages, int maxAnnots, int maxObjects);
</programlisting>

<para>
ClibPDF has internal limitations for the sizes of various data structures. These must be explicitly changed before the library is used if they don't fit your needs. The defaults are:
</para>

<itemizedlist>
<listitem><para><emphasis>Maximum number of pages</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of fonts</emphasis>: default value is 180</para></listitem>
<listitem><para><emphasis>Maximum number of images (rasters)</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of annotations</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of objects</emphasis>: default value is 5,000 (it is strange that this value is exposed to the user)</para></listitem>
</itemizedlist>

<para>
These values can be changed using the <command>CPDFdocLimits</command> structure, which is passed to many of the ClibPDF function calls. It is interesting to note that this gives us a perspective on the internal coding style of ClibPDF. Many of the internal structures are based on fixed size arrays, which is why the size must be known from the start. These arrays will allow for ClibPDF to be marginally faster than implementations that use linked lists, but it also decreases the utility of the library.
</para>
</sect2>






</sect1>










<sect1><title>PDFlib</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>Installation</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect3><title>Unix</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>

<sect3><title>win32</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>



<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>






</sect1>





















<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>

<programlisting>
#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage;

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("hello.pdf", "w")) == NULL)
    {
      fprintf (stderr, "Could not open hello.pdf\n");
      exit (1);
    }

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Write some text to the page
  panda_setfont (demo, panda_createfont (demo, "Times-Roman", 1,
  					 "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300, "Hello world");

  // Finished all the demoing, close the PDF document
  panda_close (demo);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/panda/hello/hello.c</emphasis></para>

<para>
Which produces...
</para>

<figure>
<title>Panda hello world</title>
<graphic format="EPS" fileref="source/pdf/panda/hello/hello.pdf.eps">
</figure>


<para>
The calling order here is very similar to ClibPDF and PDFlib, so I wont go into incredibly verbose explainations here.
</para>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>







</sect1>




























<sect1><title>Adobe products</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>


<sect1><title>Summary of the differences between PDF libraries</title>
<para>
It seems useful to provide a summary of the differences we have learnt about the various PDF libraries which are available as we worked through this chapter.
</para>

<table frame='all'><title>Differences between the PDF libraries</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Feature</entry>
  <entry>ClibPDF</entry>
  <entry>PDFlib</entry>
  <entry>Panda</entry>
  <entry>Adobe</entry>
</row>
</thead>
<tbody>

<row>
<entry>License</entry>
<entry>FastIO license. Not opensource / free software / public domain</entry>
<entry></entry>
<entry>GNU GPL Version 2</entry>
<entry></entry>
</row>

<row>
<entry>Cost</entry>
<entry>$1,000 USD+</entry>
<entry></entry>
<entry>$0</entry>
<entry></entry>
</row>


<row>
<entry>Free for non commercial use?</entry>
<entry>Yes, with conditions</entry>
<entry></entry>
<entry>Always free</entry>
<entry></entry>
</row>


<row>
<entry>DeleteMe</entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>



</tbody>
</tgroup>
</table>
</sect1>

<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
<programlisting>
%{
#include "parser.h"
#include "lexinterface.h"
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

void debuglex(char *, int, char *);
char *returnStr(char *, int);
void *pandalex_xmalloc(size_t);
void *pandalex_xrealloc(void *, size_t);
char *pandalex_xsnprintf(char *, ...);
void pandalex_error(char *);

void *
pandalex_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pandalex_error ("pandalex_xmalloc failed to allocate memory");
    }

  return buffer;
}
void *
pandalex_xrealloc (void *memory, size_t size)
{
  void *buffer;

  if ((buffer = realloc (memory, size)) == NULL)
    {
      pandalex_error ("pandalex_xrealloc failed to allocate memory");
    }

  return buffer;
}

char *
pandalex_xsnprintf (char *format, ...)
{
  char *output = NULL;
  int size, result;
  va_list ap;

  /* We start with the size of the format string as a guess */
  size = strlen (format);
  va_start (ap, format);

  while (1)
    {
      output = pandalex_xrealloc (output, size);
      result = vsnprintf (output, size, format, ap);

      if (result == -1)
        {
          /* Up to glibc 2.0.6 and Microsoft's implementation*/
          size += 100;
        }
      else
        {
          /* Check if we are done */
      if (result &lt; size)
            break;

          /* Glibc from now on */
          size = result + 1;
        }
  }

  va_end (ap);
  return output;
}

void
pandalex_error(char *msg){
fprintf(stderr, "%s\n", msg);
exit(42);
}
%}

%x BINARY
%%

&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { debuglex(yytext, -1, "version");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return VERSION;
                                                                             }

&lt;INITIAL&gt;[ \t\r\n]+              { debuglex(yytext, -1, "whitespace");
                                                                          }

&lt;INITIAL&gt;xref                    { debuglex(yytext, -1, "xref");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return XREF;
                                                                             }

&lt;INITIAL&gt;trailer                 { debuglex(yytext, -1, "trailer");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return TRAILER;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+,]+ { debuglex(yytext, -1, "name");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;\/[#a-zA-Z\-_0-9\.\+]+ { debuglex(yytext, -1, "dbllt-name");
                            yyless(2);
                            return DBLLT;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+]+\&gt;\&gt;     { debuglex(yytext, -1, "name-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
}

                        /* --- stuff required for objects ---               */
&lt;INITIAL&gt;R                       { debuglex(yytext, -1, "object reference");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\&gt;\&gt;                       { debuglex(yytext, -1, "object-reference-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\/                       { debuglex(yytext, -1, "object-reference-namestart");
                            yyless(yyleng - 1);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;obj                     { debuglex(yytext, -1, "obj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJ; 
                                                                             }

&lt;INITIAL&gt;endobj                  { debuglex(yytext, -1, "endobj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return ENDOBJ; 
                                                                             }

&lt;INITIAL&gt;stream                  { debuglex(yytext, -1, "stream");
                          BEGIN(BINARY);
                          return STREAM;                                     }

&lt;INITIAL&gt;[+-]?[0-9]+             { debuglex(yytext, -1, "integer");
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\&gt;\&gt;             { debuglex(yytext, -1, "integer-dblgt");
                            yyless(yyleng - 2);
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }


&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { debuglex(yytext, -1, "floating point");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return FP; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt;     { debuglex(yytext, -1, "floating point");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return FP; 
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;                    { debuglex(yytext, -1, "&lt;&lt;");
                            return DBLLT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;");
                            return DBLGT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;&gt;&gt;");
                            yyless(yyleng - 2);
                            return DBLGT; 
                                                                             }


&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\]*)+ { 
                          debuglex(yytext, -1, "string");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;

                            if(strcmp(yytext, "endstream") == 0){
                              BEGIN(INITIAL);
                              return ENDSTREAM;
                              }

                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\[(([^\[\]])|(\\\[)|(\\\]))*\] {
                          debuglex(yytext, -1, "bracketted string v1");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng); 
                            yylval.sval.len = yyleng;
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\((([^\(\)])|(\\\()|(\\\)))*\) {
                          debuglex(yytext, -1, "bracketted string v2");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\&lt;(([^\&lt;\&gt;])|(\\\&lt;)|(\\\&gt;))*\&gt; {
                          debuglex(yytext, -1, "bracketted string v3");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\\/]*)+\&gt;\&gt; { 
                          debuglex(yytext, -1, "string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;[\[\(][#&lt;&gt;a-zA-Z0-9\.\ :'+\-_\\\(\)]+[\)\]]\&gt;\&gt; {
                          debuglex(yytext, -1, "bracketted-string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

                        /* --- Array handling ---                           */

&lt;INITIAL&gt;\[                      { debuglex(yytext, -1, "[");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ARRAY; 
                                                                             }

&lt;INITIAL&gt;\]                      { debuglex(yytext, -1, "]");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

&lt;INITIAL&gt;\]\&gt;\&gt;                      { debuglex(yytext, -1, "]");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

                        /* --- Stuff needed for the xref and trailer ---    */

&lt;INITIAL&gt;\%\%EOF                 { debuglex(yytext, -1, "end of file");
                            return PDFEOF; 
                                                                             }

                        /* --- Stuff used to match binary streams --- 

                               The following amazing production is
                               used to deal with the massive
                               streams that images can create              */

&lt;BINARY&gt;[^end]+           { debuglex(yytext, yyleng, "binary mode");
                          yylval.sval.data = (char *) returnStr(yytext, yyleng);
                          yylval.sval.len = yyleng;
                          return ANYTHING;
                                                                             }

.                       { debuglex("!", -1, "the catch all");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return ANYTHING; 
                                                                             }

%%

void debuglex(char *text, int len, char *desc){
#if defined DEBUG
  int i;

  printf("Lexer rule is \"%s\", match is \"", desc);  

  for(i = 0; i &lt; ((len == -1) ? strlen(text) : len); i++){
    if(text[i] == '\n') printf(" \\n " );
    else if(text[i] == '\t') printf(" \\t ");
    else if(text[i] == '\r') printf(" \\r ");
    else if(text[i] == ' ') printf(" sp ");
    else if(isprint(text[i])) printf("%c", text[i]);
    else printf(" \\%d ", (unsigned char) text[i]);
    }

  printf("\"\n");
#endif
}

char *returnStr(char *yytext, int len){
  char *lval;

  if((lval = malloc(sizeof(char) * 
    ((len == -1) ? strlen(yytext) : len) + 1)) == NULL)
    error("Could not make space for lexer return.");
  memcpy(lval, yytext, ((len == -1) ? strlen(yytext) : len) + 1);

  return lval;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexer.l</emphasis></para>
</sect2>

<sect2><title>lexinterface.h</title>
<programlisting>
// This file defines the callbacks that users can setup to use PandaLex

#include &lt;stdarg.h&gt;

enum{
  pandalex_event_begindocument = 0,
    pandalex_event_specver,
    pandalex_event_entireheader,
    pandalex_event_objstart,
    pandalex_event_objend,
    pandalex_event_dictitem_string,
    pandalex_event_dictitem_name,
    pandalex_event_dictitem_arraystart,
    pandalex_event_dictitem_arrayitem,
    pandalex_event_dictitem_arrayend,
    pandalex_event_dictitem_object,
    pandalex_event_dictitem_dict,
    pandalex_event_dictitem_dictend,
    pandalex_event_dictitem_int,
    pandalex_event_stream,
    pandalex_event_dictint,
    pandalex_event_xrefstart,
    pandalex_event_xrefitem,
    pandalex_event_xrefend,
    pandalex_event_trailerstart,
    pandalex_event_trailerend,
    pandalex_event_enddocument,
    pandalex_event_max
    };

// Callbacks are defined so that they have a type for the arguments they
// possess associated with them. Where possible the arguments created by the
// lexer will be converted into the types needed by the callback. If not,
// an error is returned
typedef void (*pandalex_callback_type)(int, va_list);


void pandalex_setupcallback(int, pandalex_callback_type);
void pandalex_callback(int, ...);

</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexinterface.h</emphasis></para>
</sect2>

<sect2><title>pandalex.h</title>
<programlisting>
char *pandalex_strmcat(char *, int, char *, int);
char *pandalex_strmcpy(char *, int);
int pandalex_intlen(int);
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/pandalex.h</emphasis></para>
</sect2>

<sect2><title>parser.y</title>
<programlisting>
%{
  #include "lexinterface.h"
  #include "samples.h"
  #include "pandalex.h"

  #include &lt;stdarg.h&gt;

  #define YYMAXDEPTH 50000
  #define YYERROR_VERBOSE 1

  // The callbacks
  pandalex_callback_type pandalex_callbacks[pandalex_event_max];
%}

          /* Define the possible yylval values */
%union {
  int        intVal;

  struct streamVal{
    char *data;
    int len;
  } sval;
}

%token &lt;sval&gt; VERSION
%token &lt;sval&gt; NAME
%token &lt;sval&gt; STRING
%token &lt;sval&gt; OBJREF &lt;sval&gt; OBJ &lt;sval&gt; ENDOBJ 
%token &lt;intVal&gt; INT
%token &lt;sval&gt; FP
%token &lt;sval&gt; DBLLT &lt;sval&gt; DBLGT
%token &lt;sval&gt; STREAM &lt;sval&gt; ENDSTREAM
%token &lt;sval&gt; ARRAY &lt;sval&gt; ENDARRAY &lt;sval&gt; ENDARRAYDBLGT
%token &lt;sval&gt; PDFEOF XREF TRAILER
%token &lt;sval&gt; ANYTHING

%type &lt;sval&gt; binary
%type &lt;sval&gt; header
%type &lt;sval&gt; objref
%type &lt;sval&gt; arrayvals

%type &lt;intVal&gt; dictionary
%type &lt;intVal&gt; subdictionary

%%

// completely implemented
pdf       : { pandalex_callback(pandalex_event_begindocument, ""); } 
            header { pandalex_callback(pandalex_event_entireheader, $2.data); } 
            object linear objects xref trailer endcrap
          ;

// completely implemented
header    : VERSION { pandalex_callback(pandalex_event_specver, $1.data); }
            binary { $$.data = pandalex_strmcat($1.data, $1.len, $3.data, $3.len); $$.len = $1.len + $3.len + 1; }
          ;

linear    : xref trailer { }
          |
          ;

// Clibpdf sometimes puts some binary crap at the end of the file (pointer
// problems?)
// completely implemented
endcrap   : binary { }
          |
          ;

// completely implemented
objects   : object objects
          | 
          ;

// todo_mikal: might need a .data here
object    : INT INT OBJ { pandalex_callback(pandalex_event_objstart, $1, $2); } 
            dictionary { if($5 != -1) pandalex_callback(pandalex_event_dictint, $1, $2, $5); } 
            stream ENDOBJ { pandalex_callback(pandalex_event_objend, $1, $2); }
          ;

dictionary: DBLLT dict DBLGT { $$ = -1; }
          | INT { $$ = $1; }
          | ARRAY arrayvals ENDARRAY { $$ = -1; }
          | objref { $$ = -1; }
          | NAME { $$ = -1; }
          | STRING { $$ = -1 };
          | { $$ = -1; }
          ;

subdictionary: DBLLT dict DBLGT { $$ = -1 };

dict      : NAME STRING { pandalex_callback(pandalex_event_dictitem_string, $1.data, $2.data); } dict
          | NAME NAME { pandalex_callback(pandalex_event_dictitem_name, $1.data, $2.data); } dict
          | NAME ARRAY { pandalex_callback(pandalex_event_dictitem_arraystart, $1.data); } 
              arrayvals ENDARRAY { pandalex_callback(pandalex_event_dictitem_arrayend, $1.data); } dict
          | NAME objref { pandalex_callback(pandalex_event_dictitem_object, $1.data, $2.data); } dict
          | NAME { pandalex_callback(pandalex_event_dictitem_dict, $1.data); } 
              subdictionary { pandalex_callback(pandalex_event_dictitem_dictend, $1.data); } dict
          | NAME INT { pandalex_callback(pandalex_event_dictitem_int, $1.data, $2); } dict
          | NAME FP {} dict
          | 
          ;

arrayvals : objref { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals 
          | INT { /*todo*/ } arrayvals
          | NAME { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | STRING { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | ARRAY { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | DBLLT { pandalex_callback(pandalex_event_dictitem_dict, "array-dictitem"); } 
              dict DBLGT { pandalex_callback(pandalex_event_dictitem_dictend, "array-dictitem"); } arrayvals
          | {}
          ;

// completely implemented
objref    : INT INT OBJREF { if(($$.data = (char *) malloc((pandalex_intlen($1) + pandalex_intlen($2) + 5) * sizeof(char))) == NULL){
			       fprintf(stderr, "Could not allocate enough space for objref\n");
			       exit(42);
                               }
			     
			     sprintf($$.data, "%d %d R", $1, $2);
			     $$.len = strlen($$.data) + 1;
			                       }
          ;

// completely implemented
stream    : STREAM binary ENDSTREAM { pandalex_callback(pandalex_event_stream, $2.data, $2.len); free($2); }
          |
          ;

// completely implemented: callbacks are handled in the callers to this
binary    : ANYTHING binary { $$.data = pandalex_strmcat($1.data, $1.len, $2.data, $2.len); $$.len = $1.len + $2.len; free($2); }
          | STRING binary { $$.data = pandalex_strmcpy($1.data, -1); $$.len = strlen($1.data); }
          | { $$.data = pandalex_strmcpy("", -1); $$.len = 0; }
          ;

// completely implemented
xref      : XREF INT INT { pandalex_callback(pandalex_event_xrefstart); }
              xrefitems {}
          ;

// completely implemented
xrefitems : INT INT STRING { pandalex_callback(pandalex_event_xrefitem, $1, $2, $3); }
              xrefitems
          | { pandalex_callback(pandalex_event_xrefend); }
          ;

// completely implemented
trailer   : TRAILER { pandalex_callback(pandalex_event_trailerstart); } 
              DBLLT dict DBLGT STRING INT { pandalex_callback(pandalex_event_trailerend, $6, $7); } 
              PDFEOF { pandalex_callback(pandalex_event_enddocument); }
          ;

%%

void pandalex_init(){
  int i;

  // Make sure that the callbacks default to nothing
  for(i = 0; i &lt; pandalex_event_max; ++i){
    pandalex_callbacks[i] = NULL;
  }
}

void pandalex_setupcallback(int callback, pandalex_callback_type functoid){
  pandalex_callbacks[callback] = functoid;
}

// Here we call the callbacks. This includes converting to the types that the
// callback function expects.
void pandalex_callback(int event, ...){
  va_list argptr;

  // Start accessing the arguements from the end
  va_start(argptr, event);
  
  // If no event handler is setup, then we ignore the event
  if(pandalex_callbacks[event] != NULL){
    pandalex_callbacks[event] (event, argptr);
  }
  
  // Stop with the arguements
  va_end(argptr);
}

int pandalex_parse(){
  // We are not looking into a stream at the moment
  yyparse();
}

int yyerror(char *s){
  fprintf(stderr, "\n---------------------------------------------------------------\n");
  fprintf(stderr, "PandaLex parser error (%s):\n", s);
  fprintf(stderr, "  Please send this error text, along with a copy of your PDF\n");
  fprintf(stderr, "  document (if possible) to mikal@stillhq.com, so that this can\n");
  fprintf(stderr, "  be fixed for the next release...\n\n");
  fprintf(stderr, "version = 0.4\n");
  fprintf(stderr, "last token = \"%s\" (%d) or %d\n", yylval.sval.data, yylval.sval.len, yylval.intVal);
  fprintf(stderr, "\n---------------------------------------------------------------\n");

  exit(42);
}

// Buffer overrun safe strcat
char *pandalex_strmcat(char *dest, int destLen, char *append, int appendLen){
  char *new;
  int count, len;

  // What length do we need?
  if((new = (char *) malloc(sizeof(char) * 
			    (((destLen == -1) ? strlen(dest) : destLen) + 
			    ((appendLen == -1) ? strlen(append) : appendLen) + 
			    2))) == NULL){
    fprintf(stderr, "Could not malloc enough space\n");
    exit(42);
  }
  
  if((destLen == -1) &amp;&amp; (appendLen == -1))
    sprintf(new, "%s%s", dest, append);
  else{
    // We need to copy characters the hard way -- change this to a memcpy
    count = 0;

    for(len = 0; len &lt; ((destLen == -1) ? strlen(dest) : destLen); len++){
      new[count] = dest[len];
      count++;
    }

    for(len = 0; len &lt; ((appendLen == -1) ? strlen(append) : appendLen); len++){
      new[count] = append[len];
      count++;
    }

    new[count] = '\0';
  }
  return new;
}

// Buffer overrun safe strcpy
char *pandalex_strmcpy(char *data, int len){
  return pandalex_strmcat(data, len, "", 0);
}

int pandalex_intlen(int number){
  int length = 0;

  while(number &gt; 0){
    length ++;
    number /= 10;
  }

  return number;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/parser.y</emphasis></para>
</sect2>

<sect2><title>samples.c</title>
<programlisting>
/* A sample application using pandalex -- this is pdfdump */

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;zlib.h&gt;
#include "samples.h"
#include "lexinterface.h"

enum{
  pdfdump_dump = 0,
    pdfdump_meta
    };
int pdfdump_application;

pdfdump_dictint_list *dictint_list;

// Some demo code for how to use PandaLex
int main(int argc, char *argv[]){
  pandalex_init();

  // Parse the command line to find out what we are doing today -- this needs more thought
  if(strcmp(argv[0], "pdfmeta") == 0){
    pdfdump_application = pdfdump_meta;
  }
  else
    pdfdump_application = pdfdump_dump;

  // Setup the callbacks
  pandalex_setupcallback(pandalex_event_begindocument, pdfdump_begindocument);

  pandalex_setupcallback(pandalex_event_specver, pdfdump_specversion);
  pandalex_setupcallback(pandalex_event_entireheader, pdfdump_entireheader);
  pandalex_setupcallback(pandalex_event_objstart, pdfdump_objstart);
  pandalex_setupcallback(pandalex_event_objend, pdfdump_objend);

  pandalex_setupcallback(pandalex_event_dictitem_string, pdfdump_dictitem_string);
  pandalex_setupcallback(pandalex_event_dictitem_name, pdfdump_dictitem_name);
  pandalex_setupcallback(pandalex_event_dictitem_arraystart, pdfdump_dictitem_arraystart);
  pandalex_setupcallback(pandalex_event_dictitem_arrayitem, pdfdump_dictitem_arrayitem);
  pandalex_setupcallback(pandalex_event_dictitem_arrayend, pdfdump_dictitem_arrayend);
  pandalex_setupcallback(pandalex_event_dictitem_object, pdfdump_dictitem_object);
  pandalex_setupcallback(pandalex_event_dictitem_dict, pdfdump_dictitem_dict);
  pandalex_setupcallback(pandalex_event_dictitem_dictend, pdfdump_dictitem_dictend);
  pandalex_setupcallback(pandalex_event_dictitem_int, pdfdump_dictitem_int);

  pandalex_setupcallback(pandalex_event_stream, pdfdump_stream);
  pandalex_setupcallback(pandalex_event_dictint, pdfdump_dictint);
  
  // Initialise the dictint_list structure;
  if((dictint_list = (pdfdump_dictint_list *)
      malloc(sizeof(pdfdump_dictint_list))) == NULL){
    fprintf(stderr, "Could not initialise the dictint list\n");
    exit(42);
  }

  dictint_list-&gt;next = NULL;

  // Start parsing
  pandalex_parse();

  return 0;
}

char *pandalex_xsnprintf(char *, ...);

// Arguement is the name of the file as a char *
void pdfdump_begindocument(int event, va_list argptr){
  char *filename;

  filename = va_arg(argptr, char *);
  printf("Information for document: \"%s\"\n\n", filename);
}

void pdfdump_specversion(int event, va_list argptr){
  printf("Specification version is: %s\n", (char *) va_arg(argptr, char *));
}

void pdfdump_entireheader(int event, va_list argptr){
  int    i;
  char   *textMatch = (char *) va_arg(argptr, char *);

  printf("Entire document header is: ");

  for(i = 0; i &lt; strlen(textMatch); i++){
    if(isprint(textMatch[i])) printf("%c ", textMatch[i]);
    else printf("\\%d ", textMatch[i]);
  }

  printf("\n");
}

void pdfdump_objstart(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d started (generation %d)\n",
	 number, generation);
}

void pdfdump_objend(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d ended (generation %d)\n",
	 number, generation);
}

void pdfdump_dictitem_string(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [String] %s = \"%s\"\n", name, value);
}

void pdfdump_dictitem_name(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Name] %s = %s\n", name, value);
}

void pdfdump_dictitem_arraystart(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s starts\n", name);
}

void pdfdump_dictitem_arrayitem(int event, va_list argptr){
  char *value;
  
  value = va_arg(argptr, char *);
  printf("  [Array] %s\n", value);
}

void pdfdump_dictitem_arrayend(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s ends\n", name);
}

void pdfdump_dictitem_object(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Object reference] %s = %s\n", name, value);
}

void pdfdump_dictitem_dict(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" starts\n", name);
}

void pdfdump_dictitem_dictend(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" ends\n", name);
}

void pdfdump_dictitem_int(int event, va_list argptr){
  int value;
  char *name;

  name = va_arg(argptr, char *);
  value = va_arg(argptr, int);

  printf("  [Integer] %s = %d\n", name, value);
}

void pdfdump_stream(int event, va_list argptr){
  char *filter;
  int length;
  char *lengthObj;
  char *streamData;
  int streamDataLen;
  pdfdump_dictint_list  *now;
  int found;

  printf("  [Stream]\n");

  filter = va_arg(argptr, char *);
  length = (int) va_arg(argptr, char *);
  lengthObj = va_arg(argptr, char *);
  streamData = va_arg(argptr, char *);
  streamDataLen = va_arg(argptr, int);

  // Determine if we know the length
  switch(length){
  case -2:
    // We don't - have we seen the obj already?
    printf("    Length is stored in object\n");
    break;

  case -1:
    // It was never defined
    printf("    Length field not defined\n");
    break;

  default:
    printf("    Length is stated to be %d\n", length);
    pdfdump_procstream(filter, length, streamData, streamDataLen);
    break;
  }
}

void pdfdump_dictint(int event, va_list argptr){
  int found;
  int objnum, objgen, value;
  char *objref;
  pdfdump_dictint_list *now;

  // Get the passed information
  objnum = va_arg(argptr, int);
  objgen = va_arg(argptr, int);
  value = va_arg(argptr, int);

  printf("Do something with the dictint %d %d R = %d\n", objnum, objgen, value);

  // Information is handed to this event in a slightly different manner to
  // the stream event handler. Fix this.
  if((objref = (char *) malloc((pandalex_intlen(objnum) + pandalex_intlen(objgen) + 5) * sizeof(char))) == NULL){
    fprintf(stderr, "Could not allocate enough space for objref\n");
    exit(42);
  }
  
  sprintf(objref, "%d %d R", objnum, objgen);

  // Are we already waiting?
  now = dictint_list;
  found = 0;

  while((now-&gt;next != NULL) &amp;&amp; (found == 0)){
    if(strcmp(objref, now-&gt;value) == 0){
      // Yes -- do something
      pdfdump_procstream(now-&gt;filter, value, now-&gt;stream, now-&gt;streamlen);
      found = 1;
    }

    now = now-&gt;next;
  }

  // No -- save data and wait
  if(found == 0){
    // now is already the end of the list
    if((now-&gt;next = (pdfdump_dictint_list *)
	malloc(sizeof(pdfdump_dictint_list))) == NULL){
      fprintf(stderr, "Could not add to list of waiting streams\n");
      exit(42);
    }
    
    now-&gt;value = (char *) pandalex_strmcpy(objref, -1);
    now-&gt;filter = NULL;
    now-&gt;stream = NULL;
    now-&gt;waiting = 2;
    now = now-&gt;next;
    now-&gt;next = NULL;
  }
}

void pdfdump_procstream(char *filter, int length, char *data, int dataLen){
  char *uncompressed, *dataPtr, *linhintdesc[17];
  uLong srcLen, dstLen = 512;
  int result, i, linhintlens[17], number, count;

  linhintlens[0] = 32;
  linhintdesc[0] = pandalex_xsnprintf("Least number of objects in a page");
  linhintlens[1] = 32;
  linhintdesc[1] = pandalex_xsnprintf("Location of the first page object");
  linhintlens[2] = 16;
  linhintdesc[2] = pandalex_xsnprintf("Page objects delta bits");
  linhintlens[3] = 32;
  linhintdesc[3] = pandalex_xsnprintf("Least page length");
  linhintlens[4] = 16;
  linhintdesc[4] = pandalex_xsnprintf("Page length delta bits");
  linhintlens[5] = 32;
  linhintdesc[5] = pandalex_xsnprintf("Least content stream offset");
  linhintlens[6] = 16;
  linhintdesc[6] = pandalex_xsnprintf("Content stream offset delta bits");
  linhintlens[7] = 32;
  linhintdesc[7] = pandalex_xsnprintf("Least content stream length");
  linhintlens[8] = 16;
  linhintdesc[8] = pandalex_xsnprintf("Contents stream length delta bits");
  linhintlens[9] = 16;
  linhintdesc[9] = pandalex_xsnprintf("Greatest shared object number bits");
  linhintlens[10] = 16;
  linhintdesc[10] = pandalex_xsnprintf("Numerically greatest shared object number bits");
  linhintlens[11] = 16;
  linhintdesc[11] = pandalex_xsnprintf("Numeration object fraction bits");
  linhintlens[12] = 16;
  linhintdesc[12] = pandalex_xsnprintf("Denominator object fraction bits");
  linhintlens[13] = 16;
  linhintdesc[13] = pandalex_xsnprintf("?????");

  // Check length
  if(length &lt; 1){
    fprintf(stderr, "Stream length is not believable\n");
    return;
  }

  // Check there is a filter at all
  if(filter == NULL){
    fprintf(stderr, "This stream is not compressed!\n");
    return;
  }

  // If the stream starts with a \r or a \n or a \r\n, then these should be stripped off
  dataPtr = data;
  while((dataPtr[0] == '\r') || (dataPtr[0] == '\n')) dataPtr++;

  // Do something with the stream
  if(strcmp(filter, "FlateDecode") == 0){
    printf("Do something involving Flate\n");
    
    //    printf("--------------------------------------------------");
    //for(i = 0; i &lt; dataLen; i++)
    //  printf("%c", data[i]);
    //printf("--------------------------------------------------");


    // - 1
    for(i = -10; i &lt; 1; i++){
      srcLen = dataLen + i;
      dstLen = 512;
      printf("[%d] ", i);
     
      if((uncompressed = (char *) malloc(sizeof(char) * dstLen)) == NULL){
	fprintf(stderr, "Could not make enough space to decompress Flate stream\n");
	exit(42);
      }
      
      // We grow the output buffer until we no longer get buffer size errors
      while((result = uncompress(uncompressed, &amp;dstLen, dataPtr, srcLen)) == Z_BUF_ERROR){
	printf(".");
	fflush(stdout);
	
	dstLen *= 2;
	if(((uncompressed = (char *) realloc(uncompressed, dstLen)) == NULL) ||
	   (dstLen &gt; 10000000)){
	  // We could not grow the buffer, so we exit
	  printf("!");
	  fflush(stdout);
	  free(uncompressed);
	  break;
	}
      }

      if(result == Z_OK) printf(" HIT");
      printf(" *\n");
    }
    
    if(result != Z_OK){
      fprintf(stderr, "Flate decompression failed because of ");
      
      switch(result){
      case Z_MEM_ERROR:
	fprintf(stderr, "not enough memory\n");
	break;
	
      case Z_DATA_ERROR:
	fprintf(stderr, "corrupt input data\n");
	break;

      case Z_BUF_ERROR:
	fprintf(stderr, "buffer error\n");
	break;

      default:
	fprintf(stderr, "unknown error (%d)\n", result);
	break;
      }
      
      debuglex(data, srcLen, "Flate compression failure", 0);
      exit(46);
    }
    
    printf("\n");
    printf("----------- UNCOMPRESSED STREAM IS -------------------------------------------\n");
    // printf("%s\n", uncompressed);
    printf("Total uncompressed size: %d\n\n", dstLen);

    count = 0;

    for(i = 0; count &lt; 13;){
      number = 0;
      if(linhintlens[count] == 16){
	number = uncompressed[i] &lt;&lt; 8 | uncompressed[i + 1];
	i += 2;
      }
      else{
	number = uncompressed[i] &lt;&lt; 24 | uncompressed[i + 1] &lt;&lt; 16 |
	  uncompressed[i + 2] &lt;&lt; 8 | uncompressed[i + 3];
	i += 4;
      }

      printf("%s [%d]: %d\n", linhintdesc[count], linhintlens[count], number);
      count++;
    }

    printf("\nTotal bytes used: %d\n", i);
    printf("\n------------------------------------------------------------------------------\n");
  }
  else if(strcmp(filter, "LZWDecode") == 0){
    printf("LZW compression is encumbered by Patents and therefore not supported\n"); 
  }
  else if(strcmp(filter, "CCITTFaxDecode") == 0){
    printf("Do something involving CCITTFax compression (TIFF)\n");
  }
  else{
    printf("Unknown filter \"%s\"\n", filter);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.c</emphasis></para>
</sect2>

<sect2><title>samples.h</title>
<programlisting>
void pdfdump_begindocument(int, va_list);
void pdfdump_specversion(int, va_list);
void pdfdump_entireheader(int, va_list);
void pdfdump_objstart(int, va_list);
void pdfdump_objend(int, va_list);

void pdfdump_dictitem_string(int, va_list);
void pdfdump_dictitem_name(int, va_list);
void pdfdump_dictitem_arraystart(int, va_list);
void pdfdump_dictitem_arrayitem(int, va_list);
void pdfdump_dictitem_arrayend(int, va_list);
void pdfdump_dictitem_object(int, va_list);
void pdfdump_dictitem_dict(int, va_list);
void pdfdump_dictitem_dictend(int, va_list);
void pdfdump_dictitem_int(int, va_list);

void pdfdump_stream(int, va_list);
void pdfdump_dictint(int, va_list);
void pdfdump_procstream(char *, int, char *, int);

// This data type is needed for pdfdump_stream and 
// pdfdump_dictint
typedef struct pdfdump_internal_dictint_list{
  char *value;
  int waiting;
  int number;

  char *stream;
  int streamlen;
  char *filter;

  struct pdfdump_internal_dictint_list  *next; 
} pdfdump_dictint_list;
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.h</emphasis></para>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the three libraries discussed here).</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>
</sect1>

</chapter>
<chapter id="chap-imagemagick"><title>Imagemagick</title>
<para>
There are also a few topics which are important enough to be mentioned here, but haven't found their way into the discussions in any other place. They therefore get a chapter of their own here at the end.
</para>

<sect1><title>ImageMagick</title>
<para>
Available from: xxx
Installation steps; ./configure; make; make install
</para>

<para>
<figure>
<title>I'm only really talking about convert here -- what about the others?</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<para>
ImageMagick provides a series of convenient tools for converting and manipulating images. This includes converting between formats, changing the color space attributes, downsampling, scaling, rotation and text annotation. It should be noted that ImageMagick doesn't implement an API -- in other words it is a command line tool, which isn't really suited to being built into applications. ImageMagick also depends on many other packages (such as libtiff) being available for all it's functionality to work. These required helper packages are called "delegates".
</para>

<sect2><title>Example: Converting between image formats</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Scaling an image</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Rotating an image</title>
<para>
...
</para>
</sect2>

<sect2><title>Example: Inserting text annotations onto an image</title>
<para>
...
</para>
</sect2>

<sect2><title>A sample script -- generating a history of CVS commits to a repository</title>
<para>
Now it's time to provide an example of how the ImageMagick commands can be used to create something quite useful. This example is a script I wrote a few months ago to generate a graphical history of a CVS repository. The script takes the output of the <command>cvs log</command> command, and parses this. The <command>cvs log</command> output looks something like this:
</para>

<para>
<figure>
<title> should this be cut down a little</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<programlisting>
<programlisting>
? source/.deps
? source/sample
? source/.xvpics
? source/ui

RCS file: /cvs/cvs001/source/Makefile,v
Working file: source/Makefile
head: 1.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4;	selected revisions: 4
description:
----------------------------
revision 1.4
date: 2002/05/29 02:27:58;  author: u964076;  state: Exp;  lines: +16 -6
Mikal: Imported shamelessly stolen sample code from wx windows... This will hopefully become the basis for our user interface. Also modified the autotools stuff so that it all compiles cleanly. Some users might need to install wx windows before ui will build for them...
----------------------------
revision 1.3
date: 2002/05/04 03:20:26;  author: u964076;  state: Exp;  lines: +3 -4
Mikal: Code changes for the dataset storage
----------------------------
revision 1.2
date: 2002/04/30 23:58:09;  author: u964076;  state: Exp;  lines: +27 -50
Mikal: Added cepWindows to build process
----------------------------
revision 1.1
date: 2002/04/20 14:44:04;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/Makefile.am,v
Working file: source/Makefile.am
head: 1.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4;	selected revisions: 4
description:
----------------------------
revision 1.4
date: 2002/05/29 02:27:58;  author: u964076;  state: Exp;  lines: +2 -1
Mikal: Imported shamelessly stolen sample code from wx windows... This will hopefully become the basis for our user interface. Also modified the autotools stuff so that it all compiles cleanly. Some users might need to install wx windows before ui will build for them...
----------------------------
revision 1.3
date: 2002/05/04 03:20:26;  author: u964076;  state: Exp;  lines: +1 -1
Mikal: Code changes for the dataset storage
----------------------------
revision 1.2
date: 2002/04/30 23:58:09;  author: u964076;  state: Exp;  lines: +1 -1
Mikal: Added cepWindows to build process
----------------------------
revision 1.1
date: 2002/04/20 14:44:04;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/Makefile.in,v
Working file: source/Makefile.in
head: 1.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4;	selected revisions: 4
description:
----------------------------
revision 1.4
date: 2002/05/29 02:27:58;  author: u964076;  state: Exp;  lines: +14 -4
Mikal: Imported shamelessly stolen sample code from wx windows... This will hopefully become the basis for our user interface. Also modified the autotools stuff so that it all compiles cleanly. Some users might need to install wx windows before ui will build for them...
----------------------------
revision 1.3
date: 2002/05/04 03:20:26;  author: u964076;  state: Exp;  lines: +3 -4
Mikal: Code changes for the dataset storage
----------------------------
revision 1.2
date: 2002/04/30 23:58:09;  author: u964076;  state: Exp;  lines: +24 -47
Mikal: Added cepWindows to build process
----------------------------
revision 1.1
date: 2002/04/20 14:44:05;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/NEWS,v
Working file: source/NEWS
head: 1.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1.1
date: 2002/04/20 14:44:05;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/README,v
Working file: source/README
head: 1.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1.1
date: 2002/04/20 14:44:05;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/TODO,v
Working file: source/TODO
head: 1.2
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1.2
date: 2002/04/30 23:54:42;  author: u964076;  state: Exp;  lines: +1 -0
Mikal: Updated changelog
----------------------------
revision 1.1
date: 2002/04/20 14:44:05;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

RCS file: /cvs/cvs001/source/aclocal.m4,v
Working file: source/aclocal.m4
head: 1.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1.1
date: 2002/04/20 14:44:05;  author: u964076;  state: Exp;
Mikal: Imported initial source tree
=============================================================================

...and so on...
</programlisting>
<para><emphasis>Code: source/imagemagick/cvsreport/sample.log</emphasis></para>
</programlisting>

<para>
The following perl script parses this log file to produce a HTML description of the activity described by the log:
</para>

<programlisting>
<programlisting>
#!/usr/local/bin/perl

use strict;
my($HISTORY, $filename, $date, %dateline, $day, $adate, @dates,
   $author, %cols, $newcolnum, @today, @html, $event, $file, $user, $i,
   $table, %authorcolor, @colors, $newauthnum, %heading, $color, $temp,
   $revision, $lines, $state, %authorcommits, $nowmonth, $prevmonth,
   @monthnames, $headerhtml, $loghtml, $nowyear);

open HISTORY, "&lt; logout";

# We need some colors for authors -- I only bother to define 10 here
$colors[0] = "CC3399";
$colors[1] = "9900FF";
$colors[2] = "666699";
$colors[3] = "6699FF";
$colors[4] = "00FFCC";
$colors[5] = "66FF99";
$colors[6] = "33CC33";
$colors[7] = "99CC33";
$colors[8] = "663300";
$colors[9] = "FF6666";

# Some names for the months of the year
$monthnames[1] = "Jan";
$monthnames[2] = "Feb";
$monthnames[3] = "Mar";
$monthnames[4] = "Apr";
$monthnames[5] = "May";
$monthnames[6] = "Jun";
$monthnames[7] = "Jul";
$monthnames[8] = "Aug";
$monthnames[9] = "Sep";
$monthnames[10] = "Oct";
$monthnames[11] = "Nov";
$monthnames[12] = "Dec";

# Hoon through the CVS history
while(&lt;HISTORY&gt;){
    if(/^Working file: (.*)/){
	$filename = $1;
	chomp $filename;
    }
    elsif(/^date: ([0-9\/]+).*author: (.*);.*state: (.*);(.*)$/){
	$date = $1;
	$author = $2;
	$state = $3;
	$_ = $4;

	if(/.*lines: \+(.*) -(.*)/){
	    $lines = int($1) + int($2);
	    if($lines &gt; 100){
		$lines = "*";
	    }
	    else{
		$lines = ".";
	    }
	}
	elsif($revision eq "1.1"){
	    $lines = "I";
	    $revision = "";
	    }
	else{
	    $lines = "&amp;nbsp;";
	}

	if($state eq "dead"){
	    $lines = "D";
	}

	$date =~ s/\///g;
	$dateline{$date} = $dateline{$date} . "$filename!$author!$lines;";
    }
    elsif(/^revision (.*)/){
	$revision = $1;
    }
}

# Draw the graph
$newcolnum = 0;
$newauthnum = 0;
$table = "";
$prevmonth = "";

# For each date
@dates = sort keys %dateline;
foreach $adate (@dates) {
    for($i = 0; $i &lt; $newcolnum; $i++){
	$html[$i] = "&amp;nbsp;";
    }

    # If this is a new month, then we need to reset ourselves and draw a 
    # new header line
    $_ = $adate;
    /([0-9][0-9][0-9][0-9])([0-9][0-9])/;
    $nowmonth = $2;
    $nowyear = $1;
    if($nowmonth ne $prevmonth){
	if($prevmonth ne ""){
	    $table = $table . "&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;$monthnames[$prevmonth] $1&lt;/b&gt;&lt;/td&gt;";
	    
	    # The funky header thingie
	    $headerhtml = "";
	    for($i = 0; $i &lt; $newcolnum; $i++){
		$temp = $heading{$i};
		$temp =~ s/[\/\.]/_/g;
		if(! -e "colheader-$temp.jpg"){
		    `convert -font helvetica -pointsize 10 -draw "text 1,10 $heading{$i}" -rotate -90 blank.jpg colheader-$temp.jpg`;
		}
		$headerhtml = $headerhtml . 
		    "&lt;td&gt;&lt;img src=\"colheader-$temp.jpg\"&gt;&lt;/td&gt;";
	    }
	    
	    $table = $table . $headerhtml . $loghtml;
	}
	$loghtml = "";
	$prevmonth = $nowmonth;
	$newcolnum = 0;
	%cols = ();
    }

    @today = split(/;/, $dateline{$adate});
    foreach $event (@today){
	$_ = $event;
	/(.*)!(.*)!(.*)/;
	$file = $1;
	$user = $2;
	$lines = $3;
	
	if($lines eq ""){
	    $lines = "&amp;nbsp;";
	}

	# Do we need a new cell number?
	if($cols{$file} eq ""){
	    $cols{$file} = $newcolnum;
	    $heading{$newcolnum} = $file;
	    $newcolnum++;
	}

	# Do we need a new author color?
	if($authorcolor{$user} eq ""){
	    $authorcolor{$user} = $colors[$newauthnum];
	    $authorcommits{$user} = 0;
	    $newauthnum++;
	}

	# Increment the count of commits for this author
	$authorcommits{$user}++;

	# This could be cleaned up... Build the cell
	if($html[$cols{$file}] eq "&amp;nbsp;"){
	    $html[$cols{$file}] = "";
	}

	if($html[$cols{$file}] eq ""){
	    $html[$cols{$file}] = 
		"&lt;tr&gt;&lt;td bgcolor=\"$authorcolor{$user}\"&gt;$lines&lt;/td&gt;&lt;/tr&gt;";
	}
	else{
	    $html[$cols{$file}] = 
		"&lt;tr&gt;&lt;td bgcolor=\"$authorcolor{$user}\"&gt;$lines&lt;/td&gt;&lt;/tr&gt;" .
		    $html[$cols{$file}];
	}
    }

    # This should be improved
    for($i = 0; $i &lt; $newcolnum; $i++){
	$html[$i] = 
	    "&lt;td valign=\"top\"&gt;&lt;table width=\"100%\" cellspacing=0 cellpadding=0 bgcolor=\"000000\"&gt;" 
		. $html[$i] . "&lt;/table&gt;&lt;/td&gt;";
    }

    $loghtml = $loghtml . "&lt;tr&gt;&lt;td valign=\"top\"&gt;$adate&lt;/td&gt;@html&lt;/tr&gt;\n";
}

# And the left over month
if($prevmonth ne ""){
    $table = $table . "&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;$monthnames[$prevmonth] $nowyear&lt;/b&gt;&lt;/td&gt;";
    
    # The funky header thingie
    $headerhtml = "";
    for($i = 0; $i &lt; $newcolnum; $i++){
	$temp = $heading{$i};
	$temp =~ s/[\/\.]/_/g;
	if(! -e "colheader-$temp.jpg"){
	    `convert -font helvetica -pointsize 10 -draw "text 1,10 $heading{$i}" -rotate -90 blank.jpg colheader-$temp.jpg`;
	}
	$headerhtml = $headerhtml . 
	    "&lt;td&gt;&lt;img src=\"colheader-$temp.jpg\"&gt;&lt;/td&gt;";
    }
    
    $table = $table . $headerhtml . $loghtml;
}

print "&lt;table cellspacing=0 cellpadding=0&gt;";
print "$table&lt;/table&gt;";
print "&lt;BR&gt;&lt;HR&gt;&lt;BR&gt;Authors: ";
print "&lt;table&gt;&lt;tr&gt;";

while(($user, $color) = each %authorcolor){
    print "&lt;td bgcolor=\"$color\"&gt;$user: ";
    print `grep $user authors | sed 's/^$user://'`;
    print " ($authorcommits{$user})";
    print "&lt;/td&gt;";
}

print "&lt;/tr&gt;&lt;/table&gt;";
print "&lt;BR&gt;Key: ";
print "&lt;table&gt;&lt;tr&gt;&lt;td&gt;I: Initial import of a file&lt;/td&gt;";
print "&lt;td&gt;D: File deleted from repository&lt;/td&gt;";
print "&lt;td&gt;.: Minor code change (less than 100 lines)&lt;/td&gt;";
print "&lt;td&gt;*: Major code change (more than 100 lines)&lt;/td&gt;";
print "&lt;/tr&gt;&lt;/table&gt;";

print "&lt;BR&gt;&lt;BR&gt;END OF REPORT";
</programlisting>
<para><emphasis>Code: source/imagemagick/cvsreport/cvsreport.pl</emphasis></para>
</programlisting>

<para>
The output of the script looks something like this:
</para>

<para>
<figure>
<title> figure</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>
</sect1>
</chapter>
<chapter id="chap-conclusion"><title>Conclusion</title>
<para>
...
</para>
</chapter>
</book>
