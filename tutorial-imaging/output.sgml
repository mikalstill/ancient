<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>
</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>

<sect1><title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>
</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>
</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<sect2><title>C</title>
<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not necessarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>
</sect2>

<sect2><title>How to compile and link on your chosen operating system</title>
<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The make files included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>
</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.
</para>

<figure><title>Catherine and Andrew</title>
<graphic format="EPS" fileref="introduction-figure1.eps">
</figure>


<para>
I should also thank the following people:
</para>

<itemizedlist>
<listitem><para>Doug Jackson (doug_jackson@citadel.com.au), for proof reading and getting me interested in this whole topic to start with</para></listitem>
<listitem><para>Tony Green (greeno@bandcamp.tv), for occasional DocBook wrangling</para></listitem>
<listitem><para>Michael Smith (smith@xml-doc.org), for DocBook hints</para></listitem>
</itemizedlist>
</sect1>

<sect1><title>How this document was produced</title>
<para>
This tutorial was written in DocBook SGML using xemacs. This was then converted into PDF using the jade SGML tools. Diagrams were developed in a combination of the gimp, Adobe Illustrator, and custom developed code. Diagrams were converted to EPS as required by jade using ImageMagick.
</para>

<para>
A series of DocBook generation scripts was also used to automate some of the generation of this document. These scripts can be found in my online CVS repository at: http://www.stillhq.com/cgi-bin/cvsweb/docbooktools/
</para>

<para>
The source for this tutorial is available at: http://www.stillhq.com/cgi-bin/cvsweb/tutorial-imaging/
</para>
</sect1>

<sect1><title>License</title>
<para>
This document is covered by two licenses -- the license for the text of this document, and the license for the included source code. The license terms are set out below.
</para>

<sect2><title>License for text (OPL)</title>
<para>OPEN PUBLICATION LICENSE Draft v0.4, 8 June 1999
</para>

<sect3><title>I. REQUIREMENTS ON BOTH UNMODIFIED AND MODIFIED VERSIONS</title>

<para>The Open Publication works may be reproduced and distributed in whole or
in part, in any medium physical or electronic, provided that the terms
of this license are adhered to, and that this license or an
incorporation of it by reference (with any options elected by the
author(s) and/or publisher) is displayed in the reproduction.
</para>
<para>Proper form for an incorporation by reference is as follows:
</para>
<para>Copyright (c) &lt;year&gt; by &lt;author's name or designee&gt;. This material may
be distributed only subject to the terms and conditions set forth in the
Open Publication License, vX.Y or later (the latest version is presently
available at &lt;URL:http:// TBD&gt;).
</para>
<para>The reference must be immediately followed with any options elected by
the author(s) and/or publisher of the document (see section VI).
</para>
<para>Commercial redistribution of Open Publication-licensed material is
permitted.
</para>
<para>Any publication in standard (paper) book form shall require the citation
of the original publisher and author. The publisher and author's names
shall appear on all outer surfaces of the book. On all outer surfaces
of the book the original publisher's name shall be as large as the title
of the work and cited as possessive with respect to the title.
</para>

</sect3>

<sect3><title>II. COPYRIGHT</title>

<para>The copyright to each Open Publication is owned by its author(s) or
designee.
</para>
</sect3>

<sect3><title>III. SCOPE OF LICENSE</title>

<para>The following license terms apply to all Open Publication works, unless
otherwise explicitly stated in the document.
</para>
<para>Mere aggregation of Open Publication works or a portion of an Open
Publication work with other works or programs on the same media shall
not cause this license to apply to those other works. The aggregate work
shall contain a notice specifying the inclusion of the Open Publication
material and appropriate copyright notice.
</para>
<para>SEVERABILITY. If any part of this license is found to be unenforceable
in any jurisdiction, the remaining portions of the license remain in
force.
</para>
<para>NO WARRANTY. Open Publication works are licensed and provided "as is"
without warranty of any kind, express or implied, including, but not
limited to, the implied warranties of merchantability and fitness for a
particular purpose or a warranty of non-infringement.
</para>
<para>IV. REQUIREMENTS ON MODIFIED WORKS
</para>
<para>All modified versions of documents covered by this license, including
translations, anthologies, compilations and partial documents, must meet
the following requirements:
</para>
<itemizedlist><listitem><para>1) The modified version must be labeled as such.
2) The person making the modifications must be identified and the
modifications dated.
3) Acknowledgement of the original author and publisher if applicable
must be retained according to normal academic citation practices.
4) The location of the original unmodified document must be identified.
5) The original author's (or authors') name(s) may not be used to assert
or imply endorsement of the resulting document without the original
author's (or authors') permission.
</para>

<para>V. GOOD-PRACTICE RECOMMENDATIONS
</para>
<para>In addition to the requirements of this license, it is requested from
and strongly recommended of redistributors that:
</para>
</listitem><listitem><para>1) If you are distributing Open Publication works on hardcopy or CD-ROM,
you provide email notification to the authors of your intent to
redistribute at least thirty days before your manuscript or media
freeze, to give the authors time to provide updated documents. This
notification should describe modifications, if any, made to the
document.
</para>
</listitem><listitem><para>2) All substantive modifications (including deletions) be either clearly
marked up in the document or else described in an attachment to the
document. 
</para>
<para>Finally, while it is not mandatory under this license, it is considered
good form to offer a free copy of any hardcopy and CD-ROM expression of
an Open Publication-licensed work to its author(s).
</para>
<para>VI. LICENSE OPTIONS
</para>
<para>The author(s) and/or publisher of an Open Publication-licensed document
may elect certain options by appending language to the reference to or
copy of the license. These options are considered part of the license
instance and must be included with the license (or its incorporation by
reference) in derived works.
</para>
<para>A. To prohibit distribution of substantively modified versions without
the explicit permission of the author(s). "Substantive modification"
is defined as a change to the semantic content of the document, and
excludes mere changes in format or typographical corrections. 
</para>
<para>To accomplish this, add the phrase `Distribution of substantively
modified versions of this document is prohibited without the explicit
permission of the copyright holder.' to the license reference or
copy. 
</para>
<para>B. To prohibit any publication of this work or derivative works in whole
or in part in standard (paper) book form for commercial purposes is
prohibited unless prior permission is obtained from the copyright
holder.
</para>
<para>To accomplish this, add the phrase `Distribution of the work or
derivative of the work in any standard (paper) book form is
prohibited unless prior permission is obtained from the copyright
holder.' to the license reference or copy. 
</para>
<para>OPEN PUBLICATION POLICY APPENDIX:
</para>
<para>(This is not considered part of the license.)
</para>
<para>Open Publication works are available in source format via the Open
Publication home page at &lt;URL:tbd&gt;.
</para>
<para>Open Publication authors who want to include their own license on Open
Publication works may do so, as long as their terms are not more
restrictive than the Open Publication license.
</para>
<para>If you have questions about the Open Publication License, please contact
TBD, and/or the Open Publication Authors' List at &lt;TBD&gt;, via email.
</para>
</listitem></itemizedlist></sect2>

<sect2><title>License for source code (GPL)</title>
<para>GNU GENERAL PUBLIC LICENSE
Version 2, June 1991
</para>
<para>Copyright (C) 1989, 1991 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</para>
<para>Preamble
</para>
<para>The licenses for most software are designed to take away your
freedom to share and change it. By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users. This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it. (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.) You can apply it to
your programs, too.
</para>
<para>When we speak of free software, we are referring to freedom, not
price. Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.
</para>
<para>To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
</para>
<para>For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have. You must make sure that they, too, receive or can get the
source code. And you must show them these terms so they know their
rights.
</para>
<para>We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
</para>
<para>Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software. If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
</para>
<para>Finally, any free program is threatened constantly by software
patents. We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary. To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.
</para>
<para>The precise terms and conditions for copying, distribution and
modification follow.
</para><beginpage>
<para>GNU GENERAL PUBLIC LICENSE
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
</para>
<itemizedlist><listitem><para>0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License. The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language. (Hereinafter, translation is included without limitation in
the term "modification".) Each licensee is addressed as "you".
</para>
<para>Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope. The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.
</para>
</listitem><listitem><para>1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.
</para>
<para>You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.
</para>
</listitem><listitem><para>2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:
</para>
<para>a) You must cause the modified files to carry prominent notices
stating that you changed the files and the date of any change.
</para>
<para>b) You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.
</para>
<para>c) If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License. (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)
</para>
<para>These requirements apply to the modified work as a whole. If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works. But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.
</para>
<para>Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.
</para>
<para>In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.
</para>
</listitem><listitem><para>3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:
</para>
<para>a) Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,
</para>
<para>b) Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,
</para>
<para>c) Accompany it with the information you received as to the offer
to distribute corresponding source code. (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)
</para>
<para>The source code for a work means the preferred form of the work for
making modifications to it. For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable. However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.
</para>
<para>If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.
</para></listitem></itemizedlist><beginpage>
<itemizedlist><listitem><para>4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License. Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.
</para>
</listitem><listitem><para>5. You are not required to accept this License, since you have not
signed it. However, nothing else grants you permission to modify or
distribute the Program or its derivative works. These actions are
prohibited by law if you do not accept this License. Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.
</para>
</listitem><listitem><para>6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions. You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.
</para>
</listitem><listitem><para>7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License. If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all. For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.
</para>
<para>If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.
</para>
<para>It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices. Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.
</para>
<para>This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.
</para></listitem></itemizedlist><beginpage>
<itemizedlist><listitem><para>8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded. In such case, this License incorporates
the limitation as if written in the body of this License.
</para>
</listitem><listitem><para>9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time. Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
</para>
<para>Each version is given a distinguishing version number. If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation. If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.
</para>
</listitem><listitem><para>10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission. For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this. Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
</para>
<para>NO WARRANTY
</para>
</listitem><listitem><para>11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
</para>
</listitem><listitem><para>12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
</para>
<para>END OF TERMS AND CONDITIONS
</para></listitem></itemizedlist><beginpage>
<para>How to Apply These Terms to Your New Programs
</para>
<para>If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.
</para>
<para>To do so, attach the following notices to the program. It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.
</para>
<para>&lt;one line to give the program's name and a brief idea of what it does.&gt;
Copyright (C) 19yy &lt;name of author&gt;
</para>
<para>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
</para>
<para>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
</para>
<para>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
</para>

<para>Also add information on how to contact you by electronic and paper mail.
</para>
<para>If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
</para>
<para>Gnomovision version 69, Copyright (C) 19yy name of author
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
</para>
<para>The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License. Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.
</para>
<para>You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary. Here is a sample; alter the names:
</para>
<para>Yoyodyne, Inc., hereby disclaims all copyright interest in the program
`Gnomovision' (which makes passes at compilers) written by James Hacker.
</para>
<para>&lt;signature of Ty Coon&gt;, 1 April 1989
Ty Coon, President of Vice
</para>
<para>This General Public License does not permit incorporating your program into
proprietary programs. If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library. If this is what you want to do, use the GNU Library General
Public License instead of this License.
</para>
</sect2>

<sect2><title>License for the libtiff man pages</title>
<para>
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.
</para>

<para>
Permission to use, copy, modify, distribute, and sell this software and 
its documentation for any purpose is hereby granted without fee, provided
that (i) the above copyright notices and this permission notice appear in
all copies of the software and related documentation, and (ii) the names of
Sam Leffler and Silicon Graphics may not be used in any advertising or
publicity relating to the software without the specific, prior written
permission of Sam Leffler and Silicon Graphics.
</para>

<para>
THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
</para>

<para>
IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
OF THIS SOFTWARE.
</para>
</sect2>

<sect2><title>License for some ClibPDF examples</title>
<para>
Some ClibPDF examples are subject to the ClibPDF license, which is included in the PDF chapter of this tutorial.
</para>
</sect2>
</sect1>
</chapter>
<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day. This section presents these things in alphabetical order, for ease of reference.
</para>

<para>
These terms are presented in alphabetical order. Some of them might seem a bit odd, but they're here because the are interesting...
</para>

<sect1><title>Anti-aliasing</title>
<para>
Imagine that you are drawing a triangle across an image (or on the screen for that matter). The triangle is sometimes going to cross pixels in a way which makes them not totally turned on. Have a look at the figure below to see what I mean...
</para>

<figure><title>Drawing a triangle</title>
<graphic format="EPS" fileref="antialias-figure1.eps">
</figure>

<para>
If we only have a black and white image, then we'll end up with an image like the one in the figure below. I am sure you'll agree that this isn't a very good representation of the side of the triangle.
</para>

<figure><title>A triangle with only black pixels</title>
<graphic format="EPS" fileref="antialias-figure2.eps">
</figure>

<para>
Anti-aliasing is when we try to correct for this problem by inserting some gray pixels. In the figure below, we have given some of the pixels a gray value which is based on how much of the pixel is <quote>filled</quote> with the triangle.
</para>

<figure><title>A triangle with gray scale pixels</title>
<graphic format="EPS" fileref="antialias-figure3.eps">
</figure>

<para>
The triangle might be a little clearer without the grid lines.
</para>

<figure><title>Anti-aliased triangle without grid lines</title>
<graphic format="EPS" fileref="antialias-figure4.eps">
</figure>

<para>
For comparison, there is the triangle we started with...
</para>

<figure><title>The original triangle</title>
<graphic format="EPS" fileref="antialias-figure5.eps">
</figure>

<para>
So, in summary, anti-aliasing is the process of turning on some extra gray scale pixels to improve the look of shapes we are drawing...
</para>
</sect1>
<sect1><title>Encrypting images</title>
<para>
DES in Electronic Code Book (ECB) mode is a particularly poor choice of cryptography for image files. This is because ECB mode implements a look up table between the unencrypted value and the encrypted value. This results in a known input value turning into the same output value over and over. This can have some interesting blurring effects, but wont obscure the image contents. An example will help this make more sense -- the first figure is the logo for the company I am currently working for. I took this image, and ran it through some DES ECB code and produced the second figure.
</para>

<figure><title>The TOWER corporate logo</title>
<graphic format="EPS" fileref="desecb-figure1.eps">
</figure>

<figure><title>After ECB encryption</title>
<graphic format="EPS" fileref="desecb-figure2.eps">
</figure>

<para>
You can see that whilst the image has certainly changed, the contents of the image has not really been obscured. 
</para>



<para>
We should note that ECB mode is not commonly used anyway. If you use something like PGP or blowfish, then you should be much happier... 
</para>
</sect1>
<sect1><title>Gray scale conversion</title>
<para>
How do you convert color images to gray scale? Well, my instant answer when I first had to do this was to just average the red, green and blue values. That answer is wrong. The reality is that the human eye is much better at seeing some colors than others. To get an accurate gray scale representation, you need to apply different coefficients to the color samples. Appropriate coefficients are 0.299 for red, 0.587 for green and 0.114 for blue.</para>

<para>
Below I have included several pictures that illustrate this concept. The first figure is a color image
  <footnote><para>Which may or may not give you joy, depending on if you are viewing this document in color or not</para></footnote>
, the second is the color image converted to gray scale without the coefficients applied, and the third image is a correct gray scale rendition.
</para>

<figure><title>The original image</title>
<graphic format="EPS" fileref="grayscale-figure1.eps">
</figure>

<figure><title>An average of the color values for each pixel</title>
<graphic format="EPS" fileref="grayscale-figure2.eps">
</figure>

<figure><title>A correct conversion to gray scale</title>
<graphic format="EPS" fileref="grayscale-figure3.eps">
</figure>

<para>
You can see that the sensible algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>

<para>
The source code to generate these example images may be found in the TIFF chapter.
</para>
</sect1>
<sect1><title>Pixel</title>
<para>
     <indexterm><primary>Pixel</primary></indexterm>
A pixel is the lowest unit of raster image description -- in other words, a raster image is defined in terms of pixels. Example pixels can be seen in the discussion of rasters, later in this chapter.
</para>
</sect1>

<sect1><title>Rasters</title>
<para>
     <indexterm><primary>Raster</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>raster</secondary></indexterm>
The most common image format (and the focus of the majority of this tutorial) is raster image formats. Raster image formats are those which store the picture as a bitmap
     <footnote><para>You can think of a bitmap as being simply an array of pixels. We'll talk more about this later</para></footnote>
describing the state of pixels, as opposed to recording the length and locations of primatives such as lines and curves. Common examples include the output of photoshop, the gimp, scanners and digital cameras. Effectively, your monitor and printer are raster output devices.
</para>

<figure><title>A sample raster image</title>
<graphic format="EPS" fileref="raster-figure1.eps">
</figure>

<para>
Raster image formats include TIFF, GIF, PNG, and most of the other formats in this tutorial. If in doubt, assume that it's a raster format unless I tell you otherwise.
</para>

<para>
If we zoom in enough on a portion of this image, we can see that it is made up of descrete elements -- the pixels. 
</para>

<figure><title>Zooming in on a portion of the raster image</title>
<graphic format="EPS" fileref="raster-figure2.eps">
</figure>

<para>
The code to produce this zoomed image is presented in the TIFF chapter of this tutorial.
</para>
</sect1>
<sect1><title>Theory of color and gray scale storage</title>
<para>
There are several ways that the value of a pixel can be stored within a raster image. This is a pretty fundamental concept, so it is best to get it out of the way early on before we get caught up in the actual format of images.
</para>

<figure><title>The worst picture of a house you have ever seen</title>
<graphic format="EPS" fileref="theory-figure1.eps">
</figure>

<para>
I will use the simple image above to demonstrate the ways that the pixel values can be stored...
</para>

<figure><title>A zoom in on the house</title>
<graphic format="EPS" fileref="theory-figure2.eps">
</figure>

<para>
We'll in fact only use a zoomed in portion of the image so that what is happening is clearer.
</para>

<sect2><title>Direct storage of black and white</title>
<figure><title>A black and white zoom in</title>
<graphic format="EPS" fileref="theory-figure3.eps">
</figure>

<para>
Black and white images only really have one pixel value storage option. This is to store the value of the pixel directly at the pixel location in the image data itself. This is a good option for black and white data, because it only takes on bit per pixel anyway.
</para>

<figure><title>Black and white data</title>
<graphic format="EPS" fileref="theory-figure4.eps">
</figure>

<para>
Whilst this is a very simple example, make sure you understand how the diagram works, because it gets more complex from here. Each square represents the storage space in the image data, and in this example the values representing the pixel values is stored inside the image data.
</para>
</sect2>

<sect2><title>Direct gray scale storage</title>
<figure><title>A gray scale zoom in</title>
<graphic format="EPS" fileref="theory-figure5.eps">
</figure>

<para>
In this example, we are storing the gray scale values of the pixels within the image data.
</para>
</sect2>

<sect2><title>Direct RGB storage</title>
<figure><title>A RGB zoom in</title>
<graphic format="EPS" fileref="theory-figure6.eps">
</figure>

<para>
Here we are storing the red green and blue values for each pixel within the image data.
</para>
</sect2>

<sect2><title>Paletted RGB storage</title>
<figure><title>A paletted RGB zoom in</title>
<graphic format="EPS" fileref="theory-figure7.eps">
</figure>

<para>
The other option is to instead store within the image data itself a number which uniquely identifies the color at that pixel. We can then have a table elsewhere in the image file which defines the color that is that unique value. This table is a palette, and this is a very common way of storing RGB data (it is in fact the only option with some formats such as GIF).
</para>

<para>
You can also use palettes for gray scale images, I just haven't provided an example of that here.
</para>

<sect3><title>The advantage of paletting</title>
<para>
The big advantage of paletting an image is that the final file is going to be much smaller. For example, an A4 page is 1754 by 2479 pixels. That's 4,348,166 pixels. Now, let's assume for this example that the image is 24 bit color (that is 8 bits per color per pixel), and that there are seven colors in the image. That means that unpaletted, we have 13,044,498 bytes of image data (uncompressed). If we palette the image data, then we only need three bits of data in the image data -- 1,630,562 bytes (uncompressed). We'll also need to store the palette itself, which will need another 21 bytes (uncompressed). We don't need to store the color indices, as they are just an offset into an array.
</para>

<para>
This means that the total saving on an uncompressed image is 11,413,936 bytes. The disadvantage of course is that using the image is almost certainly going to be slightly slower...
</para>
</sect3>
</sect2>
</sect1>
<sect1><title>Vector</title>
<para>
     <indexterm><primary>Vector</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>vector</secondary></indexterm>
Some images aren't raster images. These images are normally composed of primitive drawing commands, such as draw a line, draw a circle, et cetera. The advantage of vector formats is that it is an exact representation of the image, they also scale much better. Examples of vector formats include Scalar Vector Graphics (SVG), Adobe Illustrator files, Windows Meta Files, and to a certain extent PDF documents. A plotter is a vector output device.
</para>
</sect1>
</chapter>
<chapter id="chap-tiff"><title>TIFF</title>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>

<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>
</sect1>

<sect1><title>Installation</title>
<para>
The source for libtiff can be downloaded from http://www.libtiff.org/ -- the current version of the library being version 3.5.7 at the time of writing. This version can be downloaded from ftp://ftp.remotesensing.org/pub/libtiff, look for the files named either tiff-v3.5.7.tar.gz or tiff-v3.5.7.zip.
</para>

<sect2><title>Unix</title>
<para>
Once you have downloaded the tarball for the library as described above, then you need to follow the steps below to install libtiff
  <footnote><para>Please note that there are binary packages for libtiff for most operating systems, so you might be best off installing one of those.</para></footnote>.

<orderedlist>
<listitem><para>tar xvzf tiff-v3.5.7.tar.gz</para></listitem>
<listitem><para>cd tiff-v3.5.7</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</orderedlist>
</para>

<para>
Not too hard at all...
</para>
</sect2>

<sect2><title>win32</title>
<para>
The instructions for how to compile the library are as follows:
</para>

<itemizedlist>
<listitem><para>Uncompress the libtiff distribution</para></listitem>
<listitem><para>Change directory into the libtiff directory inside the distribution</para></listitem>
<listitem><para>Copy ..\contrib\winnt\fax3sm.c to fax3sm_winnt.c</para></listitem>
<listitem><para>Copy ..\contrib\winnt\libtiff.def to libtiff.def</para></listitem>
<listitem><para>Remove the line for TIFFModeCCITTFax3 from the libtiff.def file</para></listitem>
<listitem><para>Change the line for TIFFFlushdata1 in the libtiff.def file to TIFFFlushData1</para></listitem>
<listitem><para>nmake /f makefile.vc all</para></listitem>
<listitem><para>Done!</para></listitem>
</itemizedlist>

<para>
To compile the tools once you have the library, just change into the tools directory and do a nmake /f makefile.vc 
</para>

<para>
For the Visual Studio challenged, there is a precompiled version of libtiff for win32 available from http://www.stillhq.com. Have a look at the Panda documentation page...
</para>
</sect2>
</sect1>


<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>

<sect2><title>File header</title>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory</title>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory Entries</title>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
These entries have a type associated with them, possible types are:
</para>

<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>

<para>
TIFF version 6 added the following fields:
</para>

<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>
</sect2>

<sect2><title>Possible field entries</title>
<para>
Discussing the many different possible field entries is out of the scope of this document. Refer to tiff.h and the TIFF specification for more information.
</para>
</sect2>

<sect2><title>So where's the image data?</title>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:

<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</para>

<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	
<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>
</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>
	
<sect2><title>Infrastructure for writing</title>
<para>
It is traditional for bitmaps to be represented inside your code with an array of chars. This is because on most operating systems, a char maps well to one byte. In the block of code below, we will setup libtiff, and create a simple buffer which contains an image which we can then write out to disc.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int
main (int argc, char *argv[])
{
  char buffer[32 * 9];
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-infrastructure.c</emphasis></para>

<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  // Define an image -- this is 32 pixels by 9 pixels
  char buffer[25 * 144] = { ...boring hex omitted... };

  TIFF *image;

  // Open the TIFF file
  if((image = TIFFOpen("output.tif", "w")) == NULL){
    printf("Could not open output.tif for writing\n");
    exit(42);
  }

  // We need to set some values for basic tags before we can add any data
  TIFFSetField(image, TIFFTAG_IMAGEWIDTH, 25 * 8);
  TIFFSetField(image, TIFFTAG_IMAGELENGTH, 144);
  TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 1);
  TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);
  TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 144);

  TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
  TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);
  TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
  TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);

  TIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
  
  // Write the information to the file
  TIFFWriteEncodedStrip(image, 0, buffer, 25 * 144);

  // Close the file
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-nohex.c</emphasis></para>

<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>

<sidebar><title>Problems with xview</title>
<para>
Xview is part of the xloadimage package written by Jim Frost, which comes with X windows.
</para>

<para>
It's a good example of how hard it can be to handle TIFF images well. If you have trouble viewing the output of the sample code, then try using some other program, like the GIMP.
</para>
</sidebar>

<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>

<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>

<sidebar><title>More information about the libtiff function calls</title>
<para>
If you need more information about any of the libtiff function calls mentioned in this chapter, then checkout the extensive man pages which come with the library. Remember that case is important with man pages, so you need to get the case in the function names right -- it's TIFFOpen, not tiffopen.
</para>
</sidebar>

<figure><title>The Sydney Harbor Bridge, by Michael Still</title>
<graphic format="EPS" fileref="tiff-figure1.eps">
</figure>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>

<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>

<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>

<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<figure><title>The Sydney Harbor Bridge, in strips</title>
<graphic format="EPS" fileref="tiff-figure2.eps">
</figure>

<figure><title>The Sydney Harbor Bridge, in tiles</title>
<graphic format="EPS" fileref="tiff-figure3.eps">
</figure>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>

<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>

<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (TIFFTAG_MINISBLACK), whilst you might find black being 1 (TIFFTAG_MINISWHITE) more convenient. TIFF allows both, so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in MINISWHITE, so we will convert images which are in MINISBLACK.
</para>

<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint16 photo, bps, spp, fillorder;
  uint32 width;
  tsize_t stripSize;
  unsigned long imageOffset, result;
  int stripMax, stripCount;
  char *buffer, tempbyte;
  unsigned long bufferSize, count;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Check that it is of a type that we support
  if((TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &amp;bps) == 0) || (bps != 1)){
    fprintf(stderr, "Either undefined or unsupported number of bits per sample\n");
    exit(42);
  }

  if((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &amp;spp) == 0) || (spp != 1)){
    fprintf(stderr, "Either undefined or unsupported number of samples per pixel\n");
    exit(42);
  }

  // Read in the possibly multile strips
  stripSize = TIFFStripSize (image);
  stripMax = TIFFNumberOfStrips (image);
  imageOffset = 0;
  
  bufferSize = TIFFNumberOfStrips (image) * stripSize;
  if((buffer = (char *) malloc(bufferSize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory for the uncompressed image\n");
    exit(42);
  }
  
  for (stripCount = 0; stripCount &lt; stripMax; stripCount++){
    if((result = TIFFReadEncodedStrip (image, stripCount,
				      buffer + imageOffset,
				      stripSize)) == -1){
      fprintf(stderr, "Read error on input strip number %d\n", stripCount);
      exit(42);
    }

    imageOffset += result;
  }

  // Deal with photometric interpretations
  if(TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &amp;photo) == 0){
    fprintf(stderr, "Image has an undefined photometric interpretation\n");
    exit(42);
  }
  
  if(photo != PHOTOMETRIC_MINISWHITE){
    // Flip bits
    printf("Fixing the photometric interpretation\n");

    for(count = 0; count &lt; bufferSize; count++)
      buffer[count] = ~buffer[count];
  }

  // Deal with fillorder
  if(TIFFGetField(image, TIFFTAG_FILLORDER, &amp;fillorder) == 0){
    fprintf(stderr, "Image has an undefined fillorder\n");
    exit(42);
  }
  
  if(fillorder != FILLORDER_MSB2LSB){
    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA
    printf("Fixing the fillorder\n");

    for(count = 0; count &lt; bufferSize; count++){
      tempbyte = 0;
      if(buffer[count] &amp; 128) tempbyte += 1;
      if(buffer[count] &amp; 64) tempbyte += 2;
      if(buffer[count] &amp; 32) tempbyte += 4;
      if(buffer[count] &amp; 16) tempbyte += 8;
      if(buffer[count] &amp; 8) tempbyte += 16;
      if(buffer[count] &amp; 4) tempbyte += 32;
      if(buffer[count] &amp; 2) tempbyte += 64;
      if(buffer[count] &amp; 1) tempbyte += 128;
      buffer[count] = tempbyte;
    }
  }
     
  // Do whatever it is we do with the buffer -- we dump it in hex
  if(TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width) == 0){
    fprintf(stderr, "Image does not define its width\n");
    exit(42);
  }
  
  for(count = 0; count &lt; bufferSize; count++){
    printf("%02x", (unsigned char) buffer[count]);
    if((count + 1) % (width / 8) == 0) printf("\n");
    else printf(" ");
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-read/read.c</emphasis></para>

<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>
</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>
</para>

<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>TIFFTAG</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.</para>

<para>Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.</para>

<figure><title>The picture before we compressed it</title>
<graphic format="EPS" fileref="tiff-figure4.eps">
</figure>

<figure><title>The sample text before we compressed it</title>
<graphic format="EPS" fileref="tiff-figure5.eps">
</figure>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<figure><title>The picture after it has been recompressed 200 times</title>
<graphic format="EPS" fileref="tiff-figure6.eps">
</figure>

<figure><title>The text after it has been recompressed 200 times</title>
<graphic format="EPS" fileref="tiff-figure7.eps">
</figure>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>
</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>

<programlisting>
#include &lt;tiffio.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]){
  TIFF *output;
  uint32 width, height;
  char *raster;

  // Open the output image
  if((output = TIFFOpen("output.tif", "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // We need to know the width and the height before we can malloc
  width = 42;
  height = 42;

  if((raster = (char *) malloc(sizeof(char) * width * height * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Magical stuff for creating the image
  // ...

  // Write the tiff tags to the file
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster, width * height * 3) == 0){
    fprintf(stderr, "Could not write image\n");
    exit(42);
  }

  TIFFClose(output);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-write/write.c</emphasis></para>

<para>You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.</para>

<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>
</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>
</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>
</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>

<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>

<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  // Here I fix the reversal of the image (vertically) and show you how to get the color values from each pixel
  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      // Red = TIFFGetR(raster[e * width + c]);
      // Green = TIFFGetG(raster[e * width + c]);
      // Blue = TIFFGetB(raster[e * width + c]);
    }
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-read/read.c</emphasis></para>
</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>

<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>

<sidebar><title>An expanded example</title>
<para>If you need more information about hooking the file input and output functions within libtiff than this chapter allows, then have a look at the images.c file in Panda, my PDF library. The web pages for Panda can be found at http://www.stillhq.com
  <footnote><para>http://www.stillhq.com/cgi-bin/getpage?area=panda&lt;page=index.htm to be exact.</para></footnote>
.
</para>
</sidebar>

<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>

<programlisting>
// Please note that this code wont compile, and is intended to only show you 
// the sturcture of TIFFClient* calls

#include &lt;tiffio.h&gt;
#include &lt;pthread.h&gt;

// Function prototypes
static tsize_t libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size);
static tsize_t libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size);
static toff_t libtiffDummySeekProc (thandle_t fd, toff_t off, int i);
static int libtiffDummyCloseProc (thandle_t fd);

// We need globals because of the callbacks (they don't allow us to pass state)
char *globalImageBuffer;
unsigned long globalImageBufferOffset;

// This mutex keeps the globals safe by ensuring only one user at a time
pthread_mutex_t convMutex = PTHREAD_MUTEX_INITIALIZER;

TIFF *conv;

// Lock the mutex
pthread_mutex_lock (&amp;convMutex);

globalImageBuffer = NULL;
globalImageBufferOffset = 0;

// Open the dummy document (which actually only exists in memory)
conv = TIFFClientOpen ("dummy", "w", (thandle_t) - 1, libtiffDummyReadProc,
            libtiffDummyWriteProc, libtiffDummySeekProc,
            libtiffDummyCloseProc, NULL, NULL, NULL);

// Setup the image as if it was any other tiff image here, including setting tags


// Actually do the client open
TIFFWriteEncodedStrip (conv, 0, stripBuffer, imageOffset);

// Unlock the mutex
pthread_mutex_unlock (&amp;convMutex);

//...

/////////////////// Callbacks to libtiff

static tsize_t
libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // Return the amount of data read, which we will always set as 0 because
  // we only need to be able to write to these in-memory tiffs
  return 0;
}

static tsize_t
libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // libtiff will try to write an 8 byte header into the tiff file. We need
  // to ignore this because PDF does not use it...
  if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'I') &amp;&amp; (((char *) buf)[1] == 'I')
     &amp;&amp; (((char *) buf)[2] == 42))
    {
    // Skip the header -- little endian
    }
  else if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'M') &amp;&amp;
       (((char *) buf)[1] == 'M') &amp;&amp;y (((char *) buf)[2] == 42))
    {
    // Skip the header -- big endian
    }
  else
    {
    // Have we done anything yet?
    if (globalImageBuffer == NULL)
    if((globalImageBuffer = (char *) malloc (size * sizeof (char))) == NULL)
        {
          fprintf(stderr, "Memory allocation error\n");
          exit(42);
        }

    // Otherwise, we need to grow the memory buffer
    else
    {
      if ((globalImageBuffer = (char *) realloc (globalImageBuffer,
                             (size * sizeof (char)) +
                             globalImageBufferOffset)) == NULL)
        fprintf(stderr, "Could not grow the tiff conversion memory buffer\n");
            exit(42);
    }

    // Now move the image data into the buffer
    memcpy (globalImageBuffer + globalImageBufferOffset, buf, size);
    globalImageBufferOffset += size;
    }

  return (size);
}

static toff_t
libtiffDummySeekProc (thandle_t fd, toff_t off, int i)
{
  // This appears to return the location that it went to
  return off;
}

static int
libtiffDummyCloseProc (thandle_t fd)
{
  // Return a zero meaning all is well
  return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-client/client.c</emphasis></para>
</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>

<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>

<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff, optchar;
  int count = 4, i;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:c:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'c':
	  count = atoi(optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file, we do this c times
  for(i = 0; i &lt; count; i++){
    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    

    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    // Flush this subfile and move onto the next one
    if(TIFFWriteDirectory(output) == 0){
      fprintf(stderr, "Error writing subfile %d\n", i);
      exit(44);
    }
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/create.c</emphasis></para>

<figure><title>Four pictures of my son Andrew</title>
<graphic format="EPS" fileref="tiff-figure8.eps">
</figure>
</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
This example below demonstrates how to do this.
</para>


<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, 
    outputFilenameActual[200], *raster, *roff, optchar;
  int count;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Check the output parent name
  if(outputFilename == NULL){
    fprintf(stderr, \
	    "You need to specify a name for the series of output files\n");
    usage(argv[0], 42);
  }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Grab a sub file from the input image and move it to a separate file. We do
  // this forever (until we break down below)...
  for(count = 0;; count++){
    // Find the width and height of the input
    TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
    TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

    ///////////////////////////////////////////////////////////////////////////
    // Grab some memory
    if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == 
	NULL)
      {
	fprintf (stderr, 
		 "Could not allocate enough memory for input raster\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Read the input into the memory buffer
    // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
    stripSize = TIFFStripSize (input);
    roff = raster;
    for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
	 stripNumber++)
      {
	roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
      }
    
    ///////////////////////////////////////////////////////////////////////////
    // Open the output TIFF
    snprintf(outputFilenameActual, 200, "%s-%d.tif", outputFilename, count);
    if ((output = TIFFOpen (outputFilenameActual, "w")) == NULL)
      {
	fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
	usage (argv[0], 42);
      }

    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    
    // Copy the subfile to a output location
    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Flush this subfile and move onto the next one
    if(TIFFReadDirectory(input) == 0){
      printf(" No more subfiles");
      break;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Doing correct cleanup with a loop like this is important...
    free(raster);
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/read.c</emphasis></para>
</sect1>


<sect1><title>Man pages</title>
<para>
I have included the man pages to some of the more useful libtiff commands, so that you have them for reference when you need them.
</para>

<sect2><title>tiff2bw</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2bw - convert a color
<emphasis>TIFF</emphasis>
image to greyscale
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2bw</command>
[
options
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiff2bw</emphasis>
converts an
<emphasis>RGB</emphasis>
or Palette color
<emphasis>TIFF</emphasis>
image to a greyscale image by
combining percentages of the red, green, and blue channels.
By default, output samples are created by taking
28% of the red channel, 59% of the green channel, and 11% of
the blue channel.
To alter these percentages, the
and
options may be used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify a compression scheme to use when writing image data:
<command>"-c none"</command>
for no compression,
<command>"-c packbits"</command>
for the PackBits compression algorithm,
<command>"-c zip</command>
for the Deflate compression algorithm,
<command>"-c g3</command>
for the CCITT Group 3 compression algorithm,
<command>"-c g4</command>
for the CCITT Group 4 compression algorithm,
and
<command>"-c lzw"</command>
for Lempel-Ziv &amp; Welch (the default).
</para>
</listitem>
<listitem>

<para><command>-r</command>
Write data with a specified number of rows per strip;
by default the number of rows/strip is selected so that each strip
is approximately 8 kilobytes.
</para>
</listitem>
<listitem>

<para><command>-R</command>
Specify the percentage of the red channel to use (default 28).
</para>
</listitem>
<listitem>

<para><command>-G</command>
Specify the percentage of the green channel to use (default 59).
</para>
</listitem>
<listitem>

<para><command>-B</command>
Specify the percentage of the blue channel to use (default 11).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>

<sect2><title>tiff2ps</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2ps - convert a
<emphasis>TIFF</emphasis>
image to \*(Ps\(tm
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2ps</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiff2ps</emphasis>
reads
<emphasis>TIFF</emphasis>
images and writes \*(Ps or Encapsulated \*(Ps (EPS)
on the standard output.
By default,
<emphasis>tiff2ps</emphasis>
writes Encapsulated \*(Ps for the first image in the specified
<emphasis>TIFF</emphasis>
image file.
</para>

<para>By default,
<emphasis>tiff2ps</emphasis>
will generate \*(Ps that fills a printed area specified
by the
<emphasis>TIFF</emphasis>
tags in the input file.
If the file does not contain
<emphasis>XResolution</emphasis>
or
<emphasis>YResolution</emphasis>
tags, then the printed area is set according to the image dimensions.
The
<command>-w</command>
and
<command>-h</command>
options (see below)
can be used to set the dimensions of the printed area in inches;
overriding any relevant
<emphasis>TIFF</emphasis>
tags.
</para>

<para>The \*(Ps generated for
<emphasis>RGB,</emphasis>
palette, and
<emphasis>CMYK</emphasis>
images uses the
<emphasis>colorimage</emphasis>
operator.
The \*(Ps generated for
greyscale and bilevel images
uses the
<emphasis>image</emphasis>
operator.
When the
<emphasis>colorimage</emphasis>
operator is used, \*(Ps code to emulate this operator
on older \*(Ps printers is also generated.
Note that this emulation code can be very slow.
</para>

<para>Color images with associated alpha data are composited over
a white background.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-1</command>
Generate \*(Ps Level I (the default).
</para>
</listitem>
<listitem>

<para><command>-2</command>
Generate \*(Ps Level II.
</para>
</listitem>
<listitem>

<para><command>-a</command>
Generate output for all IFDs (pages) in the input file.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the specified directory number.
(NB: directories are numbered starting at zero.)
This option is useful for selecting individual pages in a
multi-page (e.g. facsimile) file.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Force the generation of Encapsulated \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-h</command>
Specify the vertical size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the
<emphasis>IFD</emphasis>
at the specified file offset.
This option is useful for selecting thumbnail images and the
like which are hidden using the SubIFD tag.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Force the generation of (non-Encapsulated) \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Generate output for a single IFD (page) in the input file.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the horizontal size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-z</command>
When generating \*(Ps Level II, data is scaled so that it does not
image into the
<emphasis>deadzone</emphasis>
on a page (the outer margin that the printing device is unable to mark).
This option suppresses this behaviour.
When \*(Ps Level I is generated, data is imaged to the entire printed
page and this option has no affect.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following generates \*(Ps Level II for all pages of a facsimile:
tiff2ps -a2 fax.tif | lpr
Note also that if you have version 2.6.1 or newer of Ghostscript then you
can efficiently preview facsimile generated with the above command.
</para>

<para>To generate Encapsulated \*(Ps for a the image at directory 2
of an image use:
tiff2ps -d 1 foo.tif
(notice that directories are numbered starting at zero.)
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Because \*(Ps does not support the notion of a colormap,
8-bit palette images produce 24-bit \*(Ps images.
This conversion results in output that is six times
bigger than the original image and which takes a long time
to send to a printer over a serial line.
Matters are even worse for 4-, 2-, and 1-bit palette images.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Does not handle tiled images when generating PS Level I output.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>tiffsv (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffcmp</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcmp - compare two
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcmp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"file1.tif file2.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffcmp</emphasis>
compares the tags and data in two files created according
to the Tagged Image File Format, Revision 6.0.
The schemes used for compressing data in each file
are immaterial when data are compared-data are compared on
a scanline-by-scanline basis after decompression.
Most directory tags are checked; notable exceptions are:
<emphasis>GrayResponseCurve ,</emphasis>
<emphasis>ColorResponseCurve ,</emphasis>
and
<emphasis>ColorMap</emphasis>
tags.
Data will not be compared if any of the
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
or
<emphasis>ImageWidth</emphasis>
values are not equal.
By default,
<emphasis>tiffcmp</emphasis>
will terminate if it encounters any difference.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-l</command>
List each byte of image data that differs between the files.
</para>
</listitem>
<listitem>

<para><command>-t</command>
Ignore any differences in directory tags.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Tags that are not recognized by the library are not
compared; they may also generate spurious diagnostics.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffcmp</command> shows the differences in tags between images, for example, when I compare the input and output images from the pixel example in this chapter:
</para>

<programlisting>
[mikal@localhost tiff-pixels]$ tiffcmp input.tif output.tif 
ImageWidth: 256 520
[mikal@localhost tiff-pixels]$ 
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffcp</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcp - copy (and possibly convert) a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"src1.tif ... srcN.tif dst.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffcp</emphasis>
combines one or more files created according
to the Tag Image File Format, Revision 6.0
into a single
<emphasis>TIFF</emphasis>
file.
Because the output file may be compressed using a different
algorithm than the input files,
<emphasis>tiffcp</emphasis>
is most often used to convert between different compression
schemes.
</para>

<para>By default,
<emphasis>tiffcp</emphasis>
will copy all the understood tags in a
<emphasis>TIFF</emphasis>
directory of an input
file to the associated directory in the output file.
</para>

<para><emphasis>tiffcp</emphasis>
can be used to reorganize the storage characteristics of data
in a file, but it is explicitly intended to not alter or convert
the image data content in any way.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-B</command>
Force output to be written with Big-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Suppress the use of ``strip chopping'' when reading images
that have a single strip/tile of uncompressed data.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffcp</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-l</command>
Specify the length of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-L</command>
Force output to be written with Little-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-M</command>
Suppress the use of memory-mapped files when reading images.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data
that has one 8-bit sample per pixel.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same planar configuration as
the original.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffcp</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Force the output file to be written with data organized in strips
(rather than tiles).
</para>
</listitem>
<listitem>

<para><command>-t</command>
Force the output file to be written wtih data organized in tiles
(rather than strips).
options can be used to force the resultant image to be written
as strips or tiles of data, respectively.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the width of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following concatenates two files and writes the result using
<emphasis>LZW</emphasis>
encoding:
tiffcp -c lzw a.tif b.tif result.tif
</para>

<para>To convert a G3 1d-encoded
<emphasis>TIFF</emphasis>
to a single strip of G4-encoded data the following might be used:
tiffcp -c g4 -r 10000 g3.tif g4.tif
(1000 is just a number that is larger than the number of rows in
the source file.)
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiffsplit (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffdither</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdither - convert a greyscale image to bilevel using dithering
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdither</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdither</emphasis>
converts a single channel 8-bit greyscale image to a bilevel image
using Floyd-Steinberg error propagation with threholding.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffdither</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffdither</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB ,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-t</command>
Set the threshold value for dithering.
By default the threshold value is 128.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>The dither algorithm is taken from the
<emphasis>tiffmedian (1)</emphasis>
program (written by Paul Heckbert).
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>fax2tiff (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<figure><title>The gray scale input image</title>
<graphic format="EPS" fileref="tiff-figure9.eps">
</figure>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<figure><title>The dithered output image</title>
<graphic format="EPS" fileref="tiff-figure10.eps">
</figure>
</sect3>
</sect2>


<sect2><title>tiffdump</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdump - print verbatim information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdump</command>
[
<emphasis>options</emphasis>
]
<emphasis>"name ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdump</emphasis>
displays directory information from files created according
to the Tag Image File Format, Revision 6.0.
The header of each
<emphasis>TIFF</emphasis>
file (magic number, version, and first directory offset)
is displayed, followed by the tag contents of each directory in the file.
For each tag, the name, datatype, count, and value(s) is displayed.
When the symbolic name for a tag or datatype is known, the symbolic
name is displayed followed by it's numeric (decimal) value.
Tag values are displayed enclosed in ``&lt;&gt;'' characters immediately
preceded by the value of the count field.
For example, an
<emphasis>ImageWidth</emphasis>
tag might be displayed as ``ImageWidth (256) SHORT (3) 1&lt;800&gt;''.
</para>

<para><emphasis>tiffdump</emphasis>
is particularly useful for investigating the contents of
<emphasis>TIFF</emphasis>
files that
<emphasis>libtiff</emphasis>
does not understand.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-h</command>
Force numeric data to be printed in hexadecimal rather than the
default decimal.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Dump the contents of the
<emphasis>IFD</emphasis>
at the a particular file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffgt</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffgt - display an image stored in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffgt</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffgt</emphasis>
displays one or more images stored using the
Tag Image File Format, Revision 6.0.
Each image is placed in a fixed size window that the
user must position on the display (unless configured
otherwise through X defaults).
If the display has fewer than 24 bitplanes, or if the
image does not warrant full color, then
<emphasis>RGB</emphasis>
color values are mapped to the closest values that exist in
the colormap (this is done using the
<emphasis>rgbi</emphasis>
routine found in the graphics utility library
</para>

<para><emphasis>tiffgt</emphasis>
correctly handles files with any of the following characteristics:
BitsPerSample	1, 2, 4, 8, 16
SamplesPerPixel	1, 3, 4 (the 4th sample is ignored)
PhotometricInterpretation	0 (min-is-white), 1 (min-is-black), 2 (RGB), 3 (palette), 6 (YCbCr)
PlanarConfiguration	1 (contiguous), 2 (separate)
Orientation	1 (top-left), 4 (bottom-left)
Data may be organized as strips or tiles and may be
compressed with any of the compression algorithms supported
by the
<emphasis>libtiff (3)</emphasis>
library.
</para>

<para>For palette images (\c
<emphasis>PhotomatricInterpretation =3),</emphasis>
<emphasis>tiffgt</emphasis>
inspects the colormap values and assumes either 16-bit
or 8-bit values according to the maximum value.
That is, if no colormap entry greater than 255 is found,
<emphasis>tiffgt</emphasis>
assumes the colormap has only 8-bit values; otherwise
it assumes 16-bit values.
This inspection is done to handle old images written by
previous (incorrect) versions of
<emphasis>libtiff .</emphasis>
</para>

<para><emphasis>tiffgt</emphasis>
can be used to display multiple images one-at-a-time.
The left mouse button switches the display to the first image in the
<emphasis>next</emphasis>
file in the list of files specified on the command line.
The right mouse button switches to the first image in the
<emphasis>previous</emphasis>
file in the list.
The middle mouse button causes the first image in the first file
specified on the command line to be displayed.
In addition the following keyboard commands are recognized:
</para>
<itemizedlist>
<listitem>

<para><command>b</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsBlack in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>l</command>
Use a
<emphasis>FillOrder</emphasis>
of lsb-to-msb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>m</command>
Use a
<emphasis>FillOrder</emphasis>
of msb-tolmsb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>c</command>
Use a colormap visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>r</command>
Use a true color (24-bit RGB) visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>w</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsWhite in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>W</command>
Toggle (enable/disable) display of warning messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>E</command>
Toggle (enable/disable) display of error messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>z</command>
Reset all parameters to their default settings (\c
<emphasis>FillOrder ,</emphasis>
<emphasis>PhotometricInterpretation ,</emphasis>
handling of warnings and errors).
</para>
</listitem>
<listitem>

<para><command>PageUp</command>
Display the previous image in the current file or the last
image in the previous file.
</para>
</listitem>
<listitem>

<para><command>PageDown</command>
Display the next image in the current file or the first image
in the next file.
</para>
</listitem>
<listitem>

<para><command>Home</command>
Display the first image in the current file.
</para>
</listitem>
<listitem>

<para><command>End</command>
Display the last image in the current file (unimplemented).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Force image display in a colormap window.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Specify an image to display by directory number.
By default the first image in the file is displayed.
Directories are numbered starting at zero.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Enable reporting of error messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
silently ignores images that cannot be read.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Force
<emphasis>tiffgt</emphasis>
to run as a foreground process.
By default
<emphasis>tiffgt</emphasis>
will place itself in the background once it has opened the
requested image file.
</para>
</listitem>
<listitem>

<para><command>-l</command>
Force the presumed bit ordering to be
<emphasis>LSB</emphasis>
to
<emphasis>MSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-m</command>
Force the presumed bit ordering to be
<emphasis>MSB</emphasis>
to
<emphasis>LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-o</command>
Specify an image to display by directory offset.
By default the first image in the file is displayed.
Directories offsets may be specified using C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Override the value of the
<emphasis>PhotometricInterpretation</emphasis>
tag; the parameter may be one of:
<emphasis>miniswhite ,</emphasis>
<emphasis>minisblack ,</emphasis>
<emphasis>rgb ,</emphasis>
<emphasis>palette ,</emphasis>
<emphasis>mask ,</emphasis>
<emphasis>separated ,</emphasis>
<emphasis>ycbcr ,</emphasis>
and
<emphasis>cielab .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-r</command>
Force image display in a full color window.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Stop on the first read error.
By default all errors in the input data are ignored and
<emphasis>tiffgt</emphasis>
does it's best to display as much of an image as possible.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Enable reporting of warning messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
ignores warning messages generated when reading an image.
</para>
</listitem>
<listitem>

<para><command>-v</command>
Place information in the title bar describing
what type of window (full color or colormap) is being
used, the name of the input file, and the directory
index of the image (if non-zero).
By default, the window type is not shown in the title bar.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Images wider and taller than the display are silently truncated to avoid
crashing old versions of the window manager.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffdump (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffinfo</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffinfo - print information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffinfo</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffinfo</emphasis>
displays information about files created according
to the Tag Image File Format, Revision 6.0.
By default, the contents of each
<emphasis>TIFF</emphasis>
directory in each file
is displayed, with the value of each tag shown symbolically
(where sensible).
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Display the colormap and color/gray response curves, if present.
</para>
</listitem>
<listitem>

<para><command>-D</command>
In addition to displaying the directory tags,
read and decompress all the data in each image (but not display it).
</para>
</listitem>
<listitem>

<para><command>-d</command>
In addition to displaying the directory tags,
print each byte of decompressed data in hexadecimal.
</para>
</listitem>
<listitem>

<para><command>-j</command>
Display any \s-2JPEG\s0-related tags that are present.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory according to the specified file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Display the offsets and byte counts for each data strip in a directory.
</para>
</listitem>
<listitem>

<para><command>-z</command>
Enable strip chopping when reading image data.
</para>
</listitem>
<listitem>

<para><command>-#</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to
<emphasis># .</emphasis>
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffmedian</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffmedian - apply the median cut algorithm to data in a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffmedian</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffmedian</emphasis>
applys the median cut algorithm to an
<emphasis>RGB</emphasis>
image in
<emphasis>input.tif</emphasis>
to generate a palette image that is written to
<emphasis>output.tif .</emphasis>
The generated colormap has, by default, 256 entries.
The image data is quantized by mapping each
pixel to the closest color values in the colormap.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
and
<command>zip</command>
for Deflate compression.
By default
<emphasis>tiffmedian</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Specify the number of entries to use in the generated colormap.
By default all 256 entries/colors are used.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Apply Floyd-Steinberg dithering before selecting a colormap entry.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffmedian</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>This program is derived from Paul Heckbert's
<emphasis>median</emphasis>
program.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>

<para>"Color Image Quantization for Frame Buffer Display", Paul
Heckbert, SIGGRAPH proceedings, 1982, pp. 297-307.
</para>
</sect3>
</sect2>


<sect2><title>tiffsplit</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1992-1997 Sam Leffler -->
<!--  Copyright (c) 1992-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsplit - split a multi-image
<emphasis>TIFF</emphasis>
into single-image
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsplit</command>
<emphasis>src.tif</emphasis>
[
<emphasis>prefix</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsplit</emphasis>
takes a multi-directory (page)
<emphasis>TIFF</emphasis>
file and creates one or more single-directory (page)
<emphasis>TIFF</emphasis>
files from it.
The output files are given names created by concatenating
a prefix, a lexically ordered
suffix in the range [<emphasis>aa</emphasis>-<emphasis>zz</emphasis>], the suffix
<emphasis>.tif </emphasis>
(e.g.
<emphasis>xaa.tif ,</emphasis>
<emphasis>xab.tif ,</emphasis>
\...
<emphasis>xzz.tif ).</emphasis>
If a prefix is not specified on the command line,
the default prefix of
<emphasis>x</emphasis>
is used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para>None.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Only a select set of ``known tags'' is copied when spliting.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffcp (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffsv</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/output.sgml,v 1.49 2002-07-13 11:17:51 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsv - save an image from the framebuffer in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsv</command>
[
<emphasis>options</emphasis>
]
<emphasis>output.tif</emphasis>
[
<emphasis>"x1 x2 y1 y2"</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsv</emphasis>
saves all or part of the framebuffer in a file using the
Tag Image File Format, Revision 6.0.
By default, the image is saved with data samples packed (\c
<emphasis>PlanarConfiguration =1),</emphasis>
compressed with the Lempel-Ziv &amp; Welch algorithm (\c
<emphasis>Compression =5),</emphasis>
and with each strip no more than 8 kilobytes.
These characteristics can be overriden, or explicitly specified
with the options described below.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-b</command>
Save the image as a greyscale image
as if it were processed by
<emphasis>tiff2bw (1).</emphasis>
This option is included for compatibility with the standard
<emphasis>scrsave (6D)</emphasis>
program.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
and
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression (default).
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data.
By default,
<emphasis>tiffsv</emphasis>
will create a new file with the data samples packed contiguously.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffsv</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTE</title>

<para>Except for the use of
<emphasis>TIFF,</emphasis>
this program is equivalent to the standard
<emphasis>scrsave</emphasis>
program.
This means, for example, that you can use it in conjunction with
the standard
<emphasis>icut</emphasis>
program simply by creating a link called
<emphasis>scrsave ,</emphasis>
or by creating a shell script called
<emphasis>scrsave</emphasis>
that invokes
<emphasis>tiffgt</emphasis>
with the appropriate options.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>If data are saved compressed and in separate planes, then the
rows in each strip is silently set to one to avoid limitations
in the
<emphasis>libtiff (3)</emphasis>
library.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>scrsave (6D)</emphasis>
<emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffdump (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>

<sect2><title>tifftopnm</title>
<sect3><title>NAME</title>

<para>tifftopnm - convert a TIFF file into a portable anymap
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tifftopnm</command>
[
={alpha-filename,-}]  [
<command>--headerdump</command>
]
<emphasis>tiff-filename</emphasis>

</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Reads a TIFF file as input.
Produces a portable anymap as output.
The type of the output file depends on the input file - if it's
black &amp; white, generates a
<emphasis>pbm</emphasis>
file;
if it's grayscale, generates a
<emphasis>pgm</emphasis>
file; otherwise, a
<emphasis>ppm</emphasis>
file.  The program tells you which type it is writing.
</para>

<para>This program cannot read every possible TIFF file -- there are myriad
variations of the TIFF format.  However, it does understand monochrome
and gray scale, RGB, RGBA (red/green/blue with alpha channel), CMYK
(Cyan-Magenta-Yellow-Black ink color separation), and color palette
TIFF files.  An RGB file can have either single plane (interleaved)
color or multiple plane format.  The program reads 1-8 and 16
bit-per-sample input, the latter in either bigendian or littlendian
encoding.  Tiff directory information may also be either bigendian or
littendian.
</para>

<para>One reason this program isn't as general as TIFF programs often are is
that it does not use the TIFFRGBAImageGet() function of the TIFF
library to read TIFF files.  Rather, it uses the more primitive
TIFFReadScanLine() function and decodes it itself.
</para>

<para>There is no fundamental reason that this program could not read other
kinds of TIFF files; the existing limitations are mainly because no one
has asked for more.

The PNM output has the same maxval as the Tiff input, except that if
the Tiff input is colormapped (which implies a maxval of 65535) the
PNM output has a maxval of 255.  Though this may result in lost
information, such input images hardly ever actually have more color
resolution than a maxval of 255 provides and people often cannot deal
with PNM files that have maxval &gt; 255.  By contrast, a non-colormapped
Tiff image that doesn't need a maxval &gt; 255 doesn't
<emphasis>have</emphasis>
a maxval &gt; 255, so when we see a non-colormapped maxval &gt; 255, we take
it seriously and produce a matching output maxval.

The
<emphasis>tiff-filename</emphasis>
argument names the regular file that contains the Tiff image.  You
cannot use Standard Input or any other special file because the Tiff
library must be able to perform seeks on it.

</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>tifftopnm </command>
creates a PGM (portable graymap) file containing the alpha channel
values in the input image.  If the input image doesn't contain an
alpha channel, the
<emphasis>alpha-filename</emphasis>
file contains all zero (transparent) alpha values.  If you don't specify
<command>tifftopnm</command>
does not generate an alpha file, and if the input image has an alpha channel,
<command>tifftopnm</command>
simply discards it.

If you specify
<command>-</command>
as the filename,
<command>tifftopnm</command>
writes the alpha output to Standard Output and discards the image.

See
for one way to use the alpha output file.
</para>
</listitem>
<listitem>

<para><command>--headerdump</command>
Dump TIFF file information to stderr.  This information may be useful
in debugging TIFF file conversion problems.
</para>

<para>All options can be abbreviated to their shortest unique prefix.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para></para>
</sect3>
<sect3><title>AUTHOR</title>

<para>Derived by Jef Poskanzer from tif2ras.c, which is
Copyright (c) 1990 by Sun Microsystems, Inc.
Author: Patrick J. Naughton (naughton@wind.sun.com).
<!--  Permission to use, copy, modify, and distribute this software and its -->
<!--  documentation for any purpose and without fee is hereby granted, -->
<!--  provided that the above copyright notice appear in all copies and that -->
<!--  both that copyright notice and this permission notice appear in -->
<!--  supporting documentation. -->
<!--   -->
<!--  This file is provided AS IS with no warranties of any kind.  The author -->
<!--  shall have no liability with respect to the infringement of copyrights, -->
<!--  trade secrets or any patents by this file or any part thereof.  In no -->
<!--  event will the author be liable for any lost revenue or profits or -->
<!--  other special, indirect and consequential damages. -->
</para>
</sect3>
</sect2>
</sect1>















<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

#define EOFFSET 150

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2, xs = 0, ys = 0, xe = -1, ye = -1;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    *enlarged, *rout, optchar;
  int xrep, yrep;
  float m;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'x':
	  xs = atoi (optarg);
	  break;

	case 'y':
	  ys = atoi (optarg);
	  break;

	case 'w':
	  xe = xs + atoi (optarg);
	  break;

	case 'l':
	  ye = ys + atoi (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Make sure we have reasonable defaults
  if (xe == -1)
    xe = xs + 10;

  if (ye == -1)
    ye = ys + 10;

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  // Sanity check some of our arguements
  if (xe &gt; width)
    {
      fprintf (stderr,
	       "You choice of starting x position, or width, results in the enlargement falling off the edge of the input image\n");
      usage (argv[0], 43);
    }

  if (ye &gt; height)
    {
      fprintf (stderr,
	       "You choice of starting y position, or length, results in the enlargement falling off the end of the input image\n");
      usage (argv[0], 43);
    }

  printf ("Enlarging a %d by %d portion of the image\n", xe - xs, ye - ys);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  // todo: crap assumption about the data being 8 bps, 3 spp
  if ((enlarged = (char *) malloc (sizeof (char) * (xe - xs) * (ye - ys) * 3 *
				   121)) == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  if ((rout = (char *) malloc (sizeof (char) * (width + EOFFSET) * height * 3))
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for output raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width + EOFFSET);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Actually do the enlargement of the portion of the image specified
  offset = offset2 = 0;
  for (y = ys; y &lt; ye; y++)
    {
      for (yrep = 0; yrep &lt; 10; yrep++)
	{
	  for (x = xs; x &lt; xe; x++)
	    {
	      offset = (x + (y * width)) * 3;
	      for (xrep = 0; xrep &lt; 10; xrep++)
		{
		  memcpy (enlarged + offset2, raster + offset, 3);
		  offset2 += 3;
		}

	      // The white border to the left of the pixel
	      memset (enlarged + offset2, 255, 3);
	      offset2 += 3;
	    }
	}

      // The white line at the bottom of these pixels
      memset (enlarged + offset2, 255, (ye - ys) * 3 * 11);
      offset2 += (ye - ys) * 3 * 11;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Now we assemble the two parts of the image together into a big output
  // raster
  memset (rout, 255, sizeof (char) * (width + EOFFSET) * height * 3);

  // The original image
  offset = 0;
  offset2 = 0;
  for (y = 0; y &lt; height; y++)
    {
      memcpy (rout + offset2, raster + offset, width * 3);
      offset += width * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  // Box the bit that was enlarged in the original image, can't use memset here
  // Top line
  offset = (((width + EOFFSET) * (ys - 1)) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Bottom line
  offset = (((width + EOFFSET) * ye) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Vertical lines
  offset = (((width + EOFFSET) * ys) + xs - 1) * 3;
  for (y = 0; y &lt; ye - ys + 1; y++)
    {
      rout[offset] = 255;
      rout[offset + 1] = 0;
      rout[offset + 2] = 0;

      rout[offset + ((ye - ys + 1) * 3)] = 255;
      rout[offset + ((ye - ys + 1) * 3) + 1] = 0;
      rout[offset + ((ye - ys + 1) * 3) + 2] = 0;

      offset += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Box the enlarged portion of the image

  /////////////////////////////////////////////////////////////////////////////
  // Draw the two diagonal lines between the original and the enlarged
  //    this bit is based on the premis that y = mx + b
  //    and m = (y2 - y1) / (x2 - x1) and that geometry hasn't significantly
  //    changed since my high school days
  //
  //    if we assume that the first point is the origin, then the maths is
  //    even easier
  // 
  //    which I think is probably a fairly safe set of assumptions at this
  //    stage...
  // todo
  //  printf("ye = %d, xe = %d\n", ye, xe);
  //  m = (ye - ys) / (xe - xs);
  //  for(x = 0; x &lt; (xe - xs); x++){
  //    y = m * x;
  //    
  //    printf("%d, %d (%f = %f)\n", x, y, m, ye / xe);
  //  }

  /////////////////////////////////////////////////////////////////////////////
  // Copy the enlarged portion across

  offset = 0;
  offset2 = (((((height / 2) - ((ye - ys) * 11 / 2)) *
	       (width + EOFFSET)) + width + 20) * 3);
  for (y = 0; y &lt; (ye - ys) * 11; y++)
    {
      memcpy (rout + offset2, enlarged + offset, (ye - ys) * 11 * 3);
      offset += (ye - ys) * 11 * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     (width + EOFFSET) * height * 3 * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (enlarged);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -x &lt;start x&gt; -y &lt;start y&gt; -w &lt;width&gt; -l &lt;length&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-pixels/pixel.c</emphasis></para>
</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>

<sect2><title>A broken algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.333 + 
		       (unsigned char) (raster[offset + 1]) * 0.333 + 
		       (unsigned char) (raster[offset + 2]) * 0.333);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-wrong.c</emphasis></para>

<para>
Which produces:
</para>

<figure><title>An average of the color values for each pixel</title>
<graphic format="EPS" fileref="grayscale-figure2.eps">
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.299 + 
		       (unsigned char) (raster[offset + 1]) * 0.587 + 
		       (unsigned char) (raster[offset + 2]) * 0.114);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-good.c</emphasis></para>

<para>
Which gives us:
</para>

<figure><title>A correct conversion to gray scale</title>
<graphic format="EPS" fileref="grayscale-figure3.eps">
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>

<sect1><title>Example: Repeated compression</title>
<para>
Earlier in this chapter I promised that I would include the code for the repeated compression loss example, so here it is. The example is made up of a simple (and quite ugly) shell script, and a c program to actually compress the images...
</para>

<programlisting>
#!/bin/bash

count=1
cp $1 $1-0.tif

while [ $count -lt 200 ]
do
  ./read $1-$(( $count -1 )).tif $1-$count.tif
  count=$(( $count + 1 ))
done
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.sh</emphasis></para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image, *output;
  uint16 photo, bps, spp, fillorder;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;
  char *raster2;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Open the output image
  if((output = TIFFOpen(argv[2], "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  if((raster2 = (char *) malloc(sizeof(char) * imagesize * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      raster2[d++] = TIFFGetR(raster[e * width + c]);
      raster2[d++] = TIFFGetG(raster[e * width + c]);
      raster2[d++] = TIFFGetB(raster[e * width + c]);
    }
  }

  // Recompress it straight away -- set the tags we require
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);
  TIFFSetField(output, TIFFTAG_JPEGQUALITY, 25);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster2, imagesize * 3) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  TIFFClose(output);
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.c</emphasis></para>
</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>
</sect1>


<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libtiff.org: The libtiff website is a good place to download the libtiff source. It is also quite likely there is a binary package for your chosen operating system.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: If all else fails, then the Adobe TIFF Specification can be useful.</para></listitem>

<listitem><para>http://gopher.std.com/homepages/jimf/xloadimage.html: The xloadimage web page might be of interest.</para></listitem>

<listitem><para>http://www.ee.cooper.edu/courses/course_pages/past_courses/EE458/TIFF/index.html: The Cooper Union for the Advancement of Science and Art has some notes from a previous course dealing with libtiff online.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/graphics/graphics.html: The Adobe Graphics technical notes page is quite useful.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: The current version of the TIFF specification can be found here.</para></listitem>

<listitem><para>http://home.earthlink.net/~ritter/tiff/: The unofficial TIFF site contains some useful resources.</para></listitem>

<listitem><para>http://www.inforamp.net/~poynton/notes/colour_and_gamma/ColorFAQ.html: a FAQ document discussion of converting to gray scale</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>Portions first published by IBM DeveloperWorks</title>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</sect1>
</chapter>
<chapter id="chap-gif"><title>GIF</title>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>

<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>








<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
</para>

<sidebar><title>Data streams?</title>
<para>
It should be noted that the GIF specification doesn't speak of files as such. Instead it uses the term <quote>Data Stream</quote>, which is a concept which embraces files, as well as in memory buffers, and other interesting forms of data storage. It doesn't really make any difference to the discussion of the format here though.
</para>
</sidebar>

<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>
</sect2>

<sect2><title>The header</title>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>

<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>

<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>
</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>

<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</para>

<sect3><title>Formula for global color table size</title>
<para>
The determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</emphasis>, or 255 items.
</para>

<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect3>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>

<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>

<sect3><title>Image descriptors</title>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>

<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
The packed field byte stores the following information:
</para>

<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>
</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>

<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>


<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>

<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>

<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>

</sect4>
</sect3>
</sect2>

<sect2><title>Special purpose blocks</title>
<para>
The other thing which can be stored in the data area of the data stream of a GIF file is special purpose blocks. These are outside the scope of this tutorial, and wont be discussed here.
</para>

</sect2>

<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>
</sect2>


<sect2><title>Interlaced images</title>
<para>
GIF supports the interlacing of images, which is where are the image is loaded, progressively better representations of the image are displayed. Discussing the inner workings of this within the file format is out of the scope of this tutorial however.
</para>

</sect2>
</sect1>


<sect1><title>Conclusion</title>
<para>
In this chapter we have learnt how the GIF format is laid out internally. This will be useful when it is time to dicsuss the PNG format...
</para>
</sect1>
</chapter>
<chapter id="chap-png"><title>PNG</title>
<para><quote>
A Turbo-Studly Image Format with Lossless Compression
(Not Related to Papua New Guinea, the Pawnee National Grassland,
the Professional Numismatists Guild or the ``Pack 'N' Go'' format)
</quote> -- libpng.org</para>

<figure>
<title>Put chunk info in here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<para>
PNG
  <footnote><para>Short for Portable Network Graphics.</para></footnote>
is my favorite image format after TIFF. It is well conceived, well implemented, and very powerful. It also has some interesting features, mainly aimed at Internet use, which TIFF lacks. It is also usable in modern web browsers
  <footnote><para>For instance Netscape 4 and Internet Explorer 4 and later.</para></footnote>
, unlike TIFF. PNG is also much simpler in many respects than TIFF.
</para>

<para>
This chapter will focus on the libpng library. This isn't really a limitation, as the people behind libpng are also the people who write the PNG specification, so you're pretty safe in assuming that if it's useful and PNG does it, then libpng implements it.
</para>

<sect1><title>Introduction</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

A bunch of the examples in this chapter are based on the pngtools code I wrote a while ago, which I have updated as part of writing this chapter.
</para>

<sidebar><title>Refer to the TIFF chapter</title>
<para>
Much of the discussion in this chapter will make a whole bunch more sense if you've read the TIFF chapter. Off you go, I'll wait for you to come back...
</para>
</sidebar>
</sect1>

<sect1><title>Installation</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>Unix</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>

<sect2><title>win32</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect2>
</sect1>

<sect1><title>The PNG on disc format</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Opening a PNG file</title>
<para>
The first step to learning how to use libpng is probably to understand how to open a PNG file and get some data out of it. Below is a minimal example of how to open a PNG file, not including actually reading the image data...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]){
  FILE *image;
  unsigned long width, height;
  int bitdepth, colourtype;
  png_uint_32 i, j;
  png_structp png;
  png_infop info;
  unsigned char sig[8];

  // Open the file
  if ((image = fopen (argv[1], "rb")) == NULL){
    fprintf(stderr, "Could not open the specified PNG file.");
    exit(0);
  }

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL){
    fprintf(stderr, "Could not create a PNG read structure (out of memory?)");
    exit(0);
  }

  if((info = png_create_info_struct(png)) == NULL){
    fprintf(stderr, "Could not create PNG info structure (out of memory?)");
    exit(0);
  }

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct
  if(setjmp(png_jmpbuf(png))){
    fprintf(stderr, "Could not set PNG jump value");
    exit(0);
  }

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

  // This cleans things up for us in the PNG library
  fclose(image);
  png_destroy_read_struct(&amp;png, &amp;info, NULL);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-open/read-infrastructure.c</emphasis></para>

<para>
In this example, we do everything we need to open a PNG image, without actually reading the image data. The steps to getting to the image data are:
</para>

<itemizedlist>
<listitem><para>Open the file ready for reading. For this we just use the c standard library's <command>FILE *</command>, unlike the libtiff examples, in which we used a <command>TIFF *</command>
  <footnote><para>In reality, the libtiff could just use the <command>FILE *</command> method internally, although they don't always, as shown by the TIFFClientOpen examples in the TIFF chapter.</para></footnote>
. I'm not aware of whether we can fake out a <command>FILE *</command> if we wanted to pull a PNG out of something other than a file, one day when I have infinite free time I really should look more into this.</para></listitem>

<listitem><para>Another thing we need to do which libtiff does for us and libpng doesn't is check that the file really is a PNG file. We do this with the <command>png_check_sig</command>() call. This expects the first 8 bytes of the file to be handed to it, which is what the <command>fread</command>() function call gets for us.</para></listitem>

<listitem><para></para></listitem>
</itemizedlist>
</sect1>

<sect1><title>PNG tags</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>pnginfo</title>
<para>
The <command>pnginfo</command> command implemented here is modeled on the <command>tiffinfo</command>, which was discussed in the TIFF chapter earlier in this tutorial. In fact, the output text is written to be as close to the <command>tiffinfo</command> command as possible.
</para>

<programlisting>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

void pnginfo_displayfile(char *, int, int);
void pnginfo_error(char *);
void *pnginfo_xmalloc(size_t);
void usage(void);

#define pnginfo_true 1
#define pnginfo_false 0

int main(int argc, char *argv[]){
  int i, optchar, extractBitmap = pnginfo_false, displayBitmap = pnginfo_false;

  // Initialise the argument that filenames start at
  i = 1;
  
  // Use getopt to determine what we have been asked to do
  while((optchar = getopt(argc, argv, "Dd")) != -1){
    switch(optchar){
    case 'd':
      displayBitmap = pnginfo_true;
      extractBitmap = pnginfo_true;
      i++;
      break;

    case 'D':
      extractBitmap = pnginfo_true;
      i++;
      break;

    case '?':
    default:
      usage();
      break;
    }
  }

  // Determine if we were given a filename on the command line
  if(argc &lt; 2)
    usage();

  // For each filename that we have:
  for(; i &lt; argc; i++)
    pnginfo_displayfile(argv[i], extractBitmap, displayBitmap);
}

void pnginfo_displayfile(char *filename, int extractBitmap, int displayBitmap){
  FILE *image;
  unsigned long imageBufSize, width, height, runlen;
  unsigned char signature;
  int bitdepth, colourtype;
  png_uint_32 i, j, rowbytes;
  png_structp png;
  png_infop info;
  unsigned char sig[8];
  png_bytepp row_pointers = NULL;
  char *bitmap;

  printf("%s...\n", filename);

  // Open the file
  if ((image = fopen (filename, "rb")) == NULL)
    pnginfo_error ("Could not open the specified PNG file.");

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("  This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL)
    pnginfo_error("Could not create a PNG read structure (out of memory?)");

  if((info = png_create_info_struct(png)) == NULL)
    pnginfo_error("Could not create PNG info structure (out of memory?)");
  
  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct

  if(setjmp(png_jmpbuf(png)))
    pnginfo_error("Could not set PNG jump value");

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

  ///////////////////////////////////////////////////////////////////////////
  // Start displaying information
  //
  // Can't fight the moonlight...
  ///////////////////////////////////////////////////////////////////////////
  
  printf("  Image Width: %d Image Length: %d\n", width, height);
  printf("  Bits/Sample: %d\n", bitdepth);
  printf("  Samples/Pixel: %d\n", info-&gt;channels);
  printf("  Pixel Depth: %d\n", info-&gt;pixel_depth);  // Does this add value?

  // Photometric interp packs a lot of information
  printf("  Colour Type (Photometric Interpretation): ");

  switch(colourtype){
  case PNG_COLOR_TYPE_GRAY:
    printf("GRAYSCALE ");
    break;

  case PNG_COLOR_TYPE_PALETTE:
    printf("PALETTED COLOUR ");
    if(info-&gt;num_trans &gt; 0) printf("with alpha ");
    printf("(%d colours, %d transparent) ", 
	   info-&gt;num_palette, info-&gt;num_trans);
    break;

  case PNG_COLOR_TYPE_RGB:
    printf("RGB ");
    break;

  case PNG_COLOR_TYPE_RGB_ALPHA:
    printf("RGB with alpha channel ");
    break;

  case PNG_COLOR_TYPE_GRAY_ALPHA:
    printf("GRAYSCALE with alpha channel ");
    break;

  default:
    printf("Unknown photometric interpretation!");
    break;
  }
  printf("\n");

  printf("  Image filter: ");
  switch(info-&gt;filter_type){
  case PNG_FILTER_TYPE_BASE:
    printf("Single row per byte filter ");
    break;

  case PNG_INTRAPIXEL_DIFFERENCING:
    printf("Intrapixel differencing (MNG only) ");
    break;

  default:
    printf("Unknown filter! ");
    break;
  }
  printf("\n");

  printf("  Interlacing: ");
  switch(info-&gt;interlace_type){
  case PNG_INTERLACE_NONE:
    printf("No interlacing ");
    break;

  case PNG_INTERLACE_ADAM7:
    printf("Adam7 interlacing ");
    break;

  default:
    printf("Unknown interlacing ");
    break;
  }
  printf("\n");

  printf("  Compression Scheme: ");
  switch(info-&gt;compression_type){
  case PNG_COMPRESSION_TYPE_BASE:
    printf("Deflate method 8, 32k window");
    break;

  default:
    printf("Unknown compression scheme!");
    break;
  }
  printf("\n");

  printf("  Resolution: %d, %d ", 
	 info-&gt;x_pixels_per_unit, info-&gt;y_pixels_per_unit);
  switch(info-&gt;phys_unit_type){
  case PNG_RESOLUTION_UNKNOWN:
    printf("(unit unknown)");
    break;

  case PNG_RESOLUTION_METER:
    printf("(pixels per meter)");
    break;

  default:
    printf("(Unknown value for unit stored)");
    break;
  }
  printf("\n");

  // FillOrder is always msb-to-lsb, big endian
  printf("  FillOrder: msb-to-lsb\n  Byte Order: Network (Big Endian)\n");

  // Text comments
  printf("  Number of text strings: %d of %d\n", 
	 info-&gt;num_text, info-&gt;max_text);

  for(i = 0; i &lt; info-&gt;num_text; i++){
    printf("    %s ", info-&gt;text[i].key);

    switch(info-&gt;text[1].compression){
    case -1:
      printf("(tEXt uncompressed)");
      break;

    case 0:
      printf("(xTXt deflate compressed)");
      break;

    case 1:
      printf("(iTXt uncompressed)");
      break;

    case 2:
      printf("(iTXt deflate compressed)");
      break;

    default:
      printf("(unknown compression)");
      break;
    }

    printf(": ");
    j = 0;
    while(info-&gt;text[i].text[j] != '\0'){
      if(info-&gt;text[i].text[j] == '\n') printf("\\n");
      else fputc(info-&gt;text[i].text[j], stdout);

      j++;
    }

    printf("\n");
  }

  // Print a blank line
  printf("\n");

  // Do we want to extract the image data? We are meant to tell the user if
  // there are errors, but we don't currently trap any errors here -- I need
  // to look into this
  if(extractBitmap == pnginfo_true){
    if (colourtype == PNG_COLOR_TYPE_PALETTE)
      png_set_expand (png);

    png_set_strip_alpha (png);
    png_read_update_info (png, info);
    
    rowbytes = png_get_rowbytes (png, info);
    bitmap =
      (unsigned char *) pnginfo_xmalloc ((rowbytes * height) + 1);
    row_pointers = pnginfo_xmalloc (height * sizeof (png_bytep));
    
    // Get the image bitmap
    for (i = 0; i &lt; height; ++i)
      row_pointers[i] = bitmap + (i * rowbytes);
    png_read_image (png, row_pointers);
    free(row_pointers);
    png_read_end (png, NULL);
    
    // Do we want to display this bitmap?
    if(displayBitmap == pnginfo_true){
      printf("Dumping the bitmap for this image:\n");

      runlen = 0;
      for(i = 0; i &lt; rowbytes * height / 3; i+=3){
	if((runlen != 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
	   &amp;&amp; (bitmap[i] == 0)) runlen++;
	else if(runlen != 0){
	  if(runlen &gt; 1) printf("* %d ", runlen);
	  runlen = 0;
	}

	if((runlen == 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
	   &amp;&amp; (bitmap[i] == 0)){
	  printf("[0, 0, 0] ");
	  runlen++;
	}
	
	if(runlen == 0)
	  printf("[%02x %02x %02x] ", (unsigned char) bitmap[i],
		 (unsigned char) bitmap[i + 1],
		 (unsigned char) bitmap[i + 2]);
      }
    }
  }

  // This cleans things up for us in the PNG library
  fclose(image);
  png_destroy_read_struct(&amp;png, &amp;info, NULL);
}

// You can bang or head or you can drown in a hole
//                                                    -- Vanessa Amarosi, Shine
void
pnginfo_error (char *message)
{
  fprintf (stderr, "%s\n", message);
  exit (42);
}

// Allocate some memory
void *
pnginfo_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pnginfo_error ("pnginfo_xmalloc failed to allocate memory");
    }

  return buffer;
}

void usage(){
  pnginfo_error("Usage: pnginfo [-d] [-D] &lt;filenames&gt;");
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pngtools/pnginfo.c</emphasis></para>
</sect2>
</sect1>

<sect1><title>Man pages</title>
<para>
To be honest, the libtiff man pages are much better than the documentation which comes with libpng. libpng has one main man page, which is included for ease of reference below.
</para>

<sect2><title>libpng</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<figure>
<title>source/png/man/libpng.3</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect2>

<sect2><title>libpng.txt</title>
<para>libpng.txt - A description on how to use and modify libpng
</para>
<para>libpng version 1.0.9 - January 31, 2001
Updated and distributed by Glenn Randers-Pehrson
&lt;randeg@alum.rpi.edu&gt;
Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson
For conditions of distribution and use, see copyright
notice in png.h.
</para>
<para>based on:
</para>
<para>libpng 1.0 beta 6 version 0.96 May 28, 1997
Updated and distributed by Andreas Dilger
Copyright (c) 1996, 1997 Andreas Dilger
</para>
<para>libpng 1.0 beta 2 - version 0.88 January 26, 1996
For conditions of distribution and use, see copyright
notice in png.h. Copyright (c) 1995, 1996 Guy Eric
Schalnat, Group 42, Inc.
</para>
<para>Updated/rewritten per request in the libpng FAQ
Copyright (c) 1995, 1996 Frank J. T. Wojcik
December 18, 1995 &amp; January 20, 1996
</para>

<sect3><title>I. Introduction</title>

<para>This file describes how to use and modify the PNG reference library
(known as libpng) for your own use. There are five sections to this
file: introduction, structures, reading, writing, and modification and
configuration notes for various special platforms. In addition to this
file, example.c is a good starting point for using the library, as
it is heavily commented and should include everything most people
will need. We assume that libpng is already installed; see the
INSTALL file for instructions on how to install libpng.
</para>
<para>Libpng was written as a companion to the PNG specification, as a way
of reducing the amount of time and effort it takes to support the PNG
file format in application programs.
</para>
<para>The PNG-1.2 specification is available at &lt;http://www.libpng.org/pub/png&gt;
and at &lt;ftp://ftp.uu.net/graphics/png/documents/&gt;.
</para>
<para>The PNG-1.0 specification is available
as RFC 2083 &lt;ftp://ftp.uu.net/graphics/png/documents/&gt; and as a
W3C Recommendation &lt;http://www.w3.org/TR/REC.png.html&gt;. Some
additional chunks are described in the special-purpose public chunks
documents at &lt;ftp://ftp.uu.net/graphics/png/documents/&gt;.
</para>
<para>Other information
about PNG, and the latest version of libpng, can be found at the PNG home
page, &lt;http://www.libpng.org/pub/png/&gt;
and at &lt;ftp://ftp.uu.net/graphics/png/&gt;.
</para>
<para>Most users will not have to modify the library significantly; advanced
users may want to modify it more. All attempts were made to make it as
complete as possible, while keeping the code easy to understand.
Currently, this library only supports C. Support for other languages
is being considered.
</para>
<para>Libpng has been designed to handle multiple sessions at one time,
to be easily modifiable, to be portable to the vast majority of
machines (ANSI, K&amp;R, 16-, 32-, and 64-bit) available, and to be easy
to use. The ultimate goal of libpng is to promote the acceptance of
the PNG file format in whatever way possible. While there is still
work to be done (see the TODO file), libpng should cover the
majority of the needs of its users.
</para>
<para>Libpng uses zlib for its compression and decompression of PNG files.
Further information about zlib, and the latest version of zlib, can
be found at the zlib home page, &lt;http://www.info-zip.org/pub/infozip/zlib/&gt;.
The zlib compression utility is a general purpose utility that is
useful for more than PNG files, and can be used without libpng.
See the documentation delivered with zlib for more details.
You can usually find the source files for the zlib utility wherever you
find the libpng source files.
</para>
<para>Libpng is thread safe, provided the threads are using different
instances of the structures. Each thread should have its own
png_struct and png_info instances, and thus its own image.
Libpng does not protect itself against two threads using the
same instance of a structure.
</para>

</sect3>

<sect3><title>II. Structures</title>

<para>There are two main structures that are important to libpng, png_struct
and png_info. The first, png_struct, is an internal structure that
will not, for the most part, be used by a user except as the first
variable passed to every libpng function call.
</para>
<para>The png_info structure is designed to provide information about the
PNG file. At one time, the fields of png_info were intended to be
directly accessible to the user. However, this tended to cause problems
with applications using dynamically loaded libraries, and as a result
a set of interface functions for png_info (the png_get_*() and png_set_*()
functions) was developed. The fields of png_info are still available for
older applications, but it is suggested that applications use the new
interfaces if at all possible.
</para>
<para>Applications that do make direct access to the members of png_struct (except
for png_ptr-&gt;jmpbuf) must be recompiled whenever the library is updated,
and applications that make direct access to the members of png_info must
be recompiled if they were compiled or loaded with libpng version 1.0.6,
in which the members were in a different order. In version 1.0.7, the
members of the png_info structure reverted to the old order, as they were
in versions 0.97c through 1.0.5. Starting with version 2.0.0, both
structures are going to be hidden, and the contents of the structures will
only be accessible through the png_get/png_set functions.
</para>
<para>The png.h header file is an invaluable reference for programming with libpng.
And while I'm on the topic, make sure you include the libpng header file:
</para>
<para>#include &lt;png.h&gt;
</para>
</sect3>

<sect3><title>III. Reading</title>

<para>We'll now walk you through the possible functions to call when reading
in a PNG file sequentially, briefly explaining the syntax and purpose
of each one. See example.c and png.h for more detail. While
progressive reading is covered in the next section, you will still
need some of the functions discussed in this section to read a PNG
file.
</para>
<para>Setup
</para>
<para>You will want to do the I/O initialization(*) before you get into libpng,
so if it doesn't work, you don't have much to undo. Of course, you
will also want to insure that you are, in fact, dealing with a PNG
file. Libpng provides a simple check to see if a file is a PNG file.
To use it, pass in the first 1 to 8 bytes of the file to the function
png_sig_cmp(), and it will return 0 if the bytes match the corresponding
bytes of the PNG signature, or nonzero otherwise. Of course, the more bytes
you pass in, the greater the accuracy of the prediction.
</para>
<para>If you are intending to keep the file pointer open for use in libpng,
you must ensure you don't read more than 8 bytes from the beginning
of the file, and you also have to make a call to png_set_sig_bytes_read()
with the number of bytes you read from the beginning. Libpng will
then only check the bytes (if any) that your program didn't read.
</para>
<para>(*): If you are not using the standard I/O functions, you will need
to replace them with custom functions. See the discussion under
Customizing libpng.
</para>

<para>FILE *fp = fopen(file_name, "rb");
if (!fp)
</para>
<para>return (ERROR);
</para>
<para>fread(header, 1, number, fp);
is_png = !png_sig_cmp(header, 0, number);
if (!is_png)
</para>
<para>return (NOT_PNG);
</para>


<para>Next, png_struct and png_info need to be allocated and initialized. In
order to ensure that the size of these structures is correct even with a
dynamically linked libpng, there are functions to initialize and
allocate the structures. We also pass the library version, optional
pointers to error handling functions, and a pointer to a data struct for
use by the error functions, if necessary (the pointer and functions can
be NULL if the default error handlers are to be used). See the section
on Changes to Libpng below regarding the old initialization functions.
The structure allocation functions quietly return NULL if they fail to
create the structure, so your application should check for that.
</para>
<para>png_structp png_ptr = png_create_read_struct
(PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
user_error_fn, user_warning_fn);
if (!png_ptr)
return (ERROR);
</para>
<para>png_infop info_ptr = png_create_info_struct(png_ptr);
if (!info_ptr)
</para>
<para>png_destroy_read_struct(&amp;png_ptr,
(png_infopp)NULL, (png_infopp)NULL);
return (ERROR);
</para>

<para>png_infop end_info = png_create_info_struct(png_ptr);
if (!end_info)
</para>
<para>png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
(png_infopp)NULL);
return (ERROR);
</para>

<para>If you want to use your own memory allocation routines,
define PNG_USER_MEM_SUPPORTED and use
png_create_read_struct_2() instead of png_create_read_struct():
</para>
<para>png_structp png_ptr = png_create_read_struct_2
(PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
user_error_fn, user_warning_fn, (png_voidp)
user_mem_ptr, user_malloc_fn, user_free_fn);
</para>
<para>The error handling routines passed to png_create_read_struct()
and the memory alloc/free routines passed to png_create_struct_2()
are only necessary if you are not using the libpng supplied error
handling and memory alloc/free functions.
</para>
<para>When libpng encounters an error, it expects to longjmp back
to your routine. Therefore, you will need to call setjmp and pass
your png_jmpbuf(png_ptr). If you read the file from different
routines, you will need to update the jmpbuf field every time you enter
a new routine that will call a png_*() function.
</para>
<para>See your documentation of setjmp/longjmp for your compiler for more
information on setjmp/longjmp. See the discussion on libpng error
handling in the Customizing Libpng section below for more information
on the libpng error handling. If an error occurs, and libpng longjmp's
back to your setjmp, you will want to call png_destroy_read_struct() to
free any memory.
</para>
<para>if (setjmp(png_jmpbuf(png_ptr)))
</para>
<para>png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
&amp;end_info);
fclose(fp);
return (ERROR);
</para>

<para>If you would rather avoid the complexity of setjmp/longjmp issues,
you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case
errors will result in a call to PNG_ABORT() which defaults to abort().
</para>
<para>Now you need to set up the input code. The default for libpng is to
use the C function fread(). If you use this, you will need to pass a
valid FILE * in the function png_init_io(). Be sure that the file is
opened in binary mode. If you wish to handle reading data in another
way, you need not call the png_init_io() function, but you must then
implement the libpng I/O methods discussed in the Customizing Libpng
section below.
</para>
<para>png_init_io(png_ptr, fp);
</para>
<para>If you had previously opened the file and read any of the signature from
the beginning in order to see if this was a PNG file, you need to let
libpng know that there are some bytes missing from the start of the file.
</para>
<para>png_set_sig_bytes(png_ptr, number);
</para>
<para>Setting up callback code
</para>
<para>You can set up a callback function to handle any unknown chunks in the
input stream. You must supply the function
</para>
<para>read_chunk_callback(png_ptr ptr,
png_unknown_chunkp chunk);
</para>
<para>/* The unknown chunk structure contains your
chunk data: */
png_byte name[5];
png_byte *data;
png_size_t size;
/* Note that libpng has already taken care of the
CRC handling */
</para>
<para>/* put your code here. Return one of the following: */
</para>
<para>return (-n); /* chunk had an error */
return (0); /* did not recognize */
return (n); /* success */
</para>

<para>(You can give your function another name that you like instead of
"read_chunk_callback")
</para>
<para>To inform libpng about your function, use
</para>
<para>png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
read_chunk_callback);
</para>
<para>This names not only the callback function, but also a user pointer that
you can retrieve with
</para>
<para>png_get_user_chunk_ptr(png_ptr);
</para>
<para>At this point, you can set up a callback function that will be
called after each row has been read, which you can use to control
a progress meter or the like. It's demonstrated in pngtest.c.
You must supply a function
</para>
<para>void read_row_callback(png_ptr ptr, png_uint_32 row, int pass);
</para>
<para>/* put your code here */
</para>

<para>(You can give it another name that you like instead of "read_row_callback")
</para>
<para>To inform libpng about your function, use
</para>
<para>png_set_read_status_fn(png_ptr, read_row_callback);
</para>
<para>Unknown-chunk handling
</para>
<para>Now you get to set the way the library processes unknown chunks in the
input PNG stream. Both known and unknown chunks will be read. Normal
behavior is that known chunks will be parsed into information in
various info_ptr members; unknown chunks will be discarded. To change
this, you can call:
</para>
<para>png_set_keep_unknown_chunks(png_ptr, info_ptr, keep,
chunk_list, num_chunks);
keep - 0: do not keep
1: keep only if safe-to-copy
2: keep even if unsafe-to-copy
chunk_list - list of chunks affected (a byte string,
five bytes per chunk, NULL or '\0' if
num_chunks is 0)
num_chunks - number of chunks affected; if 0, all
unknown chunks are affected
</para>
<para>Unknown chunks declared in this way will be saved as raw data onto a
list of png_unknown_chunk structures. If a chunk that is normally
known to libpng is named in the list, it will be handled as unknown,
according to the "keep" directive. If a chunk is named in successive
instances of png_set_keep_unknown_chunks(), the final instance will
take precedence.
</para>
<para>The high-level read interface
</para>
<para>At this point there are two ways to proceed; through the high-level
read interface, or through a sequence of low-level read operations.
You can use the high-level interface if (a) you are willing to read
the entire image into memory, and (b) the input transformations
you want to do are limited to the following set:
</para>
<para>PNG_TRANSFORM_IDENTITY No transformation
PNG_TRANSFORM_STRIP_16 Strip 16-bit samples to 8 bits
PNG_TRANSFORM_STRIP_ALPHA Discard the alpha channel
PNG_TRANSFORM_PACKING Expand 1, 2 and 4-bit samples to bytes
PNG_TRANSFORM_PACKSWAP Change order of packed pixels to LSB first
PNG_TRANSFORM_EXPAND Perform set_expand()
PNG_TRANSFORM_INVERT_MONO Invert monochrome images
PNG_TRANSFORM_SHIFT Normalize pixels to the sBIT depth
PNG_TRANSFORM_BGR Flip RGB to BGR, RGBA to BGRA
PNG_TRANSFORM_SWAP_ALPHA Flip RGBA to ARGB or GA to AG
PNG_TRANSFORM_INVERT_ALPHA Change alpha from opacity to transparency
PNG_TRANSFORM_SWAP_ENDIAN Byte-swap 16-bit samples
</para>
<para>(This excludes setting a background color, doing gamma transformation,
dithering, and setting filler.) If this is the case, simply do this:
</para>
<para>png_read_png(png_ptr, info_ptr, png_transforms, NULL)
</para>
<para>where png_transforms is an integer containing the logical OR of
some set of transformation flags. This call is equivalent to png_read_info(),
followed the set of transformations indicated by the transform mask,
then png_read_image(), and finally png_read_end().
</para>
<para>(The final parameter of this call is not yet used. Someday it might point
to transformation parameters required by some future input transform.)
</para>
<para>After you have called png_read_png(), you can retrieve the image data
with
</para>
<para>row_pointers = png_get_rows(png_ptr, info_ptr);
</para>
<para>where row_pointers is an array of pointers to the pixel data for each row:
</para>
<para>png_bytep row_pointers[height];
</para>
<para>If you know your image size and pixel size ahead of time, you can allocate
row_pointers prior to calling png_read_png() with
</para>
<para>row_pointers = png_malloc(png_ptr, height*sizeof(png_bytep));
for (int i=0; i&lt;height, i++)
row_pointers[i]=png_malloc(png_ptr, width*pixel_size);
png_set_rows(png_ptr, info_ptr, &amp;row_pointers);
</para>
<para>Alternatively you could allocate your image in one big block and define
row_pointers[i] to point into the proper places in your block.
</para>
<para>If you use png_set_rows(), the application is responsible for freeing
row_pointers (and row_pointers[i], if they were separately allocated).
</para>
<para>If you don't allocate row_pointers ahead of time, png_read_png() will
do it, and it'll be free'ed when you call png_destroy_*().
</para>
<para>The low-level read interface
</para>
<para>If you are going the low-level route, you are now ready to read all
the file information up to the actual image data. You do this with a
call to png_read_info().
</para>
<para>png_read_info(png_ptr, info_ptr);
</para>
<para>This will process all chunks up to but not including the image data.
</para>
<para>Querying the info structure
</para>
<para>Functions are used to get the information from the info_ptr once it
has been read. Note that these fields may not be completely filled
in until png_read_end() has read the chunk data following the image.
</para>
<para>png_get_IHDR(png_ptr, info_ptr, &amp;width, &amp;height,
&amp;bit_depth, &amp;color_type, &amp;interlace_type,
&amp;compression_type, &amp;filter_method);
</para>
<para>width - holds the width of the image
in pixels (up to 2^31).
height - holds the height of the image
in pixels (up to 2^31).
bit_depth - holds the bit depth of one of the
image channels. (valid values are
1, 2, 4, 8, 16 and depend also on
the color_type. See also
significant bits (sBIT) below).
color_type - describes which color/alpha channels
are present.
PNG_COLOR_TYPE_GRAY
(bit depths 1, 2, 4, 8, 16)
PNG_COLOR_TYPE_GRAY_ALPHA
(bit depths 8, 16)
PNG_COLOR_TYPE_PALETTE
(bit depths 1, 2, 4, 8)
PNG_COLOR_TYPE_RGB
(bit_depths 8, 16)
PNG_COLOR_TYPE_RGB_ALPHA
(bit_depths 8, 16)
</para>
<para>PNG_COLOR_MASK_PALETTE
PNG_COLOR_MASK_COLOR
PNG_COLOR_MASK_ALPHA
</para>
<para>filter_method - (must be PNG_FILTER_TYPE_BASE
for PNG 1.0, and can also be
PNG_INTRAPIXEL_DIFFERENCING if
the PNG datastream is embedded in
a MNG-1.0 datastream)
compression_type - (must be PNG_COMPRESSION_TYPE_BASE
for PNG 1.0)
interlace_type - (PNG_INTERLACE_NONE or
PNG_INTERLACE_ADAM7)
Any or all of interlace_type, compression_type, of
filter_method can be NULL if you are
not interested in their values.
</para>
<para>channels = png_get_channels(png_ptr, info_ptr);
channels - number of channels of info for the
color type (valid values are 1 (GRAY,
PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
4 (RGB_ALPHA or RGB + filler byte))
rowbytes = png_get_rowbytes(png_ptr, info_ptr);
rowbytes - number of bytes needed to hold a row
</para>
<para>signature = png_get_signature(png_ptr, info_ptr);
signature - holds the signature read from the
file (if any). The data is kept in
the same offset it would be if the
whole signature were read (i.e. if an
application had already read in 4
bytes of signature before starting
libpng, the remaining 4 bytes would
be in signature[4] through signature[7]
(see png_set_sig_bytes())).
</para>

<para>width = png_get_image_width(png_ptr,
info_ptr);
height = png_get_image_height(png_ptr,
info_ptr);
bit_depth = png_get_bit_depth(png_ptr,
info_ptr);
color_type = png_get_color_type(png_ptr,
info_ptr);
filter_method = png_get_filter_type(png_ptr,
info_ptr);
compression_type = png_get_compression_type(png_ptr,
info_ptr);
interlace_type = png_get_interlace_type(png_ptr,
info_ptr);
</para>

<para>These are also important, but their validity depends on whether the chunk
has been read. The png_get_valid(png_ptr, info_ptr, PNG_INFO_&lt;chunk&gt;) and
png_get_&lt;chunk&gt;(png_ptr, info_ptr, ...) functions return non-zero if the
data has been read, or zero if it is missing. The parameters to the
png_get_&lt;chunk&gt; are set directly if they are simple data types, or a pointer
into the info_ptr is returned for any complex types.
</para>
<para>png_get_PLTE(png_ptr, info_ptr, &amp;palette,
&amp;num_palette);
palette - the palette for the file
(array of png_color)
num_palette - number of entries in the palette
</para>
<para>png_get_gAMA(png_ptr, info_ptr, &amp;gamma);
gamma - the gamma the file is written
at (PNG_INFO_gAMA)
</para>
<para>png_get_sRGB(png_ptr, info_ptr, &amp;srgb_intent);
srgb_intent - the rendering intent (PNG_INFO_sRGB)
The presence of the sRGB chunk
means that the pixel data is in the
sRGB color space. This chunk also
implies specific values of gAMA and
cHRM.
</para>
<para>png_get_iCCP(png_ptr, info_ptr, &amp;name, &amp;compression_type,
&amp;profile, &amp;proflen);
name - The profile name.
compression - The compression type; always PNG_COMPRESSION_TYPE_BASE
for PNG 1.0. You may give NULL to this argument
to ignore it.
profile - International Color Consortium color profile
data. May contain NULs.
proflen - length of profile data in bytes.
</para>
<para>png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit);
sig_bit - the number of significant bits for
(PNG_INFO_sBIT) each of the gray,
red, green, and blue channels,
whichever are appropriate for the
given color type (png_color_16)
</para>
<para>png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans,
&amp;trans_values);
trans - array of transparent entries for
palette (PNG_INFO_tRNS)
trans_values - graylevel or color sample values of
the single transparent color for
non-paletted images (PNG_INFO_tRNS)
num_trans - number of transparent entries
(PNG_INFO_tRNS)
</para>
<para>png_get_hIST(png_ptr, info_ptr, &amp;hist);
(PNG_INFO_hIST)
hist - histogram of palette (array of
png_uint_16)
</para>
<para>png_get_tIME(png_ptr, info_ptr, &amp;mod_time);
mod_time - time image was last modified
(PNG_VALID_tIME)
</para>
<para>png_get_bKGD(png_ptr, info_ptr, &amp;background);
background - background color (PNG_VALID_bKGD)
valid 16-bit red, green and blue
values, regardless of color_type
</para>
<para>num_comments = png_get_text(png_ptr, info_ptr,
&amp;text_ptr, &amp;num_text);
num_comments - number of comments
text_ptr - array of png_text holding image
comments
text_ptr[i].compression - type of compression used
on "text" PNG_TEXT_COMPRESSION_NONE
PNG_TEXT_COMPRESSION_zTXt
PNG_ITXT_COMPRESSION_NONE
PNG_ITXT_COMPRESSION_zTXt
text_ptr[i].key - keyword for comment. Must contain
1-79 characters.
text_ptr[i].text - text comments for current
keyword. Can be empty.
text_ptr[i].text_length - length of text string,
after decompression, 0 for iTXt
text_ptr[i].itxt_length - length of itxt string,
after decompression, 0 for tEXt/zTXt
text_ptr[i].lang - language of comment (empty
string for unknown).
text_ptr[i].translated_keyword - keyword in UTF-8
(empty string for unknown).
num_text - number of comments (same as num_comments;
you can put NULL here to avoid the duplication)
Note while png_set_text() will accept text, language, and
translated keywords that can be NULL pointers, the structure
returned by png_get_text will always contain regular
zero-terminated C strings. They might be empty strings but
they will never be NULL pointers.
</para>
<para>num_spalettes = png_get_sPLT(png_ptr, info_ptr, &amp;palette_ptr);
palette_ptr - array of palette structures holding
contents of one or more sPLT chunks read.
num_spalettes - number of sPLT chunks read.
</para>
<para>png_get_oFFs(png_ptr, info_ptr, &amp;offset_x, &amp;offset_y,
&amp;unit_type);
offset_x - positive offset from the left edge
of the screen
offset_y - positive offset from the top edge
of the screen
unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
</para>
<para>png_get_pHYs(png_ptr, info_ptr, &amp;res_x, &amp;res_y,
&amp;unit_type);
res_x - pixels/unit physical resolution in
x direction
res_y - pixels/unit physical resolution in
x direction
unit_type - PNG_RESOLUTION_UNKNOWN,
PNG_RESOLUTION_METER
</para>
<para>png_get_sCAL(png_ptr, info_ptr, &amp;unit, &amp;width, &amp;height)
unit - physical scale units (an integer)
width - width of a pixel in physical scale units
height - height of a pixel in physical scale units
(width and height are doubles)
</para>
<para>png_get_sCAL_s(png_ptr, info_ptr, &amp;unit, &amp;width, &amp;height)
unit - physical scale units (an integer)
width - width of a pixel in physical scale units
height - height of a pixel in physical scale units
(width and height are strings like "2.54")
</para>
<para>num_unknown_chunks = png_get_unknown_chunks(png_ptr, info_ptr,
&amp;unknowns)
unknowns - array of png_unknown_chunk structures holding
unknown chunks
unknowns[i].name - name of unknown chunk
unknowns[i].data - data of unknown chunk
unknowns[i].size - size of unknown chunk's data
unknowns[i].location - position of chunk in file
</para>
<para>The value of "i" corresponds to the order in which the chunks were read
from the PNG file or inserted with the png_set_unknown_chunks() function.
</para>
<para>The data from the pHYs chunk can be retrieved in several convenient
forms:
</para>
<para>res_x = png_get_x_pixels_per_meter(png_ptr,
info_ptr)
res_y = png_get_y_pixels_per_meter(png_ptr,
info_ptr)
res_x_and_y = png_get_pixels_per_meter(png_ptr,
info_ptr)
res_x = png_get_x_pixels_per_inch(png_ptr,
info_ptr)
res_y = png_get_y_pixels_per_inch(png_ptr,
info_ptr)
res_x_and_y = png_get_pixels_per_inch(png_ptr,
info_ptr)
aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
info_ptr)
</para>
<para>(Each of these returns 0 [signifying "unknown"] if
the data is not present or if res_x is 0;
res_x_and_y is 0 if res_x != res_y)
</para>
<para>The data from the oFFs chunk can be retrieved in several convenient
forms:
</para>
<para>x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
y_offset = png_get_y_offset_microns(png_ptr, info_ptr);
x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
y_offset = png_get_y_offset_inches(png_ptr, info_ptr);
</para>
<para>(Each of these returns 0 [signifying "unknown" if both
x and y are 0] if the data is not present or if the chunk
is present but the unit is the pixel)
</para>
<para>For more information, see the png_info definition in png.h and the
PNG specification for chunk contents. Be careful with trusting
rowbytes, as some of the transformations could increase the space
needed to hold a row (expand, filler, gray_to_rgb, etc.).
See png_read_update_info(), below.
</para>
<para>A quick word about text_ptr and num_text. PNG stores comments in
keyword/text pairs, one pair per chunk, with no limit on the number
of text chunks, and a 2^31 byte limit on their size. While there are
suggested keywords, there is no requirement to restrict the use to these
strings. It is strongly suggested that keywords and text be sensible
to humans (that's the point), so don't use abbreviations. Non-printing
symbols are not allowed. See the PNG specification for more details.
There is also no requirement to have text after the keyword.
</para>
<para>Keywords should be limited to 79 Latin-1 characters without leading or
trailing spaces, but non-consecutive spaces are allowed within the
keyword. It is possible to have the same keyword any number of times.
The text_ptr is an array of png_text structures, each holding a
pointer to a language string, a pointer to a keyword and a pointer to
a text string. The text string, language code, and translated
keyword may be empty or NULL pointers. The keyword/text
pairs are put into the array in the order that they are received.
However, some or all of the text chunks may be after the image, so, to
make sure you have read all the text chunks, don't mess with these
until after you read the stuff after the image. This will be
mentioned again below in the discussion that goes with png_read_end().
</para>
<para>Input transformations
</para>
<para>After you've read the header information, you can set up the library
to handle any special transformations of the image data. The various
ways to transform the data will be described in the order that they
should occur. This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths. Even though each transformation
checks to see if it has data that it can do something with, you should
make sure to only enable a transformation if it will be valid for the
data. For example, don't swap red and blue on grayscale data.
</para>
<para>The colors used for the background and transparency values should be
supplied in the same format/depth as the current image data. They
are stored in the same format/depth as the image data in a bKGD or tRNS
chunk, so this is what libpng expects for this data. The colors are
transformed to keep in sync with the image data when an application
calls the png_read_update_info() routine (see below).
</para>
<para>Data will be decoded into the supplied row buffers packed into bytes
unless the library has been told to transform it into another format.
For example, 4 bit/pixel paletted or grayscale data will be returned
2 pixels/byte with the leftmost pixel in the high-order bits of the
byte, unless png_set_packing() is called. 8-bit RGB data will be stored
in RGB RGB RGB format unless png_set_filler() is called to insert filler
bytes, either before or after each RGB triplet. 16-bit RGB data will
be returned RRGGBB RRGGBB, with the most significant byte of the color
value first, unless png_set_strip_16() is called to transform it to
regular RGB RGB triplets, or png_set_filler() is called to insert
filler bytes, either before or after each RRGGBB triplet. Similarly,
8-bit or 16-bit grayscale data can be modified with png_set_filler()
or png_set_strip_16().
</para>
<para>The following code transforms grayscale images of less than 8 to 8 bits,
changes paletted images to RGB, and adds a full alpha channel if there is
transparency information in a tRNS chunk. This is most useful on
grayscale images with bit depths of 2 or 4 or if there is a multiple-image
viewing application that wishes to treat all images in the same way.
</para>
<para>if (color_type == PNG_COLOR_TYPE_PALETTE)
png_set_palette_to_rgb(png_ptr);
</para>
<para>if (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp;
bit_depth &lt; 8) png_set_gray_1_2_4_to_8(png_ptr);
</para>
<para>if (png_get_valid(png_ptr, info_ptr,
PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);
</para>
<para>These three functions are actually aliases for png_set_expand(), added
in libpng version 1.0.4, with the function names expanded to improve code
readability. In some future version they may actually do different
things.
</para>
<para>PNG can have files with 16 bits per channel. If you only can handle
8 bits per channel, this will strip the pixels down to 8 bit.
</para>
<para>if (bit_depth == 16)
png_set_strip_16(png_ptr);
</para>
<para>If, for some reason, you don't need the alpha channel on an image,
and you want to remove it rather than combining it with the background
(but the image author certainly had in mind that you *would* combine
it with the background, so that's what you should probably do):
</para>
<para>if (color_type &amp; PNG_COLOR_MASK_ALPHA)
png_set_strip_alpha(png_ptr);
</para>
<para>In PNG files, the alpha channel in an image
is the level of opacity. If you need the alpha channel in an image to
be the level of transparency instead of opacity, you can invert the
alpha channel (or the tRNS chunk data) after it's read, so that 0 is
fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
images) is fully transparent, with
</para>
<para>png_set_invert_alpha(png_ptr);
</para>
<para>PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit
files. This code expands to 1 pixel per byte without changing the
values of the pixels:
</para>
<para>if (bit_depth &lt; 8)
png_set_packing(png_ptr);
</para>
<para>PNG files have possible bit depths of 1, 2, 4, 8, and 16. All pixels
stored in a PNG image have been "scaled" or "shifted" up to the next
higher possible bit depth (e.g. from 5 bits/sample in the range [0,31] to
8 bits/sample in the range [0, 255]). However, it is also possible to
convert the PNG pixel data back to the original bit depth of the image.
This call reduces the pixels back down to the original bit depth:
</para>
<para>png_color_16p sig_bit;
</para>
<para>if (png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit))
png_set_shift(png_ptr, sig_bit);
</para>
<para>PNG files store 3-color pixels in red, green, blue order. This code
changes the storage of the pixels to blue, green, red:
</para>
<para>if (color_type == PNG_COLOR_TYPE_RGB ||
color_type == PNG_COLOR_TYPE_RGB_ALPHA)
png_set_bgr(png_ptr);
</para>
<para>PNG files store RGB pixels packed into 3 bytes. This code expands them
into 4 bytes for windowing systems that need them in this format:
</para>
<para>if (bit_depth == 8 &amp;&amp; color_type ==
PNG_COLOR_TYPE_RGB) png_set_filler(png_ptr,
filler, PNG_FILLER_BEFORE);
</para>
<para>where "filler" is the 8 or 16-bit number to fill with, and the location is
either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
you want the filler before the RGB or after. This transformation
does not affect images that already have full alpha channels.
</para>
<para>If you are reading an image with an alpha channel, and you need the
data as ARGB instead of the normal PNG format RGBA:
</para>
<para>if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
png_set_swap_alpha(png_ptr);
</para>
<para>For some uses, you may want a grayscale image to be represented as
RGB. This code will do that conversion:
</para>
<para>if (color_type == PNG_COLOR_TYPE_GRAY ||
color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
png_set_gray_to_rgb(png_ptr);
</para>
<para>Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
with alpha.
</para>
<para>if (color_type == PNG_COLOR_TYPE_RGB ||
color_type == PNG_COLOR_TYPE_RGB_ALPHA)
png_set_rgb_to_gray_fixed(png_ptr, error_action,
int red_weight, int green_weight);
</para>
<para>error_action = 1: silently do the conversion
error_action = 2: issue a warning if the original
image has any pixel where
red != green or red != blue
error_action = 3: issue an error and abort the
conversion if the original
image has any pixel where
red != green or red != blue
</para>
<para>red_weight: weight of red component times 100000
green_weight: weight of green component times 100000
If either weight is negative, default
weights (21268, 71514) are used.
</para>
<para>If you have set error_action = 1 or 2, you can
later check whether the image really was gray, after processing
the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
It will return a png_byte that is zero if the image was gray or
1 if there were any non-gray pixels. bKGD and sBIT data
will be silently converted to grayscale, using the green channel
data, regardless of the error_action setting.
</para>
<para>With red_weight+green_weight&lt;=100000,
the normalized graylevel is computed:
</para>
<para>int rw = red_weight * 65536;
int gw = green_weight * 65536;
int bw = 65536 - (rw + gw);
gray = (rw*red + gw*green + bw*blue)/65536;
</para>
<para>The default values approximate those recommended in the Charles
Poynton's Color FAQ, &lt;http://www.inforamp.net/~poynton/&gt;
Copyright (c) 1998-01-04 Charles Poynton poynton@inforamp.net
</para>
<para>Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
</para>
<para>Libpng approximates this with
</para>
<para>Y = 0.21268 * R + 0.7151 * G + 0.07217 * B
</para>
<para>which can be expressed with integers as
</para>
<para>Y = (6969 * R + 23434 * G + 2365 * B)/32768
</para>
<para>The calculation is done in a linear colorspace, if the image gamma
is known.
</para>
<para>If you have a grayscale and you are using png_set_expand_depth() or
png_set_expand() to change to
a higher bit-depth, you must either supply the background color as a gray
value at the original file bit-depth (need_expand = 1) or else supply the
background color as an RGB triplet at the final, expanded bit depth
(need_expand = 0). Similarly, if you are reading a paletted image, you
must either supply the background color as a palette index (need_expand = 1)
or as an RGB triplet that may or may not be in the palette (need_expand = 0).
</para>
<para>png_color_16 my_background;
png_color_16p image_background;
</para>
<para>if (png_get_bKGD(png_ptr, info_ptr, &amp;image_background))
png_set_background(png_ptr, image_background,
PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
else
png_set_background(png_ptr, &amp;my_background,
PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
</para>
<para>The png_set_background() function tells libpng to composite images
with alpha or simple transparency against the supplied background
color. If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
you may use this color, or supply another color more suitable for
the current display (e.g., the background color from a web page). You
need to tell libpng whether the color is in the gamma space of the
display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
(PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
know why anyone would use this, but it's here).
</para>
<para>To properly display PNG images on any kind of system, the application needs
to know what the display gamma is. Ideally, the user will know this, and
the application will allow them to set it. One method of allowing the user
to set the display gamma separately for each system is to check for a
SCREEN_GAMMA or DISPLAY_GAMMA environment variable, which will hopefully be
correctly set.
</para>
<para>Note that display_gamma is the overall gamma correction required to produce
pleasing results, which depends on the lighting conditions in the surrounding
environment. In a dim or brightly lit room, no compensation other than
the physical gamma exponent of the monitor is needed, while in a dark room
a slightly smaller exponent is better.
</para>
<para>double gamma, screen_gamma;
</para>
<para>if (/* We have a user-defined screen
gamma value */)
</para>
<para>screen_gamma = user_defined_screen_gamma;
</para>
<para>/* One way that applications can share the same
screen gamma value */
else if ((gamma_str = getenv("SCREEN_GAMMA"))
!= NULL)
</para>
<para>screen_gamma = (double)atof(gamma_str);
</para>
<para>/* If we don't have another value */
else
</para>
<para>screen_gamma = 2.2; /* A good guess for a
PC monitor in a bright office or a dim room */
screen_gamma = 2.0; /* A good guess for a
PC monitor in a dark room */
screen_gamma = 1.7 or 1.0; /* A good
guess for Mac systems */
</para>

<para>The png_set_gamma() function handles gamma transformations of the data.
Pass both the file gamma and the current screen_gamma. If the file does
not have a gamma value, you can pass one anyway if you have an idea what
it is (usually 0.45455 is a good guess for GIF images on PCs). Note
that file gammas are inverted from screen gammas. See the discussions
on gamma in the PNG specification for an excellent description of what
gamma is, and why all applications should support it. It is strongly
recommended that PNG viewers support gamma correction.
</para>
<para>if (png_get_gAMA(png_ptr, info_ptr, &amp;gamma))
png_set_gamma(png_ptr, screen_gamma, gamma);
else
png_set_gamma(png_ptr, screen_gamma, 0.45455);
</para>
<para>If you need to reduce an RGB file to a paletted file, or if a paletted
file has more entries then will fit on your screen, png_set_dither()
will do that. Note that this is a simple match dither that merely
finds the closest color available. This should work fairly well with
optimized palettes, and fairly badly with linear color cubes. If you
pass a palette that is larger then maximum_colors, the file will
reduce the number of colors in the palette so it will fit into
maximum_colors. If there is a histogram, it will use it to make
more intelligent choices when reducing the palette. If there is no
histogram, it may not do as good a job.
</para>
<para>if (color_type &amp; PNG_COLOR_MASK_COLOR)
</para>
<para>if (png_get_valid(png_ptr, info_ptr,
PNG_INFO_PLTE))
</para>
<para>png_uint_16p histogram;
</para>
<para>png_get_hIST(png_ptr, info_ptr,
&amp;histogram);
png_set_dither(png_ptr, palette, num_palette,
max_screen_colors, histogram, 1);
</para>
<para>else
</para>
<para>png_color std_color_cube[MAX_SCREEN_COLORS] =
{ ... colors ... };
</para>
<para>png_set_dither(png_ptr, std_color_cube,
MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
NULL,0);
</para>
}

<para>PNG files describe monochrome as black being zero and white being one.
The following code will reverse this (make black be one and white be
zero):
</para>
<para>if (bit_depth == 1 &amp;&amp; color_type == PNG_COLOR_GRAY)
png_set_invert_mono(png_ptr);
</para>
<para>PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first). This code changes the storage to the
other way (little-endian, i.e. least significant bits first, the
way PCs store them):
</para>
<para>if (bit_depth == 16)
png_set_swap(png_ptr);
</para>
<para>If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
need to change the order the pixels are packed into bytes, you can use:
</para>
<para>if (bit_depth &lt; 8)
png_set_packswap(png_ptr);
</para>
<para>Finally, you can write your own transformation function if none of
the existing ones meets your needs. This is done by setting a callback
with
</para>
<para>png_set_read_user_transform_fn(png_ptr,
read_transform_fn);
</para>
<para>You must supply the function
</para>
<para>void read_transform_fn(png_ptr ptr, row_info_ptr
row_info, png_bytep data)
</para>
<para>See pngtest.c for a working example. Your function will be called
after all of the other transformations have been processed.
</para>
<para>You can also set up a pointer to a user structure for use by your
callback function, and you can inform libpng that your transform
function will change the number of channels or bit depth with the
function
</para>
<para>png_set_user_transform_info(png_ptr, user_ptr,
user_depth, user_channels);
</para>
<para>The user's application, not libpng, is responsible for allocating and
freeing any memory required for the user structure.
</para>
<para>You can retrieve the pointer via the function
png_get_user_transform_ptr(). For example:
</para>
<para>voidp read_user_transform_ptr =
png_get_user_transform_ptr(png_ptr);
</para>
<para>The last thing to handle is interlacing; this is covered in detail below,
but you must call the function here if you want libpng to handle expansion
of the interlaced image.
</para>
<para>number_of_passes = png_set_interlace_handling(png_ptr);
</para>
<para>After setting the transformations, libpng can update your png_info
structure to reflect any transformations you've requested with this
call. This is most useful to update the info structure's rowbytes
field so you can use it to allocate your image memory. This function
will also update your palette with the correct screen_gamma and
background if these have been given with the calls above.
</para>
<para>png_read_update_info(png_ptr, info_ptr);
</para>
<para>After you call png_read_update_info(), you can allocate any
memory you need to hold the image. The row data is simply
raw byte data for all forms of images. As the actual allocation
varies among applications, no example will be given. If you
are allocating one large chunk, you will need to build an
array of pointers to each row, as it will be needed for some
of the functions below.
</para>
<para>Reading image data
</para>
<para>After you've allocated memory, you can read the image data.
The simplest way to do this is in one function call. If you are
allocating enough memory to hold the whole image, you can just
call png_read_image() and libpng will read in all the image data
and put it in the memory area supplied. You will need to pass in
an array of pointers to each row.
</para>
<para>This function automatically handles interlacing, so you don't need
to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_read_rows().
</para>
<para>png_read_image(png_ptr, row_pointers);
</para>
<para>where row_pointers is:
</para>
<para>png_bytep row_pointers[height];
</para>
<para>You can point to void or char or whatever you use for pixels.
</para>
<para>If you don't want to read in the whole image at once, you can
use png_read_rows() instead. If there is no interlacing (check
interlace_type == PNG_INTERLACE_NONE), this is simple:
</para>
<para>png_read_rows(png_ptr, row_pointers, NULL,
number_of_rows);
</para>
<para>where row_pointers is the same as in the png_read_image() call.
</para>
<para>If you are doing this just one row at a time, you can do this with
a single row_pointer instead of an array of row_pointers:
</para>
<para>png_bytep row_pointer = row;
png_read_row(png_ptr, row_pointer, NULL);
</para>
<para>If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
get somewhat harder. The only current (PNG Specification version 1.2)
interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7)
is a somewhat complicated 2D interlace scheme, known as Adam7, that
breaks down an image into seven smaller images of varying size, based
on an 8x8 grid.
</para>
<para>libpng can fill out those images or it can give them to you "as is".
If you want them filled out, there are two ways to do that. The one
mentioned in the PNG specification is to expand each pixel to cover
those pixels that have not been read yet (the "rectangle" method).
This results in a blocky image for the first pass, which gradually
smooths out as more pixels are read. The other method is the "sparkle"
method, where pixels are drawn only in their final locations, with the
rest of the image remaining whatever colors they were initialized to
before the start of the read. The first method usually looks better,
but tends to be slower, as there are more pixels to put in the rows.
</para>
<para>If you don't want libpng to handle the interlacing details, just call
png_read_rows() seven times to read in all seven images. Each of the
images is a valid image by itself, or they can all be combined on an
8x8 grid to form a single image (although if you intend to combine them
you would be far better off using the libpng interlace handling).
</para>
<para>The first pass will return an image 1/8 as wide as the entire image
(every 8th column starting in column 0) and 1/8 as high as the original
(every 8th row starting in row 0), the second will be 1/8 as wide
(starting in column 4) and 1/8 as high (also starting in row 0). The
third pass will be 1/4 as wide (every 4th pixel starting in column 0) and
1/8 as high (every 8th row starting in row 4), and the fourth pass will
be 1/4 as wide and 1/4 as high (every 4th column starting in column 2,
and every 4th row starting in row 0). The fifth pass will return an
image 1/2 as wide, and 1/4 as high (starting at column 0 and row 2),
while the sixth pass will be 1/2 as wide and 1/2 as high as the original
(starting in column 1 and row 0). The seventh and final pass will be as
wide as the original, and 1/2 as high, containing all of the odd
numbered scanlines. Phew!
</para>
<para>If you want libpng to expand the images, call this before calling
png_start_read_image() or png_read_update_info():
</para>
<para>if (interlace_type == PNG_INTERLACE_ADAM7)
number_of_passes
= png_set_interlace_handling(png_ptr);
</para>
<para>This will return the number of passes needed. Currently, this
is seven, but may change if another interlace type is added.
This function can be called even if the file is not interlaced,
where it will return one pass.
</para>
<para>If you are not going to display the image after each pass, but are
going to wait until the entire image is read in, use the sparkle
effect. This effect is faster and the end result of either method
is exactly the same. If you are planning on displaying the image
after each pass, the "rectangle" effect is generally considered the
better looking one.
</para>
<para>If you only want the "sparkle" effect, just call png_read_rows() as
normal, with the third parameter NULL. Make sure you make pass over
the image number_of_passes times, and you don't change the data in the
rows between calls. You can change the locations of the data, just
not the data. Each pass only writes the pixels appropriate for that
pass, and assumes the data from previous passes is still valid.
</para>
<para>png_read_rows(png_ptr, row_pointers, NULL,
number_of_rows);
</para>
<para>If you only want the first effect (the rectangles), do the same as
before except pass the row buffer in the third parameter, and leave
the second parameter NULL.
</para>
<para>png_read_rows(png_ptr, NULL, row_pointers,
number_of_rows);
</para>
<para>Finishing a sequential read
</para>
<para>After you are finished reading the image through either the high- or
low-level interfaces, you can finish reading the file. If you are
interested in comments or time, which may be stored either before or
after the image data, you should pass the separate png_info struct if
you want to keep the comments from before and after the image
separate. If you are not interested, you can pass NULL.
</para>
<para>png_read_end(png_ptr, end_info);
</para>
<para>When you are done, you can free all memory allocated by libpng like this:
</para>
<para>png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
&amp;end_info);
</para>
<para>It is also possible to individually free the info_ptr members that
point to libpng-allocated storage with the following function:
</para>
<para>png_free_data(png_ptr, info_ptr, mask, n)
mask - identifies data to be freed, a mask
containing the logical OR of one or
more of
PNG_FREE_PLTE, PNG_FREE_TRNS,
PNG_FREE_HIST, PNG_FREE_ICCP,
PNG_FREE_PCAL, PNG_FREE_ROWS,
PNG_FREE_SCAL, PNG_FREE_SPLT,
PNG_FREE_TEXT, PNG_FREE_UNKN,
or simply PNG_FREE_ALL
n - sequence number of item to be freed
(-1 for all items)
</para>
<para>This function may be safely called when the relevant storage has
already been freed, or has not yet been allocated, or was allocated
by the user and not by libpng, and will in those
cases do nothing. The "n" parameter is ignored if only one item
of the selected data type, such as PLTE, is allowed. If "n" is not
-1, and multiple items are allowed for the data type identified in
the mask, such as text or sPLT, only the n'th item is freed.
</para>
<para>The default behavior is only to free data that was allocated internally
by libpng. This can be changed, so that libpng will not free the data,
or so that it will free data that was allocated by the user with png_malloc()
or png_zalloc() and passed in via a png_set_*() function, with
</para>
<para>png_data_freer(png_ptr, info_ptr, freer, mask)
mask - which data elements are affected
same choices as in png_free_data()
freer - one of
PNG_DESTROY_WILL_FREE_DATA
PNG_SET_WILL_FREE_DATA
PNG_USER_WILL_FREE_DATA
</para>
<para>This function only affects data that has already been allocated.
You can call this function after reading the PNG data but before calling
any png_set_*() functions, to control whether the user or the png_set_*()
function is responsible for freeing any existing data that might be present,
and again after the png_set_*() functions to control whether the user
or png_destroy_*() is supposed to free the data. When the user assumes
responsibility for libpng-allocated data, the application must use
png_free() to free it, and when the user transfers responsibility to libpng
for data that the user has allocated, the user must have used png_malloc()
or png_zalloc() to allocate it (the png_zalloc() function is the same
as png_malloc() except that it also zeroes the newly-allocated memory).
</para>
<para>If you allocated your row_pointers in a single block, as suggested above in
the description of the high level read interface, you must not transfer
responsibility for freeing it to the png_set_rows or png_read_destroy function,
because they would also try to free the individual row_pointers[i].
</para>
<para>If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
separately, do not transfer responsibility for freeing text_ptr to libpng,
because when libpng fills a png_text structure it combines these members with
the key member, and png_free_data() will free only text_ptr.key. Similarly,
if you transfer responsibility for free'ing text_ptr from libpng to your
application, your application must not separately free those members.
</para>
<para>The png_free_data() function will turn off the "valid" flag for anything
it frees. If you need to turn the flag off for a chunk that was freed by your
application instead of by libpng, you can use
</para>
<para>png_set_invalid(png_ptr, info_ptr, mask);
mask - identifies the chunks to be made invalid,
containing the logical OR of one or
more of
PNG_INFO_gAMA, PNG_INFO_sBIT,
PNG_INFO_cHRM, PNG_INFO_PLTE,
PNG_INFO_tRNS, PNG_INFO_bKGD,
PNG_INFO_hIST, PNG_INFO_pHYs,
PNG_INFO_oFFs, PNG_INFO_tIME,
PNG_INFO_pCAL, PNG_INFO_sRGB,
PNG_INFO_iCCP, PNG_INFO_sPLT,
PNG_INFO_sCAL, PNG_INFO_IDAT
</para>
<para>For a more compact example of reading a PNG image, see the file example.c.
</para>
<para>Reading PNG files progressively
</para>
<para>The progressive reader is slightly different then the non-progressive
reader. Instead of calling png_read_info(), png_read_rows(), and
png_read_end(), you make one call to png_process_data(), which calls
callbacks when it has the info, a row, or the end of the image. You
set up these callbacks with png_set_progressive_read_fn(). You don't
have to worry about the input/output functions of libpng, as you are
giving the library the data directly in png_process_data(). I will
assume that you have read the section on reading PNG files above,
so I will only highlight the differences (although I will show
all of the code).
</para>
<para>png_structp png_ptr;
png_infop info_ptr;
</para>
<para>/* An example code fragment of how you would
initialize the progressive reader in your
application. */
int
initialize_png_reader()
</para>
<para>png_ptr = png_create_read_struct
(PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
user_error_fn, user_warning_fn);
if (!png_ptr)
return (ERROR);
info_ptr = png_create_info_struct(png_ptr);
if (!info_ptr)
</para>
<para>png_destroy_read_struct(&amp;png_ptr, (png_infopp)NULL,
(png_infopp)NULL);
return (ERROR);
</para>

<para>if (setjmp(png_jmpbuf(png_ptr)))
</para>
<para>png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
(png_infopp)NULL);
return (ERROR);
</para>

<para>/* This one's new. You can provide functions
to be called when the header info is valid,
when each row is completed, and when the image
is finished. If you aren't using all functions,
you can specify NULL parameters. Even when all
three functions are NULL, you need to call
png_set_progressive_read_fn(). You can use
any struct as the user_ptr (cast to a void pointer
for the function call), and retrieve the pointer
from inside the callbacks using the function
</para>
<para>png_get_progressive_ptr(png_ptr);
</para>
<para>which will return a void pointer, which you have
to cast appropriately.
*/
png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
info_callback, row_callback, end_callback);
</para>
<para>return 0;
</para>

<para>/* A code fragment that you call as you receive blocks
of data */
int
process_data(png_bytep buffer, png_uint_32 length)
</para>
<para>if (setjmp(png_jmpbuf(png_ptr)))
</para>
<para>png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
(png_infopp)NULL);
return (ERROR);
</para>

<para>/* This one's new also. Simply give it a chunk
of data from the file stream (in order, of
course). On machines with segmented memory
models machines, don't give it any more than
64K. The library seems to run fine with sizes
of 4K. Although you can give it much less if
necessary (I assume you can give it chunks of
1 byte, I haven't tried less then 256 bytes
yet). When this function returns, you may
want to display any rows that were generated
in the row callback if you don't already do
so there.
*/
png_process_data(png_ptr, info_ptr, buffer, length);
return 0;
</para>

<para>/* This function is called (as set by
png_set_progressive_read_fn() above) when enough data
has been supplied so all of the header has been
read.
*/
void
info_callback(png_structp png_ptr, png_infop info)
</para>
<para>/* Do any setup here, including setting any of
the transformations mentioned in the Reading
PNG files section. For now, you _must_ call
either png_start_read_image() or
png_read_update_info() after all the
transformations are set (even if you don't set
any). You may start getting rows before
png_process_data() returns, so this is your
last chance to prepare for that.
*/
</para>

<para>/* This function is called when each row of image
data is complete */
void
row_callback(png_structp png_ptr, png_bytep new_row,
png_uint_32 row_num, int pass)
</para>
<para>/* If the image is interlaced, and you turned
on the interlace handler, this function will
be called for every row in every pass. Some
of these rows will not be changed from the
previous pass. When the row is not changed,
the new_row variable will be NULL. The rows
and passes are called in order, so you don't
really need the row_num and pass, but I'm
supplying them because it may make your life
easier.
</para>
<para>For the non-NULL rows of interlaced images,
you must call png_progressive_combine_row()
passing in the row and the old row. You can
call this function for NULL rows (it will just
return) and for non-interlaced images (it just
does the memcpy for you) if it will make the
code easier. Thus, you can just do this for
all cases:
*/
</para>
<para>png_progressive_combine_row(png_ptr, old_row,
new_row);
</para>
<para>/* where old_row is what was displayed for
previously for the row. Note that the first
pass (pass == 0, really) will completely cover
the old row, so the rows do not have to be
initialized. After the first pass (and only
for interlaced images), you will have to pass
the current row, and the function will combine
the old row and the new row.
*/
</para>

<para>void
end_callback(png_structp png_ptr, png_infop info)
</para>
<para>/* This function is called after the whole image
has been read, including any chunks after the
image (up to and including the IEND). You
will usually have the same info chunk as you
had in the header, although some data may have
been added to the comments and time fields.
</para>
<para>Most people won't do much here, perhaps setting
a flag that marks the image as finished.
*/
</para>



<para>IV. Writing
</para>
<para>Much of this is very similar to reading. However, everything of
importance is repeated here, so you won't have to constantly look
back up in the reading section to understand writing.
</para>
<para>Setup
</para>
<para>You will want to do the I/O initialization before you get into libpng,
so if it doesn't work, you don't have anything to undo. If you are not
using the standard I/O functions, you will need to replace them with
custom writing functions. See the discussion under Customizing libpng.
</para>
<para>FILE *fp = fopen(file_name, "wb");
if (!fp)
</para>
<para>return (ERROR);
</para>

<para>Next, png_struct and png_info need to be allocated and initialized.
As these can be both relatively large, you may not want to store these
on the stack, unless you have stack space to spare. Of course, you
will want to check if they return NULL. If you are also reading,
you won't want to name your read structure and your write structure
both "png_ptr"; you can call them anything you like, such as
"read_ptr" and "write_ptr". Look at pngtest.c, for example.
</para>
<para>png_structp png_ptr = png_create_write_struct
(PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
user_error_fn, user_warning_fn);
if (!png_ptr)
return (ERROR);
</para>
<para>png_infop info_ptr = png_create_info_struct(png_ptr);
if (!info_ptr)
</para>
<para>png_destroy_write_struct(&amp;png_ptr,
(png_infopp)NULL);
return (ERROR);
</para>

<para>If you want to use your own memory allocation routines,
define PNG_USER_MEM_SUPPORTED and use
png_create_write_struct_2() instead of png_create_write_struct():
</para>
<para>png_structp png_ptr = png_create_write_struct_2
(PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
user_error_fn, user_warning_fn, (png_voidp)
user_mem_ptr, user_malloc_fn, user_free_fn);
</para>
<para>After you have these structures, you will need to set up the
error handling. When libpng encounters an error, it expects to
longjmp() back to your routine. Therefore, you will need to call
setjmp() and pass the png_jmpbuf(png_ptr). If you
write the file from different routines, you will need to update
the png_jmpbuf(png_ptr) every time you enter a new routine that will
call a png_*() function. See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp. See
the discussion on libpng error handling in the Customizing Libpng
section below for more information on the libpng error handling.
</para>
<para>if (setjmp(png_jmpbuf(png_ptr)))
</para>
<para>png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
fclose(fp);
return (ERROR);
</para>
<para>...
return;
</para>
<para>If you would rather avoid the complexity of setjmp/longjmp issues,
you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case
errors will result in a call to PNG_ABORT() which defaults to abort().
</para>
<para>Now you need to set up the output code. The default for libpng is to
use the C function fwrite(). If you use this, you will need to pass a
valid FILE * in the function png_init_io(). Be sure that the file is
opened in binary mode. Again, if you wish to handle writing data in
another way, see the discussion on libpng I/O handling in the Customizing
Libpng section below.
</para>
<para>png_init_io(png_ptr, fp);
</para>
<para>Write callbacks
</para>
<para>At this point, you can set up a callback function that will be
called after each row has been written, which you can use to control
a progress meter or the like. It's demonstrated in pngtest.c.
You must supply a function
</para>
<para>void write_row_callback(png_ptr, png_uint_32 row, int pass);
</para>
<para>/* put your code here */
</para>

<para>(You can give it another name that you like instead of "write_row_callback")
</para>
<para>To inform libpng about your function, use
</para>
<para>png_set_write_status_fn(png_ptr, write_row_callback);
</para>
<para>You now have the option of modifying how the compression library will
run. The following functions are mainly for testing, but may be useful
in some cases, like if you need to write PNG files extremely fast and
are willing to give up some compression, or if you want to get the
maximum possible compression at the expense of slower writing. If you
have no special needs in this area, let the library do what it wants by
not calling this function at all, as it has been tuned to deliver a good
speed/compression ratio. The second parameter to png_set_filter() is
the filter method, for which the only valid values are 0 (as of the
July 1999 PNG specification, version 1.2) or 64 (if you are writing
a PNG datastream that is to be embedded in a MNG datastream). The third
parameter is a flag that indicates which filter type(s) are to be tested
for each scanline. See the PNG specification for details on the specific filter
types.
</para>

<para>/* turn on or off filtering, and/or choose
specific filters. You can use either a single PNG_FILTER_VALUE_NAME
or the logical OR of one or more PNG_FILTER_NAME masks. */
png_set_filter(png_ptr, 0,
PNG_FILTER_NONE | PNG_FILTER_VALUE_NONE |
PNG_FILTER_SUB | PNG_FILTER_VALUE_SUB |
PNG_FILTER_UP | PNG_FILTER_VALUE_UP |
PNG_FILTER_AVE | PNG_FILTER_VALUE_AVE |
PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
PNG_ALL_FILTERS);
</para>
<para>If an application
wants to start and stop using particular filters during compression,
it should start out with all of the filters (to ensure that the previous
row of pixels will be stored in case it's needed later), and then add
and remove them after the start of compression.
</para>
<para>If you are writing a PNG datastream that is to be embedded in a MNG
datastream, the second parameter can be either 0 or 64.
</para>
<para>The png_set_compression_*() functions interface to the zlib compression
library, and should mostly be ignored unless you really know what you are
doing. The only generally useful call is png_set_compression_level()
which changes how much time zlib spends on trying to compress the image
data. See the Compression Library (zlib.h and algorithm.txt, distributed
with zlib) for details on the compression levels.
</para>
<para>/* set the zlib compression level */
png_set_compression_level(png_ptr,
Z_BEST_COMPRESSION);
</para>
<para>/* set other zlib parameters */
png_set_compression_mem_level(png_ptr, 8);
png_set_compression_strategy(png_ptr,
Z_DEFAULT_STRATEGY);
png_set_compression_window_bits(png_ptr, 15);
png_set_compression_method(png_ptr, 8);
png_set_compression_buffer_size(png_ptr, 8192)
</para>
<para>extern PNG_EXPORT(void,png_set_zbuf_size)
</para>
<para>Setting the contents of info for output
</para>
<para>You now need to fill in the png_info structure with all the data you
wish to write before the actual image. Note that the only thing you
are allowed to write after the image is the text chunks and the time
chunk (as of PNG Specification 1.2, anyway). See png_write_end() and
the latest PNG specification for more information on that. If you
wish to write them before the image, fill them in now, and flag that
data as being valid. If you want to wait until after the data, don't
fill them until png_write_end(). For all the fields in png_info and
their data types, see png.h. For explanations of what the fields
contain, see the PNG specification.
</para>
<para>Some of the more important parts of the png_info are:
</para>
<para>png_set_IHDR(png_ptr, info_ptr, width, height,
bit_depth, color_type, interlace_type,
compression_type, filter_method)
width - holds the width of the image
in pixels (up to 2^31).
height - holds the height of the image
in pixels (up to 2^31).
bit_depth - holds the bit depth of one of the
image channels.
(valid values are 1, 2, 4, 8, 16
and depend also on the
color_type. See also significant
bits (sBIT) below).
color_type - describes which color/alpha
channels are present.
PNG_COLOR_TYPE_GRAY
(bit depths 1, 2, 4, 8, 16)
PNG_COLOR_TYPE_GRAY_ALPHA
(bit depths 8, 16)
PNG_COLOR_TYPE_PALETTE
(bit depths 1, 2, 4, 8)
PNG_COLOR_TYPE_RGB
(bit_depths 8, 16)
PNG_COLOR_TYPE_RGB_ALPHA
(bit_depths 8, 16)
</para>
<para>PNG_COLOR_MASK_PALETTE
PNG_COLOR_MASK_COLOR
PNG_COLOR_MASK_ALPHA
</para>
<para>interlace_type - PNG_INTERLACE_NONE or
PNG_INTERLACE_ADAM7
compression_type - (must be
PNG_COMPRESSION_TYPE_DEFAULT)
filter_method - (must be PNG_FILTER_TYPE_DEFAULT
or, if you are writing a PNG to
be embedded in a MNG datastream,
can also be
PNG_INTRAPIXEL_DIFFERENCING)
</para>
<para>png_set_PLTE(png_ptr, info_ptr, palette,
num_palette);
palette - the palette for the file
(array of png_color)
num_palette - number of entries in the palette
</para>
<para>png_set_gAMA(png_ptr, info_ptr, gamma);
gamma - the gamma the image was created
at (PNG_INFO_gAMA)
</para>
<para>png_set_sRGB(png_ptr, info_ptr, srgb_intent);
srgb_intent - the rendering intent
(PNG_INFO_sRGB) The presence of
the sRGB chunk means that the pixel
data is in the sRGB color space.
This chunk also implies specific
values of gAMA and cHRM. Rendering
intent is the CSS-1 property that
has been defined by the International
Color Consortium
(http://www.color.org).
It can be one of
PNG_sRGB_INTENT_SATURATION,
PNG_sRGB_INTENT_PERCEPTUAL,
PNG_sRGB_INTENT_ABSOLUTE, or
PNG_sRGB_INTENT_RELATIVE.
</para>

<para>png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
srgb_intent);
srgb_intent - the rendering intent
(PNG_INFO_sRGB) The presence of the
sRGB chunk means that the pixel
data is in the sRGB color space.
This function also causes gAMA and
cHRM chunks with the specific values
that are consistent with sRGB to be
written.
</para>
<para>png_set_iCCP(png_ptr, info_ptr, name, compression_type,
profile, proflen);
name - The profile name.
compression - The compression type; always PNG_COMPRESSION_TYPE_BASE
for PNG 1.0. You may give NULL to this argument
to ignore it.
profile - International Color Consortium color profile
data. May contain NULs.
proflen - length of profile data in bytes.
</para>
<para>png_set_sBIT(png_ptr, info_ptr, sig_bit);
sig_bit - the number of significant bits for
(PNG_INFO_sBIT) each of the gray, red,
green, and blue channels, whichever are
appropriate for the given color type
(png_color_16)
</para>
<para>png_set_tRNS(png_ptr, info_ptr, trans, num_trans,
trans_values);
trans - array of transparent entries for
palette (PNG_INFO_tRNS)
trans_values - graylevel or color sample values of
the single transparent color for
non-paletted images (PNG_INFO_tRNS)
num_trans - number of transparent entries
(PNG_INFO_tRNS)
</para>
<para>png_set_hIST(png_ptr, info_ptr, hist);
(PNG_INFO_hIST)
hist - histogram of palette (array of
png_uint_16)
</para>
<para>png_set_tIME(png_ptr, info_ptr, mod_time);
mod_time - time image was last modified
(PNG_VALID_tIME)
</para>
<para>png_set_bKGD(png_ptr, info_ptr, background);
background - background color (PNG_VALID_bKGD)
</para>
<para>png_set_text(png_ptr, info_ptr, text_ptr, num_text);
text_ptr - array of png_text holding image
comments
text_ptr[i].compression - type of compression used
on "text" PNG_TEXT_COMPRESSION_NONE
PNG_TEXT_COMPRESSION_zTXt
PNG_ITXT_COMPRESSION_NONE
PNG_ITXT_COMPRESSION_zTXt
text_ptr[i].key - keyword for comment. Must contain
1-79 characters.
text_ptr[i].text - text comments for current
keyword. Can be NULL or empty.
text_ptr[i].text_length - length of text string,
after decompression, 0 for iTXt
text_ptr[i].itxt_length - length of itxt string,
after decompression, 0 for tEXt/zTXt
text_ptr[i].lang - language of comment (NULL or
empty for unknown).
text_ptr[i].translated_keyword - keyword in UTF-8 (NULL
or empty for unknown).
num_text - number of comments
</para>
<para>png_set_sPLT(png_ptr, info_ptr, &amp;palette_ptr, num_spalettes);
palette_ptr - array of png_sPLT_struct structures to be
added to the list of palettes in the info
structure.
num_spalettes - number of palette structures to be added.
</para>
<para>png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
unit_type);
offset_x - positive offset from the left
edge of the screen
offset_y - positive offset from the top
edge of the screen
unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
</para>
<para>png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
unit_type);
res_x - pixels/unit physical resolution
in x direction
res_y - pixels/unit physical resolution
in y direction
unit_type - PNG_RESOLUTION_UNKNOWN,
PNG_RESOLUTION_METER
</para>
<para>png_set_sCAL(png_ptr, info_ptr, unit, width, height)
unit - physical scale units (an integer)
width - width of a pixel in physical scale units
height - height of a pixel in physical scale units
(width and height are doubles)
</para>
<para>png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)
unit - physical scale units (an integer)
width - width of a pixel in physical scale units
height - height of a pixel in physical scale units
(width and height are strings like "2.54")
</para>
<para>png_set_unknown_chunks(png_ptr, info_ptr, &amp;unknowns, num_unknowns)
unknowns - array of png_unknown_chunk structures holding
unknown chunks
unknowns[i].name - name of unknown chunk
unknowns[i].data - data of unknown chunk
unknowns[i].size - size of unknown chunk's data
unknowns[i].location - position to write chunk in file
0: do not write chunk
PNG_HAVE_IHDR: before PLTE
PNG_HAVE_PLTE: before IDAT
PNG_AFTER_IDAT: after IDAT
The "location" member is set automatically according to
what part of the output file has already been written.
You can change its value after calling png_set_unknown_chunks()
as demonstrated in pngtest.c. Within each of the "locations",
the chunks are sequenced according to their position in the
structure (that is, the value of "i", which is the order in which
the chunk was either read from the input file or defined with
png_set_unknown_chunks).
</para>
<para>A quick word about text and num_text. text is an array of png_text
structures. num_text is the number of valid structures in the array.
Each png_text structure holds a language code, a keyword, a text value,
and a compression type.
</para>
<para>The compression types have the same valid numbers as the compression
types of the image data. Currently, the only valid number is zero.
However, you can store text either compressed or uncompressed, unlike
images, which always have to be compressed. So if you don't want the
text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
Because tEXt and zTXt chunks don't have a language field, if you
specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
any language code or translated keyword will not be written out.
</para>
<para>Until text gets around 1000 bytes, it is not worth compressing it.
After the text has been written out to the file, the compression type
is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
so that it isn't written out again at the end (in case you are calling
png_write_end() with the same struct.
</para>
<para>The keywords that are given in the PNG Specification are:
</para>
<para>Title Short (one line) title or
caption for image
Author Name of image's creator
Description Description of image (possibly long)
Copyright Copyright notice
Creation Time Time of original image creation
(usually RFC 1123 format, see below)
Software Software used to create the image
Disclaimer Legal disclaimer
Warning Warning of nature of content
Source Device used to create the image
Comment Miscellaneous comment; conversion
from other image format
</para>
<para>The keyword-text pairs work like this. Keywords should be short
simple descriptions of what the comment is about. Some typical
keywords are found in the PNG specification, as is some recommendations
on keywords. You can repeat keywords in a file. You can even write
some text before the image and some after. For example, you may want
to put a description of the image before the image, but leave the
disclaimer until after, so viewers working over modem connections
don't have to wait for the disclaimer to go over the modem before
they start seeing the image. Finally, keywords should be full
words, not abbreviations. Keywords and text are in the ISO 8859-1
(Latin-1) character set (a superset of regular ASCII) and can not
contain NUL characters, and should not contain control or other
unprintable characters. To make the comments widely readable, stick
with basic ASCII, and avoid machine specific character set extensions
like the IBM-PC character set. The keyword must be present, but
you can leave off the text string on non-compressed pairs.
Compressed pairs must have a text string, as only the text string
is compressed anyway, so the compression would be meaningless.
</para>
<para>PNG supports modification time via the png_time structure. Two
conversion routines are provided, png_convert_from_time_t() for
time_t and png_convert_from_struct_tm() for struct tm. The
time_t routine uses gmtime(). You don't have to use either of
these, but if you wish to fill in the png_time structure directly,
you should provide the time in universal time (GMT) if possible
instead of your local time. Note that the year number is the full
year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
that months start with 1.
</para>
<para>If you want to store the time of the original image creation, you should
use a plain tEXt chunk with the "Creation Time" keyword. This is
necessary because the "creation time" of a PNG image is somewhat vague,
depending on whether you mean the PNG file, the time the image was
created in a non-PNG format, a still photo from which the image was
scanned, or possibly the subject matter itself. In order to facilitate
machine-readable dates, it is recommended that the "Creation Time"
tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
although this isn't a requirement. Unlike the tIME chunk, the
"Creation Time" tEXt chunk is not expected to be automatically changed
by the software. To facilitate the use of RFC 1123 dates, a function
png_convert_to_rfc1123(png_timep) is provided to convert from PNG
time to an RFC 1123 format string.
</para>
<para>Writing unknown chunks
</para>
<para>You can use the png_set_unknown_chunks function to queue up chunks
for writing. You give it a chunk name, raw data, and a size; that's
all there is to it. The chunks will be written by the next following
png_write_info_before_PLTE, png_write_info, or png_write_end function.
Any chunks previously read into the info structure's unknown-chunk
list will also be written out in a sequence that satisfies the PNG
specification's ordering rules.
</para>
<para>The high-level write interface
</para>
<para>At this point there are two ways to proceed; through the high-level
write interface, or through a sequence of low-level write operations.
You can use the high-level interface if your image data is present
in the info structure. All defined output
transformations are permitted, enabled by the following masks.
</para>
<para>PNG_TRANSFORM_IDENTITY No transformation
PNG_TRANSFORM_PACKING Pack 1, 2 and 4-bit samples
PNG_TRANSFORM_PACKSWAP Change order of packed pixels to LSB first
PNG_TRANSFORM_INVERT_MONO Invert monochrome images
PNG_TRANSFORM_SHIFT Normalize pixels to the sBIT depth
PNG_TRANSFORM_BGR Flip RGB to BGR, RGBA to BGRA
PNG_TRANSFORM_SWAP_ALPHA Flip RGBA to ARGB or GA to AG
PNG_TRANSFORM_INVERT_ALPHA Change alpha from opacity to transparency
PNG_TRANSFORM_SWAP_ENDIAN Byte-swap 16-bit samples
PNG_TRANSFORM_STRIP_FILLER Strip out filler bytes.
</para>
<para>If you have valid image data in the info structure (you can use
png_set_rows() to put image data in the info structure), simply do this:
</para>
<para>png_write_png(png_ptr, info_ptr, png_transforms, NULL)
</para>
<para>where png_transforms is an integer containing the logical OR of some set of
transformation flags. This call is equivalent to png_write_info(),
followed the set of transformations indicated by the transform mask,
then png_write_image(), and finally png_write_end().
</para>
<para>(The final parameter of this call is not yet used. Someday it might point
to transformation parameters required by some future output transform.)
</para>
<para>The low-level write interface
</para>
<para>If you are going the low-level route instead, you are now ready to
write all the file information up to the actual image data. You do
this with a call to png_write_info().
</para>
<para>png_write_info(png_ptr, info_ptr);
</para>
<para>Note that there is one transformation you may need to do before
png_write_info(). In PNG files, the alpha channel in an image is the
level of opacity. If your data is supplied as a level of
transparency, you can invert the alpha channel before you write it, so
that 0 is fully transparent and 255 (in 8-bit or paletted images) or
65535 (in 16-bit images) is fully opaque, with
</para>
<para>png_set_invert_alpha(png_ptr);
</para>
<para>This must appear before png_write_info() instead of later with the
other transformations because in the case of paletted images the tRNS
chunk data has to be inverted before the tRNS chunk is written. If
your image is not a paletted image, the tRNS data (which in such cases
represents a single color to be rendered as transparent) won't need to
be changed, and you can safely do this transformation after your
png_write_info() call.
</para>
<para>If you need to write a private chunk that you want to appear before
the PLTE chunk when PLTE is present, you can write the PNG info in
two steps, and insert code to write your own chunk between them:
</para>
<para>png_write_info_before_PLTE(png_ptr, info_ptr);
png_set_unknown_chunks(png_ptr, info_ptr, ...);
png_write_info(png_ptr, info_ptr);
</para>
<para>After you've written the file information, you can set up the library
to handle any special transformations of the image data. The various
ways to transform the data will be described in the order that they
should occur. This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths. Even though each transformation
checks to see if it has data that it can do something with, you should
make sure to only enable a transformation if it will be valid for the
data. For example, don't swap red and blue on grayscale data.
</para>
<para>PNG files store RGB pixels packed into 3 or 6 bytes. This code tells
the library to strip input data that has 4 or 8 bytes per pixel down
to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2
bytes per pixel).
</para>
<para>png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
</para>
<para>where the 0 is unused, and the location is either PNG_FILLER_BEFORE or
PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
is stored XRGB or RGBX.
</para>
<para>PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit files.
If the data is supplied at 1 pixel per byte, use this code, which will
correctly pack the pixels into a single byte:
</para>
<para>png_set_packing(png_ptr);
</para>
<para>PNG files reduce possible bit depths to 1, 2, 4, 8, and 16. If your
data is of another bit depth, you can write an sBIT chunk into the
file so that decoders can recover the original data if desired.
</para>
<para>/* Set the true bit depth of the image data */
if (color_type &amp; PNG_COLOR_MASK_COLOR)
</para>
<para>sig_bit.red = true_bit_depth;
sig_bit.green = true_bit_depth;
sig_bit.blue = true_bit_depth;
</para>
<para>else
</para>
<para>sig_bit.gray = true_bit_depth;
</para>
<para>if (color_type &amp; PNG_COLOR_MASK_ALPHA)
</para>
<para>sig_bit.alpha = true_bit_depth;
</para>

<para>png_set_sBIT(png_ptr, info_ptr, &amp;sig_bit);
</para>
<para>If the data is stored in the row buffer in a bit depth other than
one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
this will scale the values to appear to be the correct bit depth as
is required by PNG.
</para>
<para>png_set_shift(png_ptr, &amp;sig_bit);
</para>
<para>PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first). This code would be used if they are
supplied the other way (little-endian, i.e. least significant bits
first, the way PCs store them):
</para>
<para>if (bit_depth &gt; 8)
png_set_swap(png_ptr);
</para>
<para>If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
need to change the order the pixels are packed into bytes, you can use:
</para>
<para>if (bit_depth &lt; 8)
png_set_packswap(png_ptr);
</para>
<para>PNG files store 3 color pixels in red, green, blue order. This code
would be used if they are supplied as blue, green, red:
</para>
<para>png_set_bgr(png_ptr);
</para>
<para>PNG files describe monochrome as black being zero and white being
one. This code would be used if the pixels are supplied with this reversed
(black being one and white being zero):
</para>
<para>png_set_invert_mono(png_ptr);
</para>
<para>Finally, you can write your own transformation function if none of
the existing ones meets your needs. This is done by setting a callback
with
</para>
<para>png_set_write_user_transform_fn(png_ptr,
write_transform_fn);
</para>
<para>You must supply the function
</para>
<para>void write_transform_fn(png_ptr ptr, row_info_ptr
row_info, png_bytep data)
</para>
<para>See pngtest.c for a working example. Your function will be called
before any of the other transformations are processed.
</para>
<para>You can also set up a pointer to a user structure for use by your
callback function.
</para>
<para>png_set_user_transform_info(png_ptr, user_ptr, 0, 0);
</para>
<para>The user_channels and user_depth parameters of this function are ignored
when writing; you can set them to zero as shown.
</para>
<para>You can retrieve the pointer via the function png_get_user_transform_ptr().
For example:
</para>
<para>voidp write_user_transform_ptr =
png_get_user_transform_ptr(png_ptr);
</para>
<para>It is possible to have libpng flush any pending output, either manually,
or automatically after a certain number of lines have been written. To
flush the output stream a single time call:
</para>
<para>png_write_flush(png_ptr);
</para>
<para>and to have libpng flush the output stream periodically after a certain
number of scanlines have been written, call:
</para>
<para>png_set_flush(png_ptr, nrows);
</para>
<para>Note that the distance between rows is from the last time png_write_flush()
was called, or the first row of the image if it has never been called.
So if you write 50 lines, and then png_set_flush 25, it will flush the
output on the next scanline, and every 25 lines thereafter, unless
png_write_flush() is called before 25 more lines have been written.
If nrows is too small (less than about 10 lines for a 640 pixel wide
RGB image) the image compression may decrease noticeably (although this
may be acceptable for real-time applications). Infrequent flushing will
only degrade the compression performance by a few percent over images
that do not use flushing.
</para>
<para>Writing the image data
</para>
<para>That's it for the transformations. Now you can write the image data.
The simplest way to do this is in one function call. If you have the
whole image in memory, you can just call png_write_image() and libpng
will write the image. You will need to pass in an array of pointers to
each row. This function automatically handles interlacing, so you don't
need to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_write_rows().
</para>
<para>png_write_image(png_ptr, row_pointers);
</para>
<para>where row_pointers is:
</para>
<para>png_byte *row_pointers[height];
</para>
<para>You can point to void or char or whatever you use for pixels.
</para>
<para>If you don't want to write the whole image at once, you can
use png_write_rows() instead. If the file is not interlaced,
this is simple:
</para>
<para>png_write_rows(png_ptr, row_pointers,
number_of_rows);
</para>
<para>row_pointers is the same as in the png_write_image() call.
</para>
<para>If you are just writing one row at a time, you can do this with
a single row_pointer instead of an array of row_pointers:
</para>
<para>png_bytep row_pointer = row;
</para>
<para>png_write_row(png_ptr, row_pointer);
</para>
<para>When the file is interlaced, things can get a good deal more
complicated. The only currently (as of the PNG Specification
version 1.2, dated July 1999) defined interlacing scheme for PNG files
is the "Adam7" interlace scheme, that breaks down an
image into seven smaller images of varying size. libpng will build
these images for you, or you can do them yourself. If you want to
build them yourself, see the PNG specification for details of which
pixels to write when.
</para>
<para>If you don't want libpng to handle the interlacing details, just
use png_set_interlace_handling() and call png_write_rows() the
correct number of times to write all seven sub-images.
</para>
<para>If you want libpng to build the sub-images, call this before you start
writing any rows:
</para>
<para>number_of_passes =
png_set_interlace_handling(png_ptr);
</para>
<para>This will return the number of passes needed. Currently, this
is seven, but may change if another interlace type is added.
</para>
<para>Then write the complete image number_of_passes times.
</para>
<para>png_write_rows(png_ptr, row_pointers,
number_of_rows);
</para>
<para>As some of these rows are not used, and thus return immediately,
you may want to read about interlacing in the PNG specification,
and only update the rows that are actually used.
</para>
<para>Finishing a sequential write
</para>
<para>After you are finished writing the image, you should finish writing
the file. If you are interested in writing comments or time, you should
pass an appropriately filled png_info pointer. If you are not interested,
you can pass NULL.
</para>
<para>png_write_end(png_ptr, info_ptr);
</para>
<para>When you are done, you can free all memory used by libpng like this:
</para>
<para>png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
</para>
<para>It is also possible to individually free the info_ptr members that
point to libpng-allocated storage with the following function:
</para>
<para>png_free_data(png_ptr, info_ptr, mask, n)
mask - identifies data to be freed, a mask
containing the logical OR of one or
more of
PNG_FREE_PLTE, PNG_FREE_TRNS,
PNG_FREE_HIST, PNG_FREE_ICCP,
PNG_FREE_PCAL, PNG_FREE_ROWS,
PNG_FREE_SCAL, PNG_FREE_SPLT,
PNG_FREE_TEXT, PNG_FREE_UNKN,
or simply PNG_FREE_ALL
n - sequence number of item to be freed
(-1 for all items)
</para>
<para>This function may be safely called when the relevant storage has
already been freed, or has not yet been allocated, or was allocated
by the user and not by libpng, and will in those
cases do nothing. The "n" parameter is ignored if only one item
of the selected data type, such as PLTE, is allowed. If "n" is not
-1, and multiple items are allowed for the data type identified in
the mask, such as text or sPLT, only the n'th item is freed.
</para>
<para>If you allocated data such as a palette that you passed
in to libpng with png_set_*, you must not free it until just before the call to
png_destroy_write_struct().
</para>
<para>The default behavior is only to free data that was allocated internally
by libpng. This can be changed, so that libpng will not free the data,
or so that it will free data that was allocated by the user with png_malloc()
or png_zalloc() and passed in via a png_set_*() function, with
</para>
<para>png_data_freer(png_ptr, info_ptr, freer, mask)
mask - which data elements are affected
same choices as in png_free_data()
freer - one of
PNG_DESTROY_WILL_FREE_DATA
PNG_SET_WILL_FREE_DATA
PNG_USER_WILL_FREE_DATA
</para>
<para>For example, to transfer responsibility for some data from a read structure
to a write structure, you could use
</para>
<para>png_data_freer(read_ptr, read_info_ptr,
PNG_USER_WILL_FREE_DATA,
PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
png_data_freer(write_ptr, write_info_ptr,
PNG_DESTROY_WILL_FREE_DATA,
PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
</para>
<para>thereby briefly reassigning responsibility for freeing to the user but
immediately afterwards reassigning it once more to the write_destroy
function. Having done this, it would then be safe to destroy the read
structure and continue to use the PLTE, tRNS, and hIST data in the write
structure.
</para>
<para>This function only affects data that has already been allocated.
You can call this function before calling after the png_set_*() functions
to control whether the user or png_destroy_*() is supposed to free the data.
When the user assumes responsibility for libpng-allocated data, the
application must use
png_free() to free it, and when the user transfers responsibility to libpng
for data that the user has allocated, the user must have used png_malloc()
or png_zalloc() to allocate it.
</para>
<para>If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
separately, do not transfer responsibility for freeing text_ptr to libpng,
because when libpng fills a png_text structure it combines these members with
the key member, and png_free_data() will free only text_ptr.key. Similarly,
if you transfer responsibility for free'ing text_ptr from libpng to your
application, your application must not separately free those members.
For a more compact example of writing a PNG image, see the file example.c.
</para>
<para>V. Modifying/Customizing libpng:
</para>
<para>There are three issues here. The first is changing how libpng does
standard things like memory allocation, input/output, and error handling.
The second deals with more complicated things like adding new chunks,
adding new transformations, and generally changing how libpng works.
Both of those are compile-time issues; that is, they are generally
determined at the time the code is written, and there is rarely a need
to provide the user with a means of changing them. The third is a
run-time issue: choosing between and/or tuning one or more alternate
versions of computationally intensive routines; specifically, optimized
assembly-language (and therefore compiler- and platform-dependent)
versions.
</para>
<para>Memory allocation, input/output, and error handling
</para>
<para>All of the memory allocation, input/output, and error handling in libpng
goes through callbacks that are user-settable. The default routines are
in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively. To change
these functions, call the appropriate png_set_*_fn() function.
</para>
<para>Memory allocation is done through the functions png_malloc(), png_zalloc(),
and png_free(). These currently just call the standard C functions. If
your pointers can't access more then 64K at a time, you will want to set
MAXSEG_64K in zlib.h. Since it is unlikely that the method of handling
memory allocation on a platform will change between applications, these
functions must be modified in the library at compile time. If you prefer
to use a different method of allocating and freeing data, you can use
</para>
<para>png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
malloc_fn, png_free_ptr free_fn)
</para>
<para>This function also provides a void pointer that can be retrieved via
</para>
<para>mem_ptr=png_get_mem_ptr(png_ptr);
</para>
<para>Your replacement memory functions must have prototypes as follows:
</para>
<para>png_voidp malloc_fn(png_structp png_ptr, png_uint_32 size);
void free_fn(png_structp png_ptr, png_voidp ptr);
</para>
<para>Input/Output in libpng is done through png_read() and png_write(),
which currently just call fread() and fwrite(). The FILE * is stored in
png_struct and is initialized via png_init_io(). If you wish to change
the method of I/O, the library supplies callbacks that you can set
through the function png_set_read_fn() and png_set_write_fn() at run
time, instead of calling the png_init_io() function. These functions
also provide a void pointer that can be retrieved via the function
png_get_io_ptr(). For example:
</para>
<para>png_set_read_fn(png_structp read_ptr,
voidp read_io_ptr, png_rw_ptr read_data_fn)
</para>
<para>png_set_write_fn(png_structp write_ptr,
voidp write_io_ptr, png_rw_ptr write_data_fn,
png_flush_ptr output_flush_fn);
</para>
<para>voidp read_io_ptr = png_get_io_ptr(read_ptr);
voidp write_io_ptr = png_get_io_ptr(write_ptr);
</para>
<para>The replacement I/O functions must have prototypes as follows:
</para>
<para>void user_read_data(png_structp png_ptr,
png_bytep data, png_uint_32 length);
void user_write_data(png_structp png_ptr,
png_bytep data, png_uint_32 length);
void user_flush_data(png_structp png_ptr);
</para>
<para>Supplying NULL for the read, write, or flush functions sets them back
to using the default C stream functions. It is an error to read from
a write stream, and vice versa.
</para>
<para>Error handling in libpng is done through png_error() and png_warning().
Errors handled through png_error() are fatal, meaning that png_error()
should never return to its caller. Currently, this is handled via
setjmp() and longjmp() (unless you have compiled libpng with
PNG_SETJMP_NOT_SUPPORTED, in which case it is handled via PNG_ABORT()),
but you could change this to do things like exit() if you should wish.
</para>
<para>On non-fatal errors, png_warning() is called
to print a warning message, and then control returns to the calling code.
By default png_error() and png_warning() print a message on stderr via
fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined
(because you don't want the messages) or PNG_NO_STDIO defined (because
fprintf() isn't available). If you wish to change the behavior of the error
functions, you will need to set up your own message callbacks. These
functions are normally supplied at the time that the png_struct is created.
It is also possible to redirect errors and warnings to your own replacement
functions after png_create_*_struct() has been called by calling:
</para>
<para>png_set_error_fn(png_structp png_ptr,
png_voidp error_ptr, png_error_ptr error_fn,
png_error_ptr warning_fn);
</para>
<para>png_voidp error_ptr = png_get_error_ptr(png_ptr);
</para>
<para>If NULL is supplied for either error_fn or warning_fn, then the libpng
default function will be used, calling fprintf() and/or longjmp() if a
problem is encountered. The replacement error functions should have
parameters as follows:
</para>
<para>void user_error_fn(png_structp png_ptr,
png_const_charp error_msg);
void user_warning_fn(png_structp png_ptr,
png_const_charp warning_msg);
</para>
<para>The motivation behind using setjmp() and longjmp() is the C++ throw and
catch exception handling methods. This makes the code much easier to write,
as there is no need to check every return code of every function call.
However, there are some uncertainties about the status of local variables
after a longjmp, so the user may want to be careful about doing anything after
setjmp returns non-zero besides returning itself. Consult your compiler
documentation for more details. For an alternative approach, you may wish
to use the "cexcept" facility (see http://cexcept.sourceforge.net).
</para>
<para>Custom chunks
</para>
<para>If you need to read or write custom chunks, you may need to get deeper
into the libpng code. The library now has mechanisms for storing
and writing chunks of unknown type; you can even declare callbacks
for custom chunks. Hoewver, this may not be good enough if the
library code itself needs to know about interactions between your
chunk and existing `intrinsic' chunks.
</para>
<para>If you need to write a new intrinsic chunk, first read the PNG
specification. Acquire a first level of
understanding of how it works. Pay particular attention to the
sections that describe chunk names, and look at how other chunks were
designed, so you can do things similarly. Second, check out the
sections of libpng that read and write chunks. Try to find a chunk
that is similar to yours and use it as a template. More details can
be found in the comments inside the code. It is best to handle unknown
chunks in a generic method, via callback functions, instead of by
modifying libpng functions.
</para>
<para>If you wish to write your own transformation for the data, look through
the part of the code that does the transformations, and check out some of
the simpler ones to get an idea of how they work. Try to find a similar
transformation to the one you want to add and copy off of it. More details
can be found in the comments inside the code itself.
</para>
<para>Configuring for 16 bit platforms
</para>
<para>You will want to look into zconf.h to tell zlib (and thus libpng) that
it cannot allocate more then 64K at a time. Even if you can, the memory
won't be accessible. So limit zlib and libpng to 64K by defining MAXSEG_64K.
</para>
<para>Configuring for DOS
</para>
<para>For DOS users who only have access to the lower 640K, you will
have to limit zlib's memory usage via a png_set_compression_mem_level()
call. See zlib.h or zconf.h in the zlib library for more information.
</para>
<para>Configuring for Medium Model
</para>
<para>Libpng's support for medium model has been tested on most of the popular
compilers. Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
defined, and FAR gets defined to far in pngconf.h, and you should be
all set. Everything in the library (except for zlib's structure) is
expecting far data. You must use the typedefs with the p or pp on
the end for pointers (or at least look at them and be careful). Make
note that the rows of data are defined as png_bytepp, which is an
unsigned char far * far *.
</para>
<para>Configuring for gui/windowing platforms:
</para>
<para>You will need to write new error and warning functions that use the GUI
interface, as described previously, and set them to be the error and
warning functions at the time that png_create_*_struct() is called,
in order to have them available during the structure initialization.
They can be changed later via png_set_error_fn(). On some compilers,
you may also have to change the memory allocators (png_malloc, etc.).
</para>
<para>Configuring for compiler xxx:
</para>
<para>All includes for libpng are in pngconf.h. If you need to add/change/delete
an include, this is the place to do it. The includes that are not
needed outside libpng are protected by the PNG_INTERNAL definition,
which is only defined for those routines inside libpng itself. The
files in libpng proper only include png.h, which includes pngconf.h.
</para>
<para>Configuring zlib:
</para>
<para>There are special functions to configure the compression. Perhaps the
most useful one changes the compression level, which currently uses
input compression values in the range 0 - 9. The library normally
uses the default compression level (Z_DEFAULT_COMPRESSION = 6). Tests
have shown that for a large majority of images, compression values in
the range 3-6 compress nearly as well as higher levels, and do so much
faster. For online applications it may be desirable to have maximum speed
(Z_BEST_SPEED = 1). With versions of zlib after v0.99, you can also
specify no compression (Z_NO_COMPRESSION = 0), but this would create
files larger than just storing the raw bitmap. You can specify the
compression level by calling:
</para>
<para>png_set_compression_level(png_ptr, level);
</para>
<para>Another useful one is to reduce the memory level used by the library.
The memory level defaults to 8, but it can be lowered if you are
short on memory (running DOS, for example, where you only have 640K).
</para>
<para>png_set_compression_mem_level(png_ptr, level);
</para>
<para>The other functions are for configuring zlib. They are not recommended
for normal use and may result in writing an invalid PNG file. See
zlib.h for more information on what these mean.
</para>
<para>png_set_compression_strategy(png_ptr,
strategy);
png_set_compression_window_bits(png_ptr,
window_bits);
png_set_compression_method(png_ptr, method);
png_set_compression_buffer_size(png_ptr, size);
</para>
<para>Controlling row filtering
</para>
<para>If you want to control whether libpng uses filtering or not, which
filters are used, and how it goes about picking row filters, you
can call one of these functions. The selection and configuration
of row filters can have a significant impact on the size and
encoding speed and a somewhat lesser impact on the decoding speed
of an image. Filtering is enabled by default for RGB and grayscale
images (with and without alpha), but not for paletted images nor
for any images with bit depths less than 8 bits/pixel.
</para>
<para>The 'method' parameter sets the main filtering method, which is
currently only '0' in the PNG 1.2 specification. The 'filters'
parameter sets which filter(s), if any, should be used for each
scanline. Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
to turn filtering on and off, respectively.
</para>
<para>Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB,
PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
ORed together with '|' to specify one or more filters to use.
These filters are described in more detail in the PNG specification. If
you intend to change the filter type during the course of writing
the image, you should start with flags set for all of the filters
you intend to use so that libpng can initialize its internal
structures appropriately for all of the filter types.
</para>
<para>filters = PNG_FILTER_NONE | PNG_FILTER_SUB
PNG_FILTER_UP | PNG_FILTER_AVE |
PNG_FILTER_PAETH | PNG_ALL_FILTERS;
or
filters = one of PNG_FILTER_VALUE_NONE,
PNG_FILTER_VALUE_SUB, PNG_FILTER_VALUE_UP,
PNG_FILTER_VALUE_AVE, PNG_FILTER_VALUE_PAETH
</para>
<para>png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
filters);
The second parameter can also be PNG_INTRAPIXEL_DIFFERENCING
if you are writing a PNG to be embedded in a MNG
datastream. This parameter must be the same as the
value of filter_method used in png_set_IHDR().
</para>
<para>It is also possible to influence how libpng chooses from among the
available filters. This is done in two ways - by telling it how
important it is to keep the same filter for successive rows, and
by telling it the relative computational costs of the filters.
</para>
<para>double weights[3] = {1.5, 1.3, 1.1},
costs[PNG_FILTER_VALUE_LAST] =
{1.0, 1.3, 1.3, 1.5, 1.7};
</para>
<para>png_set_filter_selection(png_ptr,
PNG_FILTER_SELECTION_WEIGHTED, 3,
weights, costs);
</para>
<para>The weights are multiplying factors that indicate to libpng that the
row filter should be the same for successive rows unless another row filter
is that many times better than the previous filter. In the above example,
if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a
"sum of absolute differences" 1.5 x 1.3 times higher than other filters
and still be chosen, while the NONE filter could have a sum 1.1 times
higher than other filters and still be chosen. Unspecified weights are
taken to be 1.0, and the specified weights should probably be declining
like those above in order to emphasize recent filters over older filters.
</para>
<para>The filter costs specify for each filter type a relative decoding cost
to be considered when selecting row filters. This means that filters
with higher costs are less likely to be chosen over filters with lower
costs, unless their "sum of absolute differences" is that much smaller.
The costs do not necessarily reflect the exact computational speeds of
the various filters, since this would unduly influence the final image
size.
</para>
<para>Note that the numbers above were invented purely for this example and
are given only to help explain the function usage. Little testing has
been done to find optimum values for either the costs or the weights.
</para>
<para>Removing unwanted object code
</para>
<para>There are a bunch of #define's in pngconf.h that control what parts of
libpng are compiled. All the defines end in _SUPPORTED. If you are
never going to use a capability, you can change the #define to #undef
before recompiling libpng and save yourself code and data space, or
you can turn off individual capabilities with defines that begin with
PNG_NO_.
</para>
<para>You can also turn all of the transforms and ancillary chunk capabilities
off en masse with compiler directives that define
PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
or all four,
along with directives to turn on any of the capabilities that you do
want. The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable
the extra transformations but still leave the library fully capable of reading
and writing PNG files with all known public chunks
Use of the PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive
produces a library that is incapable of reading or writing ancillary chunks.
If you are not using the progressive reading capability, you can
turn that off with PNG_NO_PROGRESSIVE_READ (don't confuse
this with the INTERLACING capability, which you'll still have).
</para>
<para>All the reading and writing specific code are in separate files, so the
linker should only grab the files it needs. However, if you want to
make sure, or if you are building a stand alone library, all the
reading files start with pngr and all the writing files start with
pngw. The files that don't match either (like png.c, pngtrans.c, etc.)
are used for both reading and writing, and always need to be included.
The progressive reader is in pngpread.c
</para>
<para>If you are creating or distributing a dynamically linked library (a .so
or DLL file), you should not remove or disable any parts of the library,
as this will cause applications linked with different versions of the
library to fail if they call functions not available in your library.
The size of the library itself should not be an issue, because only
those sections that are actually used will be loaded into memory.
</para>
<para>Requesting debug printout
</para>
<para>The macro definition PNG_DEBUG can be used to request debugging
printout. Set it to an integer value in the range 0 to 3. Higher
numbers result in increasing amounts of debugging information. The
information is printed to the "stderr" file, unless another file
name is specified in the PNG_DEBUG_FILE macro definition.
</para>
<para>When PNG_DEBUG &gt; 0, the following functions (macros) become available:
</para>
<para>png_debug(level, message)
png_debug1(level, message, p1)
png_debug2(level, message, p1, p2)
</para>
<para>in which "level" is compared to PNG_DEBUG to decide whether to print
the message, "message" is the formatted string to be printed,
and p1 and p2 are parameters that are to be embedded in the string
according to printf-style formatting directives. For example,
</para>
<para>png_debug1(2, "foo=%d\n", foo);
</para>
<para>is expanded to
</para>
<para>if(PNG_DEBUG &gt; 2)
fprintf(PNG_DEBUG_FILE, "foo=%d\n", foo);
</para>
<para>When PNG_DEBUG is defined but is zero, the macros aren't defined, but you
can still use PNG_DEBUG to control your own debugging:
</para>
<para>#ifdef PNG_DEBUG
fprintf(stderr, ...
#endif
</para>
<para>When PNG_DEBUG = 1, the macros are defined, but only png_debug statements
having level = 0 will be printed. There aren't any such statements in
this version of libpng, but if you insert some they will be printed.
</para>

<para>VI. MNG support
</para>
<para>The MNG specification (available at http://www.libpng.org/pub/mng) allows
certain extensions to PNG for PNG images that are embedded in MNG datastreams.
Libpng can support some of these extensions. To enable them, use the
png_permit_mng_features() function:
</para>
<para>feature_set = png_permit_mng_features(png_ptr, mask)
mask is a png_uint_32 containing the logical OR of the
features you want to enable. These include
PNG_FLAG_MNG_EMPTY_PLTE
PNG_FLAG_MNG_FILTER_64
PNG_ALL_MNG_FEATURES
feature_set is a png_32_uint that is the logical AND of
your mask with the set of MNG features that is
supported by the version of libpng that you are using.
</para>
<para>It is an error to use this function when reading or writing a standalone
PNG file with the PNG 8-byte signature. The PNG datastream must be wrapped
in a MNG datastream. As a minimum, it must have the MNG 8-byte signature
and the MHDR and MEND chunks. Libpng does not provide support for these
or any other MNG chunks; your application must provide its own support for
them. You may wish to consider using libmng (available at
http://www.libmng.com) instead.
</para>
<para>VII. Changes to Libpng from version 0.88
</para>
<para>It should be noted that versions of libpng later than 0.96 are not
distributed by the original libpng author, Guy Schalnat, nor by
Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
distributed versions 0.89 through 0.96, but rather by another member
of the original PNG Group, Glenn Randers-Pehrson. Guy and Andreas are
still alive and well, but they have moved on to other things.
</para>
<para>The old libpng functions png_read_init(), png_write_init(),
png_info_init(), png_read_destroy(), and png_write_destory() have been
moved to PNG_INTERNAL in version 0.95 to discourage their use. These
functions will be removed from libpng version 2.0.0.
</para>
<para>The preferred method of creating and initializing the libpng structures is
via the png_create_read_struct(), png_create_write_struct(), and
png_create_info_struct() because they isolate the size of the structures
from the application, allow version error checking, and also allow the
use of custom error handling routines during the initialization, which
the old functions do not. The functions png_read_destroy() and
png_write_destroy() do not actually free the memory that libpng
allocated for these structs, but just reset the data structures, so they
can be used instead of png_destroy_read_struct() and
png_destroy_write_struct() if you feel there is too much system overhead
allocating and freeing the png_struct for each image read.
</para>
<para>Setting the error callbacks via png_set_message_fn() before
png_read_init() as was suggested in libpng-0.88 is no longer supported
because this caused applications that do not use custom error functions
to fail if the png_ptr was not initialized to zero. It is still possible
to set the error callbacks AFTER png_read_init(), or to change them with
png_set_error_fn(), which is essentially the same function, but with a new
name to force compilation errors with applications that try to use the old
method.
</para>
<para>Starting with version 1.0.7, you can find out which version of the library
you are using at run-time:
</para>
<para>png_uint_32 libpng_vn = png_access_version_number();
</para>
<para>The number libpng_vn is constructed from the major version, minor
version with leading zero, and release number with leading zero,
(e.g., libpng_vn for version 1.0.7 is 10007).
</para>
<para>You can also check which version of png.h you used when compiling your
application:
</para>
<para>png_uint_32 application_vn = PNG_LIBPNG_VER;
</para>
<para>VIII. Y2K Compliance in libpng
</para>
<para>January 31, 2001
</para>
<para>Since the PNG Development group is an ad-hoc body, we can't make
an official declaration.
</para>
<para>This is your unofficial assurance that libpng from version 0.71 and
upward through 1.0.9 are Y2K compliant. It is my belief that earlier
versions were also Y2K compliant.
</para>
<para>Libpng only has three year fields. One is a 2-byte unsigned integer that
will hold years up to 65535. The other two hold the date in text
format, and will hold years up to 9999.
</para>
<para>The integer is
"png_uint_16 year" in png_time_struct.
</para>
<para>The strings are
"png_charp time_buffer" in png_struct and
"near_time_buffer", which is a local character string in png.c.
</para>
<para>There are seven time-related functions:
</para>
<para>png_convert_to_rfc_1123() in png.c
(formerly png_convert_to_rfc_1152() in error)
png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
png_convert_from_time_t() in pngwrite.c
png_get_tIME() in pngget.c
png_handle_tIME() in pngrutil.c, called in pngread.c
png_set_tIME() in pngset.c
png_write_tIME() in pngwutil.c, called in pngwrite.c
</para>
<para>All appear to handle dates properly in a Y2K environment. The
png_convert_from_time_t() function calls gmtime() to convert from system
clock time, which returns (year - 1900), which we properly convert to
the full 4-digit year. There is a possibility that applications using
libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
function, or that they are incorrectly passing only a 2-digit year
instead of "year - 1900" into the png_convert_from_struct_tm() function,
but this is not under our control. The libpng documentation has always
stated that it works with 4-digit years, and the APIs have been
documented as such.
</para>
<para>The tIME chunk itself is also Y2K compliant. It uses a 2-byte unsigned
integer to hold the year, and can hold years as large as 65535.
</para>
<para>zlib, upon which libpng depends, is also Y2K compliant. It contains
no date-related code.
</para>

<para>Glenn Randers-Pehrson
libpng maintainer
PNG Development Group
</para>
</sect2>
</sect1>

<sect1><title>Conclusion</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
<figure>
<title>More content here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

</chapter>

<chapter id="chap-jpeg"><title>JPEG</title>
<para>
...
</para>

<sect1><title>Further reading</title>
<para>
...
</para>
</sect1>

</chapter>
<chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<para>
This chapter is broken into five major sections. These are:

<itemizedlist>
<listitem><para>Discussion of the PDF format itself</para></listitem>
<listitem><para>An introduction to ClibPDF</para></listitem>
<listitem><para>An introduction to PDFLib</para></listitem>
<listitem><para>An introduction to Panda</para></listitem>
<listitem><para>Discussion of the Adobe PDF tools</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 <9F><92><9C><9F>
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis><9F><92><9C><9F></emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a lookup table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<figure>
<title>Do these</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
<sect4><title>Boolean</title>
<para>
Boolean values are represented with the words <command>true</command> and <command>false</command>.
</para>

<sect5><title>Examples</title>
<programlisting>
/ExplodeOnOpening true
/Rotate false
</programlisting>
</sect5>
</sect4>
<sect4><title>Names</title>
<para>
A name is a sequence of characters not including whitespace which follow a forward slash. Names are used in object dictionaries for the names of keys, and for some values of keys.
</para>

<sect5><title>Examples</title>
<programlisting>
</programlisting>
</sect5>
</sect4>
<sect4><title>Numbers</title>
<para>
Known as numeric types in the PDF specification (for somewhat obvious reasons), this includes all forms of numbers. These can either be integer or real
  <footnote><para>Non integer</para></footnote>
numbers.
</para>

<sect5><title>Integers</title>
<para>
Integer numbers can be either positive or negative (with a leading sign value if needed) and have a maximum value of ... and a minimum value of ... .

<figure>
<title>sizeof(int)</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect6><title>Examples</title>
<programlisting>
123
43445
+176
-17
0
</programlisting>
</sect6>
</sect5>

<sect5><title>Real numbers</title>
<para>
Real numbers can exist in the range ... to ..., and may or may not have leading zeros.

<figure>
<title>sizeof(real)</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect6><title>Examples</title>
<programlisting>
34.5
-3.62
+123.5
4.
-.002
0.0
</programlisting>
</sect6>
</sect5>

<sect5><title>Caveats</title>
<para>
The PDF specification makes the following point:

<quote>PDF does not support the PostScript syntax for numbers with non-decimal radices (such as 16#FFFE) or in exponent format (such as 6.02E23).</quote>
  <footnote><para>PDF Specification 1.3, second edition, page 27</para></footnote>
</para>
</sect4>
<sect4><title>Strings</title>
<para>
Strings are represented a series of unsigned bytes
  <footnote><para>That is, in the range 0 to 255.</para></footnote>
which is identical to the ASCII strings most programmers are familar with in C. There are two main representations of strings. These are:
</para>

<sect5><title>Bracket notation</title>
<para>
Strings can be wrapped in curved brackets such as () to delimit the start and end of the string. Strings may also contain brackets, so long as they are balanced or escaped with a backslash.
</para>

<para>
These are known as literal strings in the PDF specification.
</para>

<sect6><title>Examples</title>
<programlisting>
(hello)
(hello world)
(hello world \(the people I like\))
(hello world (the people I like))
</programlisting>
</sect6>

<sect6><title>Escaped characters</title>
<para>
There are a series of standard characters which are used with the backslash escape. These are:
</para>

<itemizedlist>
<listitem><para><emphasis>\n</emphasis>: Newline</para></listitem>
<listitem><para><emphasis>\r</emphasis>: Carriage return</para></listitem>
<listitem><para><emphasis>\t</emphasis>: Tab</para></listitem>
<listitem><para><emphasis>\b</emphasis>: Backspace</para></listitem>
<listitem><para><emphasis>\f</emphasis>: Form feed</para></listitem>
<listitem><para><emphasis>\(</emphasis>: Open bracket</para></listitem>
<listitem><para><emphasis>\)</emphasis>: Close bracket</para></listitem>
<listitem><para><emphasis>\\</emphasis>: Backslash</para></listitem>
<listitem><para><emphasis>\ddd</emphasis>: Arbitary character (ddd is a number in octal)</para></listitem>
</itemizedlist>

<para>
The backslash operator can also be used to continue text on the next line. For instance:
</para>

<programlisting>
(This is a very long string which we want to \
break over a couple of lines.)
</programlisting>

<para>
This means that we can also embed newlines without using the escape. For instance, these two text blocks are the same:
</para>

<programlisting>
(This is a 
string \
with some lines)
</programlisting>

<para>
and
</para>

<programlisting>
(This is a\nstring with some lines)
</programlisting>

<para>
More on strings in this notation can be found in the PDF specification, version 1.3, on page 30.
</para>
</sect5>

<sect5><title>Hexadecimal notation</title>
<para>
Strings can also be written in hexadecimal form, and in this case are enclosed in angle brackets.
</para>

<sect6><title>Examples</title>
<para>
An example of a hexidecimal string is:
</para>

<programlisting>
&lt;4E6F762073686D6F7A206B6120706F702E&gt;
</programlisting>

<para>
If the final digit is missing, then it is assumed to be zero. For instance, the following string:
</para>

<programlisting>
&lt;901FA&gt;
</programlisting>

<para>
Is the same as:
</para>

<programlisting>
&lt;901FA0&gt;
</programlisting>
</sect6>
</sect5>

</sect4>
<sect4><title></title>
<para>
</para>

<sect5><title>Examples</title>
<programlisting>
</programlisting>
</sect5>
</sect4>

<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 


The other type of information which can be stored in a stream is arbitary information such as the content of images (which would normally be raster information). 


An indepth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<figure>
<title>Do these</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

</sect3>
</sect2>

<sect2><title>Object structure</title>
<figure>
<title>Detail here</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<figure><title>A typical PDF object structure</title>
<graphic format="EPS" fileref="pdf-figure1.eps">
</figure>

</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft PowerPoint presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>On with the libraries</title>
<para>
Now that we've discussed the format of the PDF file format, we can talk about the different options for building PDF files. The three main options are ClibPDF, PDFlib, and Panda. Adobe also sells a PDf library, but it has a reputation for being extremely expensive.
</para>

<para>
In our discussion of the three libraries, we will work through the same set of programs, to give you an opportunity to compare the three libraries. After all, they all have their own strengths, and weaknesses.
</para>
</sect1>

<sect1><title>ClibPDF</title>
<para>
ClibPDF was my first introduction to PDF generation APIs. It is available from http://www.fastio.com, and was last updated in December 1999, so it is starting to get a little old. There are still many people who use ClibPDF however.
</para>

<para>
Note that ClibPDF is not free software. The license is included below for your reference:
</para>

<figure>
<title>ClibPDF license page 1</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.0.eps">
</figure>

<figure>
<title>ClibPDF license page 2</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.1.eps">
</figure>

<figure>
<title>ClibPDF license page 3</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.2.eps">
</figure>

<figure>
<title>ClibPDF license page 4</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.3.eps">
</figure>

<figure>
<title>ClibPDF license page 5</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.4.eps">
</figure>

<figure>
<title>ClibPDF license page 6</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.5.eps">
</figure>

<figure>
<title>ClibPDF license page 7</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.6.eps">
</figure>

<figure>
<title>ClibPDF license page 8</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.7.eps">
</figure>

<figure>
<title>ClibPDF license page 9</title>
<graphic format="EPS" fileref="clibpdf-license.pdf.8.eps">
</figure>


<para>
To summarise the license, this quote from the ClibPDF README page sums it up:
</para>

<programlisting>
This package is released under:
FastIO ClibPDF Software License 1.30, January 27, 2000.

ClibPDF and Premium ClibPDF are not public-domain or free software.
</programlisting>

<para>
This almost certainly limits what you can do with the library, and means that using the library will cost you money.
</para>

<sect2><title>Installation</title>
<para>
The first step to installing ClibPDF is to download the source from http://www.fastio.com. At the time of writing the source download is on the front page, about half way down. I can't guarantee that this wont have changed by the time you come to download the library, but then again the page hasn't changed in several years now, so it doesn't strike me a likely.
</para>

<sect3><title>Unix</title>
<para>
ClibPDF does not use configure scripts. The first step of the installation is to therefore copy your operating system's Makefile over the top of the sample Makefile. The various distributed Makefiles are:
</para>

<itemizedlist>
<listitem><para>Makefile.AIX42</para></listitem>
<listitem><para>Makefile.BSDI</para></listitem>
<listitem><para>Makefile.Cygwin</para></listitem>
<listitem><para>Makefile.FreeBSD</para></listitem>
<listitem><para>Makefile.HPUX</para></listitem>
<listitem><para>Makefile.irix62gcc</para></listitem>
<listitem><para>Makefile.MacOSX</para></listitem>
<listitem><para>Makefile.NetBSD</para></listitem>
<listitem><para>Makefile.NEXTSTEP</para></listitem>
<listitem><para>Makefile.SolarisGCC</para></listitem>
<listitem><para>Makefile.SolarisSunCC</para></listitem>
<listitem><para>Makefile.SunOS5x</para></listitem>
</itemizedlist>

<para>
If your operating system isn't listed in the available Makefiles, you'll need to copy the closest one and then edit it until the compile works.
</para>

<para>
Once you have copied your Makefile to the file named <emphasis>Makefile</emphasis>, then follow these steps to install ClibPDF...
</para>

<itemizedlist>
<listitem><para>make</para></listitem>
<listitem><para>make lib</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
You might need to edit parts of the Makefile to make the install work properly for your system.
</para>
</sect3>

<sect3><title>win32</title>
<para>
ClibPDF doesn't support win32 directly. It is however written in ANSI C, so a port shouldn't be very hard at all.

<figure>
<title>Port ClibPDF</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the ClibPDF iteration:
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cpdflib.h&gt;

int
main (int argc, char *argv[])
{
  CPDFdoc *pdf;

  // Open the document
  pdf = cpdf_open (0, NULL);
  cpdf_init (pdf);
  
  // Create a page
  cpdf_pageInit (pdf, 1, PORTRAIT, LETTER, LETTER);

  // Put some text on that page
  cpdf_beginText (pdf, 0);
  cpdf_setFont (pdf, "Times-Italic", "WinAnsiEncoding", 48.0);
  cpdf_text (pdf, 1.0, 8.0, 0.0, "Hello World");
  cpdf_endText (pdf);

  // Write the PDF out to disc
  cpdf_finalizeAll (pdf);
  cpdf_savePDFmemoryStreamToFile (pdf, "hello.pdf");
  cpdf_close (pdf);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/clibpdf/hello/hello.c</emphasis></para>

<para>
This produces a PDF which looks like (somewhat reduced from it's real size)...
</para>

<figure>
<title>ClibPDF hello world</title>
<graphic format="EPS" fileref="source/pdf/clibpdf/hello/hello.pdf.eps">
</figure>


<para>
The first block initializes ClibPDF, then we create a page, put some text on it, and then close the document.
</para>
</sect2>

<sect2><title>Initialization</title>
<programlisting>
CPDFdoc *cpdf_open(int pspdf, CPDFdocLimits *docLimits);
void cpdf_init(CPDFdoc *pdf);

char  *cpdf_getOutputFilename(CPDFdoc *pdf);
void cpdf_setOutputFilename(CPDFdoc *pdf, const char *file);
</programlisting>

<para>
ClibPDF requires multiple initialization calls. As seen in the hello world example above, we needed to call <command>cpdf_open</command> and <command>cpdf_init</command> at the start of our application. <command>cpdf_open</command> initializes ClibPDF itself, and returns a pointer to a <command>CPDFdoc</command>, which will represent our document. This pointer must then be initialized with a call to <command>cpdf_init</command>. The <command>*OutputFilename</command> functions are used to get and set the filename that the PDF document will be written to when finalized.
</para>

<figure>
<title>Can you be creating multiple PDF files at once?</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</sect2>

<sect2><title>Creating pages</title>
<programlisting>
int cpdf_pageInit(CPDFdoc *pdf, int pagenum, int rot, const char *mediaboxstr, const char *cropboxstr);
int cpdf_setCurrentPage(CPDFdoc *pdf, int page);
</programlisting>

<para>
Creating pages in ClibPDF is done with the <command>cpdf_pageInit</command> function. This function takes some arguements:
</para>

<itemizedlist>
<listitem><para><emphasis>CPDFdoc *pdf</emphasis>: the PDF document to add the page to</para></listitem>
<listitem><para><emphasis>int pagenum</emphasis>: the page number for the new page (the first page of a PDF is page 1)</para></listitem>
<listitem><para><emphasis>int rot</emphasis>: whether the page is PORTRAIT or LANDSCAPE (defined in the cpdflib header)</para></listitem>
<listitem><para><emphasis>const char *mediaboxstr</emphasis>: the page size string, see below</para></listitem>
<listitem><para><emphasis>const char *cropboxstr</emphasis>: the crop box for the page</para></listitem>
</itemizedlist>

<figure>
<title>Define crop box in the PDF intro</title>
<graphic format="EPS" fileref="todo.eps">
</figure>

<para>
There are some default page size strings provided by ClibPDF, although it is possible to use your own as well. The sizes provided by ClibPDF are:
</para>

<itemizedlist>
<listitem><para>LETTER</para></listitem>
<listitem><para>LEGAL</para></listitem>
<listitem><para>A4</para></listitem>
<listitem><para>B5</para></listitem>
<listitem><para>C5</para></listitem>
</itemizedlist>

<para>
There are also the following other page sizes, which for some reason aren't documented in the manual...
</para>

<itemizedlist>
<listitem><para>DL</para></listitem>
<listitem><para>EXECUTIVE</para></listitem>
<listitem><para>COMM10</para></listitem>
<listitem><para>MONARCH</para></listitem>
<listitem><para>FILM35MM</para></listitem>
</itemizedlist>

<para>
Page size strings are as embedded into the PDF document (which matches how Panda uses these strings as well). The format of the string is left, top, right, bottom. For example:
</para>

<programlisting>
0 0 612 792
</programlisting>

<para>
You can also be working on multiple pages at once. Use the <command>cpdf_setCurrentPage</command> function to switch between pages (compare this with how PDFlib and Panda implement this).
</para>
</sect2>

<sect2><title>Finalization</title>
<programlisting>
void cpdf_finalizePage(CPDFdoc *pdf, int page);
void cpdf_finalizeAll(CPDFdoc *pdf);
int cpdf_savePDFmemoryStreamToFile(CPDFdoc *pdf, const char *file);
char *cpdf_getBufferForPDF(CPDFdoc *pdf, int *length);
</programlisting>

<para>
These functions are used to finalize the PDF document. Use the <command>cpdf_finalizePage</command> function to force a page to be generated immediately. This may decrease resource usage for the PDF document. This function call is optional. <command>cpdf_finalizeAll</command> is called to write the PDF document out to the memory stream or the file on disc. If this function is not called, then the PDF file will be empty. You cannot add items to the PDF file once it has been finalized. <command>cpdf_close</command> closes the PDF file and deallocates resources which were consumed by the file.
</para>


</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<programlisting>
void cpdf_setPageDuration(CPDFdoc *pdf, float seconds);
int cpdf_setPageTransition(CPDFdoc *pdf, int type, float duration, float direction, int HV, int IO);
</programlisting>

<para>
<command>cpdf_setPageDuration</command> is self explainatory. The arguements to the <command>cpdf_setPageTransition</command> are not as obvious. They are:
</para>

<itemizedlist>
<listitem><para><empahsis>CPDFdoc *pdf</emphasis>: </para></listitem>
<listitem><para><empahsis>int type</emphasis>: </para></listitem>
<listitem><para><empahsis>float duration</emphasis>: </para></listitem>
<listitem><para><empahsis>float direction</emphasis>: </para></listitem>
<listitem><para><empahsis>int HV</emphasis>: </para></listitem>
<listitem><para><empahsis>int IO</emphasis>: </para></listitem>
</itemizedlist>

</sect2>

<sect2><title>Cool features</title>
<para>
ClibPDF has some cool features which aren't available in the other PDF generation libraries discussed in this tutorial. In brief, these are:
</para>

<itemizedlist>
<listitem><para>ClibPDF allows you to write the PDF to a memory stream, or a file, which would work well if you were byte serving the PDF on the web, or if you wanted to embed it into something like a database.</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>

<programlisting>
CPDFerrorHandler cpdf_setErrorHandler(CPDFdoc *pdf, CPDFerrorHandler handler);
void cpdf_Error(CPDFdoc *pdf, int level, const char* module, const char* fmt, ...);
CPDFglobalErrorHandler cpdf_setGlobalErrorHandler(CPDFglobalErrorHandler handler);
void cpdf_GlobalError(int level, const char* module, const char* fmt, ...);
</programlisting>

<para>
Error handling
</para>

<programlisting>
void cpdf_enableCompression(CPDFdoc *pdf, int cmpON);
</programlisting>

<para>
This function will enable compression of page descriptions, which can quite significantly reduce the size of the PDF document. This function simply enables a Flate filter on these page description streams.
</para>

<programlisting>
void cpdf_setDefaultDomainUnit(CPDFdoc *pdf, float defunit);
... and a variety of other domain function calls ...
</programlisting>

<para>
Explain domains
</para>

<programlisting>
void cpdf_useContentMemStream(CPDFdoc *pdf, int flag);
</programlisting>

<para>
This function call can be called if you want to use temporary files instead of memory buffers. This can be useful for machines which don't have much memory, but it is quite slow. You might find that you are better off simply increasing the amount of swap space allocated on the system. The ClibPDF documentation also implies that this function call is not thread safe.
</para>
</sect2>

<sect2><title>Room for improvement</title>
<programlisting>
void cpdf_setGlobalDocumentLimits(int maxPages, int maxFonts, int maxImages, int maxAnnots, int maxObjects);
</programlisting>

<para>
ClibPDF has internal limitations for the sizes of various data structures. These must be explicitly changed before the library is used if they don't fit your needs. The defaults are:
</para>

<itemizedlist>
<listitem><para><emphasis>Maximum number of pages</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of fonts</emphasis>: default value is 180</para></listitem>
<listitem><para><emphasis>Maximum number of images (rasters)</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of annotations</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of objects</emphasis>: default value is 5,000 (it is strange that this value is exposed to the user)</para></listitem>
</itemizedlist>

<para>
These values can be changed using the <command>CPDFdocLimits</command> structure, which is passed to many of the ClibPDF function calls. It is interesting to note that this gives us a perspective on the internal coding style of ClibPDF. Many of the internal structures are based on fixed size arrays, which is why the size must be known from the start. These arrays will allow for ClibPDF to be marginally faster than implementations that use linked lists, but it also decreases the utility of the library.
</para>
</sect2>






</sect1>










<sect1><title>PDFlib</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect2><title>Installation</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>

<sect3><title>Unix</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>

<sect3><title>win32</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect3>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>



<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>






</sect1>





















<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>

<programlisting>
#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage;

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("hello.pdf", "w")) == NULL)
    {
      fprintf (stderr, "Could not open hello.pdf\n");
      exit (1);
    }

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Write some text to the page
  panda_setfont (demo, panda_createfont (demo, "Times-Roman", 1,
  					 "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300, "Hello world");

  // Finished all the demoing, close the PDF document
  panda_close (demo);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/panda/hello/hello.c</emphasis></para>

<para>
Which produces...
</para>

<figure>
<title>Panda hello world</title>
<graphic format="EPS" fileref="source/pdf/panda/hello/hello.pdf.eps">
</figure>


<para>
The calling order here is very similar to ClibPDF and PDFlib, so I wont go into incredibly verbose explainations here.
</para>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>







</sect1>




























<sect1><title>Adobe products</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>


<sect1><title>Summary of the differences between PDF libraries</title>
<para>
It seems useful to provide a summary of the differences we have learnt about the various PDF libraries which are available as we worked through this chapter.
</para>

<table frame='all'><title>Differences between the PDF libraries</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Feature</entry>
  <entry>ClibPDF</entry>
  <entry>PDFlib</entry>
  <entry>Panda</entry>
  <entry>Adobe</entry>
</row>
</thead>
<tbody>

<row>
<entry>License</entry>
<entry>FastIO license. Not opensource / free software / public domain</entry>
<entry></entry>
<entry>GNU GPL Version 2</entry>
<entry></entry>
</row>

<row>
<entry>Cost</entry>
<entry>$1,000 USD+</entry>
<entry></entry>
<entry>$0</entry>
<entry></entry>
</row>


<row>
<entry>Free for non commercial use?</entry>
<entry>Yes, with conditions</entry>
<entry></entry>
<entry>Always free</entry>
<entry></entry>
</row>


<row>
<entry>DeleteMe</entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>



</tbody>
</tgroup>
</table>
</sect1>

<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
<programlisting>
%{
#include "parser.h"
#include "lexinterface.h"
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

void debuglex(char *, int, char *);
char *returnStr(char *, int);
void *pandalex_xmalloc(size_t);
void *pandalex_xrealloc(void *, size_t);
char *pandalex_xsnprintf(char *, ...);
void pandalex_error(char *);

void *
pandalex_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pandalex_error ("pandalex_xmalloc failed to allocate memory");
    }

  return buffer;
}
void *
pandalex_xrealloc (void *memory, size_t size)
{
  void *buffer;

  if ((buffer = realloc (memory, size)) == NULL)
    {
      pandalex_error ("pandalex_xrealloc failed to allocate memory");
    }

  return buffer;
}

char *
pandalex_xsnprintf (char *format, ...)
{
  char *output = NULL;
  int size, result;
  va_list ap;

  /* We start with the size of the format string as a guess */
  size = strlen (format);
  va_start (ap, format);

  while (1)
    {
      output = pandalex_xrealloc (output, size);
      result = vsnprintf (output, size, format, ap);

      if (result == -1)
        {
          /* Up to glibc 2.0.6 and Microsoft's implementation*/
          size += 100;
        }
      else
        {
          /* Check if we are done */
      if (result &lt; size)
            break;

          /* Glibc from now on */
          size = result + 1;
        }
  }

  va_end (ap);
  return output;
}

void
pandalex_error(char *msg){
fprintf(stderr, "%s\n", msg);
exit(42);
}
%}

%x BINARY
%%

&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { debuglex(yytext, -1, "version");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return VERSION;
                                                                             }

&lt;INITIAL&gt;[ \t\r\n]+              { debuglex(yytext, -1, "whitespace");
                                                                          }

&lt;INITIAL&gt;xref                    { debuglex(yytext, -1, "xref");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return XREF;
                                                                             }

&lt;INITIAL&gt;trailer                 { debuglex(yytext, -1, "trailer");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return TRAILER;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+,]+ { debuglex(yytext, -1, "name");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;\/[#a-zA-Z\-_0-9\.\+]+ { debuglex(yytext, -1, "dbllt-name");
                            yyless(2);
                            return DBLLT;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+]+\&gt;\&gt;     { debuglex(yytext, -1, "name-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
}

                        /* --- stuff required for objects ---               */
&lt;INITIAL&gt;R                       { debuglex(yytext, -1, "object reference");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\&gt;\&gt;                       { debuglex(yytext, -1, "object-reference-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\/                       { debuglex(yytext, -1, "object-reference-namestart");
                            yyless(yyleng - 1);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;obj                     { debuglex(yytext, -1, "obj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJ; 
                                                                             }

&lt;INITIAL&gt;endobj                  { debuglex(yytext, -1, "endobj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return ENDOBJ; 
                                                                             }

&lt;INITIAL&gt;stream                  { debuglex(yytext, -1, "stream");
                          BEGIN(BINARY);
                          return STREAM;                                     }

&lt;INITIAL&gt;[+-]?[0-9]+             { debuglex(yytext, -1, "integer");
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\&gt;\&gt;             { debuglex(yytext, -1, "integer-dblgt");
                            yyless(yyleng - 2);
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }


&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { debuglex(yytext, -1, "floating point");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return FP; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt;     { debuglex(yytext, -1, "floating point");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return FP; 
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;                    { debuglex(yytext, -1, "&lt;&lt;");
                            return DBLLT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;");
                            return DBLGT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;&gt;&gt;");
                            yyless(yyleng - 2);
                            return DBLGT; 
                                                                             }


&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\]*)+ { 
                          debuglex(yytext, -1, "string");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;

                            if(strcmp(yytext, "endstream") == 0){
                              BEGIN(INITIAL);
                              return ENDSTREAM;
                              }

                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\[(([^\[\]])|(\\\[)|(\\\]))*\] {
                          debuglex(yytext, -1, "bracketted string v1");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng); 
                            yylval.sval.len = yyleng;
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\((([^\(\)])|(\\\()|(\\\)))*\) {
                          debuglex(yytext, -1, "bracketted string v2");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\&lt;(([^\&lt;\&gt;])|(\\\&lt;)|(\\\&gt;))*\&gt; {
                          debuglex(yytext, -1, "bracketted string v3");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\\/]*)+\&gt;\&gt; { 
                          debuglex(yytext, -1, "string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;[\[\(][#&lt;&gt;a-zA-Z0-9\.\ :'+\-_\\\(\)]+[\)\]]\&gt;\&gt; {
                          debuglex(yytext, -1, "bracketted-string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

                        /* --- Array handling ---                           */

&lt;INITIAL&gt;\[                      { debuglex(yytext, -1, "[");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ARRAY; 
                                                                             }

&lt;INITIAL&gt;\]                      { debuglex(yytext, -1, "]");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

&lt;INITIAL&gt;\]\&gt;\&gt;                      { debuglex(yytext, -1, "]");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

                        /* --- Stuff needed for the xref and trailer ---    */

&lt;INITIAL&gt;\%\%EOF                 { debuglex(yytext, -1, "end of file");
                            return PDFEOF; 
                                                                             }

                        /* --- Stuff used to match binary streams --- 

                               The following amazing production is
                               used to deal with the massive
                               streams that images can create              */

&lt;BINARY&gt;[^end]+           { debuglex(yytext, yyleng, "binary mode");
                          yylval.sval.data = (char *) returnStr(yytext, yyleng);
                          yylval.sval.len = yyleng;
                          return ANYTHING;
                                                                             }

.                       { debuglex("!", -1, "the catch all");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return ANYTHING; 
                                                                             }

%%

void debuglex(char *text, int len, char *desc){
#if defined DEBUG
  int i;

  printf("Lexer rule is \"%s\", match is \"", desc);  

  for(i = 0; i &lt; ((len == -1) ? strlen(text) : len); i++){
    if(text[i] == '\n') printf(" \\n " );
    else if(text[i] == '\t') printf(" \\t ");
    else if(text[i] == '\r') printf(" \\r ");
    else if(text[i] == ' ') printf(" sp ");
    else if(isprint(text[i])) printf("%c", text[i]);
    else printf(" \\%d ", (unsigned char) text[i]);
    }

  printf("\"\n");
#endif
}

char *returnStr(char *yytext, int len){
  char *lval;

  if((lval = malloc(sizeof(char) * 
    ((len == -1) ? strlen(yytext) : len) + 1)) == NULL)
    error("Could not make space for lexer return.");
  memcpy(lval, yytext, ((len == -1) ? strlen(yytext) : len) + 1);

  return lval;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexer.l</emphasis></para>
</sect2>

<sect2><title>lexinterface.h</title>
<programlisting>
// This file defines the callbacks that users can setup to use PandaLex

#include &lt;stdarg.h&gt;

enum{
  pandalex_event_begindocument = 0,
    pandalex_event_specver,
    pandalex_event_entireheader,
    pandalex_event_objstart,
    pandalex_event_objend,
    pandalex_event_dictitem_string,
    pandalex_event_dictitem_name,
    pandalex_event_dictitem_arraystart,
    pandalex_event_dictitem_arrayitem,
    pandalex_event_dictitem_arrayend,
    pandalex_event_dictitem_object,
    pandalex_event_dictitem_dict,
    pandalex_event_dictitem_dictend,
    pandalex_event_dictitem_int,
    pandalex_event_stream,
    pandalex_event_dictint,
    pandalex_event_xrefstart,
    pandalex_event_xrefitem,
    pandalex_event_xrefend,
    pandalex_event_trailerstart,
    pandalex_event_trailerend,
    pandalex_event_enddocument,
    pandalex_event_max
    };

// Callbacks are defined so that they have a type for the arguments they
// possess associated with them. Where possible the arguments created by the
// lexer will be converted into the types needed by the callback. If not,
// an error is returned
typedef void (*pandalex_callback_type)(int, va_list);


void pandalex_setupcallback(int, pandalex_callback_type);
void pandalex_callback(int, ...);

</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexinterface.h</emphasis></para>
</sect2>

<sect2><title>pandalex.h</title>
<programlisting>
char *pandalex_strmcat(char *, int, char *, int);
char *pandalex_strmcpy(char *, int);
int pandalex_intlen(int);
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/pandalex.h</emphasis></para>
</sect2>

<sect2><title>parser.y</title>
<programlisting>
%{
  #include "lexinterface.h"
  #include "samples.h"
  #include "pandalex.h"

  #include &lt;stdarg.h&gt;

  #define YYMAXDEPTH 50000
  #define YYERROR_VERBOSE 1

  // The callbacks
  pandalex_callback_type pandalex_callbacks[pandalex_event_max];
%}

          /* Define the possible yylval values */
%union {
  int        intVal;

  struct streamVal{
    char *data;
    int len;
  } sval;
}

%token &lt;sval&gt; VERSION
%token &lt;sval&gt; NAME
%token &lt;sval&gt; STRING
%token &lt;sval&gt; OBJREF &lt;sval&gt; OBJ &lt;sval&gt; ENDOBJ 
%token &lt;intVal&gt; INT
%token &lt;sval&gt; FP
%token &lt;sval&gt; DBLLT &lt;sval&gt; DBLGT
%token &lt;sval&gt; STREAM &lt;sval&gt; ENDSTREAM
%token &lt;sval&gt; ARRAY &lt;sval&gt; ENDARRAY &lt;sval&gt; ENDARRAYDBLGT
%token &lt;sval&gt; PDFEOF XREF TRAILER
%token &lt;sval&gt; ANYTHING

%type &lt;sval&gt; binary
%type &lt;sval&gt; header
%type &lt;sval&gt; objref
%type &lt;sval&gt; arrayvals

%type &lt;intVal&gt; dictionary
%type &lt;intVal&gt; subdictionary

%%

// completely implemented
pdf       : { pandalex_callback(pandalex_event_begindocument, ""); } 
            header { pandalex_callback(pandalex_event_entireheader, $2.data); } 
            object linear objects xref trailer endcrap
          ;

// completely implemented
header    : VERSION { pandalex_callback(pandalex_event_specver, $1.data); }
            binary { $$.data = pandalex_strmcat($1.data, $1.len, $3.data, $3.len); $$.len = $1.len + $3.len + 1; }
          ;

linear    : xref trailer { }
          |
          ;

// Clibpdf sometimes puts some binary crap at the end of the file (pointer
// problems?)
// completely implemented
endcrap   : binary { }
          |
          ;

// completely implemented
objects   : object objects
          | 
          ;

// todo_mikal: might need a .data here
object    : INT INT OBJ { pandalex_callback(pandalex_event_objstart, $1, $2); } 
            dictionary { if($5 != -1) pandalex_callback(pandalex_event_dictint, $1, $2, $5); } 
            stream ENDOBJ { pandalex_callback(pandalex_event_objend, $1, $2); }
          ;

dictionary: DBLLT dict DBLGT { $$ = -1; }
          | INT { $$ = $1; }
          | ARRAY arrayvals ENDARRAY { $$ = -1; }
          | objref { $$ = -1; }
          | NAME { $$ = -1; }
          | STRING { $$ = -1 };
          | { $$ = -1; }
          ;

subdictionary: DBLLT dict DBLGT { $$ = -1 };

dict      : NAME STRING { pandalex_callback(pandalex_event_dictitem_string, $1.data, $2.data); } dict
          | NAME NAME { pandalex_callback(pandalex_event_dictitem_name, $1.data, $2.data); } dict
          | NAME ARRAY { pandalex_callback(pandalex_event_dictitem_arraystart, $1.data); } 
              arrayvals ENDARRAY { pandalex_callback(pandalex_event_dictitem_arrayend, $1.data); } dict
          | NAME objref { pandalex_callback(pandalex_event_dictitem_object, $1.data, $2.data); } dict
          | NAME { pandalex_callback(pandalex_event_dictitem_dict, $1.data); } 
              subdictionary { pandalex_callback(pandalex_event_dictitem_dictend, $1.data); } dict
          | NAME INT { pandalex_callback(pandalex_event_dictitem_int, $1.data, $2); } dict
          | NAME FP {} dict
          | 
          ;

arrayvals : objref { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals 
          | INT { /*todo*/ } arrayvals
          | NAME { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | STRING { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | ARRAY { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | DBLLT { pandalex_callback(pandalex_event_dictitem_dict, "array-dictitem"); } 
              dict DBLGT { pandalex_callback(pandalex_event_dictitem_dictend, "array-dictitem"); } arrayvals
          | {}
          ;

// completely implemented
objref    : INT INT OBJREF { if(($$.data = (char *) malloc((pandalex_intlen($1) + pandalex_intlen($2) + 5) * sizeof(char))) == NULL){
			       fprintf(stderr, "Could not allocate enough space for objref\n");
			       exit(42);
                               }
			     
			     sprintf($$.data, "%d %d R", $1, $2);
			     $$.len = strlen($$.data) + 1;
			                       }
          ;

// completely implemented
stream    : STREAM binary ENDSTREAM { pandalex_callback(pandalex_event_stream, $2.data, $2.len); free($2); }
          |
          ;

// completely implemented: callbacks are handled in the callers to this
binary    : ANYTHING binary { $$.data = pandalex_strmcat($1.data, $1.len, $2.data, $2.len); $$.len = $1.len + $2.len; free($2); }
          | STRING binary { $$.data = pandalex_strmcpy($1.data, -1); $$.len = strlen($1.data); }
          | { $$.data = pandalex_strmcpy("", -1); $$.len = 0; }
          ;

// completely implemented
xref      : XREF INT INT { pandalex_callback(pandalex_event_xrefstart); }
              xrefitems {}
          ;

// completely implemented
xrefitems : INT INT STRING { pandalex_callback(pandalex_event_xrefitem, $1, $2, $3); }
              xrefitems
          | { pandalex_callback(pandalex_event_xrefend); }
          ;

// completely implemented
trailer   : TRAILER { pandalex_callback(pandalex_event_trailerstart); } 
              DBLLT dict DBLGT STRING INT { pandalex_callback(pandalex_event_trailerend, $6, $7); } 
              PDFEOF { pandalex_callback(pandalex_event_enddocument); }
          ;

%%

void pandalex_init(){
  int i;

  // Make sure that the callbacks default to nothing
  for(i = 0; i &lt; pandalex_event_max; ++i){
    pandalex_callbacks[i] = NULL;
  }
}

void pandalex_setupcallback(int callback, pandalex_callback_type functoid){
  pandalex_callbacks[callback] = functoid;
}

// Here we call the callbacks. This includes converting to the types that the
// callback function expects.
void pandalex_callback(int event, ...){
  va_list argptr;

  // Start accessing the arguements from the end
  va_start(argptr, event);
  
  // If no event handler is setup, then we ignore the event
  if(pandalex_callbacks[event] != NULL){
    pandalex_callbacks[event] (event, argptr);
  }
  
  // Stop with the arguements
  va_end(argptr);
}

int pandalex_parse(){
  // We are not looking into a stream at the moment
  yyparse();
}

int yyerror(char *s){
  fprintf(stderr, "\n---------------------------------------------------------------\n");
  fprintf(stderr, "PandaLex parser error (%s):\n", s);
  fprintf(stderr, "  Please send this error text, along with a copy of your PDF\n");
  fprintf(stderr, "  document (if possible) to mikal@stillhq.com, so that this can\n");
  fprintf(stderr, "  be fixed for the next release...\n\n");
  fprintf(stderr, "version = 0.4\n");
  fprintf(stderr, "last token = \"%s\" (%d) or %d\n", yylval.sval.data, yylval.sval.len, yylval.intVal);
  fprintf(stderr, "\n---------------------------------------------------------------\n");

  exit(42);
}

// Buffer overrun safe strcat
char *pandalex_strmcat(char *dest, int destLen, char *append, int appendLen){
  char *new;
  int count, len;

  // What length do we need?
  if((new = (char *) malloc(sizeof(char) * 
			    (((destLen == -1) ? strlen(dest) : destLen) + 
			    ((appendLen == -1) ? strlen(append) : appendLen) + 
			    2))) == NULL){
    fprintf(stderr, "Could not malloc enough space\n");
    exit(42);
  }
  
  if((destLen == -1) &amp;&amp; (appendLen == -1))
    sprintf(new, "%s%s", dest, append);
  else{
    // We need to copy characters the hard way -- change this to a memcpy
    count = 0;

    for(len = 0; len &lt; ((destLen == -1) ? strlen(dest) : destLen); len++){
      new[count] = dest[len];
      count++;
    }

    for(len = 0; len &lt; ((appendLen == -1) ? strlen(append) : appendLen); len++){
      new[count] = append[len];
      count++;
    }

    new[count] = '\0';
  }
  return new;
}

// Buffer overrun safe strcpy
char *pandalex_strmcpy(char *data, int len){
  return pandalex_strmcat(data, len, "", 0);
}

int pandalex_intlen(int number){
  int length = 0;

  while(number &gt; 0){
    length ++;
    number /= 10;
  }

  return number;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/parser.y</emphasis></para>
</sect2>

<sect2><title>samples.c</title>
<programlisting>
/* A sample application using pandalex -- this is pdfdump */

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;zlib.h&gt;
#include "samples.h"
#include "lexinterface.h"

enum{
  pdfdump_dump = 0,
    pdfdump_meta
    };
int pdfdump_application;

pdfdump_dictint_list *dictint_list;

// Some demo code for how to use PandaLex
int main(int argc, char *argv[]){
  pandalex_init();

  // Parse the command line to find out what we are doing today -- this needs more thought
  if(strcmp(argv[0], "pdfmeta") == 0){
    pdfdump_application = pdfdump_meta;
  }
  else
    pdfdump_application = pdfdump_dump;

  // Setup the callbacks
  pandalex_setupcallback(pandalex_event_begindocument, pdfdump_begindocument);

  pandalex_setupcallback(pandalex_event_specver, pdfdump_specversion);
  pandalex_setupcallback(pandalex_event_entireheader, pdfdump_entireheader);
  pandalex_setupcallback(pandalex_event_objstart, pdfdump_objstart);
  pandalex_setupcallback(pandalex_event_objend, pdfdump_objend);

  pandalex_setupcallback(pandalex_event_dictitem_string, pdfdump_dictitem_string);
  pandalex_setupcallback(pandalex_event_dictitem_name, pdfdump_dictitem_name);
  pandalex_setupcallback(pandalex_event_dictitem_arraystart, pdfdump_dictitem_arraystart);
  pandalex_setupcallback(pandalex_event_dictitem_arrayitem, pdfdump_dictitem_arrayitem);
  pandalex_setupcallback(pandalex_event_dictitem_arrayend, pdfdump_dictitem_arrayend);
  pandalex_setupcallback(pandalex_event_dictitem_object, pdfdump_dictitem_object);
  pandalex_setupcallback(pandalex_event_dictitem_dict, pdfdump_dictitem_dict);
  pandalex_setupcallback(pandalex_event_dictitem_dictend, pdfdump_dictitem_dictend);
  pandalex_setupcallback(pandalex_event_dictitem_int, pdfdump_dictitem_int);

  pandalex_setupcallback(pandalex_event_stream, pdfdump_stream);
  pandalex_setupcallback(pandalex_event_dictint, pdfdump_dictint);
  
  // Initialise the dictint_list structure;
  if((dictint_list = (pdfdump_dictint_list *)
      malloc(sizeof(pdfdump_dictint_list))) == NULL){
    fprintf(stderr, "Could not initialise the dictint list\n");
    exit(42);
  }

  dictint_list-&gt;next = NULL;

  // Start parsing
  pandalex_parse();

  return 0;
}

char *pandalex_xsnprintf(char *, ...);

// Arguement is the name of the file as a char *
void pdfdump_begindocument(int event, va_list argptr){
  char *filename;

  filename = va_arg(argptr, char *);
  printf("Information for document: \"%s\"\n\n", filename);
}

void pdfdump_specversion(int event, va_list argptr){
  printf("Specification version is: %s\n", (char *) va_arg(argptr, char *));
}

void pdfdump_entireheader(int event, va_list argptr){
  int    i;
  char   *textMatch = (char *) va_arg(argptr, char *);

  printf("Entire document header is: ");

  for(i = 0; i &lt; strlen(textMatch); i++){
    if(isprint(textMatch[i])) printf("%c ", textMatch[i]);
    else printf("\\%d ", textMatch[i]);
  }

  printf("\n");
}

void pdfdump_objstart(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d started (generation %d)\n",
	 number, generation);
}

void pdfdump_objend(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d ended (generation %d)\n",
	 number, generation);
}

void pdfdump_dictitem_string(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [String] %s = \"%s\"\n", name, value);
}

void pdfdump_dictitem_name(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Name] %s = %s\n", name, value);
}

void pdfdump_dictitem_arraystart(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s starts\n", name);
}

void pdfdump_dictitem_arrayitem(int event, va_list argptr){
  char *value;
  
  value = va_arg(argptr, char *);
  printf("  [Array] %s\n", value);
}

void pdfdump_dictitem_arrayend(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s ends\n", name);
}

void pdfdump_dictitem_object(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Object reference] %s = %s\n", name, value);
}

void pdfdump_dictitem_dict(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" starts\n", name);
}

void pdfdump_dictitem_dictend(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" ends\n", name);
}

void pdfdump_dictitem_int(int event, va_list argptr){
  int value;
  char *name;

  name = va_arg(argptr, char *);
  value = va_arg(argptr, int);

  printf("  [Integer] %s = %d\n", name, value);
}

void pdfdump_stream(int event, va_list argptr){
  char *filter;
  int length;
  char *lengthObj;
  char *streamData;
  int streamDataLen;
  pdfdump_dictint_list  *now;
  int found;

  printf("  [Stream]\n");

  filter = va_arg(argptr, char *);
  length = (int) va_arg(argptr, char *);
  lengthObj = va_arg(argptr, char *);
  streamData = va_arg(argptr, char *);
  streamDataLen = va_arg(argptr, int);

  // Determine if we know the length
  switch(length){
  case -2:
    // We don't - have we seen the obj already?
    printf("    Length is stored in object\n");
    break;

  case -1:
    // It was never defined
    printf("    Length field not defined\n");
    break;

  default:
    printf("    Length is stated to be %d\n", length);
    pdfdump_procstream(filter, length, streamData, streamDataLen);
    break;
  }
}

void pdfdump_dictint(int event, va_list argptr){
  int found;
  int objnum, objgen, value;
  char *objref;
  pdfdump_dictint_list *now;

  // Get the passed information
  objnum = va_arg(argptr, int);
  objgen = va_arg(argptr, int);
  value = va_arg(argptr, int);

  printf("Do something with the dictint %d %d R = %d\n", objnum, objgen, value);

  // Information is handed to this event in a slightly different manner to
  // the stream event handler. Fix this.
  if((objref = (char *) malloc((pandalex_intlen(objnum) + pandalex_intlen(objgen) + 5) * sizeof(char))) == NULL){
    fprintf(stderr, "Could not allocate enough space for objref\n");
    exit(42);
  }
  
  sprintf(objref, "%d %d R", objnum, objgen);

  // Are we already waiting?
  now = dictint_list;
  found = 0;

  while((now-&gt;next != NULL) &amp;&amp; (found == 0)){
    if(strcmp(objref, now-&gt;value) == 0){
      // Yes -- do something
      pdfdump_procstream(now-&gt;filter, value, now-&gt;stream, now-&gt;streamlen);
      found = 1;
    }

    now = now-&gt;next;
  }

  // No -- save data and wait
  if(found == 0){
    // now is already the end of the list
    if((now-&gt;next = (pdfdump_dictint_list *)
	malloc(sizeof(pdfdump_dictint_list))) == NULL){
      fprintf(stderr, "Could not add to list of waiting streams\n");
      exit(42);
    }
    
    now-&gt;value = (char *) pandalex_strmcpy(objref, -1);
    now-&gt;filter = NULL;
    now-&gt;stream = NULL;
    now-&gt;waiting = 2;
    now = now-&gt;next;
    now-&gt;next = NULL;
  }
}

void pdfdump_procstream(char *filter, int length, char *data, int dataLen){
  char *uncompressed, *dataPtr, *linhintdesc[17];
  uLong srcLen, dstLen = 512;
  int result, i, linhintlens[17], number, count;

  linhintlens[0] = 32;
  linhintdesc[0] = pandalex_xsnprintf("Least number of objects in a page");
  linhintlens[1] = 32;
  linhintdesc[1] = pandalex_xsnprintf("Location of the first page object");
  linhintlens[2] = 16;
  linhintdesc[2] = pandalex_xsnprintf("Page objects delta bits");
  linhintlens[3] = 32;
  linhintdesc[3] = pandalex_xsnprintf("Least page length");
  linhintlens[4] = 16;
  linhintdesc[4] = pandalex_xsnprintf("Page length delta bits");
  linhintlens[5] = 32;
  linhintdesc[5] = pandalex_xsnprintf("Least content stream offset");
  linhintlens[6] = 16;
  linhintdesc[6] = pandalex_xsnprintf("Content stream offset delta bits");
  linhintlens[7] = 32;
  linhintdesc[7] = pandalex_xsnprintf("Least content stream length");
  linhintlens[8] = 16;
  linhintdesc[8] = pandalex_xsnprintf("Contents stream length delta bits");
  linhintlens[9] = 16;
  linhintdesc[9] = pandalex_xsnprintf("Greatest shared object number bits");
  linhintlens[10] = 16;
  linhintdesc[10] = pandalex_xsnprintf("Numerically greatest shared object number bits");
  linhintlens[11] = 16;
  linhintdesc[11] = pandalex_xsnprintf("Numeration object fraction bits");
  linhintlens[12] = 16;
  linhintdesc[12] = pandalex_xsnprintf("Denominator object fraction bits");
  linhintlens[13] = 16;
  linhintdesc[13] = pandalex_xsnprintf("?????");

  // Check length
  if(length &lt; 1){
    fprintf(stderr, "Stream length is not believable\n");
    return;
  }

  // Check there is a filter at all
  if(filter == NULL){
    fprintf(stderr, "This stream is not compressed!\n");
    return;
  }

  // If the stream starts with a \r or a \n or a \r\n, then these should be stripped off
  dataPtr = data;
  while((dataPtr[0] == '\r') || (dataPtr[0] == '\n')) dataPtr++;

  // Do something with the stream
  if(strcmp(filter, "FlateDecode") == 0){
    printf("Do something involving Flate\n");
    
    //    printf("--------------------------------------------------");
    //for(i = 0; i &lt; dataLen; i++)
    //  printf("%c", data[i]);
    //printf("--------------------------------------------------");


    // - 1
    for(i = -10; i &lt; 1; i++){
      srcLen = dataLen + i;
      dstLen = 512;
      printf("[%d] ", i);
     
      if((uncompressed = (char *) malloc(sizeof(char) * dstLen)) == NULL){
	fprintf(stderr, "Could not make enough space to decompress Flate stream\n");
	exit(42);
      }
      
      // We grow the output buffer until we no longer get buffer size errors
      while((result = uncompress(uncompressed, &amp;dstLen, dataPtr, srcLen)) == Z_BUF_ERROR){
	printf(".");
	fflush(stdout);
	
	dstLen *= 2;
	if(((uncompressed = (char *) realloc(uncompressed, dstLen)) == NULL) ||
	   (dstLen &gt; 10000000)){
	  // We could not grow the buffer, so we exit
	  printf("!");
	  fflush(stdout);
	  free(uncompressed);
	  break;
	}
      }

      if(result == Z_OK) printf(" HIT");
      printf(" *\n");
    }
    
    if(result != Z_OK){
      fprintf(stderr, "Flate decompression failed because of ");
      
      switch(result){
      case Z_MEM_ERROR:
	fprintf(stderr, "not enough memory\n");
	break;
	
      case Z_DATA_ERROR:
	fprintf(stderr, "corrupt input data\n");
	break;

      case Z_BUF_ERROR:
	fprintf(stderr, "buffer error\n");
	break;

      default:
	fprintf(stderr, "unknown error (%d)\n", result);
	break;
      }
      
      debuglex(data, srcLen, "Flate compression failure", 0);
      exit(46);
    }
    
    printf("\n");
    printf("----------- UNCOMPRESSED STREAM IS -------------------------------------------\n");
    // printf("%s\n", uncompressed);
    printf("Total uncompressed size: %d\n\n", dstLen);

    count = 0;

    for(i = 0; count &lt; 13;){
      number = 0;
      if(linhintlens[count] == 16){
	number = uncompressed[i] &lt;&lt; 8 | uncompressed[i + 1];
	i += 2;
      }
      else{
	number = uncompressed[i] &lt;&lt; 24 | uncompressed[i + 1] &lt;&lt; 16 |
	  uncompressed[i + 2] &lt;&lt; 8 | uncompressed[i + 3];
	i += 4;
      }

      printf("%s [%d]: %d\n", linhintdesc[count], linhintlens[count], number);
      count++;
    }

    printf("\nTotal bytes used: %d\n", i);
    printf("\n------------------------------------------------------------------------------\n");
  }
  else if(strcmp(filter, "LZWDecode") == 0){
    printf("LZW compression is encumbered by Patents and therefore not supported\n"); 
  }
  else if(strcmp(filter, "CCITTFaxDecode") == 0){
    printf("Do something involving CCITTFax compression (TIFF)\n");
  }
  else{
    printf("Unknown filter \"%s\"\n", filter);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.c</emphasis></para>
</sect2>

<sect2><title>samples.h</title>
<programlisting>
void pdfdump_begindocument(int, va_list);
void pdfdump_specversion(int, va_list);
void pdfdump_entireheader(int, va_list);
void pdfdump_objstart(int, va_list);
void pdfdump_objend(int, va_list);

void pdfdump_dictitem_string(int, va_list);
void pdfdump_dictitem_name(int, va_list);
void pdfdump_dictitem_arraystart(int, va_list);
void pdfdump_dictitem_arrayitem(int, va_list);
void pdfdump_dictitem_arrayend(int, va_list);
void pdfdump_dictitem_object(int, va_list);
void pdfdump_dictitem_dict(int, va_list);
void pdfdump_dictitem_dictend(int, va_list);
void pdfdump_dictitem_int(int, va_list);

void pdfdump_stream(int, va_list);
void pdfdump_dictint(int, va_list);
void pdfdump_procstream(char *, int, char *, int);

// This data type is needed for pdfdump_stream and 
// pdfdump_dictint
typedef struct pdfdump_internal_dictint_list{
  char *value;
  int waiting;
  int number;

  char *stream;
  int streamlen;
  char *filter;

  struct pdfdump_internal_dictint_list  *next; 
} pdfdump_dictint_list;
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.h</emphasis></para>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
<figure>
<title>Content</title>
<graphic format="EPS" fileref="todo.eps">
</figure>
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the three libraries discussed here).</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>
</sect1>

</chapter>
<chapter id="chap-conclusion"><title>Conclusion</title>
<para>
...
</para>
</chapter>
</book>
