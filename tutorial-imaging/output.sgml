<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>

</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>


<sect1><title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>

</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>

</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<sect2><title>C</title>
<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not necessarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>

</sect2>

<sect2><title>How to compile and link on your chosen operating system</title>
<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The make files included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>

</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.
</para>


<figure><title>Catherine and Andrew</title>
</figure>

<para>
I should also thank the following people:
</para>

<itemizedlist>
<listitem><para>Doug Jackson (doug_jackson@citadel.com.au), for proof reading and getting me interested in this whole topic to start with</para></listitem>
<listitem><para>Tony Green (greeno@bandcamp.tv), for occasional DocBook wrangling</para></listitem>
<listitem><para>Michael Smith (smith@xml-doc.org), for DocBook hints</para></listitem>
<listitem><para>Greg Lehey, for giving me access to his docbook environment when I was having jade pain</para></listitem>
<listitem><para>Lenny Muellner, of O'Reilly, for helping me with my gmat problems</para></listitem>
</itemizedlist>

</sect1>

<sect1><title>How this document was produced</title>
<para>
This tutorial was written in DocBook SGML using xemacs. This was then converted into PDF using the jade SGML tools. Diagrams were developed in a combination of the gimp, Adobe Illustrator, and custom developed code. Diagrams were converted to EPS as required by jade using ImageMagick.
</para>

<para>
A series of DocBook generation scripts was also used to automate some of the generation of this document. These scripts can be found in my online CVS repository at: http://www.stillhq.com/cgi-bin/cvsweb/docbooktools/
</para>

<para>
The source for this tutorial is available at: http://www.stillhq.com/cgi-bin/cvsweb/tutorial-imaging/
</para>
</sect1>

<sect1><title>License</title>
<para>
This document is covered by two licenses -- the license for the text of this document, and the license for the included source code. The license terms are set out below.
</para>

<sect2><title>License for text (OPL)</title>
<para>
<command>
This tutorial is Copyright (c) Michael Still 2002, and is released under the terms of the GNU OPL. Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder. Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.
</command>
</para>

<para>
Please note that portions of this tutorial are <command>not</command> Copyright Michael Still, or are licensed under a license other than the GNU OPL, and are acknowledged as such either below or when relevant within the text of the tutorial.
</para>

</sect2>

<sect2><title>License for source code (GPL)</title>
</sect2>

<sect2><title>License for the libtiff man pages</title>
<para>
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.
</para>

<para>
Permission to use, copy, modify, distribute, and sell this software and 
its documentation for any purpose is hereby granted without fee, provided
that (i) the above copyright notices and this permission notice appear in
all copies of the software and related documentation, and (ii) the names of
Sam Leffler and Silicon Graphics may not be used in any advertising or
publicity relating to the software without the specific, prior written
permission of Sam Leffler and Silicon Graphics.
</para>

<para>
THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
</para>

<para>
IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
OF THIS SOFTWARE.
</para>
</sect2>
</sect1>
</chapter>
<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day. This section presents these things in alphabetical order, for ease of reference.
</para>

<para>
These terms are presented in alphabetical order. Some of them might seem a bit odd, but they're here because they are interesting...
</para>


<sect1><title>Anti-aliasing</title>
<para>
Imagine that you are drawing a triangle across an image (or on the screen for that matter). The triangle is sometimes going to cross pixels in a way which makes them not totally turned on. Have a look at the figure below to see what I mean...
</para>


<figure><title>Drawing a triangle</title>
</figure>

<para>
If we only have a black and white image, then we'll end up with an image like the one in the figure below. I am sure you'll agree that this isn't a very good representation of the side of the triangle.
</para>



<figure><title>A triangle with only black pixels</title>
</figure>

<para>
Anti-aliasing is when we try to correct for this problem by inserting some gray pixels. In the figure below, we have given some of the pixels a gray value which is based on how much of the pixel is <quote>filled</quote> with the triangle.
</para>



<figure><title>A triangle with gray scale pixels</title>
</figure>

<para>
The triangle might be a little clearer without the grid lines.
</para>



<figure><title>Anti-aliased triangle without grid lines</title>
</figure>

<para>
For comparison, there is the triangle we started with...
</para>

<figure><title>The original triangle</title>
</figure>

<para>
So, in summary, anti-aliasing is the process of turning on some extra gray scale pixels to improve the look of shapes we are drawing...
</para>
</sect1>
<sect1><title>Encrypting images</title>
<para>
DES in Electronic Code Book (ECB) mode is a particularly poor choice of cryptography for image files. This is because ECB mode implements a look up table between the unencrypted value and the encrypted value. This results in a known input value turning into the same output value over and over. This can have some interesting blurring effects, but wont obscure the image contents. An example will help this make more sense -- the first figure is the logo for the company I am currently working for. I took this image, and ran it through some DES ECB code and produced the second figure.
</para>


<figure><title>The TOWER corporate logo</title>
</figure>



<figure><title>After ECB encryption</title>
</figure>

<para>
You can see that whilst the image has certainly changed, the contents of the image has not really been obscured. 
</para>




<para>
We should note that ECB mode is not commonly used anyway. If you use something like PGP or blowfish, then you should be much happier... 
</para>

</sect1>
<sect1><title>Gray scale conversion</title>
<para>
How do you convert color images to gray scale? Well, my instant answer when I first had to do this was to just average the red, green and blue values. That answer is wrong. The reality is that the human eye is much better at seeing some colors than others. To get an accurate gray scale representation, you need to apply different coefficients to the color samples. Appropriate coefficients are 0.299 for red, 0.587 for green and 0.114 for blue.
</para>


<para>
Below I have included several pictures that illustrate this concept. The first figure is a color image
  <footnote><para>Which may or may not give you joy, depending on if you are viewing this document in color or not</para></footnote>
, the second is the color image converted to gray scale without the coefficients applied, and the third image is a correct gray scale rendition.
</para>

<figure><title>The original image</title>
</figure>

<figure><title>An average of the color values for each pixel</title>
</figure>

<figure><title>A correct conversion to gray scale</title>
</figure>

<para>
You can see that the sensible algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>

<para>
The source code to generate these example images may be found in the TIFF chapter.
</para>
</sect1>
<sect1><title>Pixel samples</title>
<para>
Each pixel needs to have a value associated with this. Most practitioners call this a sample. For a black and white image we would only have one sample per pixel, whilst for a RGB color image, we would have three samples per pixel -- the red, green and blue components.
</para>


</sect1>

<sect1><title>Pixel</title>
<para>
     <indexterm><primary>Pixel</primary></indexterm>
A pixel is the lowest unit of raster image description -- in other words, a raster image is defined in terms of pixels. Example pixels can be seen in the discussion of rasters, later in this chapter.
</para>

</sect1>

<sect1><title>Rasters</title>
<para>
     <indexterm><primary>Raster</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>raster</secondary></indexterm>
The most common image format (and the focus of the majority of this tutorial) is raster image formats. Raster image formats are those which store the picture as a bitmap
     <footnote><para>You can think of a bitmap as being simply an array of pixels. We'll talk more about this later</para></footnote>
describing the state of pixels, as opposed to recording the length and locations of primatives such as lines and curves. Common examples include the output of photoshop, the gimp, scanners and digital cameras. Effectively, your monitor and printer are raster output devices.
</para>


<figure><title>A sample raster image</title>
</figure>


<para>
Raster image formats include TIFF, GIF, PNG, and most of the other formats in this tutorial. If in doubt, assume that it's a raster format unless I tell you otherwise.
</para>


<para>
If we zoom in enough on a portion of this image, we can see that it is made up of descrete elements -- the pixels. 
</para>

<figure><title>Zooming in on a portion of the raster image</title>
</figure>

<para>
The code to produce this zoomed image is presented in the TIFF chapter of this tutorial.
</para>
</sect1>
<sect1><title>Theory of color and gray scale storage</title>
<para>
There are several ways that the value of a pixel can be stored within a raster image. This is a pretty fundamental concept, so it is best to get it out of the way early on before we get caught up in the actual format of images.
</para>


<figure><title>The worst picture of a house you have ever seen</title>
</figure>

<para>
I will use the simple image above to demonstrate the ways that the pixel values can be stored...
</para>



<figure><title>A zoom in on the house</title>
</figure>

<para>
We'll in fact only use a zoomed in portion of the image so that what is happening is clearer.
</para>

<sect2><title>Direct storage of black and white</title>
<figure><title>A black and white zoom in</title>
</figure>

<para>
Black and white images only really have one pixel value storage option. This is to store the value of the pixel directly at the pixel location in the image data itself. This is a good option for black and white data, because it only takes on bit per pixel anyway.
</para>



<figure><title>Black and white data</title>
</figure>

<para>
Whilst this is a very simple example, make sure you understand how the diagram works, because it gets more complex from here. Each square represents the storage space in the image data, and in this example the values representing the pixel values is stored inside the image data.
</para>

</sect2>

<sect2><title>Direct gray scale storage</title>
<figure><title>A gray scale zoom in</title>
</figure>

<para>
In this example, we are storing the gray scale values of the pixels within the image data.
</para>

</sect2>

<sect2><title>Direct RGB storage</title>
<figure><title>A RGB zoom in</title>
</figure>

<para>
Here we are storing the red green and blue values for each pixel within the image data.
</para>

</sect2>

<sect2><title>Paletted RGB storage</title>
<figure><title>A paletted RGB zoom in</title>
</figure>

<para>
The other option is to instead store within the image data itself a number which uniquely identifies the color at that pixel. We can then have a table elsewhere in the image file which defines the color that is that unique value. This table is a palette, and this is a very common way of storing RGB data (it is in fact the only option with some formats such as GIF).
</para>


<para>
You can also use palettes for gray scale images, I just haven't provided an example of that here.
</para>

<sect3><title>The advantage of paletting</title>
<para>
The big advantage of paletting an image is that the final file is going to be much smaller. For example, an A4 page is 1754 by 2479 pixels. That's 4,348,166 pixels. Now, let's assume for this example that the image is 24 bit color (that is 8 bits per color per pixel), and that there are seven colors in the image. That means that unpaletted, we have 13,044,498 bytes of image data (uncompressed). If we palette the image data, then we only need three bits of data in the image data -- 1,630,562 bytes (uncompressed). We'll also need to store the palette itself, which will need another 21 bytes (uncompressed). We don't need to store the color indices, as they are just an offset into an array.
</para>

<para>
This means that the total saving on an uncompressed image is 11,413,936 bytes. The disadvantage of course is that using the image is almost certainly going to be slightly slower...
</para>

</sect3>
</sect2>
</sect1>
<sect1><title>Vector</title>
<para>
     <indexterm><primary>Vector</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>vector</secondary></indexterm>
Some images aren't raster images. These images are normally composed of primitive drawing commands, such as draw a line, draw a circle, et cetera. The advantage of vector formats is that it is an exact representation of the image, they also scale much better. Examples of vector formats include Scalar Vector Graphics (SVG), Adobe Illustrator files, Windows Meta Files, and to a certain extent PDF documents. A plotter is a vector output device.
</para>

</sect1>

</chapter>
<chapter id="chap-tiff"><title>TIFF</title>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>



<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>

</sect1>

<sect1><title>Installation</title>
<para>
The source for libtiff can be downloaded from http://www.libtiff.org/ -- the current version of the library being version 3.5.7 at the time of writing. This version can be downloaded from ftp://ftp.remotesensing.org/pub/libtiff, look for the files named either tiff-v3.5.7.tar.gz or tiff-v3.5.7.zip.
</para>

<sect2><title>Unix</title>
<para>
Once you have downloaded the tarball for the library as described above, then you need to follow the steps below to install libtiff
  <footnote><para>Please note that there are binary packages for libtiff for most operating systems, so you might be best off installing one of those.</para></footnote>.

<orderedlist>
<listitem><para>tar xvzf tiff-v3.5.7.tar.gz</para></listitem>
<listitem><para>cd tiff-v3.5.7</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</orderedlist>
</para>

<para>
Not too hard at all...
</para>
</sect2>

<sect2><title>win32</title>
<para>
The instructions for how to compile the library are as follows:
</para>

<itemizedlist>
<listitem><para>Uncompress the libtiff distribution</para></listitem>
<listitem><para>Change directory into the libtiff directory inside the distribution</para></listitem>
<listitem><para>Copy ..\contrib\winnt\fax3sm.c to fax3sm_winnt.c</para></listitem>
<listitem><para>Copy ..\contrib\winnt\libtiff.def to libtiff.def</para></listitem>
<listitem><para>Remove the line for TIFFModeCCITTFax3 from the libtiff.def file</para></listitem>
<listitem><para>Change the line for TIFFFlushdata1 in the libtiff.def file to TIFFFlushData1</para></listitem>
<listitem><para>nmake /f makefile.vc all</para></listitem>
<listitem><para>Done!</para></listitem>
</itemizedlist>

<para>
To compile the tools once you have the library, just change into the tools directory and do a nmake /f makefile.vc 
</para>

<para>
For the Visual Studio challenged, there is a precompiled version of libtiff for win32 available from http://www.stillhq.com. Have a look at the Panda documentation page...
</para>
</sect2>
</sect1>

<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>


<sect2><title>File header</title>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory</title>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory Entries</title>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
These entries have a type associated with them, possible types are:
</para>



<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>

<para>
TIFF version 6 added the following fields:
</para>

<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>

</sect2>

<sect2><title>Possible field entries</title>
<para>
Discussing the many different possible field entries is out of the scope of this document. Refer to tiff.h and the TIFF specification for more information.
</para>
</sect2>

<sect2><title>So where's the image data?</title>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:


<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</para>


<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	

<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>

</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>

	
<sect2><title>Infrastructure for writing</title>
<para>
It is traditional for bitmaps to be represented inside your code with an array of chars. This is because on most operating systems, a char maps well to one byte. In the block of code below, we will setup libtiff, and create a simple buffer which contains an image which we can then write out to disc.
</para>



<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>


<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>

<sidebar><title>Problems with xview</title>
<para>
Xview is part of the xloadimage package written by Jim Frost, which comes with X windows.
</para>

<para>
It's a good example of how hard it can be to handle TIFF images well. If you have trouble viewing the output of the sample code, then try using some other program, like the GIMP.
</para>
</sidebar>

<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>


<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>


<sidebar><title>More information about the libtiff function calls</title>
<para>
If you need more information about any of the libtiff function calls mentioned in this chapter, then checkout the extensive man pages which come with the library. Remember that case is important with man pages, so you need to get the case in the function names right -- it's TIFFOpen, not tiffopen.
</para>
</sidebar>


<figure><title>The Sydney Harbor Bridge, by Michael Still</title>
</figure>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>


<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>


<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>


<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<figure><title>The Sydney Harbor Bridge, in strips</title>
</figure>



<figure><title>The Sydney Harbor Bridge, in tiles</title>
</figure>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>


<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>


<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (PHOTOMETRIC_MINISBLACK), whilst you might find black being 1 (PHOTOMETRIC_MINISWHITE) more convenient. TIFF allows both (in the TIFFTAG_PHOTOMETRIC tag), so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in PHOTOMETRIC_MINISWHITE so we will convert images which are in PHOTOMETRIC_MINISBLACK.
</para>



<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>



<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>

</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>. The compression option is stored in the tag TIFFTAG_COMPRESSION.
</para>


<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>COMPRESSION</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>
Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.
</para>


<para>
Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.
</para>

<figure><title>The picture before we compressed it</title>
</figure>

<figure><title>The sample text before we compressed it</title>
</figure>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<figure><title>The picture after it has been recompressed 200 times</title>
</figure>

<figure><title>The text after it has been recompressed 200 times</title>
</figure>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>

</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>




<para>
You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.
</para>


<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>

</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>

</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>

</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>


<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>

<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>


</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>


<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>


<sidebar><title>An expanded example</title>
<para>If you need more information about hooking the file input and output functions within libtiff than this chapter allows, then have a look at the images.c file in Panda, my PDF library. The web pages for Panda can be found at http://www.stillhq.com
  <footnote><para>http://www.stillhq.com/cgi-bin/getpage?area=panda&lt;page=index.htm to be exact.</para></footnote>
.
</para>
</sidebar>

<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>



</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>


<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>


<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>



<figure><title>Four pictures of my son Andrew</title>
</figure>

</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
This example below demonstrates how to do this.
</para>



</sect1>

<sect1><title>Man pages</title>
<para>
I have included the man pages to some of the more useful libtiff commands, so that you have them for reference when you need them.
</para>

<sect2><title>tiff2bw</title>
</sect2>

<sect2><title>tiff2ps</title>
</sect2>


<sect2><title>tiffcmp</title>

<sect3><title>Sample output</title>
<para>
<command>tiffcmp</command> shows the differences in tags between images, for example, when I compare the input and output images from the pixel example in this chapter:
</para>

<programlisting>
[mikal@localhost tiff-pixels]$ tiffcmp input.tif output.tif 
ImageWidth: 256 520
[mikal@localhost tiff-pixels]$ 
</programlisting>
</sect3>
</sect2>

<sect2><title>tiffcp</title>
</sect2>


<sect2><title>tiffdither</title>

<sect3><title>Sample output</title>
<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<figure><title>The gray scale input image</title>
</figure>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<figure><title>The dithered output image</title>
</figure>
</sect3>
</sect2>

<sect2><title>tiffdump</title>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</sect3>
</sect2>

<sect2><title>tiffgt</title>
</sect2>

<sect2><title>tiffinfo</title>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</sect3>
</sect2>

<sect2><title>tiffmedian</title>
</sect2>

<sect2><title>tiffsplit</title>
</sect2>

<sect2><title>tiffsv</title>
</sect2>

<sect2><title>tifftopnm</title>
</sect2>
</sect1>









<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>


</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>


<sect2><title>A broken algorithm</title>

<para>
Which produces:
</para>

<figure><title>An average of the color values for each pixel</title>
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>

<para>
Which gives us:
</para>

<figure><title>A correct conversion to gray scale</title>
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>

<sect1><title>Example: Repeated compression</title>
<para>
Earlier in this chapter I promised that I would include the code for the repeated compression loss example, so here it is. The example is made up of a simple (and quite ugly) shell script, and a c program to actually compress the images...
</para>

</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed the TIFF file format, how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>

</sect1>

<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libtiff.org: The libtiff website is a good place to download the libtiff source. It is also quite likely there is a binary package for your chosen operating system.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: If all else fails, then the Adobe TIFF Specification can be useful.</para></listitem>

<listitem><para>http://gopher.std.com/homepages/jimf/xloadimage.html: The xloadimage web page might be of interest.</para></listitem>

<listitem><para>http://www.ee.cooper.edu/courses/course_pages/past_courses/EE458/TIFF/index.html: The Cooper Union for the Advancement of Science and Art has some notes from a previous course dealing with libtiff online.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/graphics/graphics.html: The Adobe Graphics technical notes page is quite useful.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: The current version of the TIFF specification can be found here.</para></listitem>

<listitem><para>http://home.earthlink.net/~ritter/tiff/: The unofficial TIFF site contains some useful resources.</para></listitem>

<listitem><para>http://www.inforamp.net/~poynton/notes/colour_and_gamma/ColorFAQ.html: a FAQ document discussion of converting to gray scale</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>Portions first published by IBM DeveloperWorks</title>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</sect1>
</chapter>
<chapter id="chap-gif"><title>GIF</title>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>

<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>







<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
</para>


<sidebar><title>Data streams?</title>
<para>
It should be noted that the GIF specification doesn't speak of files as such. Instead it uses the term <quote>Data Stream</quote>, which is a concept which embraces files, as well as in memory buffers, and other interesting forms of data storage. It doesn't really make any difference to the discussion of the format here though.
</para>
</sidebar>

<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>

</sect2>

<sect2><title>The header</title>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>


<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>


<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>

</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>


<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>


<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</para>


<sect3><title>Formula for global color table size</title>
<para>
To determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</emphasis>, or 255 items.
</para>


<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect3>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>


<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>


<sect3><title>Image descriptors</title>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>


<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
The packed field byte stores the following information:
</para>


<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>

</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>


<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>


<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>


<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>


<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>

</sect4>
</sect3>
</sect2>

<sect2><title>Special purpose blocks</title>
<para>
The other thing which can be stored in the data area of the data stream of a GIF file is special purpose blocks. These are outside the scope of this tutorial, and wont be discussed here.
</para>

</sect2>

<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>

</sect2>


<sect2><title>Interlaced images</title>
<para>
GIF supports the interlacing of images, which is where are the image is loaded, progressively better representations of the image are displayed. Discussing the inner workings of this within the file format is out of the scope of this tutorial however.
</para>

</sect2>
</sect1>


<sect1><title>Conclusion</title>
<para>
In this chapter we have learnt how the GIF format is laid out internally. This will be useful when it is time to dicsuss the PNG format...
</para>

</sect1>
</chapter>
<chapter id="chap-png"><title>PNG</title>
<para><quote>
A Turbo-Studly Image Format with Lossless Compression
(Not Related to Papua New Guinea, the Pawnee National Grassland,
the Professional Numismatists Guild or the ``Pack 'N' Go'' format)
</quote> -- libpng.org</para>

<para>
PNG
  <footnote><para>Short for Portable Network Graphics.</para></footnote>
is my favorite image format after TIFF. It is well conceived, well implemented, and very powerful. It also has some interesting features, mainly aimed at Internet use, which TIFF lacks. It is also usable in modern web browsers
  <footnote><para>For instance Netscape 4 and Internet Explorer 4 and later.</para></footnote>
, unlike TIFF. PNG is also much simpler in many respects than TIFF.
</para>

<para>
This chapter will focus on the libpng library. This isn't really a limitation, as the people behind libpng are also the people who write the PNG specification, so you're pretty safe in assuming that if it's useful and PNG does it, then libpng implements it.
</para>


<sect1><title>Introduction</title>
<para>
PNG happened because of the patent problems with the GIF format described in an earlier chapter of this tutorial. In the words of the official history of PNG:
</para>


<para>
<quote>
... Unisys in 1993 began aggressively pursuing commercial vendors of software-only LZW implementations. CompuServe seems to have been its primary target at first, culminating in an agreement--quietly announced on 28 December 1994, right in the middle of the Christmas holidays--to begin collecting royalties from authors of GIF-supporting software. The spit hit the fan on the Internet the following week; what was then the comp.graphics newsgroup went nuts, to use a technical term. As is the way of Usenet, much ire was directed at CompuServe for making the announcement, and then at Unisys once the details became a little clearer; but mixed in with the noise was the genesis of an informal Internet working group led by Thomas Boutell [2]. Its purpose was not only to design a replacement for the GIF format, but a successor to it: better, smaller, more extensible, and FREE.
</quote>
-- http://www.libpng.org/pub/png/pnghist.html
</para>


<para>
The PNG has gone from being a simple specification with limitations such as only supporting 8 bit images first announced on comp.graphics, comp.compression and comp.infosystems.www.providers, into a mature and extremely extensible image format.
</para>

<para>
Various versions of the PNG specification have been published as RFC-2083 and as a W3C Recommendation, which means that supporting the format is a lot easier because it is well defined.
</para>

<para>
A bunch of the examples in this chapter are based on the pngtools code I wrote a while ago, which I have updated as part of writing this chapter.
</para>

<sidebar><title>Refer to the TIFF chapter</title>
<para>
Much of the discussion in this chapter will make a whole bunch more sense if you've read the TIFF chapter. Off you go, I'll wait for you to come back...
</para>
</sidebar>
</sect1>

<sect1><title>Installation</title>
<para>
You can get the latest libpng code from http://www.libpng.org.
</para>

<sect2><title>Unix</title>
<para>
libpng doesn't have a configure script. You'll need to follow the steps below to get it to compile:
</para>

<itemizedlist>
<listitem><para>cp scripts/makefile.linux Makefile <emphasis>(You'll need to copy the Makefile that matches your architecture and operating system)</emphasis></para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>win32</title>
<para>
There are Makefiles for the win32 platform as well. I haven't verified how well they work however.
</para>
</sect2>
</sect1>

<sect1><title>The PNG on disc format</title>
<para>
It is useful to introduce the PNG file format as one of the first parts of this chapter, as it helps to see the advantages and disadvantages of the PNG format compared with the other formats that we will discuss during this tutorial.
</para>

<sect2><title>Byte order</title>
<para>
If you recall the TIFF format, multi byte values can either be little endian or big endian. This means that the libtiff library must perform byte swapping every time you read a value which takes more than one byte (which is most of the time). libpng doesn't have these problems, as all multi byte values are in network byte order (big endian).
</para>
</sect2>

<sect2><title>File header</title>
<para>
All PNG files start with a magic number (as have all the other formats which we have discussed in this tutorial). It looks something like:
</para>

<table frame='all'><title>PNG on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Decimal 137 <emphasis>No ASCII equivalent</emphasis></entry>
</row>

<row>
  <entry>1</entry>
  <entry>Decimal 80 <emphasis>P</emphasis></entry>
</row>

<row>
  <entry>2</entry>
  <entry>Decimal 78 <emphasis>N</emphasis></entry>
</row>

<row>
  <entry>3</entry>
  <entry>Decimal 71 <emphasis>G</emphasis></entry>
</row>

<row>
  <entry>4</entry>
  <entry>Decimal 13 <emphasis>Carriage return (\r)</emphasis></entry>
</row>

<row>
  <entry>5</entry>
  <entry>Decimal 10 <emphasis>Newline (\n)</emphasis></entry>
</row>

<row>
  <entry>6</entry>
  <entry>Decimal 26 <emphasis>No ASCII equivalent</emphasis></entry>
</row>

<row>
  <entry>7</entry>
  <entry>Decimal 10 <emphasis>Newline (\n)</emphasis></entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Chunk format</title>
<para>
Chunks map as a concept to the blocks that the GIF format used. The generic format for a PNG chunk is:
</para>

<table frame='all'><title>PNG on disc: chunk format</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 3</entry>
  <entry>Length of the data portion of this chunk (does not include the length field, the type field, or the CRC). The value is unsigned, and zero is a valid length. The maximum value is 2^32 - 1</entry>
</row>

<row>
  <entry>4 - 7</entry>
  <entry>Chunk type. Chunk types normally fall into the upper and lower case ASCII ranges. Software should treat this field as an unsigned value however. Chunk type naming conventions are discussed later in this chapter.</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Chunk data.</entry>
</row>

<row>
  <entry>(4 bytes at end of chunk)</entry>
  <entry>Cyclic Redundancy Check (CRC). The CRC covers the type and data fields, but not the length field. The CRC is always present, even if we have no data.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Chunk naming conventions</title>
<para>
The case used in chunk names has special significance. The table below describes the chunk name characters.
</para>

<table frame='all'><title>PNG on disc: chunk naming conventions</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Uppercase: critical. Lowercase: optional (known as ancillary). If a decoder encounters a critical chunk it does not understand, it will warn the user about possible incorrect decoding of the image.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Uppercase: public. Lowercase: private. A public chunk is either part of the PNG specification, or is published in the list of PNG public chunk types. Private chunks are developer specific, and should be ignored if not understood.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Uppercase: PNG 1.2 compliant. Lowercase: reserved for future use. For the time being, you should never see a third character which is lower case.</entry>
</row>

<row>
  <entry>3</entry>
  <entry>Uppercase: unsafe to copy. Lowercase: safe to copy. If the decoder doesn't understand the chunk, then should it be copied into new images? A chunk would be unsafe to copy if it relied on the image data which the decoder might have changed (including some critical chunks). An example of a safe to copy chunk might be a chunk which includes a MP3 sound recording from the time in which the image was encoded. An example of an unsafe to copy chunk might be an MD5 hash on the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>CRC algorithm</title>
<para>
The exact workings of the CRC algorithm are outside the scope of this tutorial...
</para>

</sect2>







<sect2><title>The IHDR chunk</title>
<para>
This is the image header chunk. This chunk <emphasis>must be first</emphasis> in the PNG file. This chunk contains the following fields:
</para>

<table frame='all'><title>PNG on disc: IHDR chunk fields</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 3</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>4 - 7</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>8</entry>
  <entry>Bit depth (not of bits per sample or palette index)</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Color type</entry>
</row>

<row>
  <entry>10</entry>
  <entry>Compression method (method zero is the only method currently defined)</entry>
</row>

<row>
  <entry>11</entry>
  <entry>Filter method (method zero is the only method currently defined)</entry>
</row>

<row>
  <entry>12</entry>
  <entry>Interlace method. The current options are: zero (no interlace) and one (adam7)</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are various values which are valid for the color type field. Each of these types has only certain byte depths allowed.
</para>

<table frame='all'><title>PNG on disc: IHDR chunk color types</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Color type: allowed bit depths</entry>
  <entry>Comments</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0: 1, 2, 4, 8, 16</entry>
  <entry>Each pixel is a gray scale sample</entry>
</row>

<row>
  <entry>1: not applicable</entry>
  <entry>Each pixel value is an index into a palette table</entry>
</row>

<row>
  <entry>2: 8, 16</entry>
  <entry>Each pixel has an red, green, and blue value</entry>
</row>

<row>
  <entry>3: 1, 2, 4, 8</entry>
  <entry>Each pixel is a palette index, and a PLTE chunk must appear in the PNG file</entry>
</row>

<row>
  <entry>4: 8, 16</entry>
  <entry>Each pixel is a gray scale sample, followed by an alpha channel</entry>
</row>

<row>
  <entry>6: 8, 16</entry>
  <entry>Each pixel is an red, green, blue, alpha set</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
For all of these types, the sample depth is the same as the bit depth, except for type three, where the sample depth is always eight bits.
</para>

<table frame='all'><title>PNG on disc: IHDR chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>

<sect3><title>Filtering algorithm</title>
<para>
The PNG specification states on page 16 of version 1.2:

<quote>
Filter method is a single-byte integer that indicates the preprocessing method applied to the image data be-fore compression. At present, only filter method 0 (adaptive filtering with five basic filter types) is defined. As with the compression method field, decoders must check this byte and report an error if it holds an unrec-ognized code. See Filter Algorithms (Chapter 6) for details.
</quote
</para>
</sect3>
</sect2>

<sect2><title>The PLTE chunk</title>
<para>
This chunks stores the palette information for the image. A palette contains 1 through 256 entries, and each entry consists of a red byte, green byte, and a blue byte. You don't need to have 256 entries in the palette -- the size of the palette is determined by dividing the chunk length by three. A chunk length which is not divisible by three is an error condition.
</para>

<table frame='all'><title>PNG on disc: PLTE chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The IDAT chunk</title>
<para>
The IDAT chunk contains the actual image data. This data will be the output of the selected compression method, and will need to be uncompressed before it is used.
</para>

<table frame='all'><title>PNG on disc: IDAT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The IEND chunk</title>
<para>
The IEND chunk must be the last chunk in the PNG file. It marks the end of the PNG file. The length of the data inside this chunk is zero.
</para>

<table frame='all'><title>PNG on disc: IEND chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Ancillary chunks</title>
<para>
Each ancillary chunk is only given a brief description below. Refer to the PNG specification for more information...
</para>
</sect2>

<sect2><title>The tRNS chunk</title>
<para>
Transparency information.
</para>

<table frame='all'><title>PNG on disc: tRNS chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The gAMA chunk</title>
<para>
Image gamma (pixel intensity) information.
</para>

<table frame='all'><title>PNG on disc: gAMA chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The cHRM chunk</title>
<para>
Chromacity information.
</para>

<table frame='all'><title>PNG on disc: cHRM chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sRGB chunk</title>
<para>
The image data conforms to the ICC RGB color space.
</para>

<table frame='all'><title>PNG on disc: sRGB chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The iCCP chunk</title>
<para>
Contains an embedded ICC profile.
</para>

<table frame='all'><title>PNG on disc: iCCP chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The iTXt chunk</title>
<para>
International textual data.
</para>

<table frame='all'><title>PNG on disc: iTXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The tEXt chunk</title>
<para>
Uncompressed text.
</para>

<table frame='all'><title>PNG on disc: tEXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The zTXt chunk</title>
<para>
Flate compressed text.
</para>

<table frame='all'><title>PNG on disc: zTXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The bKGD chunk</title>
<para>
Background color information.
</para>

<table frame='all'><title>PNG on disc: bKGD chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The pHYs chunk</title>
<para>
Pixel size information.
</para>

<table frame='all'><title>PNG on disc: pHYs chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sBIT chunk</title>
<para>
Stores the original number of significant bits.
</para>

<table frame='all'><title>PNG on disc: sBIT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sPLT chunk</title>
<para>
Suggested palette.
</para>

<table frame='all'><title>PNG on disc: sPLT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The hIST chunk</title>
<para>
Palette histogram.
</para>

<table frame='all'><title>PNG on disc: hIST chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The tIME chunk</title>
<para>
Time of last image modification.
</para>

<table frame='all'><title>PNG on disc: tIME chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>














</sect1>











<sect1><title>PNG should be easier than TIFF</title>
<para>
Unlike the TIFF format, which allows the creator of the image files to specify many different image options, PNG imposes rules such as that the images are big endian. Whilst this is less flexible for the creators of PNG files compared with TIFF, it does make it much easier to reliably decode a PNG image.
</para>
</sect1>












<sect1><title>Opening a PNG file</title>
<para>
The first step to learning how to use libpng is probably to understand how to open a PNG file and get some data out of it. Below is a minimal example of how to open a PNG file, not including actually reading the image data...
</para>


<para>
In this example, we do everything we need to open a PNG image, without actually reading the image data. The steps to getting to the image data are:
</para>

<itemizedlist>
<listitem><para>Open the file ready for reading. For this we just use the c standard library's <command>FILE *</command>, unlike the libtiff examples, in which we used a <command>TIFF *</command>
  <footnote><para>In reality, the libtiff could just use the <command>FILE *</command> method internally, although they don't always, as shown by the TIFFClientOpen examples in the TIFF chapter.</para></footnote>
</para></listitem>

<listitem><para>Another thing we need to do which libtiff does for us and libpng doesn't is check that the file really is a PNG file. We do this with the <command>png_check_sig</command>() call. This expects the first 8 bytes of the file to be handed to it, which is what the <command>fread</command>() function call gets for us.</para></listitem>

<listitem><para>We then start decompressing the image</para></listitem>

<listitem><para>The info struct gives us access to important information about the image</para></listitem>

<listitem><para>Then we read the IHDR chunk (see above for a description of this chunk)</para></listitem>
</itemizedlist>
</sect1>










<sect1><title>Example: pnginfo</title>
<para>
The <command>pnginfo</command> command implemented here is modeled on the <command>tiffinfo</command>, which was discussed in the TIFF chapter earlier in this tutorial. In fact, the output text is written to be as close to the <command>tiffinfo</command> command as possible.
</para>

</sect1>



<sect1><title>Reading a PNG image</title>
<para>
This example shows you how to read in the raster data that is embedded into the image file. libpng will also expand paletted raster information for you if you ask nicely...
</para>

</sect1>




<sect1><title>Writing a PNG image</title>
<para>
Writing a PNG file is <emphasis>very</emphasis> to reading the PNG file. The example below extends the code from above to open a PNG file, and then copy it to a new PNG file.
</para>

</sect1>

<sect1><title>Storing PNG data in places other than files</title>
<para>
This example below, much like the TIFFClient examples in the TIFF chapter shows how to use the libpng call backs to get to image data in places other than files. Note that it wont compile, but it does give you an example of the structure you need...
</para>

</sect1>






<sect1><title>Man pages</title>
<para>
To be honest, the libtiff man pages are much better than the documentation which comes with libpng. libpng has one main man page, which is included for ease of reference below.
</para>

<sect2><title>libpng</title>
</sect2>
</sect1>

<sect1><title>Conclusion</title>
<para>
This chapter hasn't been as complete as the TIFF chapter, for which I apologize. I have shown you all the important things about the PNG format though -- the layout of the images on disc, how to open and read an image, how to write an image, how to use the client call backs to save data in places other than files, and I have included the libpng documentation.
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libpng.org/pub/png/png.html: The libpng homepage.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pngintro.html: An introduction to PNG features.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pngfaq.html: The PNG FAQ.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pnghist.html: A history of PNG.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/spec/: Version 1.2 of the PNG specification.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/libpng.html: libpng download page</para></listitem>
</itemizedlist>
</para>
</sect1>

</chapter>

            <chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
In a sense this PDF chapter is the culmination of the tutorial... Many of the formats we have discussed up to this point can be included in some way in PDF files. I think that PDF is probably the most interesting imaging format in common use today.
</para>

<para>
This chapter is broken into two major sections. These are: a discussion of the PDF format, and then an introduction to Panda, a PDF generation API.
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 <9F><92><9C><9F>
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis><9F><92><9C><9F></emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a look up table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<sect4><title>Arrays</title>
<para>
An array is a one dimensional collection of other values. Unlike most programming languages, the contents of the array can be of several types, for instance we could mix integers with strings in a single array. Arrays start and end with square brackets.
</para>

<sect5><title>Examples</title>
<programlisting>
[(foo) (bar) 42.3 /AName]
</programlisting>
</sect5>
</sect4>
<sect4><title>Boolean</title>
<para>
Boolean values are represented with the words <command>true</command> and <command>false</command>.
</para>

<sect5><title>Examples</title>
<programlisting>
/ExplodeOnOpening true
/Rotate false
</programlisting>
</sect5>
</sect4>
<sect4><title>Names</title>
<para>
A name is a sequence of characters not including whitespace which follow a forward slash. Names are used in object dictionaries for the names of keys, and for some values of keys.
</para>

<sect5><title>Examples</title>
<programlisting>
</programlisting>
</sect5>
</sect4>
<sect4><title>Numbers</title>
<para>
Known as numeric types in the PDF specification (for somewhat obvious reasons), this includes all forms of numbers. These can either be integer or real
  <footnote><para>Non integer</para></footnote>
numbers.
</para>

<sect5><title>Integers</title>
<para>
Integer numbers can be either positive or negative (with a leading sign value if needed) and have a maximum value of ... and a minimum value of ... .

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
123
43445
+176
-17
0
</programlisting>
</sect5>

<sect5><title>Real numbers</title>
<para>
Real numbers can exist in the range ... to ..., and may or may not have leading zeros.

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
34.5
-3.62
+123.5
4.
-.002
0.0
</programlisting>
</sect5>

<sect5><title>Caveats</title>
<para>
The PDF specification makes the following point:

<quote>PDF does not support the PostScript syntax for numbers with non-decimal radices (such as 16#FFFE) or in exponent format (such as 6.02E23).</quote>
  <footnote><para>PDF Specification 1.3, second edition, page 27</para></footnote>
</para>
</sect5>
</sect4>
<sect4><title>Strings</title>
<para>
Strings are represented a series of unsigned bytes
  <footnote><para>That is, in the range 0 to 255.</para></footnote>
which is identical to the ASCII strings most programmers are familar with in C. There are two main representations of strings. These are:
</para>

<sect5><title>Bracket notation</title>
<para>
Strings can be wrapped in curved brackets such as () to delimit the start and end of the string. Strings may also contain brackets, so long as they are balanced or escaped with a backslash.
</para>

<para>
These are known as literal strings in the PDF specification.
</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
(hello)
(hello world)
(hello world \(the people I like\))
(hello world (the people I like))
</programlisting>
</sect5>

<sect5><title>Escaped characters</title>
<para>
There are a series of standard characters which are used with the backslash escape. These are:
</para>

<itemizedlist>
<listitem><para><emphasis>\n</emphasis>: Newline</para></listitem>
<listitem><para><emphasis>\r</emphasis>: Carriage return</para></listitem>
<listitem><para><emphasis>\t</emphasis>: Tab</para></listitem>
<listitem><para><emphasis>\b</emphasis>: Backspace</para></listitem>
<listitem><para><emphasis>\f</emphasis>: Form feed</para></listitem>
<listitem><para><emphasis>\(</emphasis>: Open bracket</para></listitem>
<listitem><para><emphasis>\)</emphasis>: Close bracket</para></listitem>
<listitem><para><emphasis>\\</emphasis>: Backslash</para></listitem>
<listitem><para><emphasis>\ddd</emphasis>: Arbitary character (ddd is a number in octal)</para></listitem>
</itemizedlist>

<para>
The backslash operator can also be used to continue text on the next line. For instance:
</para>

<programlisting>
(This is a very long string which we want to \
break over a couple of lines.)
</programlisting>

<para>
This means that we can also embed newlines without using the escape. For instance, these two text blocks are the same:
</para>

<programlisting>
(This is a 
string \
with some lines)
</programlisting>

<para>
and
</para>

<programlisting>
(This is a\nstring with some lines)
</programlisting>

<para>
More on strings in this notation can be found in the PDF specification, version 1.3, on page 30.
</para>
</sect5>

<sect5><title>Hexadecimal notation</title>
<para>
Strings can also be written in hexadecimal form, and in this case are enclosed in angle brackets.
</para>
</sect5>

<sect5><title>Examples</title>
<para>
An example of a hexidecimal string is:
</para>

<programlisting>
&lt;4E6F762073686D6F7A206B6120706F702E&gt;
</programlisting>

<para>
If the final digit is missing, then it is assumed to be zero. For instance, the following string:
</para>

<programlisting>
&lt;901FA&gt;
</programlisting>

<para>
Is the same as:
</para>

<programlisting>
&lt;901FA0&gt;
</programlisting>
</sect5>

</sect4>


<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 


The other type of information which can be stored in a stream is arbitrary information such as the content of images (which would normally be raster information). 


An in depth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<sect4><title>ASCII85Decode</title>
<para>
The ASCII85 filter takes binary data, and turns it into base 85 representation. This is needed by some email clients (among other things), because they can't handle embedding binary data into their protocols.
</para>

<para>
The <emphasis>comp.text.pdf frequently asked questions</emphasis> refers to the code examples below by way of explaination:
</para>



<para>
These two code snippets were written by Paul Haahr, http://www.webcom.com/~haahr/, and is stated to be in the public domain.
</para>

</sect4>
<sect4><title>ASCIIHexDecode</title>
<para>
For similar reasons to ASCII85, you can also represent your binary data as hexidecimal. This filter implements this.
</para>

</sect4>
<sect4><title>CCITTFaxDecode</title>
<para>
This is the compression codec known as group3 and group 4 fax in TIFF. It is about as good as compression gets for black and white images.
</para>

</sect4>
<sect4><title>DCTDecode</title>
<para>
DCT (Descrete Cosine Transform) is the compression codec used by JPEG images. As discussed elsewhere in this document, it is good for color images, but is lossy.
</para>

</sect4>
<sect4><title>FlateDecode</title>
<para>
Flate compression (which is implemented by zlib), is the compression codec using in PNG images. It is very good for colour image and textual data.
</para>

</sect4>
<sect4><title>LZWDecode</title>
<para>
LZW is the compression codec used by GIF images. No publically available libraries implement LZW compression, and it is recommended you don't use it as many Acrobat viewers don't implement LZW decompression. Even Adobe's own products stear away from using this filter.
</para>

</sect4>
<sect4><title>RunLengthDecode</title>
<para>
Run length compression is a very simple compression codec, and it not recommended for most purposes.
</para>
</sect4>


</sect3>
</sect2>

<sect2><title>Object structure</title>
<para>
The diagram below shows the basic object structure of a PDF document. It can be much more complex than this, especially if you reuse commonly used objects like the logo which is on every page of the document. In words, the structure is something like:
</para>

<sect3><title>Catalog Object</title>
<para>
Every PDF document has a catalog object. This catalog object refers to a pages object.
</para>
</sect3>

<sect3><title>Pages object</title>
<para>
The pages object stores a list of pages within the PDF document, in the form of a dictionary array with the key name <quote>/Kids</quote>. Each of these pages will have an object.
</para>
</sect3>

<sect3><title>A Page object per page</title>
<para>
Each page object will have a content object.
</para>
</sect3>

<sect3><title>Content objects</title>
<para>
Each content object will refer to the pages object, as well as referring to resources that that needed to draw this page. The resources can be used by other contents objects as well. Resources are things like fonts, and images.
</para>

<para>
A postscript-like description of the layout of the page is stored in this object's stream.
</para>
</sect3>

<sect3><title>Resources</title>
<para>
A resources object stores information you need to be able to use a given resource such as a font or image.
</para>

<para>
If the resource is an image or an embedded font, then the additional binary data (such as a raster) is stored in this objects stream.
</para>
</sect3>

<sect3><title>Typical object structure</title>
<figure><title>A typical PDF object structure</title>
</figure>
</sect3>
</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft Power Point presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>


<para>
Which produces...
</para>

<figure>
<title></title>
<graphic format="eps" fileref="gen-todo.eps">
</figure>
</sect2>

<sect2><title>Initialization</title>
<para>
Initialization of Panda is easy. Simply call <command>panda_init</command>(). You'll also need to create a PDF document, which is done with the <command>panda_open</command> function.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_init</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_init</refname>
<refpurpose>setup Panda ready for use</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_init (void);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Performs some simple setup of Panda before it is used for the first time in your application.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_init();
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_open</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_open</refname>
<refpurpose>open a PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_pdf * panda_open (char *filename, char *mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Open the named PDF document with the mode specified. The only mode currently supported is "w", but others will be integrated later. The interface to this function is identical in it's behaviour to the <command>fopen</command>() function call offered by the ANSI C standard IO library.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to a panda_pdf structure</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_init, panda_open_actual, panda_open_suppress, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Creating pages</title>
<para>
Pages are created in Panda using the <command>panda_newpage</command> function. You can magically be editing as many pages at a time as you like with Panda without any additional calls being needed.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_newpage</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newpage</refname>
<refpurpose>create a new page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_page *panda_newpage(panda_pdf *document, char *pagesize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Create a new blank page at the end of the PDF with the specified size. Use the standard pagesize strings that are defined by Panda for most things. These are <command>panda_pagesize_a4</command>, and <command>panda_pagesize_usletter</command>. If you need to create your own page sizes, then have a look at these for hints.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Object properties</title>
<para>
Panda allows you to selectively apply properties to portions of your PDF document. The most common example is choosing which portions of your PDF document to compress.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_setobjectproperty</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setobjectproperty</refname>
<refpurpose>set a property value for an object</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setobjectproperty (panda_object *target, int scope, int propid, int propval);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Properties are a way of specifing things about objects. These properties can have either a cascade scope (they affect all subsequently created objects that are children of that object) -- <command>panda_scope_cascade</command>, or local (they only occur for that object) -- <command>panda_scope_local</command>. Possible properties are defined in the <command>panda_const_properties</command> manual page.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>None</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_object *obj;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 obj = panda_newobject(document, panda_object_normal);
 panda_setproperty(obj, panda_scope_cascade, panda_object_property_compress, panda_true);
 
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newobject, panda_const_properties</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Finalizing</title>
<para>
Pages don't need to be closed in Panda. This is done when the <command>panda_close</command> function is called. This function writes the entire PDF document out to disc.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_close</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_close</refname>
<refpurpose>write a PDF document out to disk</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_close (panda_pdf *document);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Write out the PDF document we have created to disk, clean up and free memory.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_close(document);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Inserting text</title>
<para>
One of the advantages which ClibPDF has over Panda is that it currently supported word wrap, whereas Panda doesn't. Panda does have a variety of text functionality however. The public text functions in Panda are: <command>panda_textboxrot</command>, which creates a text box at a jaunty angle, <command>panda_textbox</command>, which creates a horizontal textbox (a zero angle), and <command>panda_textdirection</command>, which sets the flow direction for text.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_textbox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textbox</refname>
<refpurpose>display some text on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textbox (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textboxrot</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_textboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textboxrot</refname>
<refpurpose>display some text at a jaunty angle on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, double angle, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The text is displayed at the spefied angle. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textboxrot (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, 33.0, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textbox</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_textdirection</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textdirection</refname>
<refpurpose>specify the direction that the text flows within the document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textdirection (panda_pdf *document, int dir);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the direction that the text in the document flows in. The possible values for the dir arguement are: <command>panda_textdirection_l2r</command>, text is read left to right; <command>panda_textdirection_r2l</command>, text is read right to left. The default for this value is <command>panda_textdirection_l2r</command>.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_textdirection(document, panda_textdirection_r2l);
</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Fonts</title>
<para>
Panda currently only supports the standard PDF fonts, and will not allow you to embed arbitrary fonts into your PDF documents (unlike PDFlib). Some users might find this a little limiting for the time being. In Panda, you use fonts by first creating a pointer to the font using <command>panda_createfont</command>, and then start using that font with <command>panda_setfont</command>. This allows you use efficiently create the five fonts you are going to use in the document, and then swap backwards and forwards within that set of five with no performance penalty.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_createfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_createfont</refname>
<refpurpose>return a handle to the requested font</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 char * panda_createfont (panda_pdf * output, char *fontname, int type, char *encoding)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para><command>PANDA INTERNAL</command>. This funtion call creates a font object for the requested font and returns the identifier that should be used when the font is set within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A font identifier (handle) as a null terminated string.</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 fonthandle = (output, "Helventica", 3, "MacRomanEncoding");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfont</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfont</refname>
<refpurpose>set the current font to be that specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfont (char *fontident);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Once you have generated a font identifier for a given font, you can then set that current font to that font using this call. Create a font identifier with the <command>panda_createfont</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open ("output.pdf", "w");
 fonthandle = panda_createfont (output, "Helventica", 3, "MacRomanEncoding");
 panda_setfont (fonthandle);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Font attributes</title>
<para>
Panda also allows you to set a variety of font attributes...
</para>

<refentry>
<refmeta>
<refentrytitle>panda_setcharacterspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setcharacterspacing</refname>
<refpurpose>set the space between characters</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setcharacterspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between characters in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setcharacterspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setwordspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setfillcolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfillcolor</refname>
<refpurpose>set the color to fill a close shape with</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfillcolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the color to fill a close shape with when the shape is closed. It is expressed as a combinartion of red, green, and blue. The maximum number for each value is 255 (a number greater than 255 is reduced to 255).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setfillcolor (page, 100, 200, 300);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 300);
 panda_closeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setfontmode</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontmode</refname>
<refpurpose>set the current font mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontmode (panda_page *target, int mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the drawing mode for the current font. Valid modes are: panda_textmode_normal, panda_textmode_outline, panda_textmode_filledoutline, panda_textmode_invisible, panda_textmode_filledclipped, panda_textmode_strokedclipped, panda_textmode_filledstrokedclipped and panda_textmode_clipped.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setfontmode(output, panda_textmode_outline);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontsize, panda_setfont</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setfontsize</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontsize</refname>
<refpurpose>set the current font size</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontsize (panda_page *target, int size);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the size of the font to be used next (in points).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 setfontsize(output, 42);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontmode, panda_setfont</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_sethorizontalscaling</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_sethorizontalscaling</refname>
<refpurpose>set the horizontal scaling of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_sethorizontalscaling (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the horizontal scaling factor of the text in percent.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_sethorizontalscaling(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_setleading</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setleading</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setleading</refname>
<refpurpose>set the amount of space between lines of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setleading (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of space between lines of text in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setleading(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setwordspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setwordspacing</refname>
<refpurpose>set the space between words</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setwordspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between words in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setwordspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Inserting raster images</title>
<para>
Panda probably has the best raster image support of any of the PDF libraries available (not including Adobe's libraries). This is because this is my main area of expertise, and has been the main focus of the Panda development effort. For example ClibPDF only supports TIFF images in a limited set of formats, whereas I am not aware of any TIFF files which cannot be inserting into a PDF with Panda. Panda also never creates temporary files on disc when it needs to convert between TIFF formats, unlike PDFlib.
</para>

<sect3><title>TIFF support</title>
<para>
Panda support TIFF fully.
</para>
</sect3>

<sect3><title>JPEG support</title>
<para>
Panda supports JPEG fully.
</para>
</sect3>

<sect3><title>PNG support</title>
<para>
Panda supports PNG fully.
</para>
</sect3>

<sect3><title>Inserting images onto pages</title>
<para>
In Panda you use the <command>panda_imagebox</command>, and the <command>panda_imageboxrot</command> functions to insert images.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_imagebox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imagebox</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imagebox (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location using a reasonable default for rotation (none). This call is included for backward compatability withprevious releases of the API and it is recommened that new code call <command>panda_imageboxrot</command>(). It is unlikely that this call will be retired however. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imageboxrot</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_imageboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imageboxrot</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imageboxrot (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, double angle, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location, including the ability to rotate the image on the page. It should be noted that xpdf will sometimes make the rotated image look quite sickly. This is in fact a bug in xpdf (which has beenr eported), and not a bug in <command>Panda</command>. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, 45.0, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imagebox</para>
</refsect1>

</refentry>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>
Panda, supports the full range of PDF vector graphics commands. See the sections below for a description of the functionality available.
</para>

<sect3><title>Lines</title>
<para>
With Panda, the way you draw a line is to first create a line with <command>panda_setlinestart</command>, you then draw line segments with <command>panda_addlinesegment</command>. When you're finished, you close the line with <command>panda_closeline</command>. <command>panda_strokeline</command> is used to force the line to be drawn. You can also add curved segments to a line using <command>panda_addcubiccurvesegment</command>, <command>panda_addquadraticcurvesegmentone</command>, and <command>panda_addquadraticcurvesegmenttwo</command>. Finally, if all you want is a rectangle, then use <command>panda_rectangle</command> to do it for you.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_setlinestart</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinestart</refname>
<refpurpose>sets the starting point of a curve</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinestart (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the starting point for the sequence of curves and lines that it to be drawn on the current page. This call is compulsory for almost all of the line drawing functions. It is not required for the <command>panda_rectangle</command> call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_addlinesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addlinesegment</refname>
<refpurpose>add a straight segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addlinesegment (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a straight line between the current cursor location and (x,y).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_closeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_closeline</refname>
<refpurpose>close off the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_closeline(panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Close the line shape we are drawing by returning to the starting point as set by <command>panda_setlinestart</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 400, 300);
 panda_closeline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_endline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_endline</refname>
<refpurpose>finalise the current line shape</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_endline( panda_page *target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Finalise the line shape we are drawing. Only one line shape may be drawn at any one time. There is no need for this call with the <command>panda_rectangle</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_strokeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_strokeline</refname>
<refpurpose>stroke the line shape we have just drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_strokeline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function must be called for the line shape that we have drawn to actually display on the PDF page. This process is known as 'stroking', and hence the name of this function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_strokeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry>
<refmeta>
<refentrytitle>panda_addcubiccurvesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addcubiccurvesegment</refname>
<refpurpose>add a curved segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addcubiccurvesegment (panda_page * target, int x, int y, int cx1, int cy1, int cx2, int cy2);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a cubic curve between the current cursor location and (x,y). There are two control points used to generate the cubic curve. They are (cx1, cy1) and (cx2, cy2).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (currPage, 210, 210);
 panda_addcubiccurvesegment (currPage, 310, 210, 225, 300, 275, 400);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmentone</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmentone</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmentone (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmenttwo</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmentone (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmenttwo</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmenttwo</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmenttwo (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmentone</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmenttwo (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry>
<refmeta>
<refentrytitle>panda_rectangle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_rectangle</refname>
<refpurpose>draw a rectangle</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_rectangle (panda_page * target, int top, int left, int bottom, int right);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Draw a rectangle on the PDF page. There is no need for the <command>panda_setlinestart</command>() or <command>panda_closeline</command>() calls.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_rectangle( page, 10, 10, 150, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
</sect3>

<sect3><title>Fills and other line attributes</title>
<para>
Once you have drawn a line, then it can be filled. You can also configure the state of the pen <emphasis>before</emphasis> you draw the line to change the way it appears...
</para>

<refentry>
<refmeta>
<refentrytitle>panda_fillline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fillline</refname>
<refpurpose>fill the closed shape we just drew</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fillline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Fill the shape we have just drawn with the previously defined fill.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 250);
 panda_endline (page);
 panda_fillline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setlinecap</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecap</refname>
<refpurpose>sets the line cap for the lines we are drawing now</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecap ( panda_page *target, int cap);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line cap is used at the ends of lines that do not meet other lines. The different cap styles are defined in panda/constants.h and are: panda_linecap_butt, panda_linecap_round and panda_linecap_projectedsquare.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecap (page, panda_linecap_round);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setlinecolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecolor</refname>
<refpurpose>change the color of the line drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the color of lines being drawn using a combination of red, green and blue.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecolor (page, 100, 200, 450);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setlinejoin</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinejoin</refname>
<refpurpose>is used to set the line join style</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinejoin (panda_page *target, int join);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line join is used where the ends of two lines meet. The valid line joins are defined in panda/constants.h and are: panda_linejoin_miter, panda_linejoin_round and panda_linejoin_bevel.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinejoin (page, panda_linejoin_bevel);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setlinewidth</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinewidth</refname>
<refpurpose>sets the width of the line that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinewidth (panda_page * target, int width);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the width of the line that is being drawn... You can use <command>panda_setlinecap</command>(), <command>panda_setlinejoin</command>() and <command>panda_setlinedash</command>() to change other characteristics of the line.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinewidth (page, 42);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setlinedashing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinedashing</refname>
<refpurpose>draw the subsequent lines with the defined dashing pattern</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinedashing (panda_page *target, int on, int off, int pahse);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function allows the user to define a line dashing style, which is then applied to subsequent lines drawn on that page. The dashing style is defined as a on and off number, as well as a phase. For example, on = 2, off = 4, phase = 0 should result in a line like:</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinedash (page, 2, 4, 0);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

</sect3>
</sect2>

<sect2><title>Document meta data</title>
<para>
PDF supports embedding meta data about a document into the PDF itself, and Panda supports this through the following calls:
</para>

<refentry>
<refmeta>
<refentrytitle>panda_setauthor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setauthor</refname>
<refpurpose>set the author string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setauthor (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the author within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setauthor(document, "Mikal");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_settitle, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setkeywords</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setkeywords</refname>
<refpurpose>set the keywords string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setkeywords (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the keywords string within the PDF document. The string is merely a list of keywords in the form "cats dogs hamsters chickens"</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setkeywords(document, "panda documentation pdf api generate");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setsubject, panda_setid</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_setsubject</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setsubject</refname>
<refpurpose>set the subject string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setsubject (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the subject within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setsubject(document, "Mikal's homework");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_settitle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_settitle</refname>
<refpurpose>set the title string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_settitle (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the title within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_settitle(document, "Mikal's excellent PDF document");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_setauthor, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Presentation support</title>
<para>
PDF can be used for presentations, and therefore allows you to specify a number of interesting things which are normally associated more with Microsoft Power Point presentations...
</para>

<refentry>
<refmeta>
<refentrytitle>panda_centerwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_centerwindow</refname>
<refpurpose>ask the viewer to center the document's window on the screen when the PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_centerwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application center the displayed PDF document on the screen when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not center the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_centerwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_fitwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fitwindow</refname>
<refpurpose>ask the viewer to fit the viewer window to the first page of the PDF document when it is opened</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fitwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application fit the display window to the first page of the PDF document when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not fit the document to the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fitwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_fullscreen</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fullscreen</refname>
<refpurpose>ask the viewer to display the PDF document in fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fullscreen (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application display the document in full screen mode. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not display the PDF in fullscreen mode.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fullscreen(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_hidemenubar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidemenubar</refname>
<refpurpose>ask the viewer to hide it's menu bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidemenubar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's menu bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the menu bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidemenubar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_hidetoolbar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidetoolbar</refname>
<refpurpose>ask the viewer to hide it's tool bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidetoolbar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's tool bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the tool bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidetoolbar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_hidewindowui</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidewindowui</refname>
<refpurpose>ask the viewer to hide it's display window user interface when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidewindowui (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's window user interface not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to display the user interface.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidewindowui(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_nfspagemodde</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_nfspagemodde</refname>
<refpurpose>defines display characteristics for the PDF document if it is using non fullscreen mode after defaulting to fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_nfspagemode (panda_pdf *document, int pagemode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>If the document in question is using fullscreen mode and then exits from fullscreen mode, then this function configures the behaviour of several of the 'eye candy' options available in some viewers. The possible values for pagemode are: <command>panda_window_usenone</command>, which displays neither the outline or thumbnails (if present); <command>panda_window_useoutlines</command>, which displays only the outline for the document; <command>panda_window_usethumbs</command>, which only displays thumbnails. <command>Please note that this function will only have an effect on the viewer if the page mode has been set to fullscreen with the panda_fullscreen() function call</command></para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_nfspagemode(document, panda_window_usenone);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_fullscreen</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_pageduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_pageduration</refname>
<refpurpose>specify the maximum number of seconds that a page should be displayed by the viewer before moving on</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_pageduration (panda_page *target, int seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page should be displayed within the viewer. This is useful for presentations and the like where you might like to automatically move onto the next page in the document at some point. The default value for this is to never move onto the next page automatically. If this value is changed from the default, there is currently no way to revert back to the default later. The feature may not be implemented by all viewers.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_pageduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_transduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transduration</refname>
<refpurpose>specify the number of seconds that a page transition effect should take to occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transduration (panda_page *target, double seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page transition effect should be displayed within the viewer. This is useful for presentations and the like when you realise that you are addicted to Microsoft Powerpoint...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_transstyle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transstyle</refname>
<refpurpose>specify the type of page change transition that should occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transstyle (panda_page *target, int style);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para> his function records information within the PDF indicating the preferred page transition style to use. The following are valid styles to use:
 <orderedlist>
 <listitem><para>panda_pagetrans_split_yi -- vertical split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_yo -- vertical split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xi -- horizontal split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xo -- horizontal split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_blinds_y -- vertical blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_blinds_x -- horizontal blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_box_i -- box expanding from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_box_o -- box contracting from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_wipe_0 -- a single line wipes the page away from the left to the right</para></listitem>
 <listitem><para>panda_pagetrans_wipe_90 -- a single line wipes the page away from the bottom to the top</para></listitem>
 <listitem><para>panda_pagetrans_wipe_180 -- a single line wipes the page away from the right to the left</para></listitem>
 <listitem><para>panda_pagetrans_wipe_270 -- a single line wipes the page away from the top to the bottom</para></listitem>
 <listitem><para>panda_pagetrans_dissolve -- the old page dissolves slowly into the new page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_0 -- a glitter effect that moves from the left to the right of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_270 -- a glitter effect that moves from the top to the bottom of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_315 -- a glitter effect that moves from the top left to the bottom right of the page</para></listitem>
 <listitem><para>panda_pagetrans_none -- no transition effect</para></listitem>
 </orderedlist>
 
 </para>
 <para>
 he default transition is to have no transition at all. It should be noted that not all viewers support these transition effects.
</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Page templates</title>
<para>
A page template is created using <command>panda_newtemplate</command>. A template is just like any other page, and uses all the normal drawing functions. The cool bit is that you can then apply a template to another page using <command>panda_applytemplate</command>. This allows for the standard parts of the page to only be defined once -- which is very useful for things like letterhead.
</para>

<refentry>
<refmeta>
<refentrytitle>panda_newtemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newtemplate</refname>
<refpurpose>create a template page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_newtemplate(panda_pdf *document, char *pageSize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to create 'template' pages which can then be refered to on other pages. For instance, if you were creating a document that used a standard letter head, then it would make sense to construct the letterhead as a template, and then use this on all the pages. The created template looks and feels just like any other page in the document for the purposes of creating content. Refer to the <command>panda_newpage</command> man page for details on how to use pages.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to the template page</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_applytemplate</para>
</refsect1>

</refentry>
<refentry>
<refmeta>
<refentrytitle>panda_applytemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_applytemplate</refname>
<refpurpose>use a template page previously created</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_applytemplate (panda_pdf * output, panda_page * target,
 panda_page * template)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to use a template created with the <command>panda_newtemplate</command> function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage, *realpage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
 realpage = panda_newpage (document, panda_pagesize_a4);
 
 ... the order of the drawing commands to the two pages doesn't matter ...
 
 panda_applytemplate(document, realpage, templatepage);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_newtemplate</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>A full Panda example</title>
<para>
This section presents a full Panda example showing what the library is capable of. This code comes from the Panda distribution:
</para>


<para>
It produces output like:
</para>

<figure>
<title>~mikal/opensource/panda/examples/output.pdf</title>
<graphic format="eps" fileref="gen-todo.eps">
</figure>
</sect2>

</sect1>




























<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
</sect2>

<sect2><title>pandalex.h</title>
</sect2>

<sect2><title>parser.y</title>
</sect2>

<sect2><title>samples.c</title>
</sect2>

<sect2><title>samples.h</title>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we have discussed the inner workings of the PDF format, which is quite different to the other formats we have discussed in this document. We have also examined Panda, and seen how to use it to generate our PDF documents.
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the two libraries discussed here).</para></listitem>
<listitem><para>http://www.stillhq.com: has the comp.text.pdf frequently asked questions, as well as the Panda pages.</para></listitem>
</itemizedlist>
</sect1>

</chapter>
    <chapter id="chap-imagemagick"><title>Imagemagick</title>
<para>
There are also a few topics which are important enough to be mentioned here, but haven't found their way into the discussions in any other place. They therefore get a chapter of their own here at the end.
</para>

<figure>
<title>Better intro</title>
<graphic format="eps" fileref="gen-todo.eps">
</figure>

<sect1><title>Obtaining and building</title>
<para>
Available from: xxx
Installation steps; ./configure; make; make install
</para>

<figure>
<title>Better install</title>
<graphic format="eps" fileref="gen-todo.eps">
</figure>

<para>
<figure>
<title>I'm only really talking about convert here -- what about the others?</title>
<graphic format="eps" fileref="gen-todo.eps">
</figure>
</para>
</sect1>

<sect1><title>How imagemagick works</title>
<para>Imagemagick is implemented as a wrapper around a bunch of different imaging libraries, including libtiff and libpng. In imagemagick terminology, these are called delegates. This is own of the reasons that imagemagick is not as fast as a custom application would be, it has to be written in a generic manner which can deal with the different ways that these libraries represent image data.</para>
</sect1>

<sect1><title>Generating thumb nails</title>
<para>The first thing I needed to do with my picture collection was to generate thumb nails. I also wanted to reduce the size of the images for the web site version, as many people don't really want to see a 1920 by 1440 picture of my sons.</para>

<para>The tool I use to do this is called <emphasis>convert</emphasis>, which is part of the imagemagick suite. <emphasis>Convert</emphasis> is really cool. It doesn't just do image resizing. It also anti aliases, averages a set of images, blurs, converts between image formats, crops, despeckles, dithers, draw borders, flips, joins, re-samples, resizes, and much more. Checkout the man page for more information on it's various command line options. Many of the more visually interesting effects offered by <emphasis>convert</emphasis> are also discussed later in this article.</para>

<para>Let's assume I want to make a thumbnail of this rather nice image of a rose:</para>

	

<graphic format="eps" fileref="gen-rose.eps">


<para>To resize the image with convert, just use the -sample command line option. For example, let's say that I want thumb nails to be 80x40 pixels. The command line would be:</para>


<programlisting>
convert -sample 80x40 input.jpg output.jpg
</programlisting>

<para>This produces a thumbnail which looks like:</para>

	

<graphic format="eps" fileref="gen-convert-sample-8040.eps">


<para>Imagemagick will automatically respect the ratio created by the two sides of the image when it is resizing. This means that the aspect ratio of the new image will be the same as that of the previous image. In the example above, this means that the resized image is actually 53 by 40, instead of the requested 80 by 40.  Another way of specifying the size of the output image is to use percentages. This can be convenient if you're not sure of the size of the input image, or if you're not concerned with having the new image be an exact size. An example of how to use percentages is:</para>


<programlisting>
convert -sample 25%x25% input.jpg output.jpg
</programlisting>

<para>Now we have a thumbnail which looks like:</para>

	

<graphic format="eps" fileref="gen-convert-sample-25pct.eps">


<para>This can be used on the command line to generate thumb nails for images within a directory. Whilst this article isn't about shell scripting, I'll quickly show you an example of how to generate a thumbnail of each JPEG in the current directory.</para>


<programlisting>
for img in `ls *.jpg`
do
  convert -sample 25%x25% $img thumb-$img
done
</programlisting>

<para>This will produce a series of thumb nails 25% the size of the real image, with a filename which is the name of the JPEG file with a <emphasis>thumb-</emphasis> prepended.</para>














</sect1>
<sect1><title>Getting information about an image file</title>

<para>Another example of something which people commonly need to do is to determine the dimensions of an image file. This might be in order to determine how big to make the thumbnail from the previous example, or any other reason you can think of.</para>

<para>Many imaging libraries come with excellent tools for this sort of purpose. For example, libtiff ships with <emphasis>tiffinfo</emphasis>, which display the following sort of information about TIFF files:</para>


<programlisting>
deathstar:/home/mikal# tiffinfo output.tif
TIFF Directory at offset 0x146
  Image Width: 352 Image Length: 288
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: RGB color
  Samples/Pixel: 3
  Planar Configuration: single image plane
</programlisting>

<para>This isn't an exhaustive example of how to use <emphasis>tiffinfo</emphasis>, but you can see that it returns useful information such as the size of the image, the pixel depth (a combination of the number of bits per sample, and the number of samples per pixel), and the compression scheme used.</para>

<para>Similarly, there is a <emphasis>pnginfo</emphasis> command which returns similar information for PNG files:</para>


<programlisting>
deathstar:/home/mikal# pnginfo sample.png 
sample.png...
  Image Width: 640 Image Length: 480
  Bitdepth (Bits/Sample): 8
  Channels (Samples/Pixel): 3
  Pixel depth (Pixel Depth): 24
  Colour Type (Photometric Interpretation): RGB 
  Image filter: Single row per byte filter 
  Interlacing: No interlacing 
  Compression Scheme: Deflate method 8, 32k window
  Resolution: 0, 0 (unit unknown)
  FillOrder: msb-to-lsb
  Byte Order: Network (Big Endian)
  Number of text strings: 0 of 0
</programlisting>

<sidebar>
<title>pnginfo?</title>
<para>I had been a user of libtiff for quite some time when I started using PNG. At the time, there was no <emphasis>tiffinfo</emphasis> equivalent for PNG files, which is why I wrote <emphasis>pnginfo</emphasis>. <emphasis>pnginfo</emphasis> can be downloaded from the URL at the end of this article.</para> 
</sidebar>

<para>I am not aware of equivalent individual tools for other formats such as BMP, GIF and JPEG. However, here imagemagick comes to the rescue once more, this time with a tool called <emphasis>identify</emphasis>.</para>


<programlisting>
deathstar:/home/mikal# identify -verbose sample.png 
Image: sample.png
  Format: PNG (Portable Network Graphics)
  Geometry: 640x480
  Class: DirectClass
  Type: true color
  Depth: 8 bits-per-pixel component
  Colors: 142360
  Filesize: 555.6k
  Interlace: None
  Background Color: grey100
  Border Color: #DFDFDF
  Matte Color: grey74
  Dispose: Undefined
  Iterations: 0
  Compression: Zip
  signature: 361fe70ae623ef6f1fca44e0d29d157c2d701039fcf0f8625862925d881e13a4
  Tainted: False
  User Time: 0.190u
  Elapsed Time: 0:01
</programlisting>

<para>You can see from this example that <emphasis>identify</emphasis> displays a bunch of useful information about the image file, for example the size of the image in pixels, the color depth of the image, and the image format.</para>

<para><emphasis>identify</emphasis> also has a -format command line flag which allows you to specify that only the information you want be output. For example, if we were only interested in the image dimensions, the you might use a command like shown in this example:</para>


<programlisting>
deathstar:/home/mikal# identify -format "%wx%h" sample.png 
640x480
</programlisting>

<para>Here, <emphasis>%w</emphasis> means image width, and <emphasis>%h</emphasis> means image height. Checkout the <emphasis>identify</emphasis> man page for more information on the formatting characters which can be used with the option.</para>










</sect1>
<sect1><title>Rotating images</title>

<para>Another commonly needed image manipulation is the rotation of images. For example, many of the photos I take with my digital cameras are rotated ninety degrees, as they are taken as portrait pictures. My camera doesn't rotate these for me, so I have a script which does it for me once I have downloaded the images from the camera.<para>

<para>For example, this is a photo taken on a trip I made to Port Arthur in Tasmania recently:</para>

	

<graphic format="eps" fileref="gen-portarthur.eps">


<para>To rotate this picture, we again turn to the <emphasis>convert</emphasis> command from imagemagick. The command line to use is:</para>



<programlisting>
convert -rotate 90 input.jpg output.jpg
</programlisting>

<para>This produces an image which looks like:</para>

	

<graphic format="eps" fileref="gen-portarthur-rot.eps">


<para>Note that the argument to the -rotate option is the number of degrees of the right to rotate the image. If you want to rotate to the left, then use a negative number.</para>





</sect1>
<sect1><title>Changing the format of an image</title>

<para>The <emphasis>convert</emphasis> imagemagick command is also capable of converting the formation of the image files. This includes converting between image formats, such as converting a JPEG image to PNG, but it also includes converting from color to gray scale, dithering, and similar operations.</para>

<para><emphasis>convert</emphasis> knows what image format the input and output are based on the file extensions given on the command line. Therefore, to convert a JPEG to a PNG, use a command line like the following:</para>


<programlisting>
convert input.jpg output.png
</programlisting>

<para>Imagemagick supports 89 image formats at the time of writing this article. Checkout the imagemagick web site for more information.</para>










</sect1>
<sect1><title>Adding textual annotations to an image</title>

<para>Sometimes you need to add textual annotations to an image. For example, imagine that your company had a standard business card image, and needed to put each employee's details onto the card before sending it to the printer. Another example generating presentation certificates for users of your web site, for instance when they pass an online course.</para>

	

<graphic format="eps" fileref="gen-floriade.eps">



<programlisting>
convert -font helvetica -fill white -pointsize 36 \
-draw 'text 10,50 "Floriade 2002, Canberra, Australia"' \
floriade.jpg comment.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-comment.eps">


<para>This is by far the most complex <emphasis>convert</emphasis> command line we have seen so far in the article, so I will take some time to explain it bit by bit.</para>

<para><emphasis>-font helvetica</emphasis>: sets the font for the annotation to helvetica. It is possible here to specify a path to a font file as well. For example, this example badges the image so it can't be reused by other web sites without permission, but does so using a font which is in a non-standard location...</para>


<programlisting>
convert -font fonts/1900805.ttf -fill white -pointsize 36 \
-draw 'text 10,475 "stillhq.com"' \
floriade.jpg stillhq.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-stillhq.eps">


<para><emphasis>-fill white</emphasis>: fill the letters with white, instead of the standard black.</para>

<para><emphasis>-pointsize 36</emphasis>: the size of the letters, in points. There are 72 points to an inch.</para>

<para><emphasis>-draw 'text 10,50 "..."'</emphasis>: a set of drawing commands, in this case move to the position 10, 50 and then draw the text in the double quotes. The single quotes are used because the double quotes are needed within the drawing command if more than one word is to be drawn, and you cannot have double quotes within double quotes.</para>











</sect1>
<sect1><title>Other, more artistic, conversions</title>

<para><emphasis>convert</emphasis> also implements a series of quite artistic conversions. I'll only demonstrate some of the more visually interesting ones here, if you're interested in stuff like this, then you should checkout the imagemagick man page and web site for more information. The input image I will use for the demonstrations is:</para>

	

<graphic format="eps" fileref="gen-uluru.eps">


<para>This photo of Uluru, formerly known as Ayer's Rock, was taken at sunset.</para>










<sect2><title>Charcoal</title>

<para>The charcoal effect simulates a charcoal artist's impression of the scene represented by the picture.</para>


<programlisting>
convert -charcoal 2 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-charcoal.eps">


<para>Increasing the magnitude of the argument to the charcoal option increases the amount of "charcoal" applied to the image, but also makes the generation of the image much slower. Here's an example with a little more charcoal.</para>


<programlisting>
convert -charcoal 10 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-charcoal-medium.eps">



<programlisting>
convert -charcoal 200 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-charcoal-intense.eps">


<para>An intensity of 200 was used to produce the image above.</para>











</sect2>
<sect2><title>Colorize</title>

<para>Colorizing is the process of blending the color of each pixel with a specified color. The argument to the effect is the color to blend with. This can either be specified as a percentage (which will be used for each of red, green, and blue), or as three percentages. It is also possible to provide either one of three actual values.</para>

<sidebar>
<title>Specifying three values</title>
<para>To specify three values, one for each of the red, green and blue samples, use an argument of the form <emphasis>red/green/blue</emphasis>, for example, 10/20/30 would mean red has a value of 10, green a value of 20, and blue a value of 30. You can also use percentages within this construct.</para>
</sidebar>


<programlisting>
convert -colourize 255 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-colorize.eps">







</sect2>
<sect2><title>Implode</title>

<para>The implode effect simulates the center of you image being sucked into a virtual black hole. The argument is the amount of implosion effect you desire.</para>


<programlisting>
convert -implode 4 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-implode.eps">










</sect2>
<sect2><title>Solarize</title>

<para>Solarizing is an effect that occurs when a negative is exposed to light part of the way through the photographic development process. Here, the input argument is the intensity above which to apply the effect, either specified as an absolute value, or as a percentage of the maximum possible value for the pixel. If a pixel is above the threshold, then it is negated.</para>

<sidebar>
<title>The solarize argument</title>
<para>The imagemagick documentation states that the argument to solarize is always a percentage. This is not strictly true. If the argument has a percentage sign at the end of it, then it will be treated as a percentage. Otherwise, it is treated as a literal value.</para>
</sidebar>


<programlisting>
convert -solarize 42 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-solarize.eps">









</sect2>
<sect2><title>Spread</title>

<para>Spread moves pixels by a random amount within the image. The argument is the size of the area around the pixel from which to select the new location. It therefore specifies how closely the output resembles the input.</para>


<programlisting>
convert -spread 5 input.jpg output.jpg
</programlisting>

	

<graphic format="eps" fileref="gen-spread.eps">












</sect2>
</sect1>
<sect1><title>Multiple commands in one imagemagick invocation</title>

<para>I should also take the time to mention that it's possible to chain imagemagick commands. We have in fact already seen an example of this with the annotation examples. It is possible however to chain any of the imagemagick commands mentioned in this article. For example, perhaps we would like to make a thumbnail of an image, and then apply a spread to it. Once the spread has occurred, then we'll apply the charcoal effect.</para>


<programlisting>
convert -sample 25%x25% -spread 4 \
-charcoal 4 input.jpg output.jpg
</programlisting>

<para>This produces:</para>

	

<graphic format="eps" fileref="gen-chained.eps">























</sect1>
<sect1><title>Things to note about image manipulation</title>

<para>There are some things you should remember about image manipulation before you rush out and start modifying every image you own. Firstly, you should give some thought to what image format you are going to use long term, before you end up with many images in a format that you later regret. This is made especially easy, as you can use <emphasis>convert</emphasis> to change the format of the images, as discussed earlier in this article.</para>

<para>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative.</para>

<para>PNG is normally a good choice for color images where you don't want accumulating loss to effect the quality of the image after a series of manipulations.</para>

<para>See my previous DeveloperWorks article on color imaging with libtiff for more information on this topic, the URL is in the resources section at the end of this article.</para>

<para>Also, you should remember that most of the manipulations shown in this article are one way. For example, once you've shrunk and image, that image data is gone. If you blow up the image again later, then the output will be quite pixelated. For example, let's take a picture, make a thumbnail, and then expand the image again. To save some space, I'll just include the before and after images here, and skip the intervening thumbnail.</para>

	

<graphic format="eps" fileref="gen-waterfall.eps">



<programlisting>
convert -sample 10% -sample 1000% input.jpg output.jpg
</programlisting>

<para>This produces an image which looks like:</para>

	

<graphic format="eps" fileref="gen-blocky.eps">


<para>I think you would have to agree, it's quite hard to see the waterfall in the finished picture, although unfocusing your eyes seems to help.</para>








</sect1>
<sect1><title>Conclusion</title>

<para>In this article we've discussed some of the interesting things which imagemagick can do with your command line imaging needs. Hopefully I have provided somewhat of a cook book of imaging options which you'll find of use later. Remember however that generic command line imaging tools are not the answer to every problem. Sometimes you'll need a custom piece of code, in order to meet the requirements of the system.</para>







</chapter>
                            </book>
