<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>

<slidetext>
Welcome to the image programming tutorial for AUUG 2002...


<figure><title>Port Arthur, Tasmania</title>
<graphic format="jpg" fileref="gen-tutorial-figure1.jpg">
</figure>

</slidetext>
</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>

<slidetext>
<li>This set of slides will cover the material for the tutorial
<li>It is available online at http://www.stillhq.com
<li>I strongly prefer that people interrupt with questions as we go along...
<li>If something isn't clear to you, then it is probably unclear to other people as well
<li>It also eases the boredom associated with having to listen to me all day long
</slidetext>

<sect1><title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>

<slidetext>
Michael Still<br>
Senior Software Engineer<br>
TOWER Software<br>
<br>
Architecture and Data Services Group,<br>
Research and Development Section<br>
<br>
<li>TOWER is an Australian ISV developing document management software

<br><br>

<li>I can be contacted at: mikal@stillhq.com
<li>There is heaps of sample code, including the samples from this tutorial at http://www.stillhq.com
</slidetext>
</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>

<slidetext>
<li>This tutorial started life as two articles on TIFF for IBM DeveloperWorks
<li>I came to the conclusion that I couldn't explain everything I wanted to in 7,000 words

<br><br>

<li>It's the start of the manual I wished I had had when I started image programming
<li>It isn't finished yet -- there is always so much more to tell
</slidetext>
</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<noslide>
<sect2><title>C</title>
</noslide>
<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not necessarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>

<slidetext>
<li>C
</slidetext>
</sect2>

<noslide>
<sect2><title>How to compile and link on your chosen operating system</title>
</noslide>
<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The make files included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>

<slidetext>
<li>How to compile and link
</slidetext>
</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.
</para>

<slidetext>
<li>I should thank the following people:
  <ul>
  <li>My wife Catherine, and my son Andrew
  <li>Doug Jackson
  <li>Tony Green
  <li>Michael Smith
  <li>Greg Lehey
  <li>Lenny Muellner  
</slidetext>

<slideinclude>
<figure><title>Catherine and Andrew</title>
<graphic format="jpg" fileref="gen-introduction-figure1.jpg">
</figure>
</slideinclude>

<para>
I should also thank the following people:
</para>

<itemizedlist>
<listitem><para>Doug Jackson (doug_jackson@citadel.com.au), for proof reading and getting me interested in this whole topic to start with</para></listitem>
<listitem><para>Tony Green (greeno@bandcamp.tv), for occasional DocBook wrangling</para></listitem>
<listitem><para>Michael Smith (smith@xml-doc.org), for DocBook hints</para></listitem>
<listitem><para>Greg Lehey, for giving me access to his docbook environment when I was having jade pain</para></listitem>
<listitem><para>Lenny Muellner, of O'Reilly, for helping me with my gmat problems</para></listitem>
</itemizedlist>

</sect1>

<noslide>
<sect1><title>How this document was produced</title>
<para>
This tutorial was written in DocBook SGML using xemacs. This was then converted into PDF using the jade SGML tools. Diagrams were developed in a combination of the gimp, Adobe Illustrator, and custom developed code. Diagrams were converted to EPS as required by jade using ImageMagick.
</para>

<para>
A series of DocBook generation scripts was also used to automate some of the generation of this document. These scripts can be found in my online CVS repository at: http://www.stillhq.com/cgi-bin/cvsweb/docbooktools/
</para>

<para>
The source for this tutorial is available at: http://www.stillhq.com/cgi-bin/cvsweb/tutorial-imaging/
</para>
</sect1>

<sect1><title>License</title>
<para>
This document is covered by two licenses -- the license for the text of this document, and the license for the included source code. The license terms are set out below.
</para>

<sect2><title>License for text (OPL)</title>
<para>
<command>
This tutorial is Copyright (c) Michael Still 2002, and is released under the terms of the GNU OPL. Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder. Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.
</command>
</para>

<para>
Please note that portions of this tutorial are <command>not</command> Copyright Michael Still, or are licensed under a license other than the GNU OPL, and are acknowledged as such either below or when relevant within the text of the tutorial.
</para>

<para>OPEN PUBLICATION LICENSE  Draft v0.4, 8 June 1999
</para>

<sect3><title>I. REQUIREMENTS ON BOTH UNMODIFIED AND MODIFIED VERSIONS</title>

<para>The Open Publication works may be reproduced and distributed in whole or
in part, in any medium physical or electronic, provided that the terms
of this license are adhered to, and that this license or an
incorporation of it by reference (with any options elected by the
author(s) and/or publisher) is displayed in the reproduction.
</para>
<para>Proper form for an incorporation by reference is as follows:
</para>
<para>Copyright (c) &lt;year&gt; by &lt;author's name or designee&gt;.  This material may
be distributed only subject to the terms and conditions set forth in the
Open Publication License, vX.Y or later (the latest version is presently
available at &lt;URL:http:// TBD&gt;).
</para>
<para>The reference must be immediately followed with any options elected by
the author(s) and/or publisher of the document (see section VI).
</para>
<para>Commercial redistribution of Open Publication-licensed material is
permitted.
</para>
<para>Any publication in standard (paper) book form shall require the citation
of the original publisher and author. The publisher and author's names
shall appear on all outer surfaces of the book.  On all outer surfaces
of the book the original publisher's name shall be as large as the title
of the work and cited as possessive with respect to the title.
</para>

</sect3>

<sect3><title>II. COPYRIGHT</title>

<para>The copyright to each Open Publication is owned by its author(s) or
designee.
</para>
</sect3>

<sect3><title>III. SCOPE OF LICENSE</title>

<para>The following license terms apply to all Open Publication works, unless
otherwise explicitly stated in the document.
</para>
<para>Mere aggregation of Open Publication works or a portion of an Open
Publication work with other works or programs on the same media shall
not cause this license to apply to those other works. The aggregate work
shall contain a notice specifying the inclusion of the Open Publication
material and appropriate copyright notice.
</para>
<para>SEVERABILITY. If any part of this license is found to be unenforceable
in any jurisdiction, the remaining portions of the license remain in
force.
</para>
<para>NO WARRANTY. Open Publication works are licensed and provided "as is"
without warranty of any kind, express or implied, including, but not
limited to, the implied warranties of merchantability and fitness for a
particular purpose or a warranty of non-infringement.
</para>
</sect3>

<sect3><title>IV. REQUIREMENTS ON MODIFIED WORKS</title>

<para>All modified versions of documents covered by this license, including
translations, anthologies, compilations and partial documents, must meet
the following requirements:
</para>
<itemizedlist><listitem><para>1) The modified version must be labeled as such.
</para></listitem><listitem><para>2) The person making the modifications must be identified and the
   modifications dated.
</para></listitem><listitem><para>3) Acknowledgement of the original author and publisher if applicable
   must be retained according to normal academic citation practices.
</para></listitem><listitem><para>4) The location of the original unmodified document must be identified.
</para></listitem><listitem><para>5) The original author's (or authors') name(s) may not be used to assert
   or imply endorsement of the resulting document without the original
   author's (or authors') permission.
</para>

</listitem></itemizedlist></sect3>

<sect3><title>V. GOOD-PRACTICE RECOMMENDATIONS</title>

<para>In addition to the requirements of this license, it is requested from
and strongly recommended of redistributors that:
</para>
<itemizedlist><listitem><para>1) If you are distributing Open Publication works on hardcopy or CD-ROM,
   you provide email notification to the authors of your intent to
   redistribute at least thirty days before your manuscript or media
   freeze, to give the authors time to provide updated documents. This
   notification should describe modifications, if any, made to the
   document.
</para>
</listitem><listitem><para>2) All substantive modifications (including deletions) be either clearly
   marked up in the document or else described in an attachment to the
   document. 
</para>
<para>Finally, while it is not mandatory under this license, it is considered
good form to offer a free copy of any hardcopy and CD-ROM expression of
an Open Publication-licensed work to its author(s).
</para>
</listitem></itemizedlist></sect3>

<sect3><title>VI. LICENSE OPTIONS</title>

<para>The author(s) and/or publisher of an Open Publication-licensed document
may elect certain options by appending language to the reference to or
copy of the license. These options are considered part of the license
instance and must be included with the license (or its incorporation by
reference) in derived works.
</para>
<itemizedlist><listitem><para>A. To prohibit distribution of substantively modified versions without
   the explicit permission of the author(s). "Substantive modification"
   is defined as a change to the semantic content of the document, and
   excludes mere changes in format or typographical corrections. 
</para>
<para>   To accomplish this, add the phrase `Distribution of substantively
   modified versions of this document is prohibited without the explicit
   permission of the copyright holder.' to the license reference or
   copy. 
</para>
</listitem><listitem><para>B. To prohibit any publication of this work or derivative works in whole
   or in part in standard (paper) book form for commercial purposes is
   prohibited unless prior permission is obtained from the copyright
   holder.
</para>
<para>   To accomplish this, add the phrase `Distribution of the work or
   derivative of the work in any standard (paper) book form is
   prohibited unless prior permission is obtained from the copyright
   holder.' to the license reference or copy. 
</para>
<para>OPEN PUBLICATION POLICY APPENDIX:
</para>
<para>(This is not considered part of the license.)
</para>
<para>Open Publication works are available in source format via the Open
Publication home page at &lt;URL:tbd&gt;.
</para>
<para>Open Publication authors who want to include their own license on Open
Publication works may do so, as long as their terms are not more
restrictive than the Open Publication license.
</para>
<para>If you have questions about the Open Publication License, please contact
TBD, and/or the Open Publication Authors' List at &lt;TBD&gt;, via email.
</para>
</listitem></itemizedlist></sect3>
</sect2>

<sect2><title>License for source code (GPL)</title>
<para>    GNU GENERAL PUBLIC LICENSE
       Version 2, June 1991
</para>
<para> Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
</para>
<para>    Preamble
</para>
<para>  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.
</para>
<para>  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.
</para>
<para>  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
</para>
<para>  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.
</para>
<para>  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
</para>
<para>  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
</para>
<para>  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.
</para>
<para>  The precise terms and conditions for copying, distribution and
modification follow.
</para><beginpage>
<para>    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
</para>
<para>  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".
</para>
<para>Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.
</para>
<para>  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.
</para>
<para>You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.
</para>
<para>  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:
</para>
<para>    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.
</para>
<para>    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.
</para>
<para>    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)
</para>
<para>These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.
</para>
<para>Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.
</para>
<para>In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.
</para>
<para>  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:
</para>
<para>    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,
</para>
<para>    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,
</para>
<para>    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)
</para>
<para>The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.
</para>
<para>If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.
</para><beginpage>
<para>  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.
</para>
<para>  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.
</para>
<para>  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.
</para>
<para>  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.
</para>
<para>If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.
</para>
<para>It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.
</para>
<para>This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.
</para><beginpage>
<para>  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.
</para>
<para>  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
</para>
<para>Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.
</para>
<para>  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
</para>
<para>    NO WARRANTY
</para>
<para>  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
</para>
<para>  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
</para>
<para>     END OF TERMS AND CONDITIONS
</para><beginpage>
<para>    How to Apply These Terms to Your New Programs
</para>
<para>  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.
</para>
<para>  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.
</para>
<para>    &lt;one line to give the program's name and a brief idea of what it does.&gt;
    Copyright (C) 19yy  &lt;name of author&gt;
</para>
<para>    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
</para>
<para>    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
</para>
<para>    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</para>

<para>Also add information on how to contact you by electronic and paper mail.
</para>
<para>If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
</para>
<para>    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
</para>
<para>The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.
</para>
<para>You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:
</para>
<para>  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.
</para>
<para>  &lt;signature of Ty Coon&gt;, 1 April 1989
  Ty Coon, President of Vice
</para>
<para>This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
</para>
</sect2>

<sect2><title>License for the libtiff man pages</title>
<para>
Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.
</para>

<para>
Permission to use, copy, modify, distribute, and sell this software and 
its documentation for any purpose is hereby granted without fee, provided
that (i) the above copyright notices and this permission notice appear in
all copies of the software and related documentation, and (ii) the names of
Sam Leffler and Silicon Graphics may not be used in any advertising or
publicity relating to the software without the specific, prior written
permission of Sam Leffler and Silicon Graphics.
</para>

<para>
THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
</para>

<para>
IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
OF THIS SOFTWARE.
</para>
</sect2>
</sect1>
</noslide>
</chapter>
<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day. This section presents these things in alphabetical order, for ease of reference.
</para>

<para>
These terms are presented in alphabetical order. Some of them might seem a bit odd, but they're here because they are interesting...
</para>

<slidetext>
<li>There are some core terms which we need to define before we continue
<li>These terms are all in the manual
<li>So you can refer back to that if you get confused later
<li><b>If these are too basic, and I am wasting your time, then please let me know</b>
</slidetext>

<sect1><title>Anti-aliasing</title>
<para>
Imagine that you are drawing a triangle across an image (or on the screen for that matter). The triangle is sometimes going to cross pixels in a way which makes them not totally turned on. Have a look at the figure below to see what I mean...
</para>

<slidetext>
<li>Imagine that you're drawing a triangle
<li>There are some pixels which are only going to be half on...
</slidetext>

<slideinclude>
<figure><title>Drawing a triangle</title>
<graphic format="jpg" fileref="gen-antialias-figure1.jpg">
</figure>
</slideinclude>

<para>
If we only have a black and white image, then we'll end up with an image like the one in the figure below. I am sure you'll agree that this isn't a very good representation of the side of the triangle.
</para>

<slidetext>
<li>This results in a black and white image which looks quite gross...
</slidetext>

<slidebreak>

<slideinclude>
<figure><title>A triangle with only black pixels</title>
<graphic format="jpg" fileref="gen-antialias-figure2.jpg">
</figure>
</slideinclude>

<para>
Anti-aliasing is when we try to correct for this problem by inserting some gray pixels. In the figure below, we have given some of the pixels a gray value which is based on how much of the pixel is <quote>filled</quote> with the triangle.
</para>

<slidetext>
<li>We can try to correct this by making some pixels half black
  <ul>
  <li>(Assuming we can have a grayscale version of the image)
  </ul>
</slidetext>

<slidebreak>

<slideinclude>
<figure><title>A triangle with gray scale pixels</title>
<graphic format="jpg" fileref="gen-antialias-figure3.jpg">
</figure>
</slideinclude>

<para>
The triangle might be a little clearer without the grid lines.
</para>

<slidebreak>

<slidetext>
<li>Without the gridlines...
</slidetext>

<slideinclude>
<figure><title>Anti-aliased triangle without grid lines</title>
<graphic format="jpg" fileref="gen-antialias-figure4.jpg">
</figure>
</slideinclude>

<para>
For comparison, there is the triangle we started with...
</para>

<figure><title>The original triangle</title>
<graphic format="jpg" fileref="gen-antialias-figure5.jpg">
</figure>

<para>
So, in summary, anti-aliasing is the process of turning on some extra gray scale pixels to improve the look of shapes we are drawing...
</para>
</sect1>
<sect1><title>Encrypting images</title>
<para>
DES in Electronic Code Book (ECB) mode is a particularly poor choice of cryptography for image files. This is because ECB mode implements a look up table between the unencrypted value and the encrypted value. This results in a known input value turning into the same output value over and over. This can have some interesting blurring effects, but wont obscure the image contents. An example will help this make more sense -- the first figure is the logo for the company I am currently working for. I took this image, and ran it through some DES ECB code and produced the second figure.
</para>

<slidetext>
<li>Encrypting images using codebook cryptography can have unexpected results
<li>For example, my company's logo...
</slidetext>

<slideinclude>
<figure><title>The TOWER corporate logo</title>
<graphic format="jpg" fileref="gen-desecb-figure1.jpg">
</figure>
</slideinclude>

<slidebreak>

<slidetext>
<li>After encryption using DES ECB mode
</slidetext>

<slideinclude>
<figure><title>After ECB encryption</title>
<graphic format="jpg" fileref="gen-desecb-figure2.jpg">
</figure>
</slideinclude>

<para>
You can see that whilst the image has certainly changed, the contents of the image has not really been obscured. 
</para>

<slidetext>
<li>(This image is upside down because I am lazy)
<li>We can see that the content of the image has not been hidden
</slidetext>



<para>
We should note that ECB mode is not commonly used anyway. If you use something like PGP or blowfish, then you should be much happier... 
</para>

<slidetext>
<li>We should note that non codebook cryptography <i>might</i> be better
</slidetext>
</sect1>
<sect1><title>Gray scale conversion</title>
<para>
How do you convert color images to gray scale? Well, my instant answer when I first had to do this was to just average the red, green and blue values. That answer is wrong. The reality is that the human eye is much better at seeing some colors than others. To get an accurate gray scale representation, you need to apply different coefficients to the color samples. Appropriate coefficients are 0.299 for red, 0.587 for green and 0.114 for blue.
</para>

<slidetext>
<li>How do you convert color images to grayscale?
<li>Well, most people (including myself) just start off by averaging the red, green and blue color values for each pixel
<li>This is not optimal...
<li>Because your eye is much more sensitive to green than blue for instance
<BR><BR>
<li>The NSTC folk dealt with this, and propose the following coefficients...
  <ul>
  <li>Red: 0.299
  <li>Green: 0.587
  <li>Blue: 0.114
  </ul>
</slidetext>

<para>
Below I have included several pictures that illustrate this concept. The first figure is a color image
  <footnote><para>Which may or may not give you joy, depending on if you are viewing this document in color or not</para></footnote>
, the second is the color image converted to gray scale without the coefficients applied, and the third image is a correct gray scale rendition.
</para>

<figure><title>The original image</title>
<graphic format="EPS" fileref="grayscale-figure1.eps">
</figure>

<figure><title>An average of the color values for each pixel</title>
<graphic format="EPS" fileref="grayscale-figure2.eps">
</figure>

<figure><title>A correct conversion to gray scale</title>
<graphic format="EPS" fileref="grayscale-figure3.eps">
</figure>

<para>
You can see that the sensible algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>

<para>
The source code to generate these example images may be found in the TIFF chapter.
</para>
</sect1>
<sect1><title>Pixel samples</title>
<para>
Each pixel needs to have a value associated with this. Most practitioners call this a sample. For a black and white image we would only have one sample per pixel, whilst for a RGB color image, we would have three samples per pixel -- the red, green and blue components.
</para>


<slidetext>
<li>The value associated with a given pixel
<li>Black and white: one sample per pixel
<li>Color: normally three samples per pixel (red, green, and blue)
</slidetext>
</sect1>

<sect1><title>Pixel</title>
<para>
     <indexterm><primary>Pixel</primary></indexterm>
A pixel is the lowest unit of raster image description -- in other words, a raster image is defined in terms of pixels. Example pixels can be seen in the discussion of rasters, later in this chapter.
</para>

<slidetext>
<li>The smallest unit of image description
<li>A "dot" in the picture
</slidetext>
</sect1>

<sect1><title>Rasters</title>
<para>
     <indexterm><primary>Raster</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>raster</secondary></indexterm>
The most common image format (and the focus of the majority of this tutorial) is raster image formats. Raster image formats are those which store the picture as a bitmap
     <footnote><para>You can think of a bitmap as being simply an array of pixels. We'll talk more about this later</para></footnote>
describing the state of pixels, as opposed to recording the length and locations of primatives such as lines and curves. Common examples include the output of photoshop, the gimp, scanners and digital cameras. Effectively, your monitor and printer are raster output devices.
</para>

<slidetext>
<li>Raster = bitmap
<li>Most common formats are raster formats
<li>Think of a raster as being an array of pixels
</slidetext>

<slideinclude>
<figure><title>A sample raster image</title>
<graphic format="jpg" fileref="gen-raster-figure1.jpg">
</figure>
</slideinclude>

<slidebreak>

<para>
Raster image formats include TIFF, GIF, PNG, and most of the other formats in this tutorial. If in doubt, assume that it's a raster format unless I tell you otherwise.
</para>

<slidetext>
<li>TIFF, GIF, PNG etc
</slidetext>

<para>
If we zoom in enough on a portion of this image, we can see that it is made up of descrete elements -- the pixels. 
</para>

<slideinclude>
<figure><title>Zooming in on a portion of the raster image</title>
<graphic format="jpg" fileref="gen-raster-figure2.jpg">
</figure>
</slideinclude>

<para>
The code to produce this zoomed image is presented in the TIFF chapter of this tutorial.
</para>
</sect1>
<sect1><title>Theory of color and gray scale storage</title>
<para>
There are several ways that the value of a pixel can be stored within a raster image. This is a pretty fundamental concept, so it is best to get it out of the way early on before we get caught up in the actual format of images.
</para>

<slidetext>
<li>There are several ways that we can store the pixels within a raster
</slidetext>

<slideinclude>
<figure><title>The worst picture of a house you have ever seen</title>
<graphic format="jpg" fileref="gen-theory-figure1.jpg">
</figure>
</slideinclude>

<para>
I will use the simple image above to demonstrate the ways that the pixel values can be stored...
</para>

<slidetext>
<li>Let's use this house as an example...
</slidetext>

<slidebreak>

<slideinclude>
<figure><title>A zoom in on the house</title>
<graphic format="jpg" fileref="gen-theory-figure2.jpg">
</figure>
</slideinclude>

<para>
We'll in fact only use a zoomed in portion of the image so that what is happening is clearer.
</para>

<sect2><title>Direct storage of black and white</title>
<slideinclude>
<figure><title>A black and white zoom in</title>
<graphic format="jpg" fileref="gen-theory-figure3.jpg">
</figure>
</slideinclude>

<para>
Black and white images only really have one pixel value storage option. This is to store the value of the pixel directly at the pixel location in the image data itself. This is a good option for black and white data, because it only takes on bit per pixel anyway.
</para>

<slidetext>
<li>Black and white images only have one storage option
<li>Store the on / off value at the pixel location within the raster
<li>We only need one bit per pixel...
</slidetext>

<slidebreak>

<slideinclude>
<figure><title>Black and white data</title>
<graphic format="jpg" fileref="gen-theory-figure4.jpg">
</figure>
</slideinclude>

<para>
Whilst this is a very simple example, make sure you understand how the diagram works, because it gets more complex from here. Each square represents the storage space in the image data, and in this example the values representing the pixel values is stored inside the image data.
</para>

<slidetext>
<li>Watch out, it only gets more complex from here...
</slidetext>
</sect2>

<sect2><title>Direct gray scale storage</title>
<slideinclude>
<figure><title>A gray scale zoom in</title>
<graphic format="jpg" fileref="gen-theory-figure5.jpg">
</figure>
</slideinclude>

<para>
In this example, we are storing the gray scale values of the pixels within the image data.
</para>

<slidetext>
<li>Similar to black and white, we just store the value at the pixel location
</slidetext>
</sect2>

<sect2><title>Direct RGB storage</title>
<slideinclude>
<figure><title>A RGB zoom in</title>
<graphic format="jpg" fileref="gen-theory-figure6.jpg">
</figure>
</slideinclude>

<para>
Here we are storing the red green and blue values for each pixel within the image data.
</para>

<slidetext>
<li>We could store the RGB values within the pixel location
</slidetext>
</sect2>

<sect2><title>Paletted RGB storage</title>
<slideinclude>
<figure><title>A paletted RGB zoom in</title>
<graphic format="jpg" fileref="gen-theory-figure7.jpg">
</figure>
</slideinclude>

<para>
The other option is to instead store within the image data itself a number which uniquely identifies the color at that pixel. We can then have a table elsewhere in the image file which defines the color that is that unique value. This table is a palette, and this is a very common way of storing RGB data (it is in fact the only option with some formats such as GIF).
</para>

<slidetext>
<li>Here we just store the index into a lookup table in the pixel location
<li>The lookup table is called a palette
<li>This also works for grayscale images...
</slidetext>

<para>
You can also use palettes for gray scale images, I just haven't provided an example of that here.
</para>

<sect3><title>The advantage of paletting</title>
<para>
The big advantage of paletting an image is that the final file is going to be much smaller. For example, an A4 page is 1754 by 2479 pixels. That's 4,348,166 pixels. Now, let's assume for this example that the image is 24 bit color (that is 8 bits per color per pixel), and that there are seven colors in the image. That means that unpaletted, we have 13,044,498 bytes of image data (uncompressed). If we palette the image data, then we only need three bits of data in the image data -- 1,630,562 bytes (uncompressed). We'll also need to store the palette itself, which will need another 21 bytes (uncompressed). We don't need to store the color indices, as they are just an offset into an array.
</para>

<para>
This means that the total saving on an uncompressed image is 11,413,936 bytes. The disadvantage of course is that using the image is almost certainly going to be slightly slower...
</para>

<slidetext>
<li>A4 page = 1754 x 2479 pixels = 4,348,166 pixels
<li>Assume 24 bit color (8 bits for each of R, G, and B)
<li>Assume 7 colors in the image (3 bits for the palette index)
<li>Unpaletted: 4,348,166 * 24 bits = 13,044,498 bytes (uncompressed)
<li>Paletted: 4,348,166 * 3 bits = 1,630,562 bytes (uncompressed)
  <ul>
  <li>Plus the size of the palette: 7 * 24 bits = 21 bytes
  </ul>
</slidetext>
</sect3>
</sect2>
</sect1>
<sect1><title>Vector</title>
<para>
     <indexterm><primary>Vector</primary></indexterm>
     <indexterm><primary>Image format</primary><secondary>vector</secondary></indexterm>
Some images aren't raster images. These images are normally composed of primitive drawing commands, such as draw a line, draw a circle, et cetera. The advantage of vector formats is that it is an exact representation of the image, they also scale much better. Examples of vector formats include Scalar Vector Graphics (SVG), Adobe Illustrator files, Windows Meta Files, and to a certain extent PDF documents. A plotter is a vector output device.
</para>

<slidetext>
<li>The alternative to raster images
<li>Describe the drawing primitives, not the state of pixels

  <ul>
  <li><i>There is a rectangle between (10, 100) and (30, 200)</i>
  </ul>

<li>Much smaller, but slower to display
<li>Resizes much better...
</slidetext>
</sect1>
</chapter>
<chapter id="chap-tiff"><title>TIFF</title>
<slideinclude>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>
</slideinclude>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>

<slidetext>
<li><b>T</b>agged <b>I</b>mage <b>F</b>ile <b>F</b>ormat
<li>Developed by Aldus (remember them?) and Microsoft
<li>Aldus was acquired by Adobe, who still administer the TIFF specification
<li>Download the spec from:

  <a href="http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf">http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf</a>

<li>Technical implementation notes can be found at:

  <a href="http://partners.adobe.com/asn/developer/technotes/main.html">http://partners.adobe.com/asn/developer/technotes/main.html</a>
</slidetext>

<slidebreak>

<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>

<slidetext>
<li>Libtiff is an open implementation of the TIFF specification
<li>It is not GPL
<li>More like a BSD license
<li>There is documentation in the manual on how to install libtiff
</slidetext>
</sect1>

<noslide>
<sect1><title>Installation</title>
<para>
The source for libtiff can be downloaded from http://www.libtiff.org/ -- the current version of the library being version 3.5.7 at the time of writing. This version can be downloaded from ftp://ftp.remotesensing.org/pub/libtiff, look for the files named either tiff-v3.5.7.tar.gz or tiff-v3.5.7.zip.
</para>

<sect2><title>Unix</title>
<para>
Once you have downloaded the tarball for the library as described above, then you need to follow the steps below to install libtiff
  <footnote><para>Please note that there are binary packages for libtiff for most operating systems, so you might be best off installing one of those.</para></footnote>.

<orderedlist>
<listitem><para>tar xvzf tiff-v3.5.7.tar.gz</para></listitem>
<listitem><para>cd tiff-v3.5.7</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</orderedlist>
</para>

<para>
Not too hard at all...
</para>
</sect2>

<sect2><title>win32</title>
<para>
The instructions for how to compile the library are as follows:
</para>

<itemizedlist>
<listitem><para>Uncompress the libtiff distribution</para></listitem>
<listitem><para>Change directory into the libtiff directory inside the distribution</para></listitem>
<listitem><para>Copy ..\contrib\winnt\fax3sm.c to fax3sm_winnt.c</para></listitem>
<listitem><para>Copy ..\contrib\winnt\libtiff.def to libtiff.def</para></listitem>
<listitem><para>Remove the line for TIFFModeCCITTFax3 from the libtiff.def file</para></listitem>
<listitem><para>Change the line for TIFFFlushdata1 in the libtiff.def file to TIFFFlushData1</para></listitem>
<listitem><para>nmake /f makefile.vc all</para></listitem>
<listitem><para>Done!</para></listitem>
</itemizedlist>

<para>
To compile the tools once you have the library, just change into the tools directory and do a nmake /f makefile.vc 
</para>

<para>
For the Visual Studio challenged, there is a precompiled version of libtiff for win32 available from http://www.stillhq.com. Have a look at the Panda documentation page...
</para>
</sect2>
</sect1>
</noslide>

<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>

<slidetext>
<li>We should talk about how TIFF images are laid out on disc
<li>This will help us understand the inner workings of the format better
<li>There are more details on this in the TIFF specification if you need them
</slidetext>

<sect2><title>File header</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>




<sect2><title>Image File Directory</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>




<sect2><title>Image File Directory Entries</title>
<slideinclude>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>

<para>
These entries have a type associated with them, possible types are:
</para>

<slidebreak>

<slidetext>
<li>These entries have a type
<li>Options are:
  <br>
  <ul>
</slidetext>

<slideinclude>
<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>
</slideinclude>

<para>
TIFF version 6 added the following fields:
</para>

<slideinclude>
<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>
</slideinclude>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>

<slidetext>
<br><br>
<li>Sign is implemented using 2's complement
<li>Adobe reserve the right to add new types later
</slidetext>
</sect2>

<noslide>
<sect2><title>Possible field entries</title>
<para>
Discussing the many different possible field entries is out of the scope of this document. Refer to tiff.h and the TIFF specification for more information.
</para>
</sect2>
</noslide>

<sect2><title>So where's the image data?</title>
<slideinclude>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</slideinclude>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:

<slidetext>
<li>Most file formats lay down basic rules covering:
  <ul>
</slidetext>

<slideinclude>
<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</slideinclude>
</para>

<slidetext>
  </ul>
<li>TIFF doesn't
</slidetext>

<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	
<slidetext>
<li>This makes it very easy to create TIFFs
<li>Your current internal format is probably good enough
<li>Very hard to read in TIFF files well however
</slidetext>

<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>

<slidetext>
<br><br>
<li><i>Try to avoid making assumptions...</i>
</slidetext>
</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>

<slidetext>
<li>It must be time to see some code by now...
</slidetext>
	
<noslide>
<sect2><title>Infrastructure for writing</title>
<para>
It is traditional for bitmaps to be represented inside your code with an array of chars. This is because on most operating systems, a char maps well to one byte. In the block of code below, we will setup libtiff, and create a simple buffer which contains an image which we can then write out to disc.
</para>
</noslide>

<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int
main (int argc, char *argv[])
{
  char buffer[32 * 9];
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-infrastructure.c</emphasis></para>
</slideinclude>

<slidetext>
<BR><BR>
<li>Is this the most boring code example <b>every</b> or what?
</slidetext>

<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>

<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  // Define an image -- this is 32 pixels by 9 pixels
  char buffer[25 * 144] = { ...boring hex omitted... };

  TIFF *image;

  // Open the TIFF file
  if((image = TIFFOpen("output.tif", "w")) == NULL){
    printf("Could not open output.tif for writing\n");
    exit(42);
  }

  // We need to set some values for basic tags before we can add any data
  TIFFSetField(image, TIFFTAG_IMAGEWIDTH, 25 * 8);
  TIFFSetField(image, TIFFTAG_IMAGELENGTH, 144);
  TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 1);
  TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);
  TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 144);

  TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
  TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);
  TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
  TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);

  TIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
  
  // Write the information to the file
  TIFFWriteEncodedStrip(image, 0, buffer, 25 * 144);

  // Close the file
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-nohex.c</emphasis></para>
</slideinclude>

<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>

<noslide>
<sidebar><title>Problems with xview</title>
<para>
Xview is part of the xloadimage package written by Jim Frost, which comes with X windows.
</para>

<para>
It's a good example of how hard it can be to handle TIFF images well. If you have trouble viewing the output of the sample code, then try using some other program, like the GIMP.
</para>
</sidebar>
</noslide>

<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>

<slidebreak>
<slidetext>
<li>Things to note from this example:
  <ul>
</slidetext>

<slideinclude>
<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>
</slideinclude>

<slidetext>
  </ul>
</slidetext>

<noslide>
<sidebar><title>More information about the libtiff function calls</title>
<para>
If you need more information about any of the libtiff function calls mentioned in this chapter, then checkout the extensive man pages which come with the library. Remember that case is important with man pages, so you need to get the case in the function names right -- it's TIFFOpen, not tiffopen.
</para>
</sidebar>
</noslide>

<slidebreak>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, by Michael Still</title>
<graphic format="jpg" fileref="gen-tiff-figure1.jpg">
</figure>
</slideinclude>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>

<slidetext>
<li>As I said before, reliable reading is much harder than writing
<li>First let's talk about stripping, and tiling of images...
</slidetext>

<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>

<slidetext>
<li>Single strip is where all the image data is in one block (a strip)
<li>This can be unreliable if the strip is bigger than 8kb
</slidetext>

<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>

<slidetext>
<BR><BR>
<li>Multiple strip images have many horizontal strips
</slidetext>

<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, in strips</title>
<graphic format="jpg" fileref="gen-tiff-figure2.jpg">
</figure>
</slideinclude>

<slidebreak>

<slidetext>
<li>A tiled image is like your bathroom wall...
<li>This is often used for extremely large images such as maps
</slidetext>

<slideinclude>
<figure><title>The Sydney Harbor Bridge, in tiles</title>
<graphic format="jpg" fileref="gen-tiff-figure3.jpg">
</figure>
</slideinclude>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>

<slidetext>
<li>Tiled images are not very common
<li>So we'll focus on stripped images
</slidetext>

<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>

<slidetext>
<li>We need to remember to be flexible in the input that we accept
<BR><BR>
<li>Be flexible about:
  <ul>
  <li>Stipping / tiling
  <li>Strip sizes
  <li>Photometric interpretation
  </ul>
</slidetext>

<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (PHOTOMETRIC_MINISBLACK), whilst you might find black being 1 (PHOTOMETRIC_MINISWHITE) more convenient. TIFF allows both (in the TIFFTAG_PHOTOMETRIC tag), so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in PHOTOMETRIC_MINISWHITE so we will convert images which are in PHOTOMETRIC_MINISBLACK.
</para>

<slidebreak>
<slidetext>
<li>What is photometric interpretation?
<li>It's the representation of the image in the raster
<BR><BR>
<li>For example, I might code my bitmaps so black is represented by 1
<li>... you might use 0 for black
<li>TIFF allows both in the TIFFTAG_PHOTOMETRIC tag
  <ul>
  <li>PHOTOMETRIC_MINISWHITE
  <li>PHOTOMETRIC_MINISBLACK
  </ul>
<BR><BR>
<li>In the examples here I have assumed we need PHOTOMETRIC_MINISWHITE, so we will convert PHOTOMETRIC_MINISBLACK as required.

<BR><BR>
<i>Note that some versions of this tutorial had the tag names wrong...</i>
</slidetext>


<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>

<slidebreak>
<slidetext>
<li>The other thing to bear in mind is the fill order of the bytes
<li>This is whether the first bit in the byte has the highest value or the lowest
<li>This is subtly different from endianness
<BR><BR>
<li>Libtiff deals with endian issues for us automatically
</slidetext>

<slidebreak>
<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint16 photo, bps, spp, fillorder;
  uint32 width;
  tsize_t stripSize;
  unsigned long imageOffset, result;
  int stripMax, stripCount;
  char *buffer, tempbyte;
  unsigned long bufferSize, count;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Check that it is of a type that we support
  if((TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &amp;bps) == 0) || (bps != 1)){
    fprintf(stderr, "Either undefined or unsupported number of bits per sample\n");
    exit(42);
  }

  if((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &amp;spp) == 0) || (spp != 1)){
    fprintf(stderr, "Either undefined or unsupported number of samples per pixel\n");
    exit(42);
  }

  // Read in the possibly multile strips
  stripSize = TIFFStripSize (image);
  stripMax = TIFFNumberOfStrips (image);
  imageOffset = 0;
  
  bufferSize = TIFFNumberOfStrips (image) * stripSize;
  if((buffer = (char *) malloc(bufferSize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory for the uncompressed image\n");
    exit(42);
  }
  
  for (stripCount = 0; stripCount &lt; stripMax; stripCount++){
    if((result = TIFFReadEncodedStrip (image, stripCount,
				      buffer + imageOffset,
				      stripSize)) == -1){
      fprintf(stderr, "Read error on input strip number %d\n", stripCount);
      exit(42);
    }

    imageOffset += result;
  }

  // Deal with photometric interpretations
  if(TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &amp;photo) == 0){
    fprintf(stderr, "Image has an undefined photometric interpretation\n");
    exit(42);
  }
  
  if(photo != PHOTOMETRIC_MINISWHITE){
    // Flip bits
    printf("Fixing the photometric interpretation\n");

    for(count = 0; count &lt; bufferSize; count++)
      buffer[count] = ~buffer[count];
  }

  // Deal with fillorder
  if(TIFFGetField(image, TIFFTAG_FILLORDER, &amp;fillorder) == 0){
    fprintf(stderr, "Image has an undefined fillorder\n");
    exit(42);
  }
  
  if(fillorder != FILLORDER_MSB2LSB){
    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA
    printf("Fixing the fillorder\n");

    for(count = 0; count &lt; bufferSize; count++){
      tempbyte = 0;
      if(buffer[count] &amp; 128) tempbyte += 1;
      if(buffer[count] &amp; 64) tempbyte += 2;
      if(buffer[count] &amp; 32) tempbyte += 4;
      if(buffer[count] &amp; 16) tempbyte += 8;
      if(buffer[count] &amp; 8) tempbyte += 16;
      if(buffer[count] &amp; 4) tempbyte += 32;
      if(buffer[count] &amp; 2) tempbyte += 64;
      if(buffer[count] &amp; 1) tempbyte += 128;
      buffer[count] = tempbyte;
    }
  }
     
  // Do whatever it is we do with the buffer -- we dump it in hex
  if(TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width) == 0){
    fprintf(stderr, "Image does not define its width\n");
    exit(42);
  }
  
  for(count = 0; count &lt; bufferSize; count++){
    printf("%02x", (unsigned char) buffer[count]);
    if((count + 1) % (width / 8) == 0) printf("\n");
    else printf(" ");
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-read/read.c</emphasis></para>
</slideinclude>

<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>

<slidebreak>
<slidetext>
<li>This code works by opening an image
<li>Checking that it is one that we support
<li>Reading in all the strips and appending them together
<li>Twiddling bits if required
<li>Output the hex representation of the image
</slidetext>
</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>. The compression option is stored in the tag TIFFTAG_COMPRESSION.
</para>

<slidetext>
<li>Stored in TIFFTAG_COMPRESSION
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>COMPRESSION</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>
Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.
</para>

<slidetext>
<li>JPEG compression can be a bad choice for some forms of data
<li>This is because it is lossy
<li>This loss accumulates through repeated compression and decompression
</slidetext>

<para>
Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.
</para>

<slidebreak>
<slideinclude>
<figure><title>The picture before we compressed it</title>
<graphic format="jpg" fileref="gen-tiff-figure4.jpg">
</figure>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>The sample text before we compressed it</title>
<graphic format="jpg" fileref="gen-tiff-figure5.jpg">
</figure>
</slideinclude>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<slidebreak>
<slideinclude>
<figure><title>The picture after it has been recompressed 200 times</title>
<graphic format="jpg" fileref="gen-tiff-figure6.jpg">
</figure>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>The text after it has been recompressed 200 times</title>
<graphic format="jpg" fileref="gen-tiff-figure7.jpg">
</figure>
</slideinclude>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>

<slidebreak>
<slidetext>
<li>I cheated here, and had a quality of 25% set on the JPEG compression
<li>The default is 75%
<BR><BR>
<li>The code for repeated compression is the the printed manual
</slidetext>
</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>

<slidetext>
<li>It's time to show you a color example
</slidetext>

<slideinclude>
<programlisting>
#include &lt;tiffio.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]){
  TIFF *output;
  uint32 width, height;
  char *raster;

  // Open the output image
  if((output = TIFFOpen("output.tif", "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // We need to know the width and the height before we can malloc
  width = 42;
  height = 42;

  if((raster = (char *) malloc(sizeof(char) * width * height * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Magical stuff for creating the image
  // ...

  // Write the tiff tags to the file
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster, width * height * 3) == 0){
    fprintf(stderr, "Could not write image\n");
    exit(42);
  }

  TIFFClose(output);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-write/write.c</emphasis></para>
</slideinclude>

<slidebreak>

<para>
You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.
</para>

<slidetext>
<li>There are some things we should pay attention to in this code:
  <ul>
  <li>The image has three (red, green and blue) samples per pixel
  <li>Each of these samples is 8 bits
  <li>This is therefore a 24 bit color image
  </ul>
</slidetext>

<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>

<slidetext>
<li>Now is probably as good a time as any to tell you that you're not limited to three samples per pixel
<li>You can have an arbitary number
<li>For instance, this is where alpha channel information is stored in almost all image formats
<li>Having more than three samples per pixel can break viewers which make ugly assumptions
</slidetext>
</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>

<slidebreak>
<slidetext>
<li>The other interesting thing we should talk about now is planar configuration
<li>You don't have to have your image data grouped like:

<pre>
RGBRGBRGBRGBRGB
</pre>

<li>Grouping all the red samples together is equally valid, for instance:

<pre>
RRRRRGGGGGBBBBB
</pre>

<li>Have a look at the libtiff documentation on TIFFTAG_PLANARCONFIG for more details
</slidetext>
</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>

<slidetext>
<li>Writing a paletted image with libtiff is really easy...
<li>Just change TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE
</slidetext>
</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>

<slidetext>
<li>Now we just need to work out how to read color images in
<li>Here's why I'm not telling you about TIFFReadRGBAStrip() and TIFFReadRGBATile()
</slidetext>

<slideinclude>
<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<slidebreak>
<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>
</slideinclude>

<slidebreak>
<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>

<slidetext>
<li>So what's wrong with this function?
  <ul>
  <li>It defines the origin (0,0) in a different way from <b>all</b> the other libtiff calls
  <li>Not all valid values for bits per sample are handled
  </ul>

<BR><BR>

<li>We're going to use it anyway, because it makes the code clearer...
<li>Remember that you can always use TIFFReadEncodedStrip() like we did for the black and white images -- although you then have to interpret the image data yourself
</slidetext>

<slidebreak>
<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  // Here I fix the reversal of the image (vertically) and show you how to get the color values from each pixel
  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      // Red = TIFFGetR(raster[e * width + c]);
      // Green = TIFFGetG(raster[e * width + c]);
      // Blue = TIFFGetB(raster[e * width + c]);
    }
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-read/read.c</emphasis></para>
</slideinclude>
</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>

<slidetext>
<li>There are times when it isn't appropriate to store your image data in files
<li>There are lots of examples of when you might want to put the data in a database instead
<li>Perhaps the image data is going to be embedded into another file format
</slidetext>

<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>

<slidetext>
<BR><BR>
<li>The example I am most familiar with is the PDF specification
<li>The PDF format is basically ASCII (as we will see later)
<li>But has embedded binary "streams" such as TIFF data
<li>So we would like to be able to create these streams with libtiff
<li>...instead of having to implement our own TIFF library
</slidetext>

<noslide>
<sidebar><title>An expanded example</title>
<para>If you need more information about hooking the file input and output functions within libtiff than this chapter allows, then have a look at the images.c file in Panda, my PDF library. The web pages for Panda can be found at http://www.stillhq.com
  <footnote><para>http://www.stillhq.com/cgi-bin/getpage?area=panda&lt;page=index.htm to be exact.</para></footnote>
.
</para>
</sidebar>
</noslide>

<slidebreak>
<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>

<slidetext>
<li>Use the TIFFClientOpen() function...
</slidetext>


<slideinclude>
<programlisting>
// Please note that this code wont compile, and is intended to only show you 
// the sturcture of TIFFClient* calls

#include &lt;tiffio.h&gt;
#include &lt;pthread.h&gt;

// Function prototypes
static tsize_t libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size);
static tsize_t libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size);
static toff_t libtiffDummySeekProc (thandle_t fd, toff_t off, int i);
static int libtiffDummyCloseProc (thandle_t fd);

// We need globals because of the callbacks (they don't allow us to pass state)
char *globalImageBuffer;
unsigned long globalImageBufferOffset;

// This mutex keeps the globals safe by ensuring only one user at a time
pthread_mutex_t convMutex = PTHREAD_MUTEX_INITIALIZER;

TIFF *conv;

// Lock the mutex
pthread_mutex_lock (&amp;convMutex);

globalImageBuffer = NULL;
globalImageBufferOffset = 0;

// Open the dummy document (which actually only exists in memory)
conv = TIFFClientOpen ("dummy", "w", (thandle_t) - 1, libtiffDummyReadProc,
            libtiffDummyWriteProc, libtiffDummySeekProc,
            libtiffDummyCloseProc, NULL, NULL, NULL);

// Setup the image as if it was any other tiff image here, including setting tags


// Actually do the client open
TIFFWriteEncodedStrip (conv, 0, stripBuffer, imageOffset);

// Unlock the mutex
pthread_mutex_unlock (&amp;convMutex);

//...

/////////////////// Callbacks to libtiff

static tsize_t
libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // Return the amount of data read, which we will always set as 0 because
  // we only need to be able to write to these in-memory tiffs
  return 0;
}

static tsize_t
libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // libtiff will try to write an 8 byte header into the tiff file. We need
  // to ignore this because PDF does not use it...
  if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'I') &amp;&amp; (((char *) buf)[1] == 'I')
     &amp;&amp; (((char *) buf)[2] == 42))
    {
    // Skip the header -- little endian
    }
  else if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'M') &amp;&amp;
       (((char *) buf)[1] == 'M') &amp;&amp;y (((char *) buf)[2] == 42))
    {
    // Skip the header -- big endian
    }
  else
    {
    // Have we done anything yet?
    if (globalImageBuffer == NULL)
    if((globalImageBuffer = (char *) malloc (size * sizeof (char))) == NULL)
        {
          fprintf(stderr, "Memory allocation error\n");
          exit(42);
        }

    // Otherwise, we need to grow the memory buffer
    else
    {
      if ((globalImageBuffer = (char *) realloc (globalImageBuffer,
                             (size * sizeof (char)) +
                             globalImageBufferOffset)) == NULL)
        fprintf(stderr, "Could not grow the tiff conversion memory buffer\n");
            exit(42);
    }

    // Now move the image data into the buffer
    memcpy (globalImageBuffer + globalImageBufferOffset, buf, size);
    globalImageBufferOffset += size;
    }

  return (size);
}

static toff_t
libtiffDummySeekProc (thandle_t fd, toff_t off, int i)
{
  // This appears to return the location that it went to
  return off;
}

static int
libtiffDummyCloseProc (thandle_t fd)
{
  // Return a zero meaning all is well
  return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-client/client.c</emphasis></para>
</slideinclude>
</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>

<slidetext>
<li>People commonly want to be able to store more than one image in a TIFF file
<li>TIFF and libtiff support this
<li>This is called multipage / multidirectory TIFF
<li>Multidirectory because there is more than one IFD
<li>There is in fact one per image
</slidetext>

<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>

<slidetext>
<BR><BR>
<li><i>Before writing heaps of code for multipage TIFFs, remember that the specification doesn't require viewers to support this feature, so you might end up with a whole heap of data that no-one can look at...</i>
</slidetext>

<slidebreak>
<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>

<slidetext>
<li>Actually doing it is quite easy...
<li>Just use the TIFFWriteDirectory() call between the images
</slidetext>

<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff, optchar;
  int count = 4, i;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:c:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'c':
	  count = atoi(optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file, we do this c times
  for(i = 0; i &lt; count; i++){
    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    

    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    // Flush this subfile and move onto the next one
    if(TIFFWriteDirectory(output) == 0){
      fprintf(stderr, "Error writing subfile %d\n", i);
      exit(44);
    }
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/create.c</emphasis></para>
</slideinclude>

<slidebreak>
<slideinclude>
<figure><title>Four pictures of my son Andrew</title>
<graphic format="jpg" fileref="gen-tiff-figure8.jpg">
</figure>
</slideinclude>

</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
This example below demonstrates how to do this.
</para>


<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, 
    outputFilenameActual[200], *raster, *roff, optchar;
  int count;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Check the output parent name
  if(outputFilename == NULL){
    fprintf(stderr, \
	    "You need to specify a name for the series of output files\n");
    usage(argv[0], 42);
  }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Grab a sub file from the input image and move it to a separate file. We do
  // this forever (until we break down below)...
  for(count = 0;; count++){
    // Find the width and height of the input
    TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
    TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

    ///////////////////////////////////////////////////////////////////////////
    // Grab some memory
    if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == 
	NULL)
      {
	fprintf (stderr, 
		 "Could not allocate enough memory for input raster\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Read the input into the memory buffer
    // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
    stripSize = TIFFStripSize (input);
    roff = raster;
    for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
	 stripNumber++)
      {
	roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
      }
    
    ///////////////////////////////////////////////////////////////////////////
    // Open the output TIFF
    snprintf(outputFilenameActual, 200, "%s-%d.tif", outputFilename, count);
    if ((output = TIFFOpen (outputFilenameActual, "w")) == NULL)
      {
	fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
	usage (argv[0], 42);
      }

    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    
    // Copy the subfile to a output location
    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Flush this subfile and move onto the next one
    if(TIFFReadDirectory(input) == 0){
      printf(" No more subfiles");
      break;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Doing correct cleanup with a loop like this is important...
    free(raster);
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/read.c</emphasis></para>
</slideinclude>

</sect1>

<noslide>
<sect1><title>Man pages</title>
<para>
I have included the man pages to some of the more useful libtiff commands, so that you have them for reference when you need them.
</para>

<sect2><title>tiff2bw</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2bw - convert a color
<emphasis>TIFF</emphasis>
image to greyscale
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2bw</command>
[
options
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiff2bw</emphasis>
converts an
<emphasis>RGB</emphasis>
or Palette color
<emphasis>TIFF</emphasis>
image to a greyscale image by
combining percentages of the red, green, and blue channels.
By default, output samples are created by taking
28% of the red channel, 59% of the green channel, and 11% of
the blue channel.
To alter these percentages, the
and
options may be used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify a compression scheme to use when writing image data:
<command>"-c none"</command>
for no compression,
<command>"-c packbits"</command>
for the PackBits compression algorithm,
<command>"-c zip</command>
for the Deflate compression algorithm,
<command>"-c g3</command>
for the CCITT Group 3 compression algorithm,
<command>"-c g4</command>
for the CCITT Group 4 compression algorithm,
and
<command>"-c lzw"</command>
for Lempel-Ziv &amp; Welch (the default).
</para>
</listitem>
<listitem>

<para><command>-r</command>
Write data with a specified number of rows per strip;
by default the number of rows/strip is selected so that each strip
is approximately 8 kilobytes.
</para>
</listitem>
<listitem>

<para><command>-R</command>
Specify the percentage of the red channel to use (default 28).
</para>
</listitem>
<listitem>

<para><command>-G</command>
Specify the percentage of the green channel to use (default 59).
</para>
</listitem>
<listitem>

<para><command>-B</command>
Specify the percentage of the blue channel to use (default 11).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>

<sect2><title>tiff2ps</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiff2ps - convert a
<emphasis>TIFF</emphasis>
image to \*(Ps\(tm
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiff2ps</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiff2ps</emphasis>
reads
<emphasis>TIFF</emphasis>
images and writes \*(Ps or Encapsulated \*(Ps (EPS)
on the standard output.
By default,
<emphasis>tiff2ps</emphasis>
writes Encapsulated \*(Ps for the first image in the specified
<emphasis>TIFF</emphasis>
image file.

</para>

<para>By default,
<emphasis>tiff2ps</emphasis>
will generate \*(Ps that fills a printed area specified
by the
<emphasis>TIFF</emphasis>
tags in the input file.
If the file does not contain
<emphasis>XResolution</emphasis>
or
<emphasis>YResolution</emphasis>
tags, then the printed area is set according to the image dimensions.
The
<command>-w</command>
and
<command>-h</command>
options (see below)
can be used to set the dimensions of the printed area in inches;
overriding any relevant
<emphasis>TIFF</emphasis>
tags.

</para>

<para>The \*(Ps generated for
<emphasis>RGB,</emphasis>
palette, and
<emphasis>CMYK</emphasis>
images uses the
<emphasis>colorimage</emphasis>
operator.
The \*(Ps generated for
greyscale and bilevel images
uses the
<emphasis>image</emphasis>
operator.
When the
<emphasis>colorimage</emphasis>
operator is used, \*(Ps code to emulate this operator
on older \*(Ps printers is also generated.
Note that this emulation code can be very slow.

</para>

<para>Color images with associated alpha data are composited over
a white background.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-1</command>
Generate \*(Ps Level I (the default).
</para>
</listitem>
<listitem>

<para><command>-2</command>
Generate \*(Ps Level II.
</para>
</listitem>
<listitem>

<para><command>-a</command>
Generate output for all IFDs (pages) in the input file.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the specified directory number.
(NB: directories are numbered starting at zero.)
This option is useful for selecting individual pages in a
multi-page (e.g. facsimile) file.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Force the generation of Encapsulated \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-h</command>
Specify the vertical size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-i</command>
Enable/disable pixel interpolation.  This option requires a
single numeric value: zero to disable pixel interpolation and
non-zero to enable.  The default is enabled.
</para>
</listitem>
<listitem>

<para><command>-m</command>
Where possible render using the
<command>imagemask</command>
\*(Ps operator instead of the image operator.  When this option is specified
<emphasis>tiff2ps</emphasis>
will use
<command>imagemask</command>
for rendering 1 bit deep images.  If this option is not specified
or if the image depth is greater than 1 then the image operator
is used.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to the
<emphasis>IFD</emphasis>
at the specified file offset.
This option is useful for selecting thumbnail images and the
like which are hidden using the SubIFD tag.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Force the generation of (non-Encapsulated) \*(Ps.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Generate output for a single IFD (page) in the input file.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the horizontal size of the printed area (in inches).
</para>
</listitem>
<listitem>

<para><command>-z</command>
When generating \*(Ps Level II, data is scaled so that it does not
image into the
<emphasis>deadzone</emphasis>
on a page (the outer margin that the printing device is unable to mark).
This option suppresses this behaviour.
When \*(Ps Level I is generated, data is imaged to the entire printed
page and this option has no affect.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following generates \*(Ps Level II for all pages of a facsimile:
tiff2ps -a2 fax.tif | lpr
Note also that if you have version 2.6.1 or newer of Ghostscript then you
can efficiently preview facsimile generated with the above command.

</para>

<para>To generate Encapsulated \*(Ps for a the image at directory 2
of an image use:
tiff2ps -d 1 foo.tif
(notice that directories are numbered starting at zero.)
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Because \*(Ps does not support the notion of a colormap,
8-bit palette images produce 24-bit \*(Ps images.
This conversion results in output that is six times
bigger than the original image and which takes a long time
to send to a printer over a serial line.
Matters are even worse for 4-, 2-, and 1-bit palette images.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Does not handle tiled images when generating PS Level I output.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>tiffsv (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffcmp</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcmp - compare two
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcmp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"file1.tif file2.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffcmp</emphasis>
compares the tags and data in two files created according
to the Tagged Image File Format, Revision 6.0.
The schemes used for compressing data in each file
are immaterial when data are compared-data are compared on
a scanline-by-scanline basis after decompression.
Most directory tags are checked; notable exceptions are:
<emphasis>GrayResponseCurve ,</emphasis>
<emphasis>ColorResponseCurve ,</emphasis>
and
<emphasis>ColorMap</emphasis>
tags.
Data will not be compared if any of the
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
or
<emphasis>ImageWidth</emphasis>
values are not equal.
By default,
<emphasis>tiffcmp</emphasis>
will terminate if it encounters any difference.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-l</command>
List each byte of image data that differs between the files.
</para>
</listitem>
<listitem>

<para><command>-t</command>
Ignore any differences in directory tags.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Tags that are not recognized by the library are not
compared; they may also generate spurious diagnostics.

</para>

<para>The image data of tiled files is not compared, since the TIFFReadScanline()
function is used.  A error will be reported for tiled files.

</para>

<para>The pixel and/or sample number reported in differences may be off
in some exotic cases.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffcmp</command> shows the differences in tags between images, for example, when I compare the input and output images from the pixel example in this chapter:
</para>

<programlisting>
[mikal@localhost tiff-pixels]$ tiffcmp input.tif output.tif 
ImageWidth: 256 520
[mikal@localhost tiff-pixels]$ 
</programlisting>
</sect3>
</sect2>
</noslide>

<sect2><title>tiffcp</title>
<slideinclude>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcp - copy (and possibly convert) a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"src1.tif ... srcN.tif dst.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffcp</emphasis>
combines one or more files created according
to the Tag Image File Format, Revision 6.0
into a single
<emphasis>TIFF</emphasis>
file.
Because the output file may be compressed using a different
algorithm than the input files,
<emphasis>tiffcp</emphasis>
is most often used to convert between different compression
schemes.

</para>

<para>By default,
<emphasis>tiffcp</emphasis>
will copy all the understood tags in a
<emphasis>TIFF</emphasis>
directory of an input
file to the associated directory in the output file.

</para>

<para><emphasis>tiffcp</emphasis>
can be used to reorganize the storage characteristics of data
in a file, but it is explicitly intended to not alter or convert
the image data content in any way.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-b image</command>
subtract the following monochrome image from all others
processed.  This can be used to remove a noise bias
from a set of images.  This bias image is typlically an
image of noise the camera saw with its shutter closed.
</para>
</listitem>
<listitem>

<para><command>-B</command>
Force output to be written with Big-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Suppress the use of ``strip chopping'' when reading images
that have a single strip/tile of uncompressed data.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffcp</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-l</command>
Specify the length of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-L</command>
Force output to be written with Little-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-M</command>
Suppress the use of memory-mapped files when reading images.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data
that has one 8-bit sample per pixel.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same planar configuration as
the original.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffcp</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Force the output file to be written with data organized in strips
(rather than tiles).
</para>
</listitem>
<listitem>

<para><command>-t</command>
Force the output file to be written wtih data organized in tiles
(rather than strips).
options can be used to force the resultant image to be written
as strips or tiles of data, respectively.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the width of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-,={character}</command>
substitute {character} for ',' in parsing image directory indices
in files.  This is necessary if filenames contain commas.
Note that ',=' with whitespace immediately following will disable
the special meaning of the ',' entirely.  See examples.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following concatenates two files and writes the result using
<emphasis>LZW</emphasis>
encoding:
tiffcp -c lzw a.tif b.tif result.tif

</para>

<para>To convert a G3 1d-encoded
<emphasis>TIFF</emphasis>
to a single strip of G4-encoded data the following might be used:
tiffcp -c g4 -r 10000 g3.tif g4.tif
(1000 is just a number that is larger than the number of rows in
the source file.)

</para>

<para>To extract a selected set of images from a multi-image
TIFF file, the file name may be immediately followed by a ','
separated list of image directory indices.  The first image
is always in directory 0.  Thus, to copy the 1st and 3rd
images of image file "album.tif" to "result.tif":
tiffcp album.tif,0,2 result.tif

</para>

<para>Given file "CCD.tif" whose first image is a noise bias
followed by images which include that bias,
subtract the noise from all those images following it
(while decompressing) with the command:
tiffcp -c none -b CCD.tif CCD.tif,1, result.tif

</para>

<para>If the file above were named "CCD,X.tif", the "-,=" option would
be required to correctly parse this filename with image numbers,
as follows:
tiffcp -c none -,=% -b CCD,X.tif CCD,X%1%.tif result.tif
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiffsplit (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</slideinclude>
</sect2>


<sect2><title>tiffdither</title>
<slideinclude>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdither - convert a greyscale image to bilevel using dithering
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdither</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdither</emphasis>
converts a single channel 8-bit greyscale image to a bilevel image
using Floyd-Steinberg error propagation with threholding.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffdither</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffdither</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB ,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-t</command>
Set the threshold value for dithering.
By default the threshold value is 128.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>The dither algorithm is taken from the
<emphasis>tiffmedian (1)</emphasis>
program (written by Paul Heckbert).
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>fax2tiff (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</slideinclude>

<noslide>
<sect3><title>Sample output</title>
</noslide>
<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<slidebreak>
<slideinclude>
<figure><title>The gray scale input image</title>
<graphic format="jpg" fileref="gen-tiff-figure9.jpg">
</figure>
</slideinclude>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<slidebreak>
<slideinclude>
<figure><title>The dithered output image</title>
<graphic format="jpg" fileref="gen-tiff-figure10.jpg">
</slideinclude>
</figure>
</sect3>
</sect2>

<sect2><title>tiffdump</title>
<slideinclude>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdump - print verbatim information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdump</command>
[
<emphasis>options</emphasis>
]
<emphasis>"name ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdump</emphasis>
displays directory information from files created according
to the Tag Image File Format, Revision 6.0.
The header of each
<emphasis>TIFF</emphasis>
file (magic number, version, and first directory offset)
is displayed, followed by the tag contents of each directory in the file.
For each tag, the name, datatype, count, and value(s) is displayed.
When the symbolic name for a tag or datatype is known, the symbolic
name is displayed followed by it's numeric (decimal) value.
Tag values are displayed enclosed in ``&lt;&gt;'' characters immediately
preceded by the value of the count field.
For example, an
<emphasis>ImageWidth</emphasis>
tag might be displayed as ``ImageWidth (256) SHORT (3) 1&lt;800&gt;''.

</para>

<para><emphasis>tiffdump</emphasis>
is particularly useful for investigating the contents of
<emphasis>TIFF</emphasis>
files that
<emphasis>libtiff</emphasis>
does not understand.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-h</command>
Force numeric data to be printed in hexadecimal rather than the
default decimal.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Dump the contents of the
<emphasis>IFD</emphasis>
at the a particular file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</slideinclude>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</slideinclude>
</sect3>
</sect2>

<noslide>
<sect2><title>tiffgt</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffgt - display an image stored in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffgt</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffgt</emphasis>
displays one or more images stored using the
Tag Image File Format, Revision 6.0.
Each image is placed in a fixed size window that the
user must position on the display (unless configured
otherwise through X defaults).
If the display has fewer than 24 bitplanes, or if the
image does not warrant full color, then
<emphasis>RGB</emphasis>
color values are mapped to the closest values that exist in
the colormap (this is done using the
<emphasis>rgbi</emphasis>
routine found in the graphics utility library

</para>

<para><emphasis>tiffgt</emphasis>
correctly handles files with any of the following characteristics:
BitsPerSample	1, 2, 4, 8, 16
SamplesPerPixel	1, 3, 4 (the 4th sample is ignored)
PhotometricInterpretation	0 (min-is-white), 1 (min-is-black), 2 (RGB), 3 (palette), 6 (YCbCr)
PlanarConfiguration	1 (contiguous), 2 (separate)
Orientation	1 (top-left), 4 (bottom-left)
Data may be organized as strips or tiles and may be
compressed with any of the compression algorithms supported
by the
<emphasis>libtiff (3)</emphasis>
library.

</para>

<para>For palette images (\c
<emphasis>PhotomatricInterpretation =3),</emphasis>
<emphasis>tiffgt</emphasis>
inspects the colormap values and assumes either 16-bit
or 8-bit values according to the maximum value.
That is, if no colormap entry greater than 255 is found,
<emphasis>tiffgt</emphasis>
assumes the colormap has only 8-bit values; otherwise
it assumes 16-bit values.
This inspection is done to handle old images written by
previous (incorrect) versions of
<emphasis>libtiff .</emphasis>

</para>

<para><emphasis>tiffgt</emphasis>
can be used to display multiple images one-at-a-time.
The left mouse button switches the display to the first image in the
<emphasis>next</emphasis>
file in the list of files specified on the command line.
The right mouse button switches to the first image in the
<emphasis>previous</emphasis>
file in the list.
The middle mouse button causes the first image in the first file
specified on the command line to be displayed.
In addition the following keyboard commands are recognized:
</para>
<itemizedlist>
<listitem>

<para><command>b</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsBlack in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>l</command>
Use a
<emphasis>FillOrder</emphasis>
of lsb-to-msb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>m</command>
Use a
<emphasis>FillOrder</emphasis>
of msb-tolmsb in decoding the current image.
</para>
</listitem>
<listitem>

<para><command>c</command>
Use a colormap visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>r</command>
Use a true color (24-bit RGB) visual to display the current image.
</para>
</listitem>
<listitem>

<para><command>w</command>
Use a
<emphasis>PhotometricIntepretation</emphasis>
of MinIsWhite in displaying the current image.
</para>
</listitem>
<listitem>

<para><command>W</command>
Toggle (enable/disable) display of warning messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>E</command>
Toggle (enable/disable) display of error messages from the
<emphasis>TIFF</emphasis>
library when decoding images.
</para>
</listitem>
<listitem>

<para><command>z</command>
Reset all parameters to their default settings (\c
<emphasis>FillOrder ,</emphasis>
<emphasis>PhotometricInterpretation ,</emphasis>
handling of warnings and errors).
</para>
</listitem>
<listitem>

<para><command>PageUp</command>
Display the previous image in the current file or the last
image in the previous file.
</para>
</listitem>
<listitem>

<para><command>PageDown</command>
Display the next image in the current file or the first image
in the next file.
</para>
</listitem>
<listitem>

<para><command>Home</command>
Display the first image in the current file.
</para>
</listitem>
<listitem>

<para><command>End</command>
Display the last image in the current file (unimplemented).
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Force image display in a colormap window.
</para>
</listitem>
<listitem>

<para><command>-d</command>
Specify an image to display by directory number.
By default the first image in the file is displayed.
Directories are numbered starting at zero.
</para>
</listitem>
<listitem>

<para><command>-e</command>
Enable reporting of error messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
silently ignores images that cannot be read.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Force
<emphasis>tiffgt</emphasis>
to run as a foreground process.
By default
<emphasis>tiffgt</emphasis>
will place itself in the background once it has opened the
requested image file.
</para>
</listitem>
<listitem>

<para><command>-l</command>
Force the presumed bit ordering to be
<emphasis>LSB</emphasis>
to
<emphasis>MSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-m</command>
Force the presumed bit ordering to be
<emphasis>MSB</emphasis>
to
<emphasis>LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-o</command>
Specify an image to display by directory offset.
By default the first image in the file is displayed.
Directories offsets may be specified using C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Override the value of the
<emphasis>PhotometricInterpretation</emphasis>
tag; the parameter may be one of:
<emphasis>miniswhite ,</emphasis>
<emphasis>minisblack ,</emphasis>
<emphasis>rgb ,</emphasis>
<emphasis>palette ,</emphasis>
<emphasis>mask ,</emphasis>
<emphasis>separated ,</emphasis>
<emphasis>ycbcr ,</emphasis>
and
<emphasis>cielab .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-r</command>
Force image display in a full color window.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Stop on the first read error.
By default all errors in the input data are ignored and
<emphasis>tiffgt</emphasis>
does it's best to display as much of an image as possible.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Enable reporting of warning messages from the
<emphasis>TIFF</emphasis>
library.
By default
<emphasis>tiffgt</emphasis>
ignores warning messages generated when reading an image.
</para>
</listitem>
<listitem>

<para><command>-v</command>
Place information in the title bar describing
what type of window (full color or colormap) is being
used, the name of the input file, and the directory
index of the image (if non-zero).
By default, the window type is not shown in the title bar.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BUGS</title>

<para>Images wider and taller than the display are silently truncated to avoid
crashing old versions of the window manager.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffdump (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>
</noslide>

<sect2><title>tiffinfo</title>
<slideinclude>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffinfo - print information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffinfo</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffinfo</emphasis>
displays information about files created according
to the Tag Image File Format, Revision 6.0.
By default, the contents of each
<emphasis>TIFF</emphasis>
directory in each file
is displayed, with the value of each tag shown symbolically
(where sensible).
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Display the colormap and color/gray response curves, if present.
</para>
</listitem>
<listitem>

<para><command>-D</command>
In addition to displaying the directory tags,
read and decompress all the data in each image (but not display it).
</para>
</listitem>
<listitem>

<para><command>-d</command>
In addition to displaying the directory tags,
print each byte of decompressed data in hexadecimal.
</para>
</listitem>
<listitem>

<para><command>-j</command>
Display any \s-2JPEG\s0-related tags that are present.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory according to the specified file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Display the offsets and byte counts for each data strip in a directory.
</para>
</listitem>
<listitem>

<para><command>-z</command>
Enable strip chopping when reading image data.
</para>
</listitem>
<listitem>

<para><command>-#</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to
<emphasis># .</emphasis>
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</slideinclude>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</slideinclude>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<slidebreak>
<slideinclude>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</slideinclude>
</sect3>
</sect2>

<noslide>
<sect2><title>tiffmedian</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffmedian - apply the median cut algorithm to data in a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffmedian</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffmedian</emphasis>
applys the median cut algorithm to an
<emphasis>RGB</emphasis>
image in
<emphasis>input.tif</emphasis>
to generate a palette image that is written to
<emphasis>output.tif .</emphasis>
The generated colormap has, by default, 256 entries.
The image data is quantized by mapping each
pixel to the closest color values in the colormap.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
and
<command>zip</command>
for Deflate compression.
By default
<emphasis>tiffmedian</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Specify the number of entries to use in the generated colormap.
By default all 256 entries/colors are used.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Apply Floyd-Steinberg dithering before selecting a colormap entry.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffmedian</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>This program is derived from Paul Heckbert's
<emphasis>median</emphasis>
program.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>libtiff (3)</emphasis>

</para>

<para>"Color Image Quantization for Frame Buffer Display", Paul
Heckbert, SIGGRAPH proceedings, 1982, pp. 297-307.
</para>
</sect3>
</sect2>
</noslide>

<noslide>
<sect2><title>tiffsplit</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1992-1997 Sam Leffler -->
<!--  Copyright (c) 1992-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsplit - split a multi-image
<emphasis>TIFF</emphasis>
into single-image
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsplit</command>
<emphasis>src.tif</emphasis>
[
<emphasis>prefix</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsplit</emphasis>
takes a multi-directory (page)
<emphasis>TIFF</emphasis>
file and creates one or more single-directory (page)
<emphasis>TIFF</emphasis>
files from it.
The output files are given names created by concatenating
a prefix, a lexically ordered
suffix in the range [<emphasis>aa</emphasis>-<emphasis>zz</emphasis>], the suffix
<emphasis>.tif </emphasis>
(e.g.
<emphasis>xaa.tif ,</emphasis>
<emphasis>xab.tif ,</emphasis>
\...
<emphasis>xzz.tif ).</emphasis>
If a prefix is not specified on the command line,
the default prefix of
<emphasis>x</emphasis>
is used.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para>None.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Only a select set of ``known tags'' is copied when spliting.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffcp (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>
</noslide>

<noslide>
<sect2><title>tiffsv</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffsv - save an image from the framebuffer in a
<emphasis>TIFF</emphasis>
file (Silicon Graphics version)
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffsv</command>
[
<emphasis>options</emphasis>
]
<emphasis>output.tif</emphasis>
[
<emphasis>"x1 x2 y1 y2"</emphasis>
]
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffsv</emphasis>
saves all or part of the framebuffer in a file using the
Tag Image File Format, Revision 6.0.
By default, the image is saved with data samples packed (\c
<emphasis>PlanarConfiguration =1),</emphasis>
compressed with the Lempel-Ziv &amp; Welch algorithm (\c
<emphasis>Compression =5),</emphasis>
and with each strip no more than 8 kilobytes.
These characteristics can be overriden, or explicitly specified
with the options described below.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-b</command>
Save the image as a greyscale image
as if it were processed by
<emphasis>tiff2bw (1).</emphasis>
This option is included for compatibility with the standard
<emphasis>scrsave (6D)</emphasis>
program.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
and
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression (default).
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data.
By default,
<emphasis>tiffsv</emphasis>
will create a new file with the data samples packed contiguously.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffsv</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTE</title>

<para>Except for the use of
<emphasis>TIFF,</emphasis>
this program is equivalent to the standard
<emphasis>scrsave</emphasis>
program.
This means, for example, that you can use it in conjunction with
the standard
<emphasis>icut</emphasis>
program simply by creating a link called
<emphasis>scrsave ,</emphasis>
or by creating a shell script called
<emphasis>scrsave</emphasis>
that invokes
<emphasis>tiffgt</emphasis>
with the appropriate options.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>If data are saved compressed and in separate planes, then the
rows in each strip is silently set to one to avoid limitations
in the
<emphasis>libtiff (3)</emphasis>
library.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>scrsave (6D)</emphasis>
<emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffdump (1),</emphasis>
<emphasis>tiffgt (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>
</noslide>

<noslide>
<sect2><title>tifftopnm</title>
<sect3><title>NAME</title>

<para>tifftopnm - convert a TIFF file into a portable anymap
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tifftopnm</command>
[
={alpha-filename,-}]  [
<command>--headerdump</command>
]
<emphasis>tiff-filename</emphasis>

</para>

<para></para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Reads a TIFF file as input.
Produces a portable anymap as output.
The type of the output file depends on the input file - if it's
black &amp; white, generates a
<emphasis>pbm</emphasis>
file;
if it's grayscale, generates a
<emphasis>pgm</emphasis>
file; otherwise, a
<emphasis>ppm</emphasis>
file.  The program tells you which type it is writing.

</para>

<para>This program cannot read every possible TIFF file -- there are myriad
variations of the TIFF format.  However, it does understand monochrome
and gray scale, RGB, RGBA (red/green/blue with alpha channel), CMYK
(Cyan-Magenta-Yellow-Black ink color separation), and color palette
TIFF files.  An RGB file can have either single plane (interleaved)
color or multiple plane format.  The program reads 1-8 and 16
bit-per-sample input, the latter in either bigendian or littlendian
encoding.  Tiff directory information may also be either bigendian or
littendian.

</para>

<para>One reason this program isn't as general as TIFF programs often are is
that it does not use the TIFFRGBAImageGet() function of the TIFF
library to read TIFF files.  Rather, it uses the more primitive
TIFFReadScanLine() function and decodes it itself.

</para>

<para>There is no fundamental reason that this program could not read other
kinds of TIFF files; the existing limitations are mainly because no one
has asked for more.

</para>

<para>The PNM output has the same maxval as the Tiff input, except that if
the Tiff input is colormapped (which implies a maxval of 65535) the
PNM output has a maxval of 255.  Though this may result in lost
information, such input images hardly ever actually have more color
resolution than a maxval of 255 provides and people often cannot deal
with PNM files that have maxval &gt; 255.  By contrast, a non-colormapped
Tiff image that doesn't need a maxval &gt; 255 doesn't
<emphasis>have</emphasis>
a maxval &gt; 255, so when we see a non-colormapped maxval &gt; 255, we take
it seriously and produce a matching output maxval.

</para>

<para>The
<emphasis>tiff-filename</emphasis>
argument names the regular file that contains the Tiff image.  You
cannot use Standard Input or any other special file because the Tiff
library must be able to perform seeks on it.

</para>

<para></para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>tifftopnm </command>
creates a PGM (portable graymap) file containing the alpha channel
values in the input image.  If the input image doesn't contain an
alpha channel, the
<emphasis>alpha-filename</emphasis>
file contains all zero (transparent) alpha values.  If you don't specify
<command>tifftopnm</command>
does not generate an alpha file, and if the input image has an alpha channel,
<command>tifftopnm</command>
simply discards it.

</para>

<para>If you specify
<command>-</command>
as the filename,
<command>tifftopnm</command>
writes the alpha output to Standard Output and discards the image.

</para>

<para>See
for one way to use the alpha output file.
</para>
</listitem>
<listitem>

<para><command>--headerdump</command>
Dump TIFF file information to stderr.  This information may be useful
in debugging TIFF file conversion problems.

</para>

<para>All options can be abbreviated to their shortest unique prefix.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para></para>
</sect3>
<sect3><title>AUTHOR</title>

<para>Derived by Jef Poskanzer from tif2ras.c, which is
Copyright (c) 1990 by Sun Microsystems, Inc.
Author: Patrick J. Naughton (naughton@wind.sun.com).
<!--  Permission to use, copy, modify, and distribute this software and its -->
<!--  documentation for any purpose and without fee is hereby granted, -->
<!--  provided that the above copyright notice appear in all copies and that -->
<!--  both that copyright notice and this permission notice appear in -->
<!--  supporting documentation. -->
<!--   -->
<!--  This file is provided AS IS with no warranties of any kind.  The author -->
<!--  shall have no liability with respect to the infringement of copyrights, -->
<!--  trade secrets or any patents by this file or any part thereof.  In no -->
<!--  event will the author be liable for any lost revenue or profits or -->
<!--  other special, indirect and consequential damages. -->
</para>
</sect3>
</sect2>
</noslide>
</sect1>






<sect1><title>API Man Pages</title>
<para>
It is also useful to have the man pages for the libtiff API man pages to refer to...
</para>

<slidetext>
<li>There are also extensive man pages for the API -- check yout manual
</slidetext>

<noslide>
<sect2><title>TIFFbuffer</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1995 Sam Leffler -->
<!--  Copyright (c) 1995 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadBufferSetup,
TIFFWriteBufferSetup
- I/O buffering control routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFReadBufferSetup(TIFF*, tdata_t buffer, tsize_t size);"</command>
<command>"int TIFFWriteBufferSetup(TIFF*, tdata_t buffer, tsize_t size);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>The following routines are provided for client-control of the
I/O buffers used by the library.
Applications need never use these routines; they are provided only
for ``intelligent clients'' that wish to optimize memory usage and/or
eliminate potential copy operations that can occur when working with
images that have data stored without compression.

</para>

<para><emphasis>TIFFReadBufferSetup</emphasis>
sets up the data buffer used to read raw (encoded) data from a file.
If the specified pointer is
<emphasis>NULL</emphasis>
(zero), then a buffer of the appropriate size is allocated.
Otherwise the caller must guarantee that the buffer is large
enough to hold any individual strip of raw data.
<emphasis>TIFFReadBufferSetup</emphasis>
returns a non-zero value if the setup was successful and zero otherwise.

</para>

<para><emphasis>TIFFWriteBufferSetup</emphasis>
sets up the data buffer used to write raw (encoded) data to a file.
If the specified
<emphasis>size</emphasis>
is -1 then the buffer size is selected to hold a complete
tile or strip, or at least 8 kilobytes, whichever is greater.
If the specified
<emphasis>buffer</emphasis>
is
<emphasis>NULL</emphasis>
(zero), then a buffer of the appropriate size is dynamically allocated.
<emphasis>TIFFWriteBufferSetup</emphasis>
returns a non-zero value if the setup was successful and zero otherwise.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para><emphasis>TIFFReadBufferSetup</emphasis>
was unable to dynamically allocate space for a data buffer.

</para>

<para><emphasis>TIFFWriteBufferSetup</emphasis>
was unable to dynamically allocate space for a data buffer.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFCheckTile</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFClientOpen</title>


<para>See TIFFOpen
</para>
</sect2>


<sect2><title>TIFFClose</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFClose - close a previously opened
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"void TIFFClose(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFClose</emphasis>
closes a file that was previously opened with
<emphasis>TIFFOpen (3T).</emphasis>
Any buffered data are flushed to the file, including the contents of
the current directory (if modified); and all resources
are reclaimed.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
Likewise, warning messages are directed to the
<emphasis>TIFFWarning (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFcodec</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1995 Sam Leffler -->
<!--  Copyright (c) 1995 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFFindCODEC, TIFFRegisterCODEC, TIFFUnRegisterCODEC - codec-related utility routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"const TIFFCodec* TIFFFindCODEC(uint16 scheme);"</command>
<command>"TIFFCodec* TIFFRegisterCODEC(uint16 scheme, const char* method, TIFFInitMethod init);"</command>
<command>"void TIFFUnRegisterCODEC(TIFFCodec* codec);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>libtiff</emphasis>
supports a variety of compression schemes implemented by software
<emphasis>codecs .</emphasis>
Each codec adheres to a modular interface that provides for
the decoding and encoding of image data; as well as some other
methods for initialization, setup, cleanup, and the control
of default strip and tile sizes.
Codecs are identified by the associated value of the
<emphasis>TIFF</emphasis>
<emphasis>Compression</emphasis>
tag; e.g. 5 for
<emphasis>LZW</emphasis>
compression.

</para>

<para>The
<emphasis>TIFFRegisterCODEC</emphasis>
routine can be used to
augment or override the set of codecs available to an application.
If the specified
<emphasis>scheme</emphasis>
already has a registered codec then it is
<emphasis>overridden</emphasis>
and any images with data encoded with this
compression scheme will be decoded using the supplied coded.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para><emphasis>TIFFRegisterCODEC</emphasis>
was unable to allocate memory for the data structures needed
to register a codec.

</para>

<para><emphasis>TIFFUnRegisterCODEC</emphasis>
did not locate the specified codec in the table of registered
compression schemes.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFComputeStrip</title>


<para>See TIFFstrip
</para>
</sect2>


<sect2><title>TIFFComputeTile</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFCurrentDirectory</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFCurrentRow</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFCurrentStrip</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFCurrentTile</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFDefaultStripSize</title>


<para>See TIFFstrip
</para>
</sect2>


<sect2><title>TIFFDefaultTileSize</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFError</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFError, TIFFSetErrorHandler - library error handling interface
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"void TIFFError(const char* module, const char* fmt, ...)"</command>
<command>"#include &lt;stdarg.h&gt;"</command>
<command>"typedef void (*TIFFErrorHandler)(const char* module, const char* fmt, va_list ap);"</command>
<command>"TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler handler);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFError</emphasis>
invokes the library-wide error handling function
to (normally) write an error message to the
The
<emphasis>fmt</emphasis>
parameter is a
<emphasis>printf (3S)</emphasis>
format string, and any number arguments can be supplied.
The
<emphasis>module</emphasis>
parameter, if non-zero, is printed before the message; it typically
is used to identify the software module in which an error
is detected.

</para>

<para>Applications that desire to capture control in the event of an error
should use
<emphasis>TIFFSetErrorHandler</emphasis>
to override the default error handler.
A
<emphasis>NULL</emphasis>
(0) error handling function may be installed to
suppress error messages.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFSetErrorHandler</emphasis>
returns a reference to the previous error handling function.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFWarning (3T),</emphasis>
<emphasis>printf (3S)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFFdOpen</title>


<para>See TIFFOpen
</para>
</sect2>


<sect2><title>TIFFFileName</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFFileno</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFFindCODEC</title>


<para>See TIFFcodec
</para>
</sect2>


<sect2><title>TIFFFlush</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFFlush, TIFFFlushData - flush pending writes to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFFlush(TIFF* tif)"</command>
<command>"int TIFFFlushData(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFFlush</emphasis>
causes any pending writes for the specified file (including writes
for the current directory)
to be done.
In normal operation this call is never needed- the library
automatically does any flushing required.

</para>

<para><emphasis>TIFFFlushData</emphasis>
flushes any pending image data for the specified file to be written out;
directory-related data are not flushed.
In normal operation this call is never needed- the library
automatically does any flushing required.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>0 is returned if an error is encountered, otherwise 1 is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteEncodedStrip (3T),</emphasis>
<emphasis>TIFFWriteEncodedTile (3T),</emphasis>
<emphasis>TIFFWriteRawStrip (3T),</emphasis>
<emphasis>TIFFWriteRawTile (3T),</emphasis>
<emphasis>TIFFWriteScanline (3T),</emphasis>
<emphasis>TIFFWriteTile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFFlushData</title>


<para>See TIFFFlush
</para>
</sect2>


<sect2><title>TIFFfree</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFGetField</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFGetField, TIFFVGetField - get the value(s) of a tag in an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFGetField(TIFF* tif, ttag_t tag, ...)"</command>
<command>"#include &lt;stdarg.h&gt;"</command>
<command>"int TIFFVGetField(TIFF* tif, ttag_t tag, va_list ap)"</command>
<command>"int TIFFGetFieldDefaulted(TIFF* tif, ttag_t tag, ...)"</command>
<command>"int TIFFVGetFieldDefaulted(TIFF* tif, ttag_t tag, va_list ap)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFGetField</emphasis>
returns the value of a tag or pseudo-tag associated with the
the current directory of the open
<emphasis>TIFF</emphasis>
file
<emphasis>tif .</emphasis>
(A
<emphasis>pseudo-tag </emphasis>
is a parameter that is used to control the operation of the
<emphasis>TIFF</emphasis>
library but whose value is not read or written to the underlying file.)
The file must have been previously opened with
<emphasis>TIFFOpen (3T).</emphasis>
The tag is identified by
<emphasis>tag ,</emphasis>
one of the values defined in the include file
<command>tiff.h</command>
(see also the table below).
The type and number of values returned is dependent
on the tag being requested.
The programming interface uses a variable argument list
as prescribed by the
<emphasis>stdarg (3)</emphasis>
interface.
The returned values should only be interpreted if
<emphasis>TIFFGetField</emphasis>
returns 1.

</para>

<para><emphasis>TIFFVGetField</emphasis>
is functionally equivalent to
<emphasis>TIFFGetField</emphasis>
except that it takes a pointer to a variable
argument list.
<emphasis>TIFFVGetField</emphasis>
is useful for layering interfaces on top of
the functionality provided by
<emphasis>TIFFGetField .</emphasis>

</para>

<para><emphasis>TIFFGetFieldDefaulted</emphasis>
and
<emphasis>TIFFVGetFieldDefaulted</emphasis>
are identical to
<emphasis>TIFFGetField</emphasis>
and
<emphasis>TIFFVGetField ,</emphasis>
except that if a tag is not defined in the current directory
and it has a default value, then the default value is returned.

</para>

<para>The tags understood by
<emphasis>libtiff ,</emphasis>
the number of parameter values, and the
types for the returned values are shown below.
The data types are specified as in C and correspond
to the types used to specify tag values to
<emphasis>TIFFSetField (3T).</emphasis>
Remember that
<emphasis>TIFFGetField</emphasis>
returns parameter values, so all the listed
data types are pointers to storage where values
should be returned.
Consult the
<emphasis>TIFF</emphasis>
specification for information on the meaning of
each tag and their possible values.

</para>

<para><emphasis>Tag Name</emphasis>	<emphasis>Count</emphasis>	<emphasis>Types</emphasis>	<emphasis>Notes</emphasis>
TIFFTAG_ARTIST	1	char**
TIFFTAG_BADFAXLINES	1	uint32*
TIFFTAG_BITSPERSAMPLE	1	uint16*
TIFFTAG_CLEANFAXDATA	1	uint16*
TIFFTAG_COLORMAP	3	uint16**	1&lt;&lt;BitsPerSample arrays
TIFFTAG_COMPRESSION	1	uint16*
TIFFTAG_CONSECUTIVEBADFAXLINES	1	uint32*
TIFFTAG_COPYRIGHT	1	char*
TIFFTAG_DATATYPE	1	uint16*
TIFFTAG_DATETIME	1	char**
TIFFTAG_DOCUMENTNAME	1	char**
TIFFTAG_DOTRANGE	2	uint16*
TIFFTAG_EXTRASAMPLES	2	uint16*,uint16**	count &amp; types array
TIFFTAG_FAXMODE	1	int*	G3/G4 compression pseudo-tag
TIFFTAG_FAXFILLFUNC	1	TIFFFaxFillFunc*	G3/G4 compression pseudo-tag
TIFFTAG_FILLORDER	1	uint16*
TIFFTAG_GROUP3OPTIONS	1	uint32*
TIFFTAG_GROUP4OPTIONS	1	uint32*
TIFFTAG_HALFTONEHINTS	2	uint16*
TIFFTAG_HOSTCOMPUTER	1	char**
TIFFTAG_IMAGEDEPTH	1	uint32*
TIFFTAG_IMAGEDESCRIPTION	1	char**
TIFFTAG_IMAGELENGTH	1	uint32*
TIFFTAG_IMAGEWIDTH	1	uint32*
TIFFTAG_INKNAMES	1	char**
TIFFTAG_INKSET	1	uint16*
TIFFTAG_JPEGTABLES	2	u_short*,void**	count &amp; tables
TIFFTAG_JPEGQUALITY	1	int*	JPEG pseudo-tag
TIFFTAG_JPEGCOLORMODE	1	int*	JPEG pseudo-tag
TIFFTAG_JPEGTABLESMODE	1	int*	JPEG pseudo-tag
TIFFTAG_MAKE	1	char**
TIFFTAG_MATTEING	1	uint16*
TIFFTAG_MAXSAMPLEVALUE	1	uint16*
TIFFTAG_MINSAMPLEVALUE	1	uint16*
TIFFTAG_MODEL	1	char**
TIFFTAG_ORIENTATION	1	uint16*
TIFFTAG_PAGENAME	1	char**
TIFFTAG_PAGENUMBER	2	uint16*
TIFFTAG_PHOTOMETRIC	1	uint16*
TIFFTAG_PLANARCONFIG	1	uint16*
TIFFTAG_PREDICTOR	1	uint16*
TIFFTAG_PRIMARYCHROMATICITIES	1	float**	6-entry array
TIFFTAG_REFERENCEBLACKWHITE	1	float**	2*SamplesPerPixel array
TIFFTAG_RESOLUTIONUNIT	1	uint16*
TIFFTAG_ROWSPERSTRIP	1	uint32*
TIFFTAG_SAMPLEFORMAT	1	uint16*
TIFFTAG_SAMPLESPERPIXEL	1	uint16*
TIFFTAG_SMAXSAMPLEVALUE	1	double*
TIFFTAG_SMINSAMPLEVALUE	1	double*
TIFFTAG_SOFTWARE	1	char**
TIFFTAG_STONITS	1	double**
TIFFTAG_STRIPBYTECOUNTS	1	uint32**
TIFFTAG_STRIPOFFSETS	1	uint32**
TIFFTAG_SUBFILETYPE	1	uint32*
TIFFTAG_SUBIFD	2	uint16*,uint32**	count &amp; offsets array
TIFFTAG_TARGETPRINTER	1	char**
TIFFTAG_THRESHHOLDING	1	uint16*
TIFFTAG_TILEBYTECOUNTS	1	uint32**
TIFFTAG_TILEDEPTH	1	uint32*
TIFFTAG_TILELENGTH	1	uint32*
TIFFTAG_TILEOFFSETS	1	uint32**
TIFFTAG_TILEWIDTH	1	uint32*
TIFFTAG_TRANSFERFUNCTION	1 or 3\(dg	uint16**	1&lt;&lt;BitsPerSample entry arrays
TIFFTAG_WHITEPOINT	1	float**	2-entry array
TIFFTAG_XPOSITION	1	float*
TIFFTAG_XRESOLUTION	1	float*
TIFFTAG_YCBCRCOEFFICIENTS	1	float**	3-entry array
TIFFTAG_YCBCRPOSITIONING	1	uint16*
TIFFTAG_YCBCRSUBSAMPLING	2	uint16*
TIFFTAG_YPOSITION	1	float*
TIFFTAG_YRESOLUTION	1	float*
TIFFTAG_ICCPROFILE	2	uint32*,void**	count, profile data\(dd
\(dg If
<emphasis>SamplesPerPixel</emphasis>
is one, then a single array is returned; otherwise three arrays are
returned.
\(dd The contents of this field are quite complex.  See
<emphasis>"The ICC Profile Format Specification" ,</emphasis>
Annex B.3 "Embedding ICC Profiles in TIFF Files"
(available at http://www.color.org) for an explanation.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the tag is defined in the current
directory; otherwise a 0 is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>An unknown tag was supplied.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFSetField (3T),</emphasis>
<emphasis>TIFFSetDirectory (3T),</emphasis>
<emphasis>TIFFReadDirectory (3T),</emphasis>
<emphasis>TIFFWriteDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFGetMode</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFIsByteSwapped</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFIsMSB2LSB</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFIsTiled</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFIsUpSampled</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFLastDirectory</title>


<para>See TIFFquery
</para>
</sect2>


<sect2><title>TIFFmalloc</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFmemcmp</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFmemcpy</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFmemory</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1995 Sam Leffler -->
<!--  Copyright (c) 1995 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>_TIFFmalloc, \c
_TIFFrealloc, \c
_TIFFfree, \c
_TIFFmemset, \c
_TIFFmemcpy, \c
_TIFFmemcmp, \c
- memory management-related functions for use with
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tdata_t _TIFFmalloc(tsize_t);"</command>
<command>"tdata_t _TIFFrealloc(tdata_t, tsize_t);"</command>
<command>"void _TIFFfree(tdata_t);"</command>
<command>"void _TIFFmemset(tdata_t, int, tsize_t);"</command>
<command>"void _TIFFmemcpy(tdata_t, const tdata_t, tsize_t);"</command>
<command>"int _TIFFmemcmp(const tdata_t, const tdata_t, tsize_t);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>These routines are provided for writing portable software that uses
<emphasis>libtiff ;</emphasis>
they hide any memory-management related issues, such as dealing with
segmented architectures found on 16-bit machines.

</para>

<para><emphasis>_TIFFmalloc</emphasis>
and
<emphasis>_TIFFrealloc</emphasis>
are used to dynamically allocate and reallocate memory used by
<emphasis>libtiff ;</emphasis>
such as memory passed into the I/O routines.
Memory allocated through these interfaces is released back to the
system using the
<emphasis>_TIFFfree</emphasis>
routine.

</para>

<para>Memory allocated through one of the above interfaces can be set to
a known value using
<emphasis>_TIFFmemset ,</emphasis>
copied to another memory location using
<emphasis>_TIFFmemcpy ,</emphasis>
or compared for equality using
<emphasis>_TIFFmemcmp .</emphasis>
These routines conform to the equivalent
<emphasis>ANSI</emphasis>
C routines:
<emphasis>memset ,</emphasis>
<emphasis>memcpy ,</emphasis>
and
<emphasis>memcmp ,</emphasis>
repsectively.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>malloc (3C),</emphasis>
<emphasis>memory (3C)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFmemset</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFNumberOfStrips</title>


<para>See TIFFstrip
</para>
</sect2>


<sect2><title>TIFFNumberOfTiles</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFOpen</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFOpen, TIFFFdOpen, TIFFClientOpen - open a
<emphasis>TIFF</emphasis>
file for reading or writing
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"TIFF* TIFFOpen(const char* filename, const char* mode)"</command>
<command>"TIFF* TIFFFdOpen(const int fd, const char* filename, const char* mode)"</command>
<command>"typedef tsize_t (*TIFFReadWriteProc)(thandle_t, tdata_t, tsize_t);"</command>
<command>"typedef toff_t (*TIFFSeekProc)(thandle_t, toff_t, int);"</command>
<command>"typedef int (*TIFFCloseProc)(thandle_t);"</command>
<command>"typedef toff_t (*TIFFSizeProc)(thandle_t);"</command>
<command>"typedef int (*TIFFMapFileProc)(thandle_t, tdata_t*, toff_t*);"</command>
<command>"typedef void (*TIFFUnmapFileProc)(thandle_t, tdata_t, toff_t);"</command>
<command>"TIFF* TIFFClientOpen(const char* filename, const char* mode, thandle_t clientdata,"</command>
<command>"    TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc, TIFFSeekProc seekproc,"</command>
<command>"    TIFFCloseProc closeproc, TIFFSizeProc sizeproc, TIFFMapFileProc mapproc,"</command>
<command>"    TIFFUnmapFileProc unmapproc)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFOpen</emphasis>
opens a
<emphasis>TIFF</emphasis>
file whose name is
<emphasis>filename</emphasis>
and returns a handle to be used in subsequent calls to routines in
<emphasis>libtiff .</emphasis>
If the open operation fails, then zero is returned.
The
<emphasis>mode</emphasis>
parameter specifies if the file is to be opened for reading (``r''),
writing (``w''), or appending (``a'') and, optionally, whether
to override certain default aspects of library operation (see below).
When a file is opened for appending, existing data will not
be touched; instead new data will be written as additional subfiles.
If an existing file is opened for writing, all previous data is
overwritten.

</para>

<para>If a file is opened for reading, the first
<emphasis>TIFF</emphasis>
directory in the file is automatically read
(also see
<emphasis>TIFFSetDirectory (3T)</emphasis>
for reading directories other than the first).
If a file is opened for writing or appending, a default directory
is automatically created for writing subsequent data.
This directory has all the default values specified in
<emphasis>TIFF</emphasis>
Revision 6.0:
<emphasis>BitsPerSample =1,</emphasis>
<emphasis>ThreshHolding "=bilevel art scan,"</emphasis>
<emphasis>FillOrder =1</emphasis>
(most significant bit of each data byte is filled first),
<emphasis>Orientation =1</emphasis>
(the 0th row represents the visual top of the image, and the 0th
column represents the visual left hand side),
<emphasis>SamplesPerPixel =1,</emphasis>
<emphasis>RowsPerStrip =infinity,</emphasis>
<emphasis>ResolutionUnit =2</emphasis>
(inches), and
<emphasis>Compression =1</emphasis>
(no compression).
To alter these values, or to define values for additional fields,
<emphasis>TIFFSetField (3T)</emphasis>
must be used.

</para>

<para><emphasis>TIFFFdOpen</emphasis>
is like
<emphasis>TIFFOpen</emphasis>
except that it opens a
<emphasis>TIFF</emphasis>
file given an open file descriptor
<emphasis>fd .</emphasis>
The file's name and mode must reflect that of the open descriptor.
The object associated with the file descriptor

</para>

<para><emphasis>TIFFClientOpen</emphasis>
is like
<emphasis>TIFFOpen</emphasis>
except that the caller supplies a collection of functions that the
library will use to do \s-1UNIX\s+1-like I/O operations.
The
<emphasis>readproc</emphasis>
and
<emphasis>writeproc</emphasis>
are called to read and write data at the current file position.
<emphasis>seekproc</emphasis>
is called to change the current file position a la
<emphasis>lseek (2).</emphasis>
<emphasis>closeproc</emphasis>
is invoked to release any resources associated with an open file.
<emphasis>sizeproc</emphasis>
is invoked to obtain the size in bytes of a file.
<emphasis>mapproc</emphasis>
and
<emphasis>unmapproc</emphasis>
are called to map and unmap a file's contents in memory; c.f.
<emphasis>mmap (2)</emphasis>
and
<emphasis>munmap (2).</emphasis>
The
<emphasis>clientdata</emphasis>
parameter is an opaque ``handle'' passed to the client-specified
routines passed as parameters to
<emphasis>TIFFClientOpen .</emphasis>
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para>The open mode parameter can include the following flags in
addition to the ``r'', ``w'', and ``a'' flags.
Note however that option flags must follow the read-write-append
specification.
</para>
<itemizedlist>
<listitem>

<para><command>l</command>
When creating a new file force information be written with
Little-Endian byte order (but see below).
By default the library will create new files using the native
<emphasis>CPU</emphasis>
byte order.
</para>
</listitem>
<listitem>

<para><command>b</command>
When creating a new file force information be written with
Big-Endian byte order (but see below).
By default the library will create new files using the native
<emphasis>CPU</emphasis>
byte order.
</para>
</listitem>
<listitem>

<para><command>L</command>
Force image data that is read or written to be treated with
bits filled from Least Significant Bit (\s-1LSB\s+1) to
Most Significant Bit (\s-1MSB\s+1).
Note that this is the opposite to the way the library has
worked from its inception.
</para>
</listitem>
<listitem>

<para><command>B</command>
Force image data that is read or written to be treated with
bits filled from Most Significant Bit (\s-1MSB\s+1) to
Least Significant Bit (\s-1LSB\s+1); this is the default.
</para>
</listitem>
<listitem>

<para><command>H</command>
Force image data that is read or written to be treated with
bits filled in the same order as the native
<emphasis>CPU.</emphasis>
</para>
</listitem>
<listitem>

<para><command>M</command>
Enable the use of memory-mapped files for images opened read-only.
If the underlying system does not support memory-mapped files
or if the specific image being opened cannot be memory-mapped
then the library will fallback to using the normal system interface
for reading information.
By default the library will attempt to use memory-mapped files.
</para>
</listitem>
<listitem>

<para><command>m</command>
Disable the use of memory-mapped files.
</para>
</listitem>
<listitem>

<para><command>C</command>
Enable the use of ``strip chopping'' when reading images
that are comprised of a single strip or tile of uncompressed data.
Strip chopping is a mechanism by which the library will automatically
convert the single-strip image to multiple strips,
each of which has about 8 Kilobytes of data.
This facility can be useful in reducing the amount of memory used
to read an image because the library normally reads each strip
in its entirety.
Strip chopping does however alter the apparent contents of the
image because when an image is divided into multiple strips it
looks as though the underlying file contains multiple separate
strips.
Finally, note that default handling of strip chopping is a compile-time
configuration parameter.
The default behaviour, for backwards compatibility, is to enable
strip chopping.
</para>
</listitem>
<listitem>

<para><command>c</command>
Disable the use of strip chopping when reading images.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>BYTE ORDER</title>

<para>The
<emphasis>TIFF</emphasis>
specification (<command>all versions</command>) states that compliant readers
<emphasis>"must be capable of reading images written in either byte order" .</emphasis>
Nonetheless some software that claims to support the reading of
<emphasis>TIFF</emphasis>
images is incapable of reading images in anything but the native
<emphasis>CPU</emphasis>
byte order on which the software was written.
(Especially notorious
are applications written to run on Intel-based machines.)
By default the library will create new files with the native
byte-order of the
<emphasis>CPU</emphasis>
on which the application is run.
This ensures optimal performance and is portable to any application
that conforms to the TIFF specification.
To force the library to use a specific byte-order when creating
a new file the ``b'' and ``l'' option flags may be included in
the call to open a file; for example, ``wb'' or ``wl''.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>Upon successful completion
<emphasis>TIFFOpen ,</emphasis>
<emphasis>TIFFFdOpen ,</emphasis>
and
<emphasis>TIFFClientOpen</emphasis>
return a
<emphasis>TIFF</emphasis>
pointer.
Otherwise, NULL is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
Likewise, warning messages are directed to the
<emphasis>TIFFWarning (3T)</emphasis>
routine.

</para>

<para><command>"%s": Bad mode</command>.
The specified
<emphasis>mode</emphasis>
parameter was not one of ``r'' (read), ``w'' (write), or ``a'' (append).

</para>

<para><emphasis>TIFFOpen ()</emphasis>
was unable to open the specified filename for read/writing.

</para>

<para>An error occurred while attempting to read the header information.

</para>

<para>An error occurred while writing the default header information
for a new file.

</para>

<para>The magic number in the header was not (hex)
0x4d4d or (hex) 0x4949.

</para>

<para>The version field in the header was not 42 (decimal).

</para>

<para>A file with a byte ordering opposite to the native byte
ordering of the current machine was opened for appending (``a'').
This is a limitation of the library.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFClose (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFPrintDirectory</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1991-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFPrintDirectory - print a description of a
<emphasis>TIFF</emphasis>
directory
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"void TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFPrintDirectory</emphasis>
prints a description of the current directory in the specified
<emphasis>TIFF</emphasis>
file to the standard I/O output stream
<emphasis>fd .</emphasis>
The
<emphasis>flags</emphasis>
parameter is used to control the
<emphasis>"level of detail"</emphasis>
of the printed information; it is a bit-or of the flags
defined in
#define	TIFFPRINT_NONE	0x0	/* no extra info */
#define	TIFFPRINT_STRIPS	0x1	/* strips/tiles info */
#define	TIFFPRINT_CURVES	0x2	/* color/gray response curves */
#define	TIFFPRINT_COLORMAP	0x4	/* colormap */
#define	TIFFPRINT_JPEGQTABLES	0x100	/* JPEG Q matrices */
#define	TIFFPRINT_JPEGACTABLES	0x200	/* JPEG AC tables */
#define	TIFFPRINT_JPEGDCTABLES	0x200	/* JPEG DC tables */
</para>
</sect3>
<sect3><title>NOTES</title>

<para>In C++ the
<emphasis>flags</emphasis>
parameter defaults to 0.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>None.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadDirectory (3T),</emphasis>
<emphasis>TIFFSetDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFquery</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFCurrentRow,
TIFFCurrentStrip,
TIFFCurrentTile,
TIFFCurrentDirectory,
TIFFLastDirectory,
TIFFFileno,
TIFFFileName,
TIFFGetMode,
TIFFIsTiled,
TIFFIsByteSwapped,
TIFFIsUpSampled,
TIFFIsMSB2LSB
- query routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"uint32 TIFFCurrentRow(TIFF* tif)"</command>
<command>"tstrip_t TIFFCurrentStrip(TIFF* tif)"</command>
<command>"ttile_t TIFFCurrentTile(TIFF* tif)"</command>
<command>"tdir_t TIFFCurrentDirectory(TIFF* tif)"</command>
<command>"int TIFFLastDirectory(TIFF* tif)"</command>
<command>"int TIFFFileno(TIFF* tif)"</command>
<command>"char* TIFFFileName(TIFF* tif)"</command>
<command>"int TIFFGetMode(TIFF* tif)"</command>
<command>"int TIFFIsTiled(TIFF* tif)"</command>
<command>"int TIFFIsByteSwapped(TIFF* tif)"</command>
<command>"int TIFFIsUpSampled(TIFF* tif)"</command>
<command>"int TIFFIsMSB2LSB(TIFF* tif)"</command>
<command>"const char* TIFFGetVersion(void)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>The following routines return status information about an open
<emphasis>TIFF</emphasis>
file.

</para>

<para><emphasis>TIFFCurrentDirectory</emphasis>
returns the index of the current directory (directories
are numbered starting at 0).
This number is suitable for use with the
<emphasis>TIFFSetDirectory</emphasis>
routine.

</para>

<para><emphasis>TIFFLastDirectory</emphasis>
returns a non-zero value if the current directory is the
last directory in the file;
otherwise zero is returned.

</para>

<para><emphasis>TIFFCurrentRow ,</emphasis>
<emphasis>TIFFCurrentStrip ,</emphasis>
and
<emphasis>TIFFCurrentTile ,</emphasis>
return the current row, strip, and tile, respectively,
that is being read or written.
These values are updated each time a read or write is done.

</para>

<para><emphasis>TIFFFileno</emphasis>
returns the underlying file descriptor used to access the
<emphasis>TIFF</emphasis>
image in the filesystem.

</para>

<para><emphasis>TIFFFileName</emphasis>
returns the pathname argument passed to
<emphasis>TIFFOpen</emphasis>
or
<emphasis>TIFFFdOpen .</emphasis>

</para>

<para><emphasis>TIFFGetMode</emphasis>
returns the mode with which the underlying file was opened.
On
<emphasis>UNIX</emphasis>
systems, this is the value passed to the
<emphasis>open (2)</emphasis>
system call.

</para>

<para><emphasis>TIFFIsTiled</emphasis>
returns a non-zero value if the image data has
a tiled organization.
Zero is returned if the image data is organized in strips.

</para>

<para><emphasis>TIFFIsByteSwapped</emphasis>
returns a non-zero value if the image data was in a different
byte-order than the host machine.
Zero is returned if the TIFF file and local host byte-orders
are the same.  Note that TIFFReadTile(), TIFFReadStrip() and
TIFFReadScanline() functions already normally perform byte
swapping to local host order if needed.

</para>

<para><emphasis>TIFFIsUpSampled</emphasis>
returns a non-zero value if image data returned through the
read interface routines is being up-sampled.
This can be useful to applications that want to calculate
I/O buffer sizes to reflect this usage (though the usual
strip and tile size routines already do this).

</para>

<para><emphasis>TIFFIsMSB2LSB</emphasis>
returns a non-zero value if the image data is being returned with
bit 0 as the most significant bit.

</para>

<para><emphasis>TIFFGetVersion</emphasis>
returns an
<emphasis>ASCII</emphasis>
string that has a version stamp for the
<emphasis>TIFF</emphasis>
library software.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFFdOpen (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadBufferSetup</title>


<para>See TIFFbuffer
</para>
</sect2>


<sect2><title>TIFFReadDirectory</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadDirectory - get the contents of the next directory in an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFReadDirectory(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the next directory in the specified file and make it the
current directory.
Applications only need to call
<emphasis>TIFFReadDirectory</emphasis>
to read multiple subfiles in a single
<emphasis>TIFF</emphasis>
file&mdash;
the first directory in a file is automatically read when
<emphasis>TIFFOpen</emphasis>
is called.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>If the library is compiled with
<emphasis>STRIPCHOP_SUPPORT</emphasis>
enabled, then images that have a single uncompressed strip or
tile of data are automatically treated as if they were made
up of multiple strips or tiles of approximately 8 kilobytes each.
This operation is done only in-memory; it does not alter the
contents of the file.
However, the construction of the ``chopped strips'' is visible
to the application through the number of strips [tiles]
returned by
<emphasis>TIFFNumberOfStrips</emphasis>
[\c
<emphasis>TIFFNumberOfTiles ].</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>If the next directory was successfully read, 1 is returned.
Otherwise, 0 is returned if an error was encountered,
or if there are no more directories to be read.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
All warning messages are directed to the
<emphasis>TIFFWarning (3T)</emphasis>
routine.

</para>

<para><command>Seek error accessing TIFF directory</command>.
An error occurred while positioning to the location of the
directory.

</para>

<para><command>Wrong data type %d for field "%s"</command>.
The tag entry in the directory had an incorrect data type.
For example, an
<emphasis>ImageDescription</emphasis>
tag with a
<emphasis>SHORT</emphasis>
data type.

</para>

<para><command>TIFF directory is missing required "%s" field</command>.
The specified tag is required to be present by the
<emphasis>TIFF</emphasis>
5.0 specification, but is missing.
The directory is (usually) unusable.

</para>

<para><command>%s: Rational with zero denominator</command>.
A directory tag has a
<emphasis>RATIONAL</emphasis>
value whose denominator is zero.

</para>

<para><command>Incorrect count %d for field "%s" (%lu, expecting %lu); tag ignored</command>.
The specified tag's count field is bad.
For example, a count other than 1 for a
<emphasis>SubFileType</emphasis>
tag.

</para>

<para><command>Cannot handle different per-sample values for field "%s"</command>.
The tag has
<emphasis>SamplesPerPixel</emphasis>
values and they are not all the same; e.g.
<emphasis>BitsPerSample .</emphasis>
The library is unable to handle images of this sort.

</para>

<para><command>Count mismatch for field "%s"; expecting %d, got %d</command>.
The count field in a
tag does not agree with the number expected by the library.
This should never happen, so if it does, the library refuses to
read the directory.

</para>

<para><command>Invalid TIFF directory; tags are not sorted in ascending order</command>.
The directory tags are not properly sorted as specified
in the
<emphasis>TIFF</emphasis>
5.0 specification.
This error is not fatal.

</para>

<para><command>Ignoring unknown field with tag %d (0x%x)</command>.
An unknown tag was encountered in the directory;
the library ignores all such tags.

</para>

<para><command>TIFF directory is missing requred "ImageLength" field</command>.
The image violates the specification by not having a necessary field.
There is no way for the library to recover from this error.

</para>

<para><command>TIFF directory is missing requred "PlanarConfig" field</command>.
The image violates the specification by not having a necessary field.
There is no way for the library to recover from this error.

</para>

<para><command>TIFF directory is missing requred "StripOffsets" field</command>.
The image has multiple strips, but is missing the tag that
specifies the file offset to each strip of data.
There is no way for the library to recover from this error.

</para>

<para><command>TIFF directory is missing requred "TileOffsets" field</command>.
The image has multiple tiles, but is missing the tag that
specifies the file offset to each tile of data.
There is no way for the library to recover from this error.

</para>

<para><command>TIFF directory is missing required "StripByteCounts" field</command>.
The image has multiple strips, but is missing the tag that
specifies the size of each strip of data.
There is no way for the library to recover from this error.

</para>

<para><command>TIFF directory is missing required "StripByteCounts" field, calculating from imagelength</command>.
The image violates the specification by not having a necessary field.
However, when the image is comprised of only one strip or tile, the
library will estimate the missing value based on the file size.

</para>

<para><command>Bogus "StripByteCounts" field, ignoring and calculating from imagelength</command>.
Certain vendors violate the specification by writing zero for
the StripByteCounts tag when they want to leave the value
unspecified.
If the image has a single strip, the library will estimate
the missing value based on the file size.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteDirectory (3T),</emphasis>
<emphasis>TIFFSetDirectory (3T),</emphasis>
<emphasis>TIFFSetSubDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadEncodedStrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadEncodedStrip - read and decode a strip of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFReadEncodedStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the specified strip of data and place up to
<emphasis>size</emphasis>
bytes of decompressed information in the (user supplied) data buffer.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The value of
<emphasis>strip</emphasis>
is a ``raw strip number.''
That is, the caller must take into account whether or not the
data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
To read a full strip of data the data buffer should typically be
at least as large as the number returned by
<emphasis>TIFFStripSize (3T).</emphasis>

</para>

<para>The library attempts to hide bit- and byte-ordering differences
between the image and the native machine by converting data
to the native machine order.
Bit reversal is done if the
<emphasis>FillOrder</emphasis>
tag is opposite to the native machine bit order.
16- and 32-bit samples are automatically byte-swapped if the
file was written with a byte order opposite to the native
machine byte order,
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>The actual number of bytes of data that were placed in
<emphasis>buf</emphasis>
is returned;
<emphasis>TIFFReadEncodedStrip</emphasis>
returns -1 if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadRawStrip (3T),</emphasis>
<emphasis>TIFFReadScanline (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadEncodedTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadEncodedTile - read and decode a tile of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFReadEncodedTile(TIFF* tif, u_long tile, u_char* buf, u_long size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the specified tile of data and place up to
<emphasis>size</emphasis>
bytes of decompressed information in the (user supplied) data buffer.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The value of
<emphasis>tile</emphasis>
is a ``raw tile number.''
That is, the caller must take into account whether or not the
data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
<emphasis>TIFFComputeTile</emphasis>
automatically does this when converting an (x,y,z,sample)
coordinate quadruple to a tile number.
To read a full tile of data the data buffer should be
at least as large as the value returned by
<emphasis>TIFFTileSize .</emphasis>

</para>

<para>The library attempts to hide bit- and byte-ordering differences
between the image and the native machine by converting data
to the native machine order.
Bit reversal is done if the
<emphasis>FillOrder</emphasis>
tag is opposite to the native machine bit order.
16- and 32-bit samples are automatically byte-swapped if the
file was written with a byte order opposite to the native
machine byte order,
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>The actual number of bytes of data that were placed in
<emphasis>buf</emphasis>
is returned;
<emphasis>TIFFReadEncodedTile</emphasis>
returns -1 if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadRawTile (3T),</emphasis>
<emphasis>TIFFReadTile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadRawStrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadRawStrip - return the undecoded contents
of a strip of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFReadRawStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the contents of the specified strip into the
(user supplied) data buffer.
Note that the value of
<emphasis>strip</emphasis>
is a ``raw strip number.''
That is, the caller must take into account whether or not the
data is organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
To read a full strip of data the data buffer should typically be
at least as large as the number returned by
<emphasis>TIFFStripSize .</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>The actual number of bytes of data that were placed in
<emphasis>buf</emphasis>
is returned;
<emphasis>TIFFReadEncodedStrip</emphasis>
returns -1 if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadEncodedStrip (3T),</emphasis>
<emphasis>TIFFReadScanline (3T),</emphasis>
<emphasis>TIFFStripSize (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadRawTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadRawTile - return an undecoded tile of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFReadRawTile(TIFF* tif, ttile_t tile, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the contents of the specified tile into the
(user supplied) data buffer.
Note that the value of
<emphasis>tile</emphasis>
is a ``raw tile number.''
That is, the caller must take into account whether or not the
data is organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
<emphasis>TIFFComputeTile</emphasis>
automatically does this when converting an (x,y,z,sample)
coordinate quadruple to a tile number.
To read a full tile of data the data buffer should typically be
at least as large as the value returned by
<emphasis>TIFFTileSize .</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>The actual number of bytes of data that were placed in
<emphasis>buf</emphasis>
is returned;
<emphasis>TIFFReadEncodedTile</emphasis>
returns -1 if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadEncodedTile (3T),</emphasis>
<emphasis>TIFFReadTile (3T),</emphasis>
<emphasis>TIFFTileSize (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadRGBAImage</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1991-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadRGBAImage - read and decode an image into a fixed-format raster
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"#define TIFFGetR(abgr)	((abgr) &amp; 0xff)"</command>
<command>"#define TIFFGetG(abgr)	(((abgr) &gt;&gt; 8) &amp; 0xff)"</command>
<command>"#define TIFFGetB(abgr)	(((abgr) &gt;&gt; 16) &amp; 0xff)"</command>
<command>"#define TIFFGetA(abgr)	(((abgr) &gt;&gt; 24) &amp; 0xff)"</command>
<command>"int TIFFReadRGBAImage(TIFF* tif, u_long width, u_long height, u_long* raster, int stopOnError)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFReadRGBAImage</emphasis>
reads a strip- or tile-based image into memory, storing the
result in the user supplied
<emphasis>raster .</emphasis>
The raster is assumed to be an array of
<emphasis>width</emphasis>
times
<emphasis>height</emphasis>
32-bit entries, where
<emphasis>width</emphasis>
must be less than or equal to the width of the image (\c
<emphasis>height</emphasis>
may be any non-zero size).
If the raster dimensions are smaller than the image, the image data
is cropped to the raster bounds.
If the raster height is greater than that of the image, then the
image data are placed in the lower part of the raster.
(Note that the raster is assume to be organized such that the pixel
at location (<emphasis>x</emphasis>,<emphasis>y</emphasis>) is <emphasis>raster</emphasis>[<emphasis>y</emphasis>*<emphasis>width</emphasis>+<emphasis>x</emphasis>];
with the raster origin in the lower-left hand corner.)

</para>

<para>Raster pixels are 8-bit packed red, green, blue, alpha samples.
The macros
<emphasis>TIFFGetR ,</emphasis>
<emphasis>TIFFGetG ,</emphasis>
<emphasis>TIFFGetB ,</emphasis>
and
<emphasis>TIFFGetA</emphasis>
should be used to access individual samples.
Images without Associated Alpha matting information have a constant
Alpha of 1.0 (255).

</para>

<para><emphasis>TIFFReadRGBAImage</emphasis>
converts non-8-bit images by scaling sample values.
Palette, grayscale, bilevel,
<emphasis>CMYK\c</emphasis>
, and YCbCr images are converted to
<emphasis>RGB</emphasis>
transparently.
Raster pixels are returned uncorrected by any colorimetry information
present in the directory.

</para>

<para>The paramater
<emphasis>stopOnError</emphasis>
specifies how to act if an error is encountered while reading
the image.
If
<emphasis>stopOnError</emphasis>
is non-zero, then an error will terminate the operation; otherwise
<emphasis>TIFFReadRGBAImage</emphasis>
will continue processing data until all the possible data in the
image have been requested.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>In C++ the
<emphasis>stopOnError</emphasis>
parameter defaults to 0.

</para>

<para>Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric samples/pixel must be either 1, 3, or 4 (i.e.
<emphasis>SamplesPerPixel</emphasis>
minus
<emphasis>ExtraSamples ).</emphasis>

</para>

<para>Palettte image colormaps that appear to be incorrectly written
as 8-bit values are automatically scaled to 16-bits.

</para>

<para><emphasis>TIFFReadRGBAImage</emphasis>
is just a wrapper around the more general
<emphasis>TIFFRGBAImage (3T)</emphasis>
facilities.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the image was successfully read and converted.
Otherwise, 0 is returned if an error was encountered and
<emphasis>stopOnError</emphasis>
is zero.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>The image had
<emphasis>BitsPerSample</emphasis>
other than 1, 2, 4, 8, or 16.

</para>

<para>The image had
<emphasis>SamplesPerPixel</emphasis>
other than 1, 3, or 4.

</para>

<para><command>Missing needed "PhotometricInterpretation" tag</command>.
The image did not have a tag that describes how to display
the data.

</para>

<para><command>No "PhotometricInterpretation" tag, assuming RGB</command>.
The image was missing a tag that describes how to display it,
but because it has 3 or 4 samples/pixel, it is assumed to be
<emphasis>RGB.</emphasis>

</para>

<para><command>No "PhotometricInterpretation" tag, assuming min-is-black</command>.
The image was missing a tag that describes how to display it,
but because it has 1 sample/pixel, it is assumed to be a grayscale
or bilevel image.

</para>

<para>There was insufficient memory for a table used to convert
image samples to 8-bit
<emphasis>RGB.</emphasis>

</para>

<para><command>Missing required "Colormap" tag</command>.
A Palette image did not have a required
<emphasis>Colormap</emphasis>
tag.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>The image has a format (combination of
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
and
<emphasis>PhotometricInterpretation )</emphasis>
that
<emphasis>TIFFReadRGBAImage</emphasis>
can not handle.

</para>

<para>There was insufficient memory to allocate a table used to map
grayscale data to
<emphasis>RGB.</emphasis>

</para>

<para>There was insufficient memory to allocate a table used to map
data to 8-bit
<emphasis>RGB.</emphasis>
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Orientations other than bottom-left, or top-left are
not handled correctly.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBAStrip (3T),</emphasis>
<emphasis>TIFFReadRGBATile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadRGBAStrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1991-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadRGBAStrip - read and decode an image strip into a fixed-format raster
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"#define TIFFGetR(abgr)	((abgr) &amp; 0xff)"</command>
<command>"#define TIFFGetG(abgr)	(((abgr) &gt;&gt; 8) &amp; 0xff)"</command>
<command>"#define TIFFGetB(abgr)	(((abgr) &gt;&gt; 16) &amp; 0xff)"</command>
<command>"#define TIFFGetA(abgr)	(((abgr) &gt;&gt; 24) &amp; 0xff)"</command>
<command>"int TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFReadRGBAStrip</emphasis>
reads a single strip of a strip-based image into memory,
storing the result in the user supplied RGBA
<emphasis>raster .</emphasis>
The raster is assumed to be an array of
width times rowsperstrip 32-bit entries, where width
is the width of the image (TIFFTAG_IMAGEWIDTH) and
rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).

</para>

<para>
</para>

<para>The
<emphasis>row</emphasis>
value should be the row of the first row in the strip (strip * rowsperstrip, zero based).

</para>

<para>
</para>

<para>Note that the raster is assume to be organized such that the pixel
at location (<emphasis>x</emphasis>,<emphasis>y</emphasis>) is <emphasis>raster</emphasis>[<emphasis>y</emphasis>*<emphasis>width</emphasis>+<emphasis>x</emphasis>];
with the raster origin in the
<emphasis>lower-left hand corner</emphasis>
of the strip. That is bottom to top organization.  When reading a partial
last strip in the file the last line of the image will begin at the
beginning of the buffer.

</para>

<para>
</para>

<para>Raster pixels are 8-bit packed red, green, blue, alpha samples.
The macros
<emphasis>TIFFGetR ,</emphasis>
<emphasis>TIFFGetG ,</emphasis>
<emphasis>TIFFGetB ,</emphasis>
and
<emphasis>TIFFGetA</emphasis>
should be used to access individual samples.
Images without Associated Alpha matting information have a constant
Alpha of 1.0 (255).

</para>

<para>See the
<emphasis>TIFFRGBAImage (3T) </emphasis>
page for more details on how various image types are converted to RGBA
values.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric samples/pixel must be either 1, 3, or 4 (i.e.
<emphasis>SamplesPerPixel</emphasis>
minus
<emphasis>ExtraSamples ).</emphasis>

</para>

<para>Palette image colormaps that appear to be incorrectly written
as 8-bit values are automatically scaled to 16-bits.

</para>

<para><emphasis>TIFFReadRGBAStrip</emphasis>
is just a wrapper around the more general
<emphasis>TIFFRGBAImage (3T)</emphasis>
facilities.  It's main advantage over the similar
<emphasis>TIFFReadRGBAImage() </emphasis>
function is that for large images a single
buffer capable of holding the whole image doesn't need to be allocated,
only enough for one strip.  The
<emphasis>TIFFReadRGBATile() </emphasis>
function does a similar operation for tiled images.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the image was successfully read and converted.
Otherwise, 0 is returned if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>The image had
<emphasis>BitsPerSample</emphasis>
other than 1, 2, 4, 8, or 16.

</para>

<para>The image had
<emphasis>SamplesPerPixel</emphasis>
other than 1, 3, or 4.

</para>

<para><command>Missing needed "PhotometricInterpretation" tag</command>.
The image did not have a tag that describes how to display
the data.

</para>

<para><command>No "PhotometricInterpretation" tag, assuming RGB</command>.
The image was missing a tag that describes how to display it,
but because it has 3 or 4 samples/pixel, it is assumed to be
<emphasis>RGB.</emphasis>

</para>

<para><command>No "PhotometricInterpretation" tag, assuming min-is-black</command>.
The image was missing a tag that describes how to display it,
but because it has 1 sample/pixel, it is assumed to be a grayscale
or bilevel image.

</para>

<para>There was insufficient memory for a table used to convert
image samples to 8-bit
<emphasis>RGB.</emphasis>

</para>

<para><command>Missing required "Colormap" tag</command>.
A Palette image did not have a required
<emphasis>Colormap</emphasis>
tag.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>The image has a format (combination of
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
and
<emphasis>PhotometricInterpretation )</emphasis>
that
<emphasis>TIFFReadRGBAImage</emphasis>
can not handle.

</para>

<para>There was insufficient memory to allocate a table used to map
grayscale data to
<emphasis>RGB.</emphasis>

</para>

<para>There was insufficient memory to allocate a table used to map
data to 8-bit
<emphasis>RGB.</emphasis>
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Orientations other than bottom-left, or top-left are
not handled correctly.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBATile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadRGBATile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1991-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadRGBATile - read and decode an image tile into a fixed-format raster
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"#define TIFFGetR(abgr)	((abgr) &amp; 0xff)"</command>
<command>"#define TIFFGetG(abgr)	(((abgr) &gt;&gt; 8) &amp; 0xff)"</command>
<command>"#define TIFFGetB(abgr)	(((abgr) &gt;&gt; 16) &amp; 0xff)"</command>
<command>"#define TIFFGetA(abgr)	(((abgr) &gt;&gt; 24) &amp; 0xff)"</command>
<command>"int TIFFReadRGBATile(TIFF* tif, uint32 x, uint32 y, uint32 * raster )"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFReadRGBATile</emphasis>
reads a single tile of a tile-based image into memory,
storing the result in the user supplied RGBA
<emphasis>raster .</emphasis>
The raster is assumed to be an array of
width times length 32-bit entries, where width
is the width of a tile (TIFFTAG_TILEWIDTH) and
length is the height of a tile (TIFFTAG_TILELENGTH).

</para>

<para>
</para>

<para>The
<emphasis>x</emphasis>
and
<emphasis>y</emphasis>
values are the offsets from the top left corner to the top left corner
of the tile to be read.  They must be an exact multiple of the tile
width and length.

</para>

<para>
</para>

<para>Note that the raster is assume to be organized such that the pixel
at location (<emphasis>x</emphasis>,<emphasis>y</emphasis>) is <emphasis>raster</emphasis>[<emphasis>y</emphasis>*<emphasis>width</emphasis>+<emphasis>x</emphasis>];
with the raster origin in the
<emphasis>lower-left hand corner</emphasis>
of the tile. That is bottom to top organization.  Edge tiles which
partly fall off the image will be filled out with appropriate zeroed
areas.

</para>

<para>
</para>

<para>Raster pixels are 8-bit packed red, green, blue, alpha samples.
The macros
<emphasis>TIFFGetR ,</emphasis>
<emphasis>TIFFGetG ,</emphasis>
<emphasis>TIFFGetB ,</emphasis>
and
<emphasis>TIFFGetA</emphasis>
should be used to access individual samples.
Images without Associated Alpha matting information have a constant
Alpha of 1.0 (255).

</para>

<para>See the
<emphasis>TIFFRGBAImage (3T) </emphasis>
page for more details on how various image types are converted to RGBA
values.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric samples/pixel must be either 1, 3, or 4 (i.e.
<emphasis>SamplesPerPixel</emphasis>
minus
<emphasis>ExtraSamples ).</emphasis>

</para>

<para>Palette image colormaps that appear to be incorrectly written
as 8-bit values are automatically scaled to 16-bits.

</para>

<para><emphasis>TIFFReadRGBATile</emphasis>
is just a wrapper around the more general
<emphasis>TIFFRGBAImage (3T)</emphasis>
facilities.  It's main advantage over the similar
<emphasis>TIFFReadRGBAImage() </emphasis>
function is that for large images a single
buffer capable of holding the whole image doesn't need to be allocated,
only enough for one tile.  The
<emphasis>TIFFReadRGBAStrip() </emphasis>
function does a similar operation for stripped images.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the image was successfully read and converted.
Otherwise, 0 is returned if an error was encountered.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>The image had
<emphasis>BitsPerSample</emphasis>
other than 1, 2, 4, 8, or 16.

</para>

<para>The image had
<emphasis>SamplesPerPixel</emphasis>
other than 1, 3, or 4.

</para>

<para><command>Missing needed "PhotometricInterpretation" tag</command>.
The image did not have a tag that describes how to display
the data.

</para>

<para><command>No "PhotometricInterpretation" tag, assuming RGB</command>.
The image was missing a tag that describes how to display it,
but because it has 3 or 4 samples/pixel, it is assumed to be
<emphasis>RGB.</emphasis>

</para>

<para><command>No "PhotometricInterpretation" tag, assuming min-is-black</command>.
The image was missing a tag that describes how to display it,
but because it has 1 sample/pixel, it is assumed to be a grayscale
or bilevel image.

</para>

<para>There was insufficient memory for a table used to convert
image samples to 8-bit
<emphasis>RGB.</emphasis>

</para>

<para><command>Missing required "Colormap" tag</command>.
A Palette image did not have a required
<emphasis>Colormap</emphasis>
tag.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>The image has a format (combination of
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
and
<emphasis>PhotometricInterpretation )</emphasis>
that
<emphasis>TIFFReadRGBAImage</emphasis>
can not handle.

</para>

<para>There was insufficient memory to allocate a table used to map
grayscale data to
<emphasis>RGB.</emphasis>

</para>

<para>There was insufficient memory to allocate a table used to map
data to 8-bit
<emphasis>RGB.</emphasis>
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Orientations other than bottom-left, or top-left are
not handled correctly.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBAStrip (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadScanline</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadScanline - read and decode a scanline of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFReadScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Read the data for the specified row into the (user supplied)
data buffer
<emphasis>buf .</emphasis>
The data are returned decompressed and, in the native byte-
and bit-ordering, but are otherwise packed (see further below).
The buffer must be large enough to hold an entire scanline of data.
Applications should call the routine
<emphasis>TIFFScanlineSize</emphasis>
to find out the size (in bytes) of a scanline buffer.
The
<emphasis>row</emphasis>
parameter is always used by
<emphasis>TIFFReadScanline ;</emphasis>
the
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The library attempts to hide bit- and byte-ordering differences
between the image and the native machine by converting data
to the native machine order.
Bit reversal is done if the
<emphasis>FillOrder</emphasis>
tag is opposite to the native machine bit order.
16- and 32-bit samples are automatically byte-swapped if the
file was written with a byte order opposite to the native
machine byte order,

</para>

<para>In C++ the
<emphasis>sample</emphasis>
parameter defaults to 0.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFReadScanline</emphasis>
returns -1 if it detects an error; otherwise 1 is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>Data was requested in a non-sequential order from a file that
uses a compression algorithm and that has
<emphasis>RowsPerStrip</emphasis>
greater than one.
That is, data in the image is stored in a compressed form,
and with multiple rows packed into a strip.
In this case, the library does not support random access to the data.
The data should either be accessed sequentially, or the file
should be converted so that each strip is made up of one row
of data.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Reading subsampled YCbCR data does not work correctly
because, for
<emphasis>PlanarConfiguration =2</emphasis>
the size of a scanline is not calculated on a per-sample basis,
and for
<emphasis>PlanarConfiguration =1</emphasis>
the library does not unpack the block-interleaved samples; use
the strip- and tile-based interfaces to read these formats.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadEncodedStrip (3T),</emphasis>
<emphasis>TIFFReadRawStrip (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFReadTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReadTile - read and decode a tile of data from an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFReadTile(TIFF* tif, tdata_t buf, uint32 x, uint32 y, uint32 z, tsample_t sample)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Return the data for the tile
<emphasis>containing</emphasis>
the specified coordinates.
The data placed in
<emphasis>buf</emphasis>
are returned decompressed and, typically, in the native byte-
and bit-ordering, but are otherwise packed (see further below).
The buffer must be large enough to hold an entire tile of data.
Applications should call the routine
<emphasis>TIFFTileSize</emphasis>
to find out the size (in bytes) of a tile buffer.
The
<emphasis>x</emphasis>
and
<emphasis>y</emphasis>
parameters are always used by
<emphasis>TIFFReadTile .</emphasis>
The
<emphasis>z</emphasis>
parameter is used if the image is deeper than 1 slice (\c
<emphasis>ImageDepth &gt;1).</emphasis>
The
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The library attempts to hide bit- and byte-ordering differences
between the image and the native machine by converting data
to the native machine order.
Bit reversal is done if the
<emphasis>FillOrder</emphasis>
tag is opposite to the native machine bit order.
16- and 32-bit samples are automatically byte-swapped if the
file was written with a byte order opposite to the native
machine byte order,
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFReadTile</emphasis>
returns -1 if it detects an error; otherwise the number of
bytes in the decoded tile is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFCheckTile (3T),</emphasis>
<emphasis>TIFFComputeTile (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadEncodedTile (3T),</emphasis>
<emphasis>TIFFReadRawTile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFrealloc</title>


<para>See TIFFmemory
</para>
</sect2>


<sect2><title>TIFFRegisterCODEC</title>


<para>See TIFFcodec
</para>
</sect2>


<sect2><title>TIFFReverseBits</title>


<para>See TIFFswab
</para>
</sect2>


<sect2><title>TIFFRewriteDirectory</title>


<para>See TIFFWriteDirectory
</para>
</sect2>


<sect2><title>TIFFRGBAImage</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1991-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFRGBAImage - read and decode an image into a raster
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"typedef unsigned char TIFFRGBValue;"</command>
<command>"typedef struct _TIFFRGBAImage TIFFRGBAImage;"</command>
<command>"int TIFFRGBAImageOK(TIFF* tif, char emsg[1024]);"</command>
<command>"int TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stopOnError, char emsg[1024]);"</command>
<command>"int TIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 width, uint32 height);"</command>
<command>"void TIFFRGBAImageEnd(TIFFRGBAImage* img);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>The routines described here provide a high-level interface
through which
<emphasis>TIFF</emphasis>
images may be read into memory.
Images may be strip- or tile-based and have a variety of different
characteristics: bits/sample, samples/pixel, photometric, etc.
Decoding state is encapsulated in a
<emphasis>TIFFRGBAImage</emphasis>
structure making it possible to capture state for multiple images
and quickly switch between them.
The target raster format can be customized to a particular application's
needs by installing custom routines that manipulate image data
according to application requirements.

</para>

<para>The default usage for these routines is: check if an image can
be processed using
<emphasis>TIFFRGBAImageOK ,</emphasis>
construct a decoder state block using
<emphasis>TIFFRGBAImageBegin ,</emphasis>
read and decode an image into a target raster using
<emphasis>TIFFRGBAImageGet ,</emphasis>
and then
release resources using
<emphasis>TIFFRGBAImageEnd .</emphasis>
<emphasis>TIFFRGBAImageGet</emphasis>
can be called multiple times to decode an image using different
state parameters.
If multiple images are to be displayed and there is not enough
space for each of the decoded rasters, multiple state blocks can
be managed and then calls can be made to
<emphasis>TIFFRGBAImageGet</emphasis>
as needed to display an image.

</para>

<para>The generated raster is assumed to be an array of
<emphasis>width</emphasis>
times
<emphasis>height</emphasis>
32-bit entries, where
<emphasis>width</emphasis>
must be less than or equal to the width of the image (\c
<emphasis>height</emphasis>
may be any non-zero size).
If the raster dimensions are smaller than the image, the image data
is cropped to the raster bounds.
If the raster height is greater than that of the image, then the
image data are placed in the lower part of the raster.
(Note that the raster is assume to be organized such that the pixel
at location (<emphasis>x</emphasis>,<emphasis>y</emphasis>) is <emphasis>raster</emphasis>[<emphasis>y</emphasis>*<emphasis>width</emphasis>+<emphasis>x</emphasis>];
with the raster origin in the lower-left hand corner.)

</para>

<para>Raster pixels are 8-bit packed red, green, blue, alpha samples.
The macros
<emphasis>TIFFGetR ,</emphasis>
<emphasis>TIFFGetG ,</emphasis>
<emphasis>TIFFGetB ,</emphasis>
and
<emphasis>TIFFGetA</emphasis>
should be used to access individual samples.
Images without Associated Alpha matting information have a constant
Alpha of 1.0 (255).

</para>

<para><emphasis>TIFFRGBAImageGet</emphasis>
converts non-8-bit images by scaling sample values.
Palette, grayscale, bilevel,
<emphasis>CMYK\c</emphasis>
, and YCbCr images are converted to
<emphasis>RGB</emphasis>
transparently.
Raster pixels are returned uncorrected by any colorimetry information
present in the directory.

</para>

<para>The paramater
<emphasis>stopOnError</emphasis>
specifies how to act if an error is encountered while reading
the image.
If
<emphasis>stopOnError</emphasis>
is non-zero, then an error will terminate the operation; otherwise
<emphasis>TIFFRGBAImageGet</emphasis>
will continue processing data until all the possible data in the
image have been requested.
</para>
</sect3>
<sect3><title>ALTERNATE RASTER FORMATS</title>

<para>To use the core support for reading and processing
<emphasis>TIFF</emphasis>
images, but write the resulting raster data in a different format
one need only override the ``<emphasis>put methods</emphasis>'' used to store raster data.
These methods are are defined in the
<emphasis>TIFFRGBAImage</emphasis>
structure and initially setup by
<emphasis>TIFFRGBAImageBegin</emphasis>
to point to routines that pack raster data in the default
<emphasis>ABGR</emphasis>
pixel format.
Two different routines are used according to the physical organization
of the image data in the file:
<emphasis>PlanarConfiguration =1</emphasis>
(packed samples),
and
<emphasis>PlanarConfiguration =2</emphasis>
(separated samples).
Note that this mechanism can be used to transform the data before
storing it in the raster.
For example one can convert data
to colormap indices for display on a colormap display.
</para>
</sect3>
<sect3><title>SIMULTANEOUS RASTER STORE AND DISPLAY</title>

<para>It is simple to display an image as it is being read into memory
by overriding the put methods as described above for supporting
alternate raster formats.
Simply keep a reference to the default put methods setup by
<emphasis>TIFFRGBAImageBegin</emphasis>
and then invoke them before or after each display operation.
For example, the
<emphasis>tiffgt (1)</emphasis>
utility uses the following put method to update the display as
the raster is being filled:
static void
putContigAndDraw(TIFFRGBAImage* img, uint32* raster,
    uint32 x, uint32 y, uint32 w, uint32 h,
    int32 fromskew, int32 toskew,
    unsigned char* cp)
{
    (*putContig)(img, raster, x, y, w, h, fromskew, toskew, cp);
    if (x+w == width) {
	w = width;
	if (img-&gt;orientation == ORIENTATION_TOPLEFT)
	    lrectwrite(0, y-(h-1), w-1, y, raster-x-(h-1)*w);
	else
	    lrectwrite(0, y, w-1, y+h-1, raster);
    }
}
(the original routine provided by the library is saved in the
variable
<emphasis>putContig .)</emphasis>
</para>
</sect3>
<sect3><title>SUPPORTING ADDITIONAL TIFF FORMATS</title>

<para>The
<emphasis>TIFFRGBAImage</emphasis>
routines support the most commonly encountered flavors of
<emphasis>TIFF.</emphasis>
It is possible to extend this support by overriding the ``<emphasis>get method</emphasis>''
invoked by
<emphasis>TIFFRGBAImageGet</emphasis>
to read
<emphasis>TIFF</emphasis>
image data.
Details of doing this are a bit involved, it is best to make a copy
of an existing get method and modify it to suit the needs of an
application.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric samples/pixel must be either 1, 3, or 4 (i.e.
<emphasis>SamplesPerPixel</emphasis>
minus
<emphasis>ExtraSamples ).</emphasis>

</para>

<para>Palettte image colormaps that appear to be incorrectly written
as 8-bit values are automatically scaled to 16-bits.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>All routines return
1 if the operation was successful.
Otherwise, 0 is returned if an error was encountered and
<emphasis>stopOnError</emphasis>
is zero.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>The image had
<emphasis>BitsPerSample</emphasis>
other than 1, 2, 4, 8, or 16.

</para>

<para>The image had
<emphasis>SamplesPerPixel</emphasis>
other than 1, 3, or 4.

</para>

<para><command>Missing needed "PhotometricInterpretation" tag</command>.
The image did not have a tag that describes how to display
the data.

</para>

<para><command>No "PhotometricInterpretation" tag, assuming RGB</command>.
The image was missing a tag that describes how to display it,
but because it has 3 or 4 samples/pixel, it is assumed to be
<emphasis>RGB.</emphasis>

</para>

<para><command>No "PhotometricInterpretation" tag, assuming min-is-black</command>.
The image was missing a tag that describes how to display it,
but because it has 1 sample/pixel, it is assumed to be a grayscale
or bilevel image.

</para>

<para>There was insufficient memory for a table used to convert
image samples to 8-bit
<emphasis>RGB.</emphasis>

</para>

<para><command>Missing required "Colormap" tag</command>.
A Palette image did not have a required
<emphasis>Colormap</emphasis>
tag.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>There was insufficient memory to allocate an i/o buffer.

</para>

<para>The image has a format (combination of
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
and
<emphasis>PhotometricInterpretation )</emphasis>
that can not be handled.

</para>

<para>There was insufficient memory to allocate a table used to map
grayscale data to
<emphasis>RGB.</emphasis>

</para>

<para>There was insufficient memory to allocate a table used to map
data to 8-bit
<emphasis>RGB.</emphasis>
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Orientations other than bottom-left, or top-left are
not handled correctly.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadRGBAImage (3T),</emphasis>
<emphasis>TIFFReadRGBAStrip (3T),</emphasis>
<emphasis>TIFFReadRGBATile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFRGBAImageBegin</title>


<para>See TIFFRGBAImage
</para>
</sect2>


<sect2><title>TIFFRGBAImageEnd</title>


<para>See TIFFRGBAImage
</para>
</sect2>


<sect2><title>TIFFRGBAImageGet</title>


<para>See TIFFRGBAImage
</para>
</sect2>


<sect2><title>TIFFRGBAImageOK</title>


<para>See TIFFRGBAImage
</para>
</sect2>


<sect2><title>TIFFScanlineSize</title>


<para>See TIFFsize
</para>
</sect2>


<sect2><title>TIFFSetDirectory</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFSetDirectory, TIFFSetSubDirectory - set the current directory for an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFSetDirectory(TIFF* tif, tdir_t dirnum)"</command>
<command>"int TIFFSetSubDirectory(TIFF* tif, uint32 diroff)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFSetDirectory</emphasis>
changes the current directory and reads its contents with
<emphasis>TIFFReadDirectory .</emphasis>
The parameter
<emphasis>dirnum</emphasis>
specifies the subfile/directory as an integer number, with
the first directory numbered zero.

</para>

<para><emphasis>TIFFSetSubDirectory</emphasis>
acts like
<emphasis>TIFFSetDirectory ,</emphasis>
except the directory is specified as a
file offset instead of an index; this is required for accessing
subdirectories linked through a
<emphasis>SubIFD</emphasis>
tag.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>On successful return 1 is returned.
Otherwise, 0 is returned if
<emphasis>dirnum</emphasis>
or
<emphasis>diroff</emphasis>
specifies a non-existent directory, or if an error was
encountered while reading the directory's contents.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>An error was encountered while reading the ``directory count'' field.

</para>

<para>An error was encountered while reading the ``link value'' that
points to the next directory in a file.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFCurrentDirectory (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadDirectory (3T),</emphasis>
<emphasis>TIFFWriteDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFSetErrorHandler</title>


<para>See TIFFError
</para>
</sect2>


<sect2><title>TIFFSetField</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFSetField - set the value(s) of a tag in a
<emphasis>TIFF</emphasis>
file open for writing
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFSetField(TIFF* tif, ttag_t tag, ...)"</command>
<command>"#include &lt;stdarg.h&gt;"</command>
<command>"int TIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFSetField</emphasis>
sets the value of a field
or pseudo-tag in the current directory associated with
the open
<emphasis>TIFF</emphasis>
file
<emphasis>tif .</emphasis>
(A
<emphasis>pseudo-tag </emphasis>
is a parameter that is used to control the operation of the
<emphasis>TIFF</emphasis>
library but whose value is not read or written to the underlying file.)
To set the value of a field
the file must have been previously opened for writing with
<emphasis>TIFFOpen (3T);</emphasis>
pseudo-tags can be set whether the file was opened for reading
or writing.
The field is identified by
<emphasis>tag ,</emphasis>
one of the values defined in the include file
<command>tiff.h</command>
(see also the table below).
The actual value is specified using a variable argument list,
as prescribed by the
<emphasis>stdarg (3)</emphasis>
interface (\c
or, on some machines, the
<emphasis>varargs (3)</emphasis>
interface.)

</para>

<para><emphasis>TIFFVSetField</emphasis>
is functionally equivalent to
<emphasis>TIFFSetField</emphasis>
except that it takes a pointer to a variable
argument list.
<emphasis>TIFFVSetField</emphasis>
is useful for writing routines that are layered
on top of the functionality provided by
<emphasis>TIFFSetField .</emphasis>

</para>

<para>The tags understood by
<emphasis>libtiff ,</emphasis>
the number of parameter values, and the
expected types for the parameter values are shown below.
The data types are:
<emphasis>char*</emphasis>
is null-terminated string and corresponds to the
<emphasis>ASCII</emphasis>
data type;
<emphasis>uint16</emphasis>
is an unsigned 16-bit value;
<emphasis>uint32</emphasis>
is an unsigned 32-bit value;
<emphasis>uint16*</emphasis>
is an array of unsigned 16-bit values.
<emphasis>void*</emphasis>
is an array of data values of unspecified type.

</para>

<para>Consult the
<emphasis>TIFF</emphasis>
specification for information on the meaning of each tag.

</para>

<para><emphasis>Tag Name</emphasis>	<emphasis>Count</emphasis>	<emphasis>Types</emphasis>	<emphasis>Notes</emphasis>
TIFFTAG_ARTIST	1	char*
TIFFTAG_BADFAXLINES	1	uint32
TIFFTAG_BITSPERSAMPLE	1	uint16	\(dg
TIFFTAG_CLEANFAXDATA	1	uint16
TIFFTAG_COLORMAP	3	uint16*	1&lt;&lt;BitsPerSample arrays
TIFFTAG_COMPRESSION	1	uint16	\(dg
TIFFTAG_CONSECUTIVEBADFAXLINES	1	uint32
TIFFTAG_COPYRIGHT	1	char*
TIFFTAG_DATETIME	1	char*
TIFFTAG_DOCUMENTNAME	1	char*
TIFFTAG_DOTRANGE	2	uint16
TIFFTAG_EXTRASAMPLES	2	uint16,uint16*	\(dg count &amp; types array
TIFFTAG_FAXMODE	1	int	\(dg G3/G4 compression pseudo-tag
TIFFTAG_FAXFILLFUNC	1	TIFFFaxFillFunc	G3/G4 compression pseudo-tag
TIFFTAG_FILLORDER	1	uint16	\(dg
TIFFTAG_GROUP3OPTIONS	1	uint32	\(dg
TIFFTAG_GROUP4OPTIONS	1	uint32	\(dg
TIFFTAG_HALFTONEHINTS	2	uint16
TIFFTAG_HOSTCOMPUTER	1	char*
TIFFTAG_IMAGEDESCRIPTION	1	char*
TIFFTAG_IMAGEDEPTH	1	uint32	\(dg
TIFFTAG_IMAGELENGTH	1	uint32
TIFFTAG_IMAGEWIDTH	1	uint32	\(dg
TIFFTAG_INKNAMES	1	char*
TIFFTAG_INKSET	1	uint16	\(dg
TIFFTAG_JPEGTABLES	2	uint32*,void*	\(dg count &amp; tables
TIFFTAG_JPEGQUALITY	1	int	JPEG pseudo-tag
TIFFTAG_JPEGCOLORMODE	1	int	\(dg JPEG pseudo-tag
TIFFTAG_JPEGTABLESMODE	1	int	\(dg JPEG pseudo-tag
TIFFTAG_MAKE	1	char*
TIFFTAG_MATTEING	1	uint16	\(dg
TIFFTAG_MAXSAMPLEVALUE	1	uint16
TIFFTAG_MINSAMPLEVALUE	1	uint16
TIFFTAG_MODEL	1	char*
TIFFTAG_ORIENTATION	1	uint16
TIFFTAG_PAGENAME	1	char*
TIFFTAG_PAGENUMBER	2	uint16
TIFFTAG_PHOTOMETRIC	1	uint16
TIFFTAG_PLANARCONFIG	1	uint16	\(dg
TIFFTAG_PREDICTOR	1	uint16	\(dg
TIFFTAG_PRIMARYCHROMATICITIES	1	float*	6-entry array
TIFFTAG_REFERENCEBLACKWHITE	1	float*	\(dg 2*SamplesPerPixel array
TIFFTAG_RESOLUTIONUNIT	1	uint16
TIFFTAG_ROWSPERSTRIP	1	uint32	\(dg must be &gt; 0
TIFFTAG_SAMPLEFORMAT	1	uint16	\(dg
TIFFTAG_SAMPLESPERPIXEL	1	uint16	\(dg value must be &lt;= 4
TIFFTAG_SMAXSAMPLEVALUE	1	double
TIFFTAG_SMINSAMPLEVALUE	1	double
TIFFTAG_SOFTWARE	1	char*
TIFFTAG_STONITS	1	double	\(dg
TIFFTAG_SUBFILETYPE	1	uint32
TIFFTAG_SUBIFD	2	uint16,uint32*	count &amp; offsets array
TIFFTAG_TARGETPRINTER	1	char*
TIFFTAG_THRESHHOLDING	1	uint16
TIFFTAG_TILEDEPTH	1	uint32	\(dg
TIFFTAG_TILELENGTH	1	uint32	\(dg must be a multiple of 8
TIFFTAG_TILEWIDTH	1	uint32	\(dg must be a multiple of 8
TIFFTAG_TRANSFERFUNCTION	1 or 3 \(dd	uint16*	1&lt;&lt;BitsPerSample entry arrays
TIFFTAG_XPOSITION	1	float
TIFFTAG_XRESOLUTION	1	float
TIFFTAG_WHITEPOINT	1	float*	2-entry array
TIFFTAG_YCBCRCOEFFICIENTS	1	float*	\(dg 3-entry array
TIFFTAG_YCBCRPOSITIONING	1	uint16	\(dg
TIFFTAG_YCBCRSAMPLING	2	uint16	\(dg
TIFFTAG_YPOSITION	1	float
TIFFTAG_YRESOLUTION	1	float
TIFFTAG_ICCPROFILE	2	uint32,void*	count, profile data*
\(dg Tag may not have its values changed once data is written.
\(dd
If
<emphasis>SamplesPerPixel</emphasis>
is one, then a single array is passed; otherwise three arrays should be
passed.
* The contents of this field are quite complex.  See
<emphasis>"The ICC Profile Format Specification" ,</emphasis>
Annex B.3 "Embedding ICC Profiles in TIFF Files"
(available at http://www.color.org) for an explanation.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the tag is defined in the current
directory; otherwise a 0 is returned.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned if the operation was successful.
Otherwise, 0 is returned if an error was detected.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para><command>%s: Cannot modify tag "%s" while writing</command>.
Data has already been written to the file, so the
specified tag's value can not be changed.
This restriction is applied to all tags that affect
the format of written data.

</para>

<para><command>%d: Bad value for "%s"</command>.
An invalid value was supplied for the named tag.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFGetField (3T),</emphasis>
<emphasis>TIFFSetDirectory (3T),</emphasis>
<emphasis>TIFFWriteDirectory (3T),</emphasis>
<emphasis>TIFFReadDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFSetSubDirectory</title>


<para>See TIFFSetDirectory
</para>
</sect2>


<sect2><title>TIFFSetWarningHandler</title>


<para>See TIFFWarning
</para>
</sect2>


<sect2><title>TIFFsize</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFScanlineSize,
TIFFRasterScanlineSize,
- return the size of various items associated with an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFRasterScanlineSize(TIFF* tif)"</command>
<command>"tsize_t TIFFScanlineSize(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFScanlineSize</emphasis>
returns the size in bytes of a row of data as it would be
returned in a call to
<emphasis>TIFFReadScanline ,</emphasis>
or as it would be expected in a call to
<emphasis>TIFFWriteScanline .</emphasis>

</para>

<para><emphasis>TIFFRasterScanlineSize</emphasis>
returns the size in bytes of a complete decoded and packed
raster scanline.
Note that this value may be different from the value returned by
<emphasis>TIFFScanlineSize</emphasis>
if data is stored as separate planes.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadScanline (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFstrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1992-1997 Sam Leffler -->
<!--  Copyright (c) 1992-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFDefaultStripSize,
TIFFStripSize,
TIFFVStripSize,
TIFFComputeStrip,
TIFFNumberOfStrips
- strip-related utility routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"uint32 TIFFDefaultStripSize(TIFF* tif, uint32 estimate)"</command>
<command>"tsize_t TIFFStripSize(TIFF* tif)"</command>
<command>"tsize_t TIFFVStripSize(TIFF* tif, uint32 nrows)"</command>
<command>"tstrip_t TIFFComputeStrip(TIFF* tif, uint32 row, tsample_t sample)"</command>
<command>"tstrip_t TIFFNumberOfStrips(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFDefaultStripSize</emphasis>
returns the number of rows for a reasonable-sized strip according
to the current settings of the
<emphasis>ImageWidth ,</emphasis>
<emphasis>BitsPerSample ,</emphasis>
<emphasis>SamplesPerPixel ,</emphasis>
tags and any compression-specific requirements.
If the
<emphasis>estimate</emphasis>
parameter, if non-zero, then it is taken as an estimate of the desired
strip size and adjusted according to any compression-specific requirements.
The value returned by this function is typically used to define the
<emphasis>RowsPerStrip</emphasis>
tag.
In lieu of any unusual requirements
<emphasis>TIFFDefaultStripSize</emphasis>
tries to create strips that have approximately
8 kilobytes of uncompressed data.

</para>

<para><emphasis>TIFFStripSize</emphasis>
returns the equivalent size for a strip of data as it would
be returned in a call to
<emphasis>TIFFReadEncodedStrip</emphasis>
or as it would be expected in a call to
<emphasis>TIFFWriteEncodedStrip .</emphasis>

</para>

<para><emphasis>TIFFVStripSize</emphasis>
returns the number of bytes in a strip with
<emphasis>nrows</emphasis>
rows of data.

</para>

<para><emphasis>TIFFComputeStrip</emphasis>
returns the strip that contains the specified coordinates.
A valid strip is always returned;
out-of-range coordinate values are clamped to the bounds of the image.
The
<emphasis>row</emphasis>
parameter is always used in calculating a strip.
The
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>

</para>

<para><emphasis>TIFFNumberOfStrips</emphasis>
returns the number of strips in the image.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFReadEncodedStrip (3T),</emphasis>
<emphasis>TIFFReadRawStrip (3T),</emphasis>
<emphasis>TIFFWriteEncodedStrip (3T),</emphasis>
<emphasis>TIFFWriteRawStrip (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFStripSize</title>


<para>See TIFFstrip
</para>
</sect2>


<sect2><title>TIFFswab</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFReverseBits, TIFFSwabShort, TIFFSwabLong, TIFFSwabArrayOfShort, TIFFSwabArrayOfLong - byte- and bit-swapping routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"const unsigned char* TIFFGetBitRevTable(int reversed);"</command>
<command>"void TIFFReverseBits(u_char* data, unsigned long nbytes)"</command>
<command>"void TIFFSwabShort(uint16* data)"</command>
<command>"void TIFFSwabLong(uint32* data)"</command>
<command>"void TIFFSwabArrayOfShort(uint16* data, unsigned long nshorts)"</command>
<command>"void TIFFSwabArrayOfLong(uint32* data, unsigned long nlongs)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>The following routines are used by the library to swap
16- and 32-bit data and to reverse the order of bits in bytes.

</para>

<para><emphasis>TIFFSwabShort</emphasis>
and
<emphasis>TIFFSwabLong</emphasis>
swap the bytes in a single 16-bit and 32-bit item, respectively.
<emphasis>TIFFSwabArrayOfShort</emphasis>
and
<emphasis>TIFFSwabArrayOfLong</emphasis>
swap the bytes in an array of 16-bit and 32-bit items, respectively.

</para>

<para><emphasis>TIFFReverseBits</emphasis>
replaces each byte in
<emphasis>data</emphasis>
with the equivalent bit-reversed value.
This operation is done with a lookup table,
<emphasis>TIFFBitRevTable</emphasis>
which is declared public.
A second table,
<emphasis>TIFFNoBitRevTable</emphasis>
is also declared public; it is a lookup table that
can be used as an
<emphasis>"identity function" ;</emphasis>
i.e.
<emphasis>"TIFFNoBitRevTable[n] == n" .</emphasis>
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFSwabArrayOfLong</title>


<para>See TIFFswab
</para>
</sect2>


<sect2><title>TIFFSwabArrayOfShort</title>


<para>See TIFFswab
</para>
</sect2>


<sect2><title>TIFFSwabLong</title>


<para>See TIFFswab
</para>
</sect2>


<sect2><title>TIFFSwabShort</title>


<para>See TIFFswab
</para>
</sect2>


<sect2><title>TIFFtile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFTileSize,
TIFFTileRowSize,
TIFFVTileSize,
TIFFDefaultTileSize,
TIFFComputeTile,
TIFFCheckTile,
TIFFNumberOfTiles
- tile-related utility routines
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"void TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)"</command>
<command>"tsize_t TIFFTileSize(TIFF* tif)"</command>
<command>"tsize_t TIFFTileRowSize(TIFF* tif)"</command>
<command>"tsize_t TIFFVTileSize(TIFF* tif, uint32 nrows)"</command>
<command>"ttile_t TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, tsample_t sample)"</command>
<command>"int TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, tsample_t sample)"</command>
<command>"ttile_t TIFFNumberOfTiles(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFDefaultTileSize</emphasis>
returns the pixel width and height of a reasonable-sized tile;
suitable for setting up the
<emphasis>TileWidth</emphasis>
and
<emphasis>TileLength</emphasis>
tags.
If the
<emphasis>tw</emphasis>
and
<emphasis>th</emphasis>
values passed in are non-zero, then they are adjusted to reflect
any compression-specific requirements.
The returned width and height are constrained to be a multiple
of 16 pixels to conform with the
<emphasis>TIFF</emphasis>
specification.

</para>

<para><emphasis>TIFFTileSize</emphasis>
returns the equivalent size for a tile of data as it would
be returned in a call to
<emphasis>TIFFReadTile</emphasis>
or as it would be expected in a call to
<emphasis>TIFFWriteTile .</emphasis>

</para>

<para><emphasis>TIFFVTileSize</emphasis>
returns the number of bytes in a row-aligned tile with
<emphasis>nrows</emphasis>
of data.

</para>

<para><emphasis>TIFFTileRowSize</emphasis>
returns the number of bytes of a row of data in a tile.

</para>

<para><emphasis>TIFFComputeTile</emphasis>
returns the tile that contains the specified coordinates.
A valid tile is always returned;
out-of-range coordinate values are clamped to the bounds of the image.
The
<emphasis>x</emphasis>
and
<emphasis>y</emphasis>
parameters are always used in calculating a tile.
The
<emphasis>z</emphasis>
parameter is used if the image is deeper than 1 slice (\c
<emphasis>ImageDepth &gt;1).</emphasis>
The
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>

</para>

<para><emphasis>TIFFCheckTile</emphasis>
returns a non-zero value if the supplied coordinates are
within the bounds of the image and zero otherwise.
The
<emphasis>x</emphasis>
parameter is checked against the value of the
<emphasis>ImageWidth</emphasis>
tag.
The
<emphasis>y</emphasis>
parameter is checked against the value of the
<emphasis>ImageLength</emphasis>
tag.
The
<emphasis>z</emphasis>
parameter is checked against the value of the
<emphasis>ImageDepth</emphasis>
tag (if defined).
The
<emphasis>sample</emphasis>
parameter is checked against the value of the
<emphasis>SamplesPerPixel</emphasis>
parameter if the data are organized in separate planes.

</para>

<para><emphasis>TIFFNumberOfTiles</emphasis>
returns the number of tiles in the image.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>None.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFReadEncodedTile (3T),</emphasis>
<emphasis>TIFFReadRawTile (3T),</emphasis>
<emphasis>TIFFReadTile (3T),</emphasis>
<emphasis>TIFFWriteEncodedTile (3T),</emphasis>
<emphasis>TIFFWriteRawTile (3T),</emphasis>
<emphasis>TIFFWriteTile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFTileRowSize</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFTileSize</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFUnRegisterCODEC</title>


<para>See TIFFcodec
</para>
</sect2>


<sect2><title>TIFFVGetField</title>


<para>See TIFFGetField
</para>
</sect2>


<sect2><title>TIFFVSetField</title>


<para>See TIFFSetField
</para>
</sect2>


<sect2><title>TIFFVStripSize</title>


<para>See TIFFstrip
</para>
</sect2>


<sect2><title>TIFFVTileSize</title>


<para>See TIFFtile
</para>
</sect2>


<sect2><title>TIFFWarning</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWarning, TIFFSetWarningHandler - library warning interface
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"void TIFFWarning(const char* module, const char* fmt, ...)"</command>
<command>"#include &lt;stdargh.h&gt;"</command>
<command>"typedef void (*TIFFWarningHandler)(const char* module, const char* fmt, va_list ap);"</command>
<command>"TIFFWarningHandler TIFFSetWarningHandler(TIFFWarningHandler handler);"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFWarning</emphasis>
invokes the library-wide warning handler function
to (normally) write a warning message to the
The
<emphasis>fmt</emphasis>
parameter is a
<emphasis>printf (3S)</emphasis>
format string, and any number arguments can be supplied.
The
<emphasis>module</emphasis>
parameter is interpreted as a string that, if non-zero,
should be printed before the message; it typically
is used to identify the software module in which a warning
is detected.

</para>

<para>Applications that desire to capture control in the event of a warning
should use
<emphasis>TIFFSetWarningHandler</emphasis>
to override the default warning handler.
A
<emphasis>NULL</emphasis>
(0) warning handler function may be installed to
suppress error messages.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFSetWarningHandler</emphasis>
returns a reference to the previous error handling function.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFError (3T),</emphasis>
<emphasis>printf (3S)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteBufferSetup</title>


<para>See TIFFbuffer
</para>
</sect2>


<sect2><title>TIFFWriteDirectory</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWriteDirectory, TIFFRewriteDirectory - write the current directory in an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFWriteDirectory(TIFF* tif)"</command>
<command>"int TIFFRewriteDirectory(TIFF* tif)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>TIFFWriteDirectory </emphasis>
will write the contents of the current directory to the file and setup
to create a new subfile in the same file.
Applications only need to call
<emphasis>TIFFWriteDirectory</emphasis>
when writing multiple subfiles to a single
<emphasis>TIFF</emphasis>
file.
<emphasis>TIFFWriteDirectory</emphasis>
is automatically called by
<emphasis>TIFFClose</emphasis>
and
<emphasis>TIFFFlush</emphasis>
to write a modified directory if the file is open for writing.

</para>

<para>The
<emphasis>TIFFRewriteDirectory</emphasis>
function operates similarly to
<emphasis>TIFFWriteDirectory</emphasis>
but can be called with directories previously read or written that already
have an established location in the file.  It will rewrite the directory,
but instead of place it at it's old location (as
<emphasis>TIFFWriteDirectory</emphasis>
would) it will place them at the end of the file, correcting the pointer from
the preceeding directory or file header to point to it's new location.  This
is particularly important in cases where the size of the directory and
pointed to data has grown, so it won't fit in the space available at the
old location.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>1 is returned when the contents are successfully
written to the file.
Otherwise, 0 is returned if an error was encountered when writing
the directory contents.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>Before writing the contents of the current directory, any pending
data are flushed.
This message indicates that an error occurred while doing this.

</para>

<para>Before writing the contents of the current directory, any pending
data are flushed.
This message indicates that an error occurred while doing this.

</para>

<para>There was not enough space to allocate a temporary area for
the directory that was to be written.

</para>

<para>A write error occurred when writing the count of fields in the directory.

</para>

<para>A write error occurred when writing the directory fields.

</para>

<para>A write error occurred when writing the link to the next directory.

</para>

<para><command>Error writing data for field "%s"</command>.
A write error occurred when writing indirect data for the specified field.

</para>

<para>A write error occurred when re-writing header at the front of the file.

</para>

<para>A read error occurred when fetching the directory count field for
a previous directory.
This can occur when setting up a link to the directory that is being
written.

</para>

<para>A read error occurred when fetching the directory link field for
a previous directory.
This can occur when setting up a link to the directory that is being
written.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFError (3T),</emphasis>
<emphasis>TIFFReadDirectory (3T),</emphasis>
<emphasis>TIFFSetDirectory (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteEncodedStrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWritedEncodedStrip - compress and write a strip of data to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFWriteEncodedStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Compress
<emphasis>size</emphasis>
bytes of raw data from
<emphasis>buf</emphasis>
and write the result to the specified strip; replacing
any previously written data.
Note that the value of
<emphasis>strip</emphasis>
is a ``raw strip number.''
That is, the caller must take into account whether or not the
data are organized in separate places (\c
<emphasis>PlanarConfiguration =2).</emphasis>
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The library writes encoded data using the native machine byte order.
Correctly implemented
<emphasis>TIFF</emphasis>
readers are expected to do any necessary byte-swapping to
correctly process image data with BitsPerSample greater than 8.

</para>

<para>The strip number must be valid according to the current settings
of the
<emphasis>ImageLength</emphasis>
and
<emphasis>RowsPerStrip</emphasis>
tags.
An image may be dynamically grown by increasing the value of
<emphasis>ImageLength</emphasis>
prior to each call to
<emphasis>TIFFWriteEncodedStrip .</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>-1 is returned if an error was encountered.
Otherwise, the value of
<emphasis>size</emphasis>
is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para><command>%s: File not open for writing</command>.
The file was opened for reading, not writing.

</para>

<para><command>Can not write scanlines to a tiled image</command>.
The image is assumed to be organized in tiles because the
<emphasis>TileWidth</emphasis>
and
<emphasis>TileLength</emphasis>
tags have been set with
<emphasis>TIFFSetField (3T).</emphasis>

</para>

<para><command>%s: Must set "ImageWidth" before writing data</command>.
The image's width has not be set before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: Must set "PlanarConfiguration" before writing data</command>.
The organization of data has not be defined before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: No space for strip arrays"</command>.
There was not enough space for the arrays that hold strip
offsets and byte counts.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteScanline (3T),</emphasis>
<emphasis>TIFFWriteRawStrip (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteEncodedTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWritedEncodedTile - compress and write a tile of data to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFWriteEncodedTile(TIFF* tif, ttile_t tile, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Compress
<emphasis>size</emphasis>
bytes of raw data from
<emphasis>buf</emphasis>
and
<command>append</command>
the result to the end of the specified tile.
Note that the value of
<emphasis>tile</emphasis>
is a ``raw tile number.''
That is, the caller must take into account whether or not the
data are organized in separate places (\c
<emphasis>PlanarConfiguration =2).</emphasis>
<emphasis>TIFFComputeTile</emphasis>
automatically does this when converting an (x,y,z,sample)
coordinate quadruple to a tile number.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The library writes encoded data using the native machine byte order.
Correctly implemented
<emphasis>TIFF</emphasis>
readers are expected to do any necessary byte-swapping to
correctly process image data with BitsPerSample greater than 8.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>-1 is returned if an error was encountered.
Otherwise, the value of
<emphasis>size </emphasis>
is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para><command>%s: File not open for writing</command>.
The file was opened for reading, not writing.

</para>

<para><command>Can not write tiles to a stripped image</command>.
The image is assumed to be organized in strips because neither of the
<emphasis>TileWidth</emphasis>
or
<emphasis>TileLength</emphasis>
tags have been set with
<emphasis>TIFFSetField (3T).</emphasis>

</para>

<para><command>%s: Must set "ImageWidth" before writing data</command>.
The image's width has not be set before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: Must set "PlanarConfiguration" before writing data</command>.
The organization of data has not be defined before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: No space for tile arrays"</command>.
There was not enough space for the arrays that hold tile
offsets and byte counts.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteTile (3T),</emphasis>
<emphasis>TIFFWriteRawTile (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteRawStrip</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWriteRawStrip - write a strip of raw data to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFWriteRawStrip(TIFF* tif, tstrip_t strip, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Append
<emphasis>size</emphasis>
bytes of raw data to the specified strip.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The strip number must be valid according to the current settings
of the
<emphasis>ImageLength</emphasis>
and
<emphasis>RowsPerStrip</emphasis>
tags.
An image may be dynamically grown by increasing the value of
<emphasis>ImageLength</emphasis>
prior to each call to
<emphasis>TIFFWriteRawStrip .</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>-1 is returned if an error occurred.
Otherwise, the value of
<emphasis>size </emphasis>
is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para><command>%s: File not open for writing</command>.
The file was opened for reading, not writing.

</para>

<para><command>Can not write scanlines to a tiled image</command>.
The image is assumed to be organized in tiles because the
<emphasis>TileWidth</emphasis>
and
<emphasis>TileLength</emphasis>
tags have been set with
<emphasis>TIFFSetField (3T).</emphasis>

</para>

<para><command>%s: Must set "ImageWidth" before writing data</command>.
The image's width has not be set before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: Must set "PlanarConfiguration" before writing data</command>.
The organization of data has not be defined before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: No space for strip arrays"</command>.
There was not enough space for the arrays that hold strip
offsets and byte counts.

</para>

<para><command>%s: Strip %d out of range, max %d</command>.
The specified strip is not a valid strip according to the
currently specified image dimensions.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteEncodedStrip (3T),</emphasis>
<emphasis>TIFFWriteScanline (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteRawTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWriteRawTile - write a tile of raw data to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFWriteRawTile(TIFF* tif, ttile_t tile, tdata_t buf, tsize_t size)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Append
<emphasis>size</emphasis>
bytes of raw data to the specified tile.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para>-1 is returned if an error occurred.
Otherwise, the value of
<emphasis>size </emphasis>
is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para><command>%s: File not open for writing</command>.
The file was opened for reading, not writing.

</para>

<para><command>Can not write tiles to a stripped image</command>.
The image is assumed to be organized in strips because neither of the
<emphasis>TileWidth</emphasis>
or
<emphasis>TileLength</emphasis>
tags have been set with
<emphasis>TIFFSetField (3T).</emphasis>

</para>

<para><command>%s: Must set "ImageWidth" before writing data</command>.
The image's width has not be set before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: Must set "PlanarConfiguration" before writing data</command>.
The organization of data has not be defined before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: No space for tile arrays"</command>.
There was not enough space for the arrays that hold tile
offsets and byte counts.

</para>

<para><command>%s: Specified tile %d out of range, max %d</command>.
The specified tile is not valid according to the currently
specified image dimensions.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteEncodedTile (3T),</emphasis>
<emphasis>TIFFWriteScanline (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteScanline</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWriteScanline - write a scanline to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"int TIFFWriteScanline(TIFF* tif, tdata_t buf, uint32 row, tsample_t sample)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Write data to a file at the specified row.
The
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
The data are assumed to be uncompressed and in the native
bit- and byte-order of the host machine.
The data written to the file is
compressed according to the compression scheme
of the current
<emphasis>TIFF</emphasis>
directory (see further below).
If the current scanline is past the end of the current subfile, the
<emphasis>ImageLength</emphasis>
field is automatically increased to include the scanline (except
for
<emphasis>PlanarConfiguration =2,</emphasis>
where the
<emphasis>ImageLength</emphasis>
cannot be changed once the first data are written).
If the
<emphasis>ImageLength</emphasis>
is increased, the
<emphasis>StripOffsets</emphasis>
and
<emphasis>StripByteCounts</emphasis>
fields are similarly enlarged to reflect data written past the
previous end of image.
</para>
</sect3>
<sect3><title>NOTES</title>

<para>The library writes encoded data using the native machine byte order.
Correctly implemented
<emphasis>TIFF</emphasis>
readers are expected to do any necessary byte-swapping to
correctly process image data with BitsPerSample greater than 8.
The library attempts to hide bit-ordering differences
between the image and the native machine by converting data
from the native machine order.

</para>

<para>In C++ the
<emphasis>sample</emphasis>
parameter defaults to 0.

</para>

<para>Once data are written to a file for the current directory,
the values of certain tags may not be altered; see
<emphasis>TIFFSetField (3T)</emphasis>
for more information.

</para>

<para>It is not possible to write scanlines to a file that
uses a tiled organization.  The routine
<emphasis>TIFFIsTiled</emphasis>
can be used to determine if the file is organized
as tiles or strips.
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFWriteScanline</emphasis>
returns -1 if it immediately detects an error
and 1 for a successful write.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.

</para>

<para>The file was opened for reading, not writing.

</para>

<para>An attempt was made to write a scanline to a tiled image.
The image is assumed to be organized in tiles because the
<emphasis>TileWidth</emphasis>
and
<emphasis>TileLength</emphasis>
tags have been set with
<emphasis>TIFFSetField (3T).</emphasis>

</para>

<para>Data was written in a non-sequential order to a file that
uses a compression algorithm and that has
<emphasis>RowsPerStrip</emphasis>
greater than one.
That is, data in the image is to be stored in a compressed form,
and with multiple rows packed into a strip.
In this case, the library does not support random access to the data.
The data should either be written as entire strips,
sequentially by rows, or the value of
<emphasis>RowsPerStrip</emphasis>
should be set to one.

</para>

<para><command>%s: Must set "ImageWidth" before writing data</command>.
The image's width has not be set before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>%s: Must set "PlanarConfiguration" before writing data</command>.
The organization of data has not be defined before the first write.
See
<emphasis>TIFFSetField (3T)</emphasis>
for information on how to do this.

</para>

<para><command>Can not change "ImageLength" when using separate planes</command>.
Separate image planes are being used (\c
<emphasis>PlanarConfiguration =2),</emphasis>
but the number of rows has not been specified before the first write.
The library supports the dynamic growth of an image only when data
are organized in a contiguous manner (\c
<emphasis>PlanarConfiguration =1).</emphasis>

</para>

<para>The
<emphasis>sample</emphasis>
parameter was greater than the value of the SamplesPerPixel tag.

</para>

<para>There was not enough space for the arrays that hold strip
offsets and byte counts.
</para>
</sect3>
<sect3><title>BUGS</title>

<para>Writing subsampled YCbCR data does not work correctly
because, for
<emphasis>PlanarConfiguration =2</emphasis>
the size of a scanline is not calculated on a per-sample basis,
and for
<emphasis>PlanarConfiguration =1</emphasis>
the library does not pack the block-interleaved samples.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFWriteEncodedStrip (3T),</emphasis>
<emphasis>TIFFWriteRawStrip (3T)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>TIFFWriteTile</title>
<!--  $Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.7 2002-08-29 05:17:08 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>TIFFWriteTile - encode and write a tile of data to an open
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>"#include &lt;tiffio.h&gt;"</command>
<command>"tsize_t TIFFWriteTile(TIFF* tif, tdata_t buf, uint32 x, uint32 y, uint32 z, tsample_t sample)"</command>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>Write the data for the tile
<emphasis>containing</emphasis>
the specified coordinates.
The data in
<emphasis>buf</emphasis>
are is (potentially) compressed, and written to the indicated file, normally
being appended to the end of the file.
The buffer must be contain an entire tile of data.
Applications should call the routine
<emphasis>TIFFTileSize</emphasis>
to find out the size (in bytes) of a tile buffer.
The
<emphasis>x</emphasis>
and
<emphasis>y</emphasis>
parameters are always used by
<emphasis>TIFFWriteTile .</emphasis>
The
<emphasis>z</emphasis>
parameter is used if the image is deeper than 1 slice (\c
<emphasis>ImageDepth &gt;1).</emphasis>
The
<emphasis>sample</emphasis>
parameter is used only if data are organized in separate planes (\c
<emphasis>PlanarConfiguration =2).</emphasis>
</para>
</sect3>
<sect3><title>RETURN VALUES</title>

<para><emphasis>TIFFWriteTile</emphasis>
returns -1 if it detects an error; otherwise the number of
bytes in the tile is returned.
</para>
</sect3>
<sect3><title>DIAGNOSTICS</title>

<para>All error messages are directed to the
<emphasis>TIFFError (3T)</emphasis>
routine.
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>libtiff (3T),</emphasis>
<emphasis>TIFFCheckTile (3T),</emphasis>
<emphasis>TIFFComputeTile (3T),</emphasis>
<emphasis>TIFFOpen (3T),</emphasis>
<emphasis>TIFFReadTile (3T),</emphasis>
<emphasis>TIFFWriteScanline (3T),</emphasis>
<emphasis>TIFFWriteEncodedTile (3T),</emphasis>
<emphasis>TIFFWriteRawTile (3T)</emphasis>
</para>
</sect3>
</sect2>
</sect1>
</noslide>









<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>

<slidetext>
<li>In the early stages of this tutorial I showed you a pixel enlargement...
<li>Here's the code that did that
</slidetext>

<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

#define EOFFSET 150

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2, xs = 0, ys = 0, xe = -1, ye = -1;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    *enlarged, *rout, optchar;
  int xrep, yrep;
  float m;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'x':
	  xs = atoi (optarg);
	  break;

	case 'y':
	  ys = atoi (optarg);
	  break;

	case 'w':
	  xe = xs + atoi (optarg);
	  break;

	case 'l':
	  ye = ys + atoi (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Make sure we have reasonable defaults
  if (xe == -1)
    xe = xs + 10;

  if (ye == -1)
    ye = ys + 10;

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  // Sanity check some of our arguements
  if (xe &gt; width)
    {
      fprintf (stderr,
	       "You choice of starting x position, or width, results in the enlargement falling off the edge of the input image\n");
      usage (argv[0], 43);
    }

  if (ye &gt; height)
    {
      fprintf (stderr,
	       "You choice of starting y position, or length, results in the enlargement falling off the end of the input image\n");
      usage (argv[0], 43);
    }

  printf ("Enlarging a %d by %d portion of the image\n", xe - xs, ye - ys);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  // todo: crap assumption about the data being 8 bps, 3 spp
  if ((enlarged = (char *) malloc (sizeof (char) * (xe - xs) * (ye - ys) * 3 *
				   121)) == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  if ((rout = (char *) malloc (sizeof (char) * (width + EOFFSET) * height * 3))
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for output raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width + EOFFSET);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Actually do the enlargement of the portion of the image specified
  offset = offset2 = 0;
  for (y = ys; y &lt; ye; y++)
    {
      for (yrep = 0; yrep &lt; 10; yrep++)
	{
	  for (x = xs; x &lt; xe; x++)
	    {
	      offset = (x + (y * width)) * 3;
	      for (xrep = 0; xrep &lt; 10; xrep++)
		{
		  memcpy (enlarged + offset2, raster + offset, 3);
		  offset2 += 3;
		}

	      // The white border to the left of the pixel
	      memset (enlarged + offset2, 255, 3);
	      offset2 += 3;
	    }
	}

      // The white line at the bottom of these pixels
      memset (enlarged + offset2, 255, (ye - ys) * 3 * 11);
      offset2 += (ye - ys) * 3 * 11;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Now we assemble the two parts of the image together into a big output
  // raster
  memset (rout, 255, sizeof (char) * (width + EOFFSET) * height * 3);

  // The original image
  offset = 0;
  offset2 = 0;
  for (y = 0; y &lt; height; y++)
    {
      memcpy (rout + offset2, raster + offset, width * 3);
      offset += width * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  // Box the bit that was enlarged in the original image, can't use memset here
  // Top line
  offset = (((width + EOFFSET) * (ys - 1)) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Bottom line
  offset = (((width + EOFFSET) * ye) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Vertical lines
  offset = (((width + EOFFSET) * ys) + xs - 1) * 3;
  for (y = 0; y &lt; ye - ys + 1; y++)
    {
      rout[offset] = 255;
      rout[offset + 1] = 0;
      rout[offset + 2] = 0;

      rout[offset + ((ye - ys + 1) * 3)] = 255;
      rout[offset + ((ye - ys + 1) * 3) + 1] = 0;
      rout[offset + ((ye - ys + 1) * 3) + 2] = 0;

      offset += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Box the enlarged portion of the image

  /////////////////////////////////////////////////////////////////////////////
  // Draw the two diagonal lines between the original and the enlarged
  //    this bit is based on the premis that y = mx + b
  //    and m = (y2 - y1) / (x2 - x1) and that geometry hasn't significantly
  //    changed since my high school days
  //
  //    if we assume that the first point is the origin, then the maths is
  //    even easier
  // 
  //    which I think is probably a fairly safe set of assumptions at this
  //    stage...
  // todo
  //  printf("ye = %d, xe = %d\n", ye, xe);
  //  m = (ye - ys) / (xe - xs);
  //  for(x = 0; x &lt; (xe - xs); x++){
  //    y = m * x;
  //    
  //    printf("%d, %d (%f = %f)\n", x, y, m, ye / xe);
  //  }

  /////////////////////////////////////////////////////////////////////////////
  // Copy the enlarged portion across

  offset = 0;
  offset2 = (((((height / 2) - ((ye - ys) * 11 / 2)) *
	       (width + EOFFSET)) + width + 20) * 3);
  for (y = 0; y &lt; (ye - ys) * 11; y++)
    {
      memcpy (rout + offset2, enlarged + offset, (ye - ys) * 11 * 3);
      offset += (ye - ys) * 11 * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     (width + EOFFSET) * height * 3 * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (enlarged);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -x &lt;start x&gt; -y &lt;start y&gt; -w &lt;width&gt; -l &lt;length&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-pixels/pixel.c</emphasis></para>
</slideinclude>
</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>

<slidetext>
<li>Earlier on I also promised some grayscale conversion code...
</slidetext>

<sect2><title>A broken algorithm</title>
<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.333 + 
		       (unsigned char) (raster[offset + 1]) * 0.333 + 
		       (unsigned char) (raster[offset + 2]) * 0.333);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-wrong.c</emphasis></para>
</slideinclude>

<para>
Which produces:
</para>

<figure><title>An average of the color values for each pixel</title>
<graphic format="jpg" fileref="gen-grayscale-figure2.jpg">
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>
<slideinclude>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.299 + 
		       (unsigned char) (raster[offset + 1]) * 0.587 + 
		       (unsigned char) (raster[offset + 2]) * 0.114);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-good.c</emphasis></para>
</slideinclude>

<para>
Which gives us:
</para>

<figure><title>A correct conversion to gray scale</title>
<graphic format="jpg" fileref="gen-grayscale-figure3.jpg">
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>

<noslide>
<sect1><title>Example: Repeated compression</title>
<para>
Earlier in this chapter I promised that I would include the code for the repeated compression loss example, so here it is. The example is made up of a simple (and quite ugly) shell script, and a c program to actually compress the images...
</para>

<programlisting>
#!/bin/bash

count=1
cp $1 $1-0.tif

while [ $count -lt 200 ]
do
  ./read $1-$(( $count -1 )).tif $1-$count.tif
  count=$(( $count + 1 ))
done
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.sh</emphasis></para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image, *output;
  uint16 photo, bps, spp, fillorder;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;
  char *raster2;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Open the output image
  if((output = TIFFOpen(argv[2], "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  if((raster2 = (char *) malloc(sizeof(char) * imagesize * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      raster2[d++] = TIFFGetR(raster[e * width + c]);
      raster2[d++] = TIFFGetG(raster[e * width + c]);
      raster2[d++] = TIFFGetB(raster[e * width + c]);
    }
  }

  // Recompress it straight away -- set the tags we require
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);
  TIFFSetField(output, TIFFTAG_JPEGQUALITY, 25);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster2, imagesize * 3) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  TIFFClose(output);
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-recompress/recompress.c</emphasis></para>
</sect1>
</noslide>

<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed the TIFF file format, how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>

<slidetext>
<li>So what have we learnt?
  <ul>
  <li>Something about the TIFF file format
  <li>Black and white images with libtiff
  <li>Color images with libtiff
  <li>You should now have enough information to at least start to use libtiff...
  </ul>
</slidetext>
</sect1>

<noslide>
<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libtiff.org: The libtiff website is a good place to download the libtiff source. It is also quite likely there is a binary package for your chosen operating system.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: If all else fails, then the Adobe TIFF Specification can be useful.</para></listitem>

<listitem><para>http://gopher.std.com/homepages/jimf/xloadimage.html: The xloadimage web page might be of interest.</para></listitem>

<listitem><para>http://www.ee.cooper.edu/courses/course_pages/past_courses/EE458/TIFF/index.html: The Cooper Union for the Advancement of Science and Art has some notes from a previous course dealing with libtiff online.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/graphics/graphics.html: The Adobe Graphics technical notes page is quite useful.</para></listitem>

<listitem><para>http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf: The current version of the TIFF specification can be found here.</para></listitem>

<listitem><para>http://home.earthlink.net/~ritter/tiff/: The unofficial TIFF site contains some useful resources.</para></listitem>

<listitem><para>http://www.inforamp.net/~poynton/notes/colour_and_gamma/ColorFAQ.html: a FAQ document discussion of converting to gray scale</para></listitem>
</itemizedlist>
</para>
</sect1>
</noslide>

<sect1><title>Portions first published by IBM DeveloperWorks</title>
<slideinclude>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</slideinclude>
</sect1>
</chapter>
<chapter id="chap-gif"><title>GIF</title>
<slideinclude>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>
</slideinclude>

<slidebreak>
<slideinclude>
<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>
</slideinclude>







<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
</para>

<slidetext>
<li>The GIF format is quite simple -- the entire specification is only a few pages
<li>We only describe the format
<li>Mainly because it will help with the explaination of PNG
</slidetext>

<noslide>
<sidebar><title>Data streams?</title>
<para>
It should be noted that the GIF specification doesn't speak of files as such. Instead it uses the term <quote>Data Stream</quote>, which is a concept which embraces files, as well as in memory buffers, and other interesting forms of data storage. It doesn't really make any difference to the discussion of the format here though.
</para>
</sidebar>
</noslide>

<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>

<slidetext>
<li>We're going to refer to the term data stream a bit in the coming slides...
<li>The GIF specification doesn't refer to files
<li>The equivalent concept is a data stream
<li>A data stream doesn't have to be a file
</slidetext>
</sect2>

<sect2><title>The header</title>
<slideinclude>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>
<slideinclude>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>

<slidetext>
<li>Version number options are:
  <ul>
</slidetext>

<slideinclude>
<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>
</slideinclude>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>

<slidetext>
<li>The GIF specification states that the image generator should use the lowest version number possible
<li>Whilst still having the image make sense
<li>This makes the generation of images a little more complex
<li>It ensures the maximum backwards compatability
</slidetext>

<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>

<slidetext>
<BR><BR>
<li>The version number in the header identifies the minimum set of capabilities required to view that image
</slidetext>
</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>

<slidetext>
<li>The logical screen is the area on which the image will be painted
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>
</slideinclude>

<slidebreak>
<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>

<slidetext>
<li>The packed fields in byte 4 are:
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>

<slidebreak>
<slidetext>
<li><i>
</slidetext>
<para>
<slideinclude>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</slideinclude>
</para>

<slidetext>
</i>
</slidetext>

<sect3><title>Formula for global color table size</title>
<para>
To determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</emphasis>, or 255 items.
</para>

<slidetext>
<pre>
size of global color table = 2 ^ (size in table + 1)
</pre>

<li>The maximum size is therefore:

<pre>
2 ^ (7 + 1)
</pre>

<li>Which is 255 items
<li>There will actually be three times that number of color bytes in the global color table
<li>... Because colors are 24 bit per pixel
</slidetext>

<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect3>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>

<slidetext>
<li>If the logical screen section specified the presence of a global color table, then that is next
<li>The global color table is a palette
<li>The format is very simple
  <ul>
  <li>Just the red, green and blue values
  <li>No header or footer
  </ul>
</slidetext>

<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<slidebreak>
<slideinclude>
<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>

<slidetext>
<li>Now we get each of the images stored in the GIF file...
</slidetext>

<sect3><title>Image descriptors</title>
<slideinclude>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>
</slideinclude>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>

<slidetext>
<BR><BR>
<li>The image descriptor is stored at the start of each image
<li>It stores information which is specific to that single image
</slidetext>

<slidebreak>
<slideinclude>
<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>

<slidebreak>
<para>
The packed field byte stores the following information:
</para>

<slidetext>
<li>The packed field byte stores the following information:
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>

<slidetext>
<li>The local color table is the same as the global color table
</slidetext>
</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>

<slidetext>
<li>The raster information is stored in a series of image data blocks
<li>These have a maximum size of 255 bytes
<li>...This works well on memory limited machines
<li>Each byte is an index into the global or local color table
<li>Each of these data blocks is LZW compressed as part of one big buffer
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>
</slideinclude>


<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>

<slidetext>
<li>The format of these image data subblocks is:
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>

<slidetext>
<li>The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
<BR><BR>
</slidetext>

<slideinclude>
<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>
</slideinclude>

</sect4>
</sect3>
</sect2>

<noslide>
<sect2><title>Special purpose blocks</title>
<para>
The other thing which can be stored in the data area of the data stream of a GIF file is special purpose blocks. These are outside the scope of this tutorial, and wont be discussed here.
</para>

</sect2>
</noslide>

<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>

<slidetext>
<li>The end of the data stream is signified by the byte 0x3B
</slidetext>
</sect2>


<noslide>
<sect2><title>Interlaced images</title>
<para>
GIF supports the interlacing of images, which is where are the image is loaded, progressively better representations of the image are displayed. Discussing the inner workings of this within the file format is out of the scope of this tutorial however.
</para>

</sect2>
</noslide>
</sect1>


<sect1><title>Conclusion</title>
<para>
In this chapter we have learnt how the GIF format is laid out internally. This will be useful when it is time to dicsuss the PNG format...
</para>

<slidetext>
<li>In this chapter we have learnt about the internal layout of the GIF format
</slidetext>
</sect1>
</chapter>
<chapter id="chap-png"><title>PNG</title>
<slideinclude>
<para><quote>
A Turbo-Studly Image Format with Lossless Compression
(Not Related to Papua New Guinea, the Pawnee National Grassland,
the Professional Numismatists Guild or the ``Pack 'N' Go'' format)
</quote> -- libpng.org</para>
</slideinclude>

<para>
PNG
  <footnote><para>Short for Portable Network Graphics.</para></footnote>
is my favorite image format after TIFF. It is well conceived, well implemented, and very powerful. It also has some interesting features, mainly aimed at Internet use, which TIFF lacks. It is also usable in modern web browsers
  <footnote><para>For instance Netscape 4 and Internet Explorer 4 and later.</para></footnote>
, unlike TIFF. PNG is also much simpler in many respects than TIFF.
</para>

<slidebreak>
<para>
This chapter will focus on the libpng library. This isn't really a limitation, as the people behind libpng are also the people who write the PNG specification, so you're pretty safe in assuming that if it's useful and PNG does it, then libpng implements it.
</para>

<slidetext>
<li>We'll focus on libpng
<li>This is written by the sample people as the specification
<li>So it's basically got everything
</slidetext>

<sect1><title>Introduction</title>
<para>
PNG happened because of the patent problems with the GIF format described in an earlier chapter of this tutorial. In the words of the official history of PNG:
</para>

<slidetext>
<li>Why did PNG happen?
<li>Patent problems with GIF
  <ul>
  <li>After many people had become very used to the GIF format
  </ul>
<li>To quote the official PNG history<BR>
</slidetext>

<slideinclude>
<para>
<quote>
... Unisys in 1993 began aggressively pursuing commercial vendors of software-only LZW implementations. CompuServe seems to have been its primary target at first, culminating in an agreement--quietly announced on 28 December 1994, right in the middle of the Christmas holidays--to begin collecting royalties from authors of GIF-supporting software. The spit hit the fan on the Internet the following week; what was then the comp.graphics newsgroup went nuts, to use a technical term. As is the way of Usenet, much ire was directed at CompuServe for making the announcement, and then at Unisys once the details became a little clearer; but mixed in with the noise was the genesis of an informal Internet working group led by Thomas Boutell [2]. Its purpose was not only to design a replacement for the GIF format, but a successor to it: better, smaller, more extensible, and FREE.
</quote>
-- http://www.libpng.org/pub/png/pnghist.html
</para>
</slideinclude>

<slidetext>
<BR><BR>
<li>See the printed manual for more history
</slidetext>

<para>
The PNG has gone from being a simple specification with limitations such as only supporting 8 bit images first announced on comp.graphics, comp.compression and comp.infosystems.www.providers, into a mature and extremely extensible image format.
</para>

<para>
Various versions of the PNG specification have been published as RFC-2083 and as a W3C Recommendation, which means that supporting the format is a lot easier because it is well defined.
</para>

<para>
A bunch of the examples in this chapter are based on the pngtools code I wrote a while ago, which I have updated as part of writing this chapter.
</para>

<sidebar><title>Refer to the TIFF chapter</title>
<para>
Much of the discussion in this chapter will make a whole bunch more sense if you've read the TIFF chapter. Off you go, I'll wait for you to come back...
</para>
</sidebar>
</sect1>

<sect1><title>Installation</title>
<para>
You can get the latest libpng code from http://www.libpng.org.
</para>

<sect2><title>Unix</title>
<para>
libpng doesn't have a configure script. You'll need to follow the steps below to get it to compile:
</para>

<itemizedlist>
<listitem><para>cp scripts/makefile.linux Makefile <emphasis>(You'll need to copy the Makefile that matches your architecture and operating system)</emphasis></para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>win32</title>
<para>
There are Makefiles for the win32 platform as well. I haven't verified how well they work however.
</para>
</sect2>
</sect1>

<sect1><title>The PNG on disc format</title>
<para>
It is useful to introduce the PNG file format as one of the first parts of this chapter, as it helps to see the advantages and disadvantages of the PNG format compared with the other formats that we will discuss during this tutorial.
</para>

<sect2><title>Byte order</title>
<para>
If you recall the TIFF format, multi byte values can either be little endian or big endian. This means that the libtiff library must perform byte swapping every time you read a value which takes more than one byte (which is most of the time). libpng doesn't have these problems, as all multi byte values are in network byte order (big endian).
</para>
</sect2>

<sect2><title>File header</title>
<para>
All PNG files start with a magic number (as have all the other formats which we have discussed in this tutorial). It looks something like:
</para>

<table frame='all'><title>PNG on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Decimal 137 <emphasis>No ASCII equivalent</emphasis></entry>
</row>

<row>
  <entry>1</entry>
  <entry>Decimal 80 <emphasis>P</emphasis></entry>
</row>

<row>
  <entry>2</entry>
  <entry>Decimal 78 <emphasis>N</emphasis></entry>
</row>

<row>
  <entry>3</entry>
  <entry>Decimal 71 <emphasis>G</emphasis></entry>
</row>

<row>
  <entry>4</entry>
  <entry>Decimal 13 <emphasis>Carriage return (\r)</emphasis></entry>
</row>

<row>
  <entry>5</entry>
  <entry>Decimal 10 <emphasis>Newline (\n)</emphasis></entry>
</row>

<row>
  <entry>6</entry>
  <entry>Decimal 26 <emphasis>No ASCII equivalent</emphasis></entry>
</row>

<row>
  <entry>7</entry>
  <entry>Decimal 10 <emphasis>Newline (\n)</emphasis></entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Chunk format</title>
<para>
Chunks map as a concept to the blocks that the GIF format used. The generic format for a PNG chunk is:
</para>

<table frame='all'><title>PNG on disc: chunk format</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 3</entry>
  <entry>Length of the data portion of this chunk (does not include the length field, the type field, or the CRC). The value is unsigned, and zero is a valid length. The maximum value is 2^32 - 1</entry>
</row>

<row>
  <entry>4 - 7</entry>
  <entry>Chunk type. Chunk types normally fall into the upper and lower case ASCII ranges. Software should treat this field as an unsigned value however. Chunk type naming conventions are discussed later in this chapter.</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Chunk data.</entry>
</row>

<row>
  <entry>(4 bytes at end of chunk)</entry>
  <entry>Cyclic Redundancy Check (CRC). The CRC covers the type and data fields, but not the length field. The CRC is always present, even if we have no data.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Chunk naming conventions</title>
<para>
The case used in chunk names has special significance. The table below describes the chunk name characters.
</para>

<table frame='all'><title>PNG on disc: chunk naming conventions</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Uppercase: critical. Lowercase: optional (known as ancillary). If a decoder encounters a critical chunk it does not understand, it will warn the user about possible incorrect decoding of the image.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Uppercase: public. Lowercase: private. A public chunk is either part of the PNG specification, or is published in the list of PNG public chunk types. Private chunks are developer specific, and should be ignored if not understood.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Uppercase: PNG 1.2 compliant. Lowercase: reserved for future use. For the time being, you should never see a third character which is lower case.</entry>
</row>

<row>
  <entry>3</entry>
  <entry>Uppercase: unsafe to copy. Lowercase: safe to copy. If the decoder doesn't understand the chunk, then should it be copied into new images? A chunk would be unsafe to copy if it relied on the image data which the decoder might have changed (including some critical chunks). An example of a safe to copy chunk might be a chunk which includes a MP3 sound recording from the time in which the image was encoded. An example of an unsafe to copy chunk might be an MD5 hash on the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2><title>CRC algorithm</title>
<para>
The exact workings of the CRC algorithm are outside the scope of this tutorial...
</para>

</sect2>







<sect2><title>The IHDR chunk</title>
<para>
This is the image header chunk. This chunk <emphasis>must be first</emphasis> in the PNG file. This chunk contains the following fields:
</para>

<table frame='all'><title>PNG on disc: IHDR chunk fields</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 3</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>4 - 7</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>8</entry>
  <entry>Bit depth (not of bits per sample or palette index)</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Color type</entry>
</row>

<row>
  <entry>10</entry>
  <entry>Compression method (method zero is the only method currently defined)</entry>
</row>

<row>
  <entry>11</entry>
  <entry>Filter method (method zero is the only method currently defined)</entry>
</row>

<row>
  <entry>12</entry>
  <entry>Interlace method. The current options are: zero (no interlace) and one (adam7)</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are various values which are valid for the color type field. Each of these types has only certain byte depths allowed.
</para>

<table frame='all'><title>PNG on disc: IHDR chunk color types</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Color type: allowed bit depths</entry>
  <entry>Comments</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0: 1, 2, 4, 8, 16</entry>
  <entry>Each pixel is a gray scale sample</entry>
</row>

<row>
  <entry>1: not applicable</entry>
  <entry>Each pixel value is an index into a palette table</entry>
</row>

<row>
  <entry>2: 8, 16</entry>
  <entry>Each pixel has an red, green, and blue value</entry>
</row>

<row>
  <entry>3: 1, 2, 4, 8</entry>
  <entry>Each pixel is a palette index, and a PLTE chunk must appear in the PNG file</entry>
</row>

<row>
  <entry>4: 8, 16</entry>
  <entry>Each pixel is a gray scale sample, followed by an alpha channel</entry>
</row>

<row>
  <entry>6: 8, 16</entry>
  <entry>Each pixel is an red, green, blue, alpha set</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
For all of these types, the sample depth is the same as the bit depth, except for type three, where the sample depth is always eight bits.
</para>

<table frame='all'><title>PNG on disc: IHDR chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>

<sect3><title>Filtering algorithm</title>
<para>
The PNG specification states on page 16 of version 1.2:

<quote>
Filter method is a single-byte integer that indicates the preprocessing method applied to the image data be-fore compression. At present, only filter method 0 (adaptive filtering with five basic filter types) is defined. As with the compression method field, decoders must check this byte and report an error if it holds an unrec-ognized code. See Filter Algorithms (Chapter 6) for details.
</quote
</para>
</sect3>
</sect2>

<sect2><title>The PLTE chunk</title>
<para>
This chunks stores the palette information for the image. A palette contains 1 through 256 entries, and each entry consists of a red byte, green byte, and a blue byte. You don't need to have 256 entries in the palette -- the size of the palette is determined by dividing the chunk length by three. A chunk length which is not divisible by three is an error condition.
</para>

<table frame='all'><title>PNG on disc: PLTE chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The IDAT chunk</title>
<para>
The IDAT chunk contains the actual image data. This data will be the output of the selected compression method, and will need to be uncompressed before it is used.
</para>

<table frame='all'><title>PNG on disc: IDAT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The IEND chunk</title>
<para>
The IEND chunk must be the last chunk in the PNG file. It marks the end of the PNG file. The length of the data inside this chunk is zero.
</para>

<table frame='all'><title>PNG on disc: IEND chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Critical</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Ancillary chunks</title>
<para>
Each ancillary chunk is only given a brief description below. Refer to the PNG specification for more information...
</para>
</sect2>

<sect2><title>The tRNS chunk</title>
<para>
Transparency information.
</para>

<table frame='all'><title>PNG on disc: tRNS chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The gAMA chunk</title>
<para>
Image gamma (pixel intensity) information.
</para>

<table frame='all'><title>PNG on disc: gAMA chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The cHRM chunk</title>
<para>
Chromacity information.
</para>

<table frame='all'><title>PNG on disc: cHRM chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sRGB chunk</title>
<para>
The image data conforms to the ICC RGB color space.
</para>

<table frame='all'><title>PNG on disc: sRGB chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The iCCP chunk</title>
<para>
Contains an embedded ICC profile.
</para>

<table frame='all'><title>PNG on disc: iCCP chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The iTXt chunk</title>
<para>
International textual data.
</para>

<table frame='all'><title>PNG on disc: iTXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The tEXt chunk</title>
<para>
Uncompressed text.
</para>

<table frame='all'><title>PNG on disc: tEXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The zTXt chunk</title>
<para>
Flate compressed text.
</para>

<table frame='all'><title>PNG on disc: zTXt chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The bKGD chunk</title>
<para>
Background color information.
</para>

<table frame='all'><title>PNG on disc: bKGD chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The pHYs chunk</title>
<para>
Pixel size information.
</para>

<table frame='all'><title>PNG on disc: pHYs chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Safe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sBIT chunk</title>
<para>
Stores the original number of significant bits.
</para>

<table frame='all'><title>PNG on disc: sBIT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The sPLT chunk</title>
<para>
Suggested palette.
</para>

<table frame='all'><title>PNG on disc: sPLT chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The hIST chunk</title>
<para>
Palette histogram.
</para>

<table frame='all'><title>PNG on disc: hIST chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>The tIME chunk</title>
<para>
Time of last image modification.
</para>

<table frame='all'><title>PNG on disc: tIME chunk</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<tbody>

<row>
  <entry>Required?</entry>
  <entry>Ancillary</entry>
</row>

<row>
  <entry>Scope?</entry>
  <entry>Public</entry>
</row>

<row>
  <entry>In reserved name space?</entry>
  <entry>PNG 1.2 compliant</entry>
</row>

<row>
  <entry>Safe to copy?</entry>
  <entry>Unsafe to copy</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>














</sect1>





<slidebreak>
<slidetext>
<B><I>This is where I stopped creating slides, as the tutorial was cancelled...
</i></b>
</slidetext>
<noslide>






<sect1><title>PNG should be easier than TIFF</title>
<para>
Unlike the TIFF format, which allows the creator of the image files to specify many different image options, PNG imposes rules such as that the images are big endian. Whilst this is less flexible for the creators of PNG files compared with TIFF, it does make it much easier to reliably decode a PNG image.
</para>
</sect1>












<sect1><title>Opening a PNG file</title>
<para>
The first step to learning how to use libpng is probably to understand how to open a PNG file and get some data out of it. Below is a minimal example of how to open a PNG file, not including actually reading the image data...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]){
  FILE *image;
  unsigned long width, height;
  int bitdepth, colourtype;
  png_uint_32 i, j;
  png_structp png;
  png_infop info;
  unsigned char sig[8];

  // Open the file
  if ((image = fopen (argv[1], "rb")) == NULL){
    fprintf(stderr, "Could not open the specified PNG file.");
    exit(0);
  }

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL){
    fprintf(stderr, "Could not create a PNG read structure (out of memory?)");
    exit(0);
  }

  if((info = png_create_info_struct(png)) == NULL){
    fprintf(stderr, "Could not create PNG info structure (out of memory?)");
    exit(0);
  }

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct
  if(setjmp(png_jmpbuf(png))){
    fprintf(stderr, "Could not set PNG jump value");
    exit(0);
  }

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

  // This cleans things up for us in the PNG library
  fclose(image);
  png_destroy_read_struct(&amp;png, &amp;info, NULL);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-open/read-infrastructure.c</emphasis></para>

<para>
In this example, we do everything we need to open a PNG image, without actually reading the image data. The steps to getting to the image data are:
</para>

<itemizedlist>
<listitem><para>Open the file ready for reading. For this we just use the c standard library's <command>FILE *</command>, unlike the libtiff examples, in which we used a <command>TIFF *</command>
  <footnote><para>In reality, the libtiff could just use the <command>FILE *</command> method internally, although they don't always, as shown by the TIFFClientOpen examples in the TIFF chapter.</para></footnote>
</para></listitem>

<listitem><para>Another thing we need to do which libtiff does for us and libpng doesn't is check that the file really is a PNG file. We do this with the <command>png_check_sig</command>() call. This expects the first 8 bytes of the file to be handed to it, which is what the <command>fread</command>() function call gets for us.</para></listitem>

<listitem><para>We then start decompressing the image</para></listitem>

<listitem><para>The info struct gives us access to important information about the image</para></listitem>

<listitem><para>Then we read the IHDR chunk (see above for a description of this chunk)</para></listitem>
</itemizedlist>
</sect1>










<sect1><title>Example: pnginfo</title>
<para>
The <command>pnginfo</command> command implemented here is modeled on the <command>tiffinfo</command>, which was discussed in the TIFF chapter earlier in this tutorial. In fact, the output text is written to be as close to the <command>tiffinfo</command> command as possible.
</para>

<programlisting>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

void pnginfo_displayfile (char *, int, int);
void pnginfo_error (char *);
void *pnginfo_xmalloc (size_t);
void usage (void);

#define pnginfo_true 1
#define pnginfo_false 0

int
main (int argc, char *argv[])
{
  int i, optchar, extractBitmap = pnginfo_false, displayBitmap =
    pnginfo_false;

  // Initialise the argument that filenames start at
  i = 1;

  // Use getopt to determine what we have been asked to do
  while ((optchar = getopt (argc, argv, "Dd")) != -1)
    {
      switch (optchar)
	{
	case 'd':
	  displayBitmap = pnginfo_true;
	  extractBitmap = pnginfo_true;
	  i++;
	  break;

	case 'D':
	  extractBitmap = pnginfo_true;
	  i++;
	  break;

	case '?':
	default:
	  usage ();
	  break;
	}
    }

  // Determine if we were given a filename on the command line
  if (argc &lt; 2)
    usage ();

  // For each filename that we have:
  for (; i &lt; argc; i++)
    pnginfo_displayfile (argv[i], extractBitmap, displayBitmap);
}

void
pnginfo_displayfile (char *filename, int extractBitmap, int displayBitmap)
{
  FILE *image;
  unsigned long imageBufSize, width, height, runlen;
  unsigned char signature;
  int bitdepth, colourtype;
  png_uint_32 i, j, rowbytes;
  png_structp png;
  png_infop info;
  unsigned char sig[8];
  png_bytepp row_pointers = NULL;
  char *bitmap;

  printf ("%s...\n", filename);

  // Open the file
  if ((image = fopen (filename, "rb")) == NULL)
    pnginfo_error ("Could not open the specified PNG file.");

  // Check that it really is a PNG file
  fread (sig, 1, 8, image);
  if (!png_check_sig (sig, 8))
    {
      printf ("  This file is not a valid PNG file\n");
      fclose (image);
      return;
    }

  // Start decompressing
  if ((png = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL,
				     NULL, NULL)) == NULL)
    pnginfo_error ("Could not create a PNG read structure (out of memory?)");

  if ((info = png_create_info_struct (png)) == NULL)
    pnginfo_error ("Could not create PNG info structure (out of memory?)");

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct

  if (setjmp (png_jmpbuf (png)))
    pnginfo_error ("Could not set PNG jump value");

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io (png, image);
  png_set_sig_bytes (png, 8);
  png_read_info (png, info);
  png_get_IHDR (png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL,
		NULL, NULL);

  ///////////////////////////////////////////////////////////////////////////
  // Start displaying information
  ///////////////////////////////////////////////////////////////////////////

  printf ("  Image Width: %d Image Length: %d\n", width, height);
  printf ("  Bits/Sample: %d\n", bitdepth);
  printf ("  Samples/Pixel: %d\n", info-&gt;channels);
  printf ("  Pixel Depth: %d\n", info-&gt;pixel_depth);	// Does this add value?

  // Photometric interp packs a lot of information
  printf ("  Colour Type (Photometric Interpretation): ");

  switch (colourtype)
    {
    case PNG_COLOR_TYPE_GRAY:
      printf ("GRAYSCALE ");
      break;

    case PNG_COLOR_TYPE_PALETTE:
      printf ("PALETTED COLOUR ");
      if (info-&gt;num_trans &gt; 0)
	printf ("with alpha ");
      printf ("(%d colours, %d transparent) ",
	      info-&gt;num_palette, info-&gt;num_trans);
      break;

    case PNG_COLOR_TYPE_RGB:
      printf ("RGB ");
      break;

    case PNG_COLOR_TYPE_RGB_ALPHA:
      printf ("RGB with alpha channel ");
      break;

    case PNG_COLOR_TYPE_GRAY_ALPHA:
      printf ("GRAYSCALE with alpha channel ");
      break;

    default:
      printf ("Unknown photometric interpretation!");
      break;
    }
  printf ("\n");

  printf ("  Image filter: ");
  switch (info-&gt;filter_type)
    {
    case PNG_FILTER_TYPE_BASE:
      printf ("Single row per byte filter ");
      break;

    case PNG_INTRAPIXEL_DIFFERENCING:
      printf ("Intrapixel differencing (MNG only) ");
      break;

    default:
      printf ("Unknown filter! ");
      break;
    }
  printf ("\n");

  printf ("  Interlacing: ");
  switch (info-&gt;interlace_type)
    {
    case PNG_INTERLACE_NONE:
      printf ("No interlacing ");
      break;

    case PNG_INTERLACE_ADAM7:
      printf ("Adam7 interlacing ");
      break;

    default:
      printf ("Unknown interlacing ");
      break;
    }
  printf ("\n");

  printf ("  Compression Scheme: ");
  switch (info-&gt;compression_type)
    {
    case PNG_COMPRESSION_TYPE_BASE:
      printf ("Deflate method 8, 32k window");
      break;

    default:
      printf ("Unknown compression scheme!");
      break;
    }
  printf ("\n");

  printf ("  Resolution: %d, %d ",
	  info-&gt;x_pixels_per_unit, info-&gt;y_pixels_per_unit);
  switch (info-&gt;phys_unit_type)
    {
    case PNG_RESOLUTION_UNKNOWN:
      printf ("(unit unknown)");
      break;

    case PNG_RESOLUTION_METER:
      printf ("(pixels per meter)");
      break;

    default:
      printf ("(Unknown value for unit stored)");
      break;
    }
  printf ("\n");

  // FillOrder is always msb-to-lsb, big endian
  printf ("  FillOrder: msb-to-lsb\n  Byte Order: Network (Big Endian)\n");

  // Text comments
  printf ("  Number of text strings: %d of %d\n",
	  info-&gt;num_text, info-&gt;max_text);

  for (i = 0; i &lt; info-&gt;num_text; i++)
    {
      printf ("    %s ", info-&gt;text[i].key);

      switch (info-&gt;text[1].compression)
	{
	case -1:
	  printf ("(tEXt uncompressed)");
	  break;

	case 0:
	  printf ("(xTXt deflate compressed)");
	  break;

	case 1:
	  printf ("(iTXt uncompressed)");
	  break;

	case 2:
	  printf ("(iTXt deflate compressed)");
	  break;

	default:
	  printf ("(unknown compression)");
	  break;
	}

      printf (": ");
      j = 0;
      while (info-&gt;text[i].text[j] != '\0')
	{
	  if (info-&gt;text[i].text[j] == '\n')
	    printf ("\\n");
	  else
	    fputc (info-&gt;text[i].text[j], stdout);

	  j++;
	}

      printf ("\n");
    }

  // Print a blank line
  printf ("\n");

  // Do we want to extract the image data? We are meant to tell the user if
  // there are errors, but we don't currently trap any errors here -- I need
  // to look into this
  if (extractBitmap == pnginfo_true)
    {
      if (colourtype == PNG_COLOR_TYPE_PALETTE)
	png_set_expand (png);

      png_set_strip_alpha (png);
      png_read_update_info (png, info);

      rowbytes = png_get_rowbytes (png, info);
      bitmap = (unsigned char *) pnginfo_xmalloc ((rowbytes * height) + 1);
      row_pointers = pnginfo_xmalloc (height * sizeof (png_bytep));

      // Get the image bitmap
      for (i = 0; i &lt; height; ++i)
	row_pointers[i] = bitmap + (i * rowbytes);
      png_read_image (png, row_pointers);
      free (row_pointers);
      png_read_end (png, NULL);

      // Do we want to display this bitmap?
      if (displayBitmap == pnginfo_true)
	{
	  printf ("Dumping the bitmap for this image:\n");

	  runlen = 0;
	  for (i = 0; i &lt; rowbytes * height / 3; i += 3)
	    {
	      if ((runlen != 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
		  &amp;&amp; (bitmap[i] == 0))
		runlen++;
	      else if (runlen != 0)
		{
		  if (runlen &gt; 1)
		    printf ("* %d ", runlen);
		  runlen = 0;
		}

	      if ((runlen == 0) &amp;&amp; (bitmap[i] == 0) &amp;&amp; (bitmap[i] == 0)
		  &amp;&amp; (bitmap[i] == 0))
		{
		  printf ("[0, 0, 0] ");
		  runlen++;
		}

	      if (runlen == 0)
		printf ("[%02x %02x %02x] ", (unsigned char) bitmap[i],
			(unsigned char) bitmap[i + 1],
			(unsigned char) bitmap[i + 2]);
	    }
	}
    }

  // This cleans things up for us in the PNG library
  fclose (image);
  png_destroy_read_struct (&amp;png, &amp;info, NULL);
}

// You can bang or head or you can drown in a hole
//                                                    -- Vanessa Amarosi, Shine
void
pnginfo_error (char *message)
{
  fprintf (stderr, "%s\n", message);
  exit (42);
}

// Allocate some memory
void *
pnginfo_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pnginfo_error ("pnginfo_xmalloc failed to allocate memory");
    }

  return buffer;
}

void
usage ()
{
  pnginfo_error ("Usage: pnginfo [-d] [-D] &lt;filenames&gt;");
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pngtools/pnginfo.c</emphasis></para>
</sect1>



<sect1><title>Reading a PNG image</title>
<para>
This example shows you how to read in the raster data that is embedded into the image file. libpng will also expand paletted raster information for you if you ask nicely...
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]){
  FILE *image;
  unsigned long width, height;
  int bitdepth, colourtype;
  png_uint_32 i, j, rowbytes;
  png_structp png;
  png_infop info;
  png_bytepp row_pointers = NULL;
  unsigned char sig[8];
  char *raster;

  // Open the file
  if ((image = fopen (argv[1], "rb")) == NULL){
    fprintf(stderr, "Could not open the specified PNG file.");
    exit(0);
  }

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL){
    fprintf(stderr, "Could not create a PNG read structure (out of memory?)");
    exit(0);
  }

  if((info = png_create_info_struct(png)) == NULL){
    fprintf(stderr, "Could not create PNG info structure (out of memory?)");
    exit(0);
  }

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct
  if(setjmp(png_jmpbuf(png))){
    fprintf(stderr, "Could not set PNG jump value");
    exit(0);
  }

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

 if (colourtype == PNG_COLOR_TYPE_PALETTE)
    png_set_expand (png);
  //  if(colourtype &amp; PNG_COLOR_MASK_ALPHA)
  png_set_strip_alpha (png);
  png_read_update_info (png, info);

  rowbytes = png_get_rowbytes (png, info);
  if((row_pointers = malloc (height * sizeof (png_bytep))) == NULL){
    fprintf(stderr, "Could not allocate memory\n");
    exit(42);
  }

  // Space for the bitmap
  if((raster = (unsigned char *) malloc ((rowbytes * height) + 1)) == NULL){
    fprintf(stderr, "Could not allocate memory\n");
    exit(42);
  }

  // Get the image bitmap
  for (i = 0; i &lt; height; ++i)
    row_pointers[i] = raster + (i * rowbytes);
  png_read_image (png, row_pointers);
  free(row_pointers);
  png_read_end (png, NULL);
  fclose (image);

  // We should dump the bitmap at this point
  for(i = 0; i &lt; width * height; i++){
    printf("%08x ", raster[i]);
  }

  // This cleans things up for us in the PNG library
  png_destroy_read_struct (&amp;png, &amp;info, NULL);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-open/read.c</emphasis></para>
</sect1>




<sect1><title>Writing a PNG image</title>
<para>
Writing a PNG file is <emphasis>very</emphasis> to reading the PNG file. The example below extends the code from above to open a PNG file, and then copy it to a new PNG file.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;png.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]){
  FILE *image;
  unsigned long width, height;
  int bitdepth, colourtype;
  png_uint_32 i, j, rowbytes;
  png_structp png;
  png_infop info;
  png_bytepp row_pointers = NULL;
  unsigned char sig[8];
  char *raster;

  // Open the file
  if ((image = fopen (argv[1], "rb")) == NULL){
    fprintf(stderr, "Could not open the specified PNG file.");
    exit(0);
  }

  // Check that it really is a PNG file
  fread(sig, 1, 8, image);
  if(!png_check_sig(sig, 8)){
    printf("This file is not a valid PNG file\n");
    fclose(image);
    return;
  }

  // Start decompressing
  if((png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, 
				   NULL, NULL)) == NULL){
    fprintf(stderr, "Could not create a PNG read structure (out of memory?)");
    exit(0);
  }

  if((info = png_create_info_struct(png)) == NULL){
    fprintf(stderr, "Could not create PNG info structure (out of memory?)");
    exit(0);
  }

  // If pnginfo_error did not exit, we would have to call 
  // png_destroy_read_struct
  if(setjmp(png_jmpbuf(png))){
    fprintf(stderr, "Could not set PNG jump value");
    exit(0);
  }

  // Get ready for IO and tell the API we have already read the image signature
  png_init_io(png, image);
  png_set_sig_bytes(png, 8);
  png_read_info(png, info);
  png_get_IHDR(png, info, &amp;width, &amp;height, &amp;bitdepth, &amp;colourtype, NULL, 
	       NULL, NULL);

 if (colourtype == PNG_COLOR_TYPE_PALETTE)
    png_set_expand (png);
  //  if(colourtype &amp; PNG_COLOR_MASK_ALPHA)
  png_set_strip_alpha (png);
  png_read_update_info (png, info);

  rowbytes = png_get_rowbytes (png, info);
  if((row_pointers = malloc (height * sizeof (png_bytep))) == NULL){
    fprintf(stderr, "Could not allocate memory\n");
    exit(42);
  }

  // Space for the bitmap
  if((raster = (unsigned char *) malloc ((rowbytes * height) + 1)) == NULL){
    fprintf(stderr, "Could not allocate memory\n");
    exit(42);
  }

  // Get the image bitmap
  for (i = 0; i &lt; height; ++i)
    row_pointers[i] = raster + (i * rowbytes);
  png_read_image (png, row_pointers);
  free(row_pointers);
  png_read_end (png, NULL);
  fclose (image);


  // This cleans things up for us in the PNG library
  png_destroy_read_struct (&amp;png, &amp;info, NULL);

  /////////////////////////////////////////////////////////////////////////////
  // Now write the image out again
  /////////////////////////////////////////////////////////////////////////////
  if((image = fopen("output.png", "wb")) == NULL){
    fprintf(stderr, "Could not open the output image\n");
    exit(42);
  }

  // Get ready for writing
  if ((png =
       png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL,
                                NULL)) == NULL){
    fprintf(stderr, "Could not create write structure for PNG (out of memory?)");
    exit(42);
  }

  // Get ready to specify important stuff about the image
  if ((info = png_create_info_struct (png)) == NULL){
    fprintf(stderr,
	    "Could not create PNG info structure for writing (out of memory?)");
    exit(42);
  }

  if (setjmp (png_jmpbuf (png))){
    fprintf(stderr, "Could not set the PNG jump value for writing");
    exit(42);
  }

  // This is needed before IO will work (unless you define callbacks)
  png_init_io(png, image);

  // Define important stuff about the image
  png_set_IHDR (png, info, width, height, bitdepth, PNG_COLOR_TYPE_RGB,
                PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
                PNG_FILTER_TYPE_DEFAULT);
  png_write_info (png, info);

  // Write the image out
  png_write_image (png, row_pointers);

  // Cleanup
  png_write_end (png, info);
  png_destroy_write_struct (&amp;png, &amp;info);
  fclose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-write/write.c</emphasis></para>
</sect1>

<sect1><title>Storing PNG data in places other than files</title>
<para>
This example below, much like the TIFFClient examples in the TIFF chapter shows how to use the libpng call backs to get to image data in places other than files. Note that it wont compile, but it does give you an example of the structure you need...
</para>

<programlisting>
// This code wont compile, but it provides an example of how to use the libpng
// callbacks to get to image data in other places than files...
#include &lt;png.h&gt;
#include &lt;pthread.h&gt;

#define panda_true 1
#define panda_false 0

// This mutex keeps us thread safe (for the globals)
pthread_mutex_t convMutex = PTHREAD_MUTEX_INITIALIZER;

// Function prototypes
void libpngDummyWriteProc (png_structp png, png_bytep data, png_uint_32 len);
void libpngDummyFlushProc (png_structp png);

// We need thse globals because of the callbacks
char *globalImageBuffer;
unsigned long globalImageBufferOffset;
char globalIsIDAT;

///////////////////////////////////////////////////////////////////////////////
// Setup libpng
if ((png =
     png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL,
			      NULL)) == NULL){
  fprintf(stderr,
	  "Could not create write structure for PNG (out of memory?)");
  exit(42);
}

if ((info = png_create_info_struct (png)) == NULL){
  fprintf(stderr, 
	  "Could not create PNG info structure for writing (out of memory?)");
  exit(42);
}

if (setjmp (png_jmpbuf (png))){
  fprintf(stderr, "Could not set the PNG jump value for writing");
  exit(42);
}

// If this call is done before png_create_write_struct, then everything 
// seg faults...
pthread_mutex_lock (&amp;amp;convMutex);

png_set_write_fn (png, NULL, (png_rw_ptr) libpngDummyWriteProc,
		  (png_flush_ptr) libpngDummyFlushProc);
globalIsIDAT = panda_false;
globalImageBuffer = NULL;
globalImageBufferOffset = 0;

png_set_IHDR (png, info, width, height, bitdepth, outColourType,
	      PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
	      PNG_FILTER_TYPE_DEFAULT);
png_write_info (png, info);

png_write_image (png, row_pointers);
png_write_end (png, info);
png_destroy_write_struct (&amp;amp;png, &amp;amp;info);

///////////////////////////////////////////////////////////////////////////////
// When we get back to here we have the image data

  pthread_mutex_unlock (&amp;amp;convMutex);

///////////////////////////////////////////////////////////////////////////////
// Callbacks
void
libpngDummyWriteProc (png_structp png, png_bytep data, png_uint_32 len)
{
  char tempString[5];

  // Copy the first 4 bytes into a string
  tempString[0] = data[0];
  tempString[1] = data[1];
  tempString[2] = data[2];
  tempString[3] = data[3];
  tempString[4] = '\0';

  // If we know this is an IDAT, then copy the compressed image information
  if (globalIsIDAT == panda_true)
    {
      // Have we done anything yet?
      if (globalImageBuffer == NULL)
	globalImageBuffer = (char *) panda_xmalloc (len * sizeof (char));

      // Otherwise, we need to grow the memory buffer
      else
	{
	  if ((globalImageBuffer = (char *) realloc (globalImageBuffer,
						     (len * sizeof (char)) +
						     globalImageBufferOffset))
	      == NULL){
	    fprintf(stderr,
			 "Could not grow the png conversion memory buffer.");
	    exit(42);
	  }
	}

      // Now move the image data into the buffer
      memcpy (globalImageBuffer + globalImageBufferOffset, data, len);
      globalImageBufferOffset += len;
      
      globalIsIDAT = panda_false;
    }
  else if ((len == 4) &amp;amp;&amp;amp; (strcmp (tempString, "IDAT") == 0))
    globalIsIDAT = panda_true;
  else
    globalIsIDAT = panda_false;
}

void
libpngDummyFlushProc (png_structp png)
{
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/png-client/client.c</emphasis></para>
</sect1>






<sect1><title>Man pages</title>
<para>
To be honest, the libtiff man pages are much better than the documentation which comes with libpng. libpng has one main man page, which is included for ease of reference below.
</para>

<sect2><title>libpng</title>
<sect3><title>NAME</title>

<para>libpng - Portable Network Graphics (PNG) Reference Library 1.0.9
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>#include &lt;png.h&gt;</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_access_version_number (void</command><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_check_sig (png_bytep </command><emphasis>sig</emphasis><command>, int </command><emphasis>num</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_chunk_error (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>error</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_chunk_warning (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>message</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_convert_from_struct_tm (png_timep </command><emphasis>ptime</emphasis><command>, struct tm FAR * </command><emphasis>ttime</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_convert_from_time_t (png_timep </command><emphasis>ptime</emphasis><command>, time_t </command><emphasis>ttime</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_charp png_convert_to_rfc1123 (png_structp </command><emphasis>png_ptr</emphasis><command>, png_timep </command><emphasis>ptime</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_infop png_create_info_struct (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_structp png_create_read_struct (png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_voidp </command><emphasis>error_ptr</emphasis><command>, png_error_ptr </command><emphasis>error_fn</emphasis><command>, png_error_ptr </command><emphasis>warn_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_structp png_create_read_struct_2(png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_voidp </command><emphasis>error_ptr</emphasis><command>, png_error_ptr </command><emphasis>error_fn</emphasis><command>, png_error_ptr </command><emphasis>warn_fn</emphasis><command>, png_voidp </command><emphasis>mem_ptr</emphasis><command>, png_malloc_ptr </command><emphasis>malloc_fn</emphasis><command>, png_free_ptr </command><emphasis>free_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_structp png_create_write_struct (png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_voidp </command><emphasis>error_ptr</emphasis><command>, png_error_ptr </command><emphasis>error_fn</emphasis><command>, png_error_ptr </command><emphasis>warn_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_structp png_create_write_struct_2(png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_voidp </command><emphasis>error_ptr</emphasis><command>, png_error_ptr </command><emphasis>error_fn</emphasis><command>, png_error_ptr </command><emphasis>warn_fn</emphasis><command>, png_voidp </command><emphasis>mem_ptr</emphasis><command>, png_malloc_ptr </command><emphasis>malloc_fn</emphasis><command>, png_free_ptr </command><emphasis>free_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_debug(int </command><emphasis>level</emphasis><command>, png_const_charp </command><emphasis>message</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_debug1(int </command><emphasis>level</emphasis><command>, png_const_charp </command><emphasis>message</emphasis><command>, </command><emphasis>p1</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_debug2(int </command><emphasis>level</emphasis><command>, png_const_charp </command><emphasis>message</emphasis><command>, </command><emphasis>p1</emphasis><command>, </command><emphasis>p2</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_destroy_info_struct (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infopp </command><emphasis>info_ptr_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_destroy_read_struct (png_structpp </command><emphasis>png_ptr_ptr</emphasis><command>, png_infopp </command><emphasis>info_ptr_ptr</emphasis><command>, png_infopp </command><emphasis>end_info_ptr_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_destroy_write_struct (png_structpp </command><emphasis>png_ptr_ptr</emphasis><command>, png_infopp </command><emphasis>info_ptr_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_error (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>error</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_free (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_free_chunk_list (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_free_default(png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_free_data (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>num</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_bit_depth (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_bKGD (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_color_16p </command><emphasis>*background</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_channels (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_cHRM (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, double </command><emphasis>*white_x</emphasis><command>, double </command><emphasis>*white_y</emphasis><command>, double </command><emphasis>*red_x</emphasis><command>, double </command><emphasis>*red_y</emphasis><command>, double </command><emphasis>*green_x</emphasis><command>, double </command><emphasis>*green_y</emphasis><command>, double </command><emphasis>*blue_x</emphasis><command>, double </command><emphasis>*blue_y</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_cHRM_fixed (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>*white_x</emphasis><command>, png_uint_32 </command><emphasis>*white_y</emphasis><command>, png_uint_32 </command><emphasis>*red_x</emphasis><command>, png_uint_32 </command><emphasis>*red_y</emphasis><command>, png_uint_32 </command><emphasis>*green_x</emphasis><command>, png_uint_32 </command><emphasis>*green_y</emphasis><command>, png_uint_32 </command><emphasis>*blue_x</emphasis><command>, png_uint_32 </command><emphasis>*blue_y</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_color_type (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_compression_type (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_copyright (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_error_ptr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_filter_type (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_gAMA (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, double </command><emphasis>*file_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_gAMA_fixed (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>*int_file_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_header_ver (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_header_version (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_hIST (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_16p </command><emphasis>*hist</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_iCCP (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_charpp </command><emphasis>name</emphasis><command>, int </command><emphasis>*compression_type</emphasis><command>, png_charpp </command><emphasis>profile</emphasis><command>, png_uint_32 </command><emphasis>*proflen</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_IHDR (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>*width</emphasis><command>, png_uint_32 </command><emphasis>*height</emphasis><command>, int </command><emphasis>*bit_depth</emphasis><command>, int </command><emphasis>*color_type</emphasis><command>, int </command><emphasis>*interlace_type</emphasis><command>, int </command><emphasis>*compression_type</emphasis><command>, int </command><emphasis>*filter_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_image_height (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_image_width (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_interlace_type (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_io_ptr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_libpng_ver (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_mem_ptr(png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_oFFs (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>*offset_x</emphasis><command>, png_uint_32 </command><emphasis>*offset_y</emphasis><command>, int </command><emphasis>*unit_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_pCAL (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_charp </command><emphasis>*purpose</emphasis><command>, png_int_32 </command><emphasis>*X0</emphasis><command>, png_int_32 </command><emphasis>*X1</emphasis><command>, int </command><emphasis>*type</emphasis><command>, int </command><emphasis>*nparams</emphasis><command>, png_charp </command><emphasis>*units</emphasis><command>, png_charpp </command><emphasis>*params</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_pHYs (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>*res_x</emphasis><command>, png_uint_32 </command><emphasis>*res_y</emphasis><command>, int </command><emphasis>*unit_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>float png_get_pixel_aspect_ratio (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_pixels_per_meter (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_progressive_ptr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_PLTE (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_colorp </command><emphasis>*palette</emphasis><command>, int </command><emphasis>*num_palette</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_byte png_get_rgb_to_gray_status (png_structp </command><emphasis>png_ptr)
</emphasis>
</para>

<para><command>png_uint_32 png_get_rowbytes (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_bytepp png_get_rows (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_sBIT (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_color_8p </command><emphasis>*sig_bit</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_bytep png_get_signature (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_sPLT (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_spalette_p </command><emphasis>*splt_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_sRGB (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>*intent</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_text (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_textp </command><emphasis>*text_ptr</emphasis><command>, int </command><emphasis>*num_text</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_tIME (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_timep </command><emphasis>*mod_time</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_tRNS (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_bytep </command><emphasis>*trans</emphasis><command>, int </command><emphasis>*num_trans</emphasis><command>, png_color_16p </command><emphasis>*trans_values</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_unknown_chunks (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_unknown_chunkpp </command><emphasis>unknowns</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_user_chunk_ptr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_get_user_transform_ptr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_valid (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>flag</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_int_32 png_get_x_offset_microns (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_int_32 png_get_x_offset_pixels (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_x_pixels_per_meter (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_int_32 png_get_y_offset_microns (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_int_32 png_get_y_offset_pixels (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_y_pixels_per_meter (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_get_compression_buffer_size (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_info_init (png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_init_io (png_structp </command><emphasis>png_ptr</emphasis><command>, FILE </command><emphasis>*fp</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_malloc (png_structp </command><emphasis>png_ptr</emphasis><command>, png_uint_32 </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_malloc_default(png_structp </command><emphasis>png_ptr</emphasis><command>, png_uint_32 </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>voidp png_memcpy (png_voidp </command><emphasis>s1</emphasis><command>, png_voidp </command><emphasis>s2</emphasis><command>, png_size_t </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_memcpy_check (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>s1</emphasis><command>, png_voidp </command><emphasis>s2</emphasis><command>, png_uint_32 </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>voidp png_memset (png_voidp </command><emphasis>s1</emphasis><command>, int </command><emphasis>value</emphasis><command>, png_size_t </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_voidp png_memset_check (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>s1</emphasis><command>, int </command><emphasis>value</emphasis><command>, png_uint_32 </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_permit_empty_plte (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>empty_plte_permitted</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_process_data (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_bytep </command><emphasis>buffer</emphasis><command>, png_size_t </command><emphasis>buffer_size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_progressive_combine_row (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>old_row</emphasis><command>, png_bytep </command><emphasis>new_row</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_destroy (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_infop </command><emphasis>end_info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_end (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_image (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytepp </command><emphasis>image</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>DEPRECATED: void png_read_init (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>DEPRECATED: void png_read_init_2 (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_size_t </command><emphasis>png_struct_size</emphasis><command>, png_size_t </command><emphasis>png_info_size</emphasis><command>);</command>

</para>

<para><command>void png_read_info (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_png (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>transforms</emphasis><command>, png_voidp </command><emphasis>params</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_row (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>row</emphasis><command>, png_bytep </command><emphasis>display_row</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_rows (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytepp </command><emphasis>row</emphasis><command>, png_bytepp </command><emphasis>display_row</emphasis><command>, png_uint_32 </command><emphasis>num_rows</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_read_update_info (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_background (png_structp </command><emphasis>png_ptr</emphasis><command>, png_color_16p </command><emphasis>background_color</emphasis><command>, int </command><emphasis>background_gamma_code</emphasis><command>, int </command><emphasis>need_expand</emphasis><command>, double </command><emphasis>background_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_bgr (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_bKGD (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_color_16p </command><emphasis>background</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_cHRM (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, double </command><emphasis>white_x</emphasis><command>, double </command><emphasis>white_y</emphasis><command>, double </command><emphasis>red_x</emphasis><command>, double </command><emphasis>red_y</emphasis><command>, double </command><emphasis>green_x</emphasis><command>, double </command><emphasis>green_y</emphasis><command>, double </command><emphasis>blue_x</emphasis><command>, double </command><emphasis>blue_y</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_cHRM_fixed (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>white_x</emphasis><command>, png_uint_32 </command><emphasis>white_y</emphasis><command>, png_uint_32 </command><emphasis>red_x</emphasis><command>, png_uint_32 </command><emphasis>red_y</emphasis><command>, png_uint_32 </command><emphasis>green_x</emphasis><command>, png_uint_32 </command><emphasis>green_y</emphasis><command>, png_uint_32 </command><emphasis>blue_x</emphasis><command>, png_uint_32 </command><emphasis>blue_y</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_level (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>level</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_mem_level (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>mem_level</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_method (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>method</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_strategy (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>strategy</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_window_bits (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>window_bits</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_crc_action (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>crit_action</emphasis><command>, int </command><emphasis>ancil_action</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_dither (png_structp </command><emphasis>png_ptr</emphasis><command>, png_colorp </command><emphasis>palette</emphasis><command>, int </command><emphasis>num_palette</emphasis><command>, int </command><emphasis>maximum_colors</emphasis><command>, png_uint_16p </command><emphasis>histogram</emphasis><command>, int </command><emphasis>full_dither</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_error_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>error_ptr</emphasis><command>, png_error_ptr </command><emphasis>error_fn</emphasis><command>, png_error_ptr </command><emphasis>warning_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_expand (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_filler (png_structp </command><emphasis>png_ptr</emphasis><command>, png_uint_32 </command><emphasis>filler</emphasis><command>, int </command><emphasis>flags</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_filter (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>method</emphasis><command>, int </command><emphasis>filters</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_filter_heuristics (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>heuristic_method</emphasis><command>, int </command><emphasis>num_weights</emphasis><command>, png_doublep </command><emphasis>filter_weights</emphasis><command>, png_doublep </command><emphasis>filter_costs</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_flush (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>nrows</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_gamma (png_structp </command><emphasis>png_ptr</emphasis><command>, double </command><emphasis>screen_gamma</emphasis><command>, double </command><emphasis>default_file_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_gAMA (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, double </command><emphasis>file_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_gAMA_fixed (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>file_gamma</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_gray_1_2_4_to_8(png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_gray_to_rgb (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_hIST (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_16p </command><emphasis>hist</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_iCCP (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_charp </command><emphasis>name</emphasis><command>, int </command><emphasis>compression_type</emphasis><command>, png_charp </command><emphasis>profile</emphasis><command>, png_uint_32 </command><emphasis>proflen</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_set_interlace_handling (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_invalid (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>mask</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_invert_alpha (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_invert_mono (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_IHDR (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>width</emphasis><command>, png_uint_32 </command><emphasis>height</emphasis><command>, int </command><emphasis>bit_depth</emphasis><command>, int </command><emphasis>color_type</emphasis><command>, int </command><emphasis>interlace_type</emphasis><command>, int </command><emphasis>compression_type</emphasis><command>, int </command><emphasis>filter_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_keep_unknown_chunks (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>keep</emphasis><command>, png_bytep </command><emphasis>chunk_list</emphasis><command>, int </command><emphasis>num_chunks</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_mem_fn(png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>mem_ptr</emphasis><command>, png_malloc_ptr </command><emphasis>malloc_fn</emphasis><command>, png_free_ptr </command><emphasis>free_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_oFFs (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>offset_x</emphasis><command>, png_uint_32 </command><emphasis>offset_y</emphasis><command>, int </command><emphasis>unit_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_packing (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_packswap (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_palette_to_rgb(png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_pCAL (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_charp </command><emphasis>purpose</emphasis><command>, png_int_32 </command><emphasis>X0</emphasis><command>, png_int_32 </command><emphasis>X1</emphasis><command>, int </command><emphasis>type</emphasis><command>, int </command><emphasis>nparams</emphasis><command>, png_charp </command><emphasis>units</emphasis><command>, png_charpp </command><emphasis>params</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_pHYs (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_uint_32 </command><emphasis>res_x</emphasis><command>, png_uint_32 </command><emphasis>res_y</emphasis><command>, int </command><emphasis>unit_type</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_progressive_read_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>progressive_ptr</emphasis><command>, png_progressive_info_ptr </command><emphasis>info_fn</emphasis><command>, png_progressive_row_ptr </command><emphasis>row_fn</emphasis><command>, png_progressive_end_ptr </command><emphasis>end_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_PLTE (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_colorp </command><emphasis>palette</emphasis><command>, int </command><emphasis>num_palette</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_read_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>io_ptr</emphasis><command>, png_rw_ptr </command><emphasis>read_data_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_read_status_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_read_status_ptr </command><emphasis>read_row_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_read_user_transform_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_user_transform_ptr </command><emphasis>read_user_transform_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_rgb_to_gray (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>error_action</emphasis><command>, double </command><emphasis>red</emphasis><command>, double </command><emphasis>green</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_rgb_to_gray_fixed (png_structp </command><emphasis>png_ptr</emphasis><command>, int error_action png_fixed_point </command><emphasis>red</emphasis><command>, png_fixed_point </command><emphasis>green</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_rows (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_bytepp </command><emphasis>row_pointers</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sBIT (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_color_8p </command><emphasis>sig_bit</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sCAL (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_charp </command><emphasis>unit</emphasis><command>, double </command><emphasis>width</emphasis><command>, double </command><emphasis>height</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_shift (png_structp </command><emphasis>png_ptr</emphasis><command>, png_color_8p </command><emphasis>true_bits</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sig_bytes (png_structp </command><emphasis>png_ptr</emphasis><command>, int </command><emphasis>num_bytes</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sPLT (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_spalette_p </command><emphasis>splt_ptr</emphasis><command>, int </command><emphasis>num_spalettes</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sRGB (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>intent</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_sRGB_gAMA_and_cHRM (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>intent</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_strip_16 (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_strip_alpha (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_swap (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_swap_alpha (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_text (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_textp </command><emphasis>text_ptr</emphasis><command>, int </command><emphasis>num_text</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_tIME (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_timep </command><emphasis>mod_time</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_tRNS (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_bytep </command><emphasis>trans</emphasis><command>, int </command><emphasis>num_trans</emphasis><command>, png_color_16p </command><emphasis>trans_values</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_tRNS_to_alpha(png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>png_uint_32 png_set_unknown_chunks (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, png_unknown_chunkp </command><emphasis>unknowns</emphasis><command>, int </command><emphasis>num</emphasis><command>, int </command><emphasis>location</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_unknown_chunk_location(png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>chunk</emphasis><command>, int </command><emphasis>location</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_read_user_chunk_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>user_chunk_ptr</emphasis><command>, png_user_chunk_ptr </command><emphasis>read_user_chunk_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_user_transform_info (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>user_transform_ptr</emphasis><command>, int </command><emphasis>user_transform_depth</emphasis><command>, int </command><emphasis>user_transform_channels</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_write_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_voidp </command><emphasis>io_ptr</emphasis><command>, png_rw_ptr </command><emphasis>write_data_fn</emphasis><command>, png_flush_ptr </command><emphasis>output_flush_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_write_status_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_write_status_ptr </command><emphasis>write_row_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_write_user_transform_fn (png_structp </command><emphasis>png_ptr</emphasis><command>, png_user_transform_ptr </command><emphasis>write_user_transform_fn</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_set_compression_buffer_size(png_structp </command><emphasis>png_ptr</emphasis><command>, png_uint_32 </command><emphasis>size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>int png_sig_cmp (png_bytep </command><emphasis>sig</emphasis><command>, png_size_t </command><emphasis>start</emphasis><command>, png_size_t </command><emphasis>num_to_check</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_start_read_image (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_warning (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>message</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_chunk (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>chunk_name</emphasis><command>, png_bytep </command><emphasis>data</emphasis><command>, png_size_t </command><emphasis>length</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_chunk_data (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>data</emphasis><command>, png_size_t </command><emphasis>length</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_chunk_end (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_chunk_start (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>chunk_name</emphasis><command>, png_uint_32 </command><emphasis>length</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_destroy (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_destroy_info (png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_end (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_flush (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_image (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytepp </command><emphasis>image</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>DEPRECATED: void png_write_init (png_structp </command><emphasis>png_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>DEPRECATED: void png_write_init_2 (png_structp </command><emphasis>png_ptr</emphasis><command>, png_const_charp </command><emphasis>user_png_ver</emphasis><command>, png_size_t </command><emphasis>png_struct_size</emphasis><command>, png_size_t </command><emphasis>png_info_size</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_info (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_info_before_PLTE (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_png (png_structp </command><emphasis>png_ptr</emphasis><command>, png_infop </command><emphasis>info_ptr</emphasis><command>, int </command><emphasis>transforms</emphasis><command>, png_voidp </command><emphasis>params</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_row (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytep </command><emphasis>row</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para><command>void png_write_rows (png_structp </command><emphasis>png_ptr</emphasis><command>, png_bytepp </command><emphasis>row</emphasis><command>, png_uint_32 </command><emphasis>num_rows</emphasis><command>);</command>

</para>

<para><emphasis></emphasis><command>
</command>
</para>

<para></para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para>The
<emphasis>libpng</emphasis>
library supports encoding, decoding, and various manipulations of
the Portable Network Graphics (PNG) format image files.  It uses the
<emphasis>zlib(3)</emphasis>
compression library.
Following is a copy of the libpng.txt file that accompanies libpng.
</para>
</sect3>
<sect3><title>LIBPNG.TXT</title>

<para>libpng.txt - A description on how to use and modify libpng

</para>

<para> libpng version 1.0.9 - January 31, 2001
 Updated and distributed by Glenn Randers-Pehrson
 &lt;randeg@alum.rpi.edu&gt;
 Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson
 For conditions of distribution and use, see copyright
 notice in png.h.

</para>

<para> based on:

</para>

<para> libpng 1.0 beta 6  version 0.96 May 28, 1997
 Updated and distributed by Andreas Dilger
 Copyright (c) 1996, 1997 Andreas Dilger

</para>

<para> libpng 1.0 beta 2 - version 0.88  January 26, 1996
 For conditions of distribution and use, see copyright
 notice in png.h. Copyright (c) 1995, 1996 Guy Eric
 Schalnat, Group 42, Inc.

</para>

<para> Updated/rewritten per request in the libpng FAQ
 Copyright (c) 1995, 1996 Frank J. T. Wojcik
 December 18, 1995 &amp; January 20, 1996

</para>

<para></para>
</sect3>
<sect3><title>I. Introduction</title>

<para>
</para>

<para>This file describes how to use and modify the PNG reference library
(known as libpng) for your own use.  There are five sections to this
file: introduction, structures, reading, writing, and modification and
configuration notes for various special platforms.  In addition to this
file, example.c is a good starting point for using the library, as
it is heavily commented and should include everything most people
will need.  We assume that libpng is already installed; see the
INSTALL file for instructions on how to install libpng.

</para>

<para>Libpng was written as a companion to the PNG specification, as a way
of reducing the amount of time and effort it takes to support the PNG
file format in application programs.

</para>

<para>The PNG-1.2 specification is available at &lt;http://www.libpng.org/pub/png&gt;
and at &lt;ftp://ftp.uu.net/graphics/png/documents/&gt;.

</para>

<para>The PNG-1.0 specification is available
as RFC 2083 &lt;ftp://ftp.uu.net/graphics/png/documents/&gt; and as a
W3C Recommendation &lt;http://www.w3.org/TR/REC.png.html&gt;. Some
additional chunks are described in the special-purpose public chunks
documents at &lt;ftp://ftp.uu.net/graphics/png/documents/&gt;.

</para>

<para>Other information
about PNG, and the latest version of libpng, can be found at the PNG home
page, &lt;http://www.libpng.org/pub/png/&gt;
and at &lt;ftp://ftp.uu.net/graphics/png/&gt;.

</para>

<para>Most users will not have to modify the library significantly; advanced
users may want to modify it more.  All attempts were made to make it as
complete as possible, while keeping the code easy to understand.
Currently, this library only supports C.  Support for other languages
is being considered.

</para>

<para>Libpng has been designed to handle multiple sessions at one time,
to be easily modifiable, to be portable to the vast majority of
machines (ANSI, K&amp;R, 16-, 32-, and 64-bit) available, and to be easy
to use.  The ultimate goal of libpng is to promote the acceptance of
the PNG file format in whatever way possible.  While there is still
work to be done (see the TODO file), libpng should cover the
majority of the needs of its users.

</para>

<para>Libpng uses zlib for its compression and decompression of PNG files.
Further information about zlib, and the latest version of zlib, can
be found at the zlib home page, &lt;http://www.info-zip.org/pub/infozip/zlib/&gt;.
The zlib compression utility is a general purpose utility that is
useful for more than PNG files, and can be used without libpng.
See the documentation delivered with zlib for more details.
You can usually find the source files for the zlib utility wherever you
find the libpng source files.

</para>

<para>Libpng is thread safe, provided the threads are using different
instances of the structures.  Each thread should have its own
png_struct and png_info instances, and thus its own image.
Libpng does not protect itself against two threads using the
same instance of a structure.

</para>

<para>
</para>

<para></para>
</sect3>
<sect3><title>II. Structures</title>

<para>
</para>

<para>There are two main structures that are important to libpng, png_struct
and png_info.  The first, png_struct, is an internal structure that
will not, for the most part, be used by a user except as the first
variable passed to every libpng function call.

</para>

<para>The png_info structure is designed to provide information about the
PNG file.  At one time, the fields of png_info were intended to be
directly accessible to the user.  However, this tended to cause problems
with applications using dynamically loaded libraries, and as a result
a set of interface functions for png_info (the png_get_*() and png_set_*()
functions) was developed.  The fields of png_info are still available for
older applications, but it is suggested that applications use the new
interfaces if at all possible.

</para>

<para>Applications that do make direct access to the members of png_struct (except
for png_ptr-&gt;jmpbuf) must be recompiled whenever the library is updated,
and applications that make direct access to the members of png_info must
be recompiled if they were compiled or loaded with libpng version 1.0.6,
in which the members were in a different order.  In version 1.0.7, the
members of the png_info structure reverted to the old order, as they were
in versions 0.97c through 1.0.5.  Starting with version 2.0.0, both
structures are going to be hidden, and the contents of the structures will
only be accessible through the png_get/png_set functions.

</para>

<para>The png.h header file is an invaluable reference for programming with libpng.
And while I'm on the topic, make sure you include the libpng header file:

</para>

<para>#include &lt;png.h&gt;

</para>

<para></para>
</sect3>
<sect3><title>III. Reading</title>

<para>
</para>

<para>We'll now walk you through the possible functions to call when reading
in a PNG file sequentially, briefly explaining the syntax and purpose
of each one.  See example.c and png.h for more detail.  While
progressive reading is covered in the next section, you will still
need some of the functions discussed in this section to read a PNG
file.

</para>

<para>
</para>

<para>You will want to do the I/O initialization(*) before you get into libpng,
so if it doesn't work, you don't have much to undo.  Of course, you
will also want to insure that you are, in fact, dealing with a PNG
file.  Libpng provides a simple check to see if a file is a PNG file.
To use it, pass in the first 1 to 8 bytes of the file to the function
png_sig_cmp(), and it will return 0 if the bytes match the corresponding
bytes of the PNG signature, or nonzero otherwise.  Of course, the more bytes
you pass in, the greater the accuracy of the prediction.

</para>

<para>If you are intending to keep the file pointer open for use in libpng,
you must ensure you don't read more than 8 bytes from the beginning
of the file, and you also have to make a call to png_set_sig_bytes_read()
with the number of bytes you read from the beginning.  Libpng will
then only check the bytes (if any) that your program didn't read.

</para>

<para>(*): If you are not using the standard I/O functions, you will need
to replace them with custom functions.  See the discussion under
Customizing libpng.

</para>

<para>
</para>

<para>    FILE *fp = fopen(file_name, "rb");
    if (!fp)
    {
        return (ERROR);
    }
    fread(header, 1, number, fp);
    is_png = !png_sig_cmp(header, 0, number);
    if (!is_png)
    {
        return (NOT_PNG);
    }

</para>

<para>
</para>

<para>Next, png_struct and png_info need to be allocated and initialized.  In
order to ensure that the size of these structures is correct even with a
dynamically linked libpng, there are functions to initialize and
allocate the structures.  We also pass the library version, optional
pointers to error handling functions, and a pointer to a data struct for
use by the error functions, if necessary (the pointer and functions can
be NULL if the default error handlers are to be used).  See the section
on Changes to Libpng below regarding the old initialization functions.
The structure allocation functions quietly return NULL if they fail to
create the structure, so your application should check for that.

</para>

<para>    png_structp png_ptr = png_create_read_struct
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn);
    if (!png_ptr)
        return (ERROR);

</para>

<para>    png_infop info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
    {
        png_destroy_read_struct(&amp;png_ptr,
           (png_infopp)NULL, (png_infopp)NULL);
        return (ERROR);
    }

</para>

<para>    png_infop end_info = png_create_info_struct(png_ptr);
    if (!end_info)
    {
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
          (png_infopp)NULL);
        return (ERROR);
    }

</para>

<para>If you want to use your own memory allocation routines,
define PNG_USER_MEM_SUPPORTED and use
png_create_read_struct_2() instead of png_create_read_struct():

</para>

<para>    png_structp png_ptr = png_create_read_struct_2
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn, (png_voidp)
        user_mem_ptr, user_malloc_fn, user_free_fn);

</para>

<para>The error handling routines passed to png_create_read_struct()
and the memory alloc/free routines passed to png_create_struct_2()
are only necessary if you are not using the libpng supplied error
handling and memory alloc/free functions.

</para>

<para>When libpng encounters an error, it expects to longjmp back
to your routine.  Therefore, you will need to call setjmp and pass
your png_jmpbuf(png_ptr).  If you read the file from different
routines, you will need to update the jmpbuf field every time you enter
a new routine that will call a png_*() function.

</para>

<para>See your documentation of setjmp/longjmp for your compiler for more
information on setjmp/longjmp.  See the discussion on libpng error
handling in the Customizing Libpng section below for more information
on the libpng error handling.  If an error occurs, and libpng longjmp's
back to your setjmp, you will want to call png_destroy_read_struct() to
free any memory.

</para>

<para>    if (setjmp(png_jmpbuf(png_ptr)))
    {
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
           &amp;end_info);
        fclose(fp);
        return (ERROR);
    }

</para>

<para>If you would rather avoid the complexity of setjmp/longjmp issues,
you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case
errors will result in a call to PNG_ABORT() which defaults to abort().

</para>

<para>Now you need to set up the input code.  The default for libpng is to
use the C function fread().  If you use this, you will need to pass a
valid FILE * in the function png_init_io().  Be sure that the file is
opened in binary mode.  If you wish to handle reading data in another
way, you need not call the png_init_io() function, but you must then
implement the libpng I/O methods discussed in the Customizing Libpng
section below.

</para>

<para>    png_init_io(png_ptr, fp);

</para>

<para>If you had previously opened the file and read any of the signature from
the beginning in order to see if this was a PNG file, you need to let
libpng know that there are some bytes missing from the start of the file.

</para>

<para>    png_set_sig_bytes(png_ptr, number);

</para>

<para>
</para>

<para>You can set up a callback function to handle any unknown chunks in the
input stream. You must supply the function

</para>

<para>    read_chunk_callback(png_ptr ptr,
         png_unknown_chunkp chunk);
    {
       /* The unknown chunk structure contains your
          chunk data: */
           png_byte name[5];
           png_byte *data;
           png_size_t size;
       /* Note that libpng has already taken care of the
          CRC handling */

</para>

<para>       /* put your code here.  Return one of the following: */

</para>

<para>       return (-n); /* chunk had an error */
       return (0); /* did not recognize */
       return (n); /* success */
    }

</para>

<para>(You can give your function another name that you like instead of
"read_chunk_callback")

</para>

<para>To inform libpng about your function, use

</para>

<para>    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
        read_chunk_callback);

</para>

<para>This names not only the callback function, but also a user pointer that
you can retrieve with

</para>

<para>    png_get_user_chunk_ptr(png_ptr);

</para>

<para>At this point, you can set up a callback function that will be
called after each row has been read, which you can use to control
a progress meter or the like.  It's demonstrated in pngtest.c.
You must supply a function

</para>

<para>    void read_row_callback(png_ptr ptr, png_uint_32 row, int pass);
    {
      /* put your code here */
    }

</para>

<para>(You can give it another name that you like instead of "read_row_callback")

</para>

<para>To inform libpng about your function, use

</para>

<para>    png_set_read_status_fn(png_ptr, read_row_callback);

</para>

<para>
</para>

<para>Now you get to set the way the library processes unknown chunks in the
input PNG stream. Both known and unknown chunks will be read.  Normal
behavior is that known chunks will be parsed into information in
various info_ptr members; unknown chunks will be discarded. To change
this, you can call:

</para>

<para>    png_set_keep_unknown_chunks(png_ptr, info_ptr, keep,
        chunk_list, num_chunks);
    keep       - 0: do not keep
                 1: keep only if safe-to-copy
                 2: keep even if unsafe-to-copy
    chunk_list - list of chunks affected (a byte string,
                 five bytes per chunk, NULL or '\0' if
                 num_chunks is 0)
    num_chunks - number of chunks affected; if 0, all
                 unknown chunks are affected

</para>

<para>Unknown chunks declared in this way will be saved as raw data onto a
list of png_unknown_chunk structures.  If a chunk that is normally
known to libpng is named in the list, it will be handled as unknown,
according to the "keep" directive.  If a chunk is named in successive
instances of png_set_keep_unknown_chunks(), the final instance will
take precedence.

</para>

<para>
</para>

<para>At this point there are two ways to proceed; through the high-level
read interface, or through a sequence of low-level read operations.
You can use the high-level interface if (a) you are willing to read
the entire image into memory, and (b) the input transformations
you want to do are limited to the following set:

</para>

<para>    PNG_TRANSFORM_IDENTITY      No transformation
    PNG_TRANSFORM_STRIP_16      Strip 16-bit samples to 8 bits
    PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel
    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit samples to bytes
    PNG_TRANSFORM_PACKSWAP      Change order of packed pixels to LSB first
    PNG_TRANSFORM_EXPAND        Perform set_expand()
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
    PNG_TRANSFORM_SHIFT         Normalize pixels to the sBIT depth
    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA to BGRA
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA to AG
    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity to transparency
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples

</para>

<para>(This excludes setting a background color, doing gamma transformation,
dithering, and setting filler.)  If this is the case, simply do this:

</para>

<para>    png_read_png(png_ptr, info_ptr, png_transforms, NULL)

</para>

<para>where png_transforms is an integer containing the logical OR of
some set of transformation flags.  This call is equivalent to png_read_info(),
followed the set of transformations indicated by the transform mask,
then png_read_image(), and finally png_read_end().

</para>

<para>(The final parameter of this call is not yet used.  Someday it might point
to transformation parameters required by some future input transform.)

</para>

<para>After you have called png_read_png(), you can retrieve the image data
with

</para>

<para>   row_pointers = png_get_rows(png_ptr, info_ptr);

</para>

<para>where row_pointers is an array of pointers to the pixel data for each row:

</para>

<para>   png_bytep row_pointers[height];

</para>

<para>If you know your image size and pixel size ahead of time, you can allocate
row_pointers prior to calling png_read_png() with

</para>

<para>   row_pointers = png_malloc(png_ptr, height*sizeof(png_bytep));
   for (int i=0; i&lt;height, i++)
      row_pointers[i]=png_malloc(png_ptr, width*pixel_size);
   png_set_rows(png_ptr, info_ptr, &amp;row_pointers);

</para>

<para>Alternatively you could allocate your image in one big block and define
row_pointers[i] to point into the proper places in your block.

</para>

<para>If you use png_set_rows(), the application is responsible for freeing
row_pointers (and row_pointers[i], if they were separately allocated).

</para>

<para>If you don't allocate row_pointers ahead of time, png_read_png() will
do it, and it'll be free'ed when you call png_destroy_*().

</para>

<para>
</para>

<para>If you are going the low-level route, you are now ready to read all
the file information up to the actual image data.  You do this with a
call to png_read_info().

</para>

<para>    png_read_info(png_ptr, info_ptr);

</para>

<para>This will process all chunks up to but not including the image data.

</para>

<para>
</para>

<para>Functions are used to get the information from the info_ptr once it
has been read.  Note that these fields may not be completely filled
in until png_read_end() has read the chunk data following the image.

</para>

<para>    png_get_IHDR(png_ptr, info_ptr, &amp;width, &amp;height,
       &amp;bit_depth, &amp;color_type, &amp;interlace_type,
       &amp;compression_type, &amp;filter_method);

</para>

<para>    width          - holds the width of the image
                     in pixels (up to 2^31).
    height         - holds the height of the image
                     in pixels (up to 2^31).
    bit_depth      - holds the bit depth of one of the
                     image channels.  (valid values are
                     1, 2, 4, 8, 16 and depend also on
                     the color_type.  See also
                     significant bits (sBIT) below).
    color_type     - describes which color/alpha channels
                         are present.
                     PNG_COLOR_TYPE_GRAY
                        (bit depths 1, 2, 4, 8, 16)
                     PNG_COLOR_TYPE_GRAY_ALPHA
                        (bit depths 8, 16)
                     PNG_COLOR_TYPE_PALETTE
                        (bit depths 1, 2, 4, 8)
                     PNG_COLOR_TYPE_RGB
                        (bit_depths 8, 16)
                     PNG_COLOR_TYPE_RGB_ALPHA
                        (bit_depths 8, 16)

</para>

<para>                     PNG_COLOR_MASK_PALETTE
                     PNG_COLOR_MASK_COLOR
                     PNG_COLOR_MASK_ALPHA

</para>

<para>    filter_method  - (must be PNG_FILTER_TYPE_BASE
                     for PNG 1.0, and can also be
                     PNG_INTRAPIXEL_DIFFERENCING if
                     the PNG datastream is embedded in
                     a MNG-1.0 datastream)
    compression_type - (must be PNG_COMPRESSION_TYPE_BASE
                     for PNG 1.0)
    interlace_type - (PNG_INTERLACE_NONE or
                     PNG_INTERLACE_ADAM7)
    Any or all of interlace_type, compression_type, of
                     filter_method can be NULL if you are
                     not interested in their values.

</para>

<para>    channels = png_get_channels(png_ptr, info_ptr);
    channels       - number of channels of info for the
                     color type (valid values are 1 (GRAY,
                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
                     4 (RGB_ALPHA or RGB + filler byte))
    rowbytes = png_get_rowbytes(png_ptr, info_ptr);
    rowbytes       - number of bytes needed to hold a row

</para>

<para>    signature = png_get_signature(png_ptr, info_ptr);
    signature      - holds the signature read from the
                     file (if any).  The data is kept in
                     the same offset it would be if the
                     whole signature were read (i.e. if an
                     application had already read in 4
                     bytes of signature before starting
                     libpng, the remaining 4 bytes would
                     be in signature[4] through signature[7]
                     (see png_set_sig_bytes())).

</para>

<para>
</para>

<para>    width            = png_get_image_width(png_ptr,
                         info_ptr);
    height           = png_get_image_height(png_ptr,
                         info_ptr);
    bit_depth        = png_get_bit_depth(png_ptr,
                         info_ptr);
    color_type       = png_get_color_type(png_ptr,
                         info_ptr);
    filter_method    = png_get_filter_type(png_ptr,
                         info_ptr);
    compression_type = png_get_compression_type(png_ptr,
                         info_ptr);
    interlace_type   = png_get_interlace_type(png_ptr,
                         info_ptr);

</para>

<para>
</para>

<para>These are also important, but their validity depends on whether the chunk
has been read.  The png_get_valid(png_ptr, info_ptr, PNG_INFO_&lt;chunk&gt;) and
png_get_&lt;chunk&gt;(png_ptr, info_ptr, ...) functions return non-zero if the
data has been read, or zero if it is missing.  The parameters to the
png_get_&lt;chunk&gt; are set directly if they are simple data types, or a pointer
into the info_ptr is returned for any complex types.

</para>

<para>    png_get_PLTE(png_ptr, info_ptr, &amp;palette,
                     &amp;num_palette);
    palette        - the palette for the file
                     (array of png_color)
    num_palette    - number of entries in the palette

</para>

<para>    png_get_gAMA(png_ptr, info_ptr, &amp;gamma);
    gamma          - the gamma the file is written
                     at (PNG_INFO_gAMA)

</para>

<para>    png_get_sRGB(png_ptr, info_ptr, &amp;srgb_intent);
    srgb_intent    - the rendering intent (PNG_INFO_sRGB)
                     The presence of the sRGB chunk
                     means that the pixel data is in the
                     sRGB color space.  This chunk also
                     implies specific values of gAMA and
                     cHRM.

</para>

<para>    png_get_iCCP(png_ptr, info_ptr, &amp;name, &amp;compression_type,
                      &amp;profile, &amp;proflen);
    name            - The profile name.
    compression     - The compression type; always PNG_COMPRESSION_TYPE_BASE
                      for PNG 1.0.  You may give NULL to this argument
                      to ignore it.
    profile         - International Color Consortium color profile
                      data. May contain NULs.
    proflen         - length of profile data in bytes.

</para>

<para>    png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit);
    sig_bit        - the number of significant bits for
                     (PNG_INFO_sBIT) each of the gray,
                     red, green, and blue channels,
                     whichever are appropriate for the
                     given color type (png_color_16)

</para>

<para>    png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans,
                     &amp;trans_values);
    trans          - array of transparent entries for
                     palette (PNG_INFO_tRNS)
    trans_values   - graylevel or color sample values of
                     the single transparent color for
                     non-paletted images (PNG_INFO_tRNS)
    num_trans      - number of transparent entries
                     (PNG_INFO_tRNS)

</para>

<para>    png_get_hIST(png_ptr, info_ptr, &amp;hist);
                     (PNG_INFO_hIST)
    hist           - histogram of palette (array of
                     png_uint_16)

</para>

<para>    png_get_tIME(png_ptr, info_ptr, &amp;mod_time);
    mod_time       - time image was last modified
                    (PNG_VALID_tIME)

</para>

<para>    png_get_bKGD(png_ptr, info_ptr, &amp;background);
    background     - background color (PNG_VALID_bKGD)
                     valid 16-bit red, green and blue
                     values, regardless of color_type

</para>

<para>    num_comments   = png_get_text(png_ptr, info_ptr,
                     &amp;text_ptr, &amp;num_text);
    num_comments   - number of comments
    text_ptr       - array of png_text holding image
                     comments
    text_ptr[i].compression - type of compression used
                 on "text" PNG_TEXT_COMPRESSION_NONE
                           PNG_TEXT_COMPRESSION_zTXt
                           PNG_ITXT_COMPRESSION_NONE
                           PNG_ITXT_COMPRESSION_zTXt
    text_ptr[i].key   - keyword for comment.  Must contain
                         1-79 characters.
    text_ptr[i].text  - text comments for current
                         keyword.  Can be empty.
    text_ptr[i].text_length - length of text string,
                 after decompression, 0 for iTXt
    text_ptr[i].itxt_length - length of itxt string,
                 after decompression, 0 for tEXt/zTXt
    text_ptr[i].lang  - language of comment (empty
                         string for unknown).
    text_ptr[i].translated_keyword  - keyword in UTF-8
                         (empty string for unknown).
    num_text       - number of comments (same as num_comments;
                     you can put NULL here to avoid the duplication)
    Note while png_set_text() will accept text, language, and
    translated keywords that can be NULL pointers, the structure
    returned by png_get_text will always contain regular
    zero-terminated C strings.  They might be empty strings but
    they will never be NULL pointers.

</para>

<para>    num_spalettes = png_get_sPLT(png_ptr, info_ptr, &amp;palette_ptr);
    palette_ptr    - array of palette structures holding
                     contents of one or more sPLT chunks read.
    num_spalettes  - number of sPLT chunks read.

</para>

<para>    png_get_oFFs(png_ptr, info_ptr, &amp;offset_x, &amp;offset_y,
                     &amp;unit_type);
    offset_x       - positive offset from the left edge
                     of the screen
    offset_y       - positive offset from the top edge
                     of the screen
    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER

</para>

<para>    png_get_pHYs(png_ptr, info_ptr, &amp;res_x, &amp;res_y,
                     &amp;unit_type);
    res_x          - pixels/unit physical resolution in
                     x direction
    res_y          - pixels/unit physical resolution in
                     x direction
    unit_type      - PNG_RESOLUTION_UNKNOWN,
                     PNG_RESOLUTION_METER

</para>

<para>    png_get_sCAL(png_ptr, info_ptr, &amp;unit, &amp;width, &amp;height)
    unit        - physical scale units (an integer)
    width       - width of a pixel in physical scale units
    height      - height of a pixel in physical scale units
                 (width and height are doubles)

</para>

<para>    png_get_sCAL_s(png_ptr, info_ptr, &amp;unit, &amp;width, &amp;height)
    unit        - physical scale units (an integer)
    width       - width of a pixel in physical scale units
    height      - height of a pixel in physical scale units
                 (width and height are strings like "2.54")

</para>

<para>    num_unknown_chunks = png_get_unknown_chunks(png_ptr, info_ptr,
                            &amp;unknowns)
    unknowns          - array of png_unknown_chunk structures holding
                        unknown chunks
    unknowns[i].name  - name of unknown chunk
    unknowns[i].data  - data of unknown chunk
    unknowns[i].size  - size of unknown chunk's data
    unknowns[i].location - position of chunk in file

</para>

<para>    The value of "i" corresponds to the order in which the chunks were read
    from the PNG file or inserted with the png_set_unknown_chunks() function.

</para>

<para>The data from the pHYs chunk can be retrieved in several convenient
forms:

</para>

<para>    res_x = png_get_x_pixels_per_meter(png_ptr,
                  info_ptr)
    res_y = png_get_y_pixels_per_meter(png_ptr,
                  info_ptr)
    res_x_and_y = png_get_pixels_per_meter(png_ptr,
                  info_ptr)
    res_x = png_get_x_pixels_per_inch(png_ptr,
                  info_ptr)
    res_y = png_get_y_pixels_per_inch(png_ptr,
                  info_ptr)
    res_x_and_y = png_get_pixels_per_inch(png_ptr,
                  info_ptr)
    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
                  info_ptr)

</para>

<para>   (Each of these returns 0 [signifying "unknown"] if
       the data is not present or if res_x is 0;
       res_x_and_y is 0 if res_x != res_y)

</para>

<para>The data from the oFFs chunk can be retrieved in several convenient
forms:

</para>

<para>    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);
    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);

</para>

<para>   (Each of these returns 0 [signifying "unknown" if both
       x and y are 0] if the data is not present or if the chunk
       is present but the unit is the pixel)

</para>

<para>For more information, see the png_info definition in png.h and the
PNG specification for chunk contents.  Be careful with trusting
rowbytes, as some of the transformations could increase the space
needed to hold a row (expand, filler, gray_to_rgb, etc.).
See png_read_update_info(), below.

</para>

<para>A quick word about text_ptr and num_text.  PNG stores comments in
keyword/text pairs, one pair per chunk, with no limit on the number
of text chunks, and a 2^31 byte limit on their size.  While there are
suggested keywords, there is no requirement to restrict the use to these
strings.  It is strongly suggested that keywords and text be sensible
to humans (that's the point), so don't use abbreviations.  Non-printing
symbols are not allowed.  See the PNG specification for more details.
There is also no requirement to have text after the keyword.

</para>

<para>Keywords should be limited to 79 Latin-1 characters without leading or
trailing spaces, but non-consecutive spaces are allowed within the
keyword.  It is possible to have the same keyword any number of times.
The text_ptr is an array of png_text structures, each holding a
pointer to a language string, a pointer to a keyword and a pointer to
a text string.  The text string, language code, and translated
keyword may be empty or NULL pointers.  The keyword/text
pairs are put into the array in the order that they are received.
However, some or all of the text chunks may be after the image, so, to
make sure you have read all the text chunks, don't mess with these
until after you read the stuff after the image.  This will be
mentioned again below in the discussion that goes with png_read_end().

</para>

<para>
</para>

<para>After you've read the header information, you can set up the library
to handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
should occur.  This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths.  Even though each transformation
checks to see if it has data that it can do something with, you should
make sure to only enable a transformation if it will be valid for the
data.  For example, don't swap red and blue on grayscale data.

</para>

<para>The colors used for the background and transparency values should be
supplied in the same format/depth as the current image data.  They
are stored in the same format/depth as the image data in a bKGD or tRNS
chunk, so this is what libpng expects for this data.  The colors are
transformed to keep in sync with the image data when an application
calls the png_read_update_info() routine (see below).

</para>

<para>Data will be decoded into the supplied row buffers packed into bytes
unless the library has been told to transform it into another format.
For example, 4 bit/pixel paletted or grayscale data will be returned
2 pixels/byte with the leftmost pixel in the high-order bits of the
byte, unless png_set_packing() is called.  8-bit RGB data will be stored
in RGB RGB RGB format unless png_set_filler() is called to insert filler
bytes, either before or after each RGB triplet.  16-bit RGB data will
be returned RRGGBB RRGGBB, with the most significant byte of the color
value first, unless png_set_strip_16() is called to transform it to
regular RGB RGB triplets, or png_set_filler() is called to insert
filler bytes, either before or after each RRGGBB triplet.  Similarly,
8-bit or 16-bit grayscale data can be modified with png_set_filler()
or png_set_strip_16().

</para>

<para>The following code transforms grayscale images of less than 8 to 8 bits,
changes paletted images to RGB, and adds a full alpha channel if there is
transparency information in a tRNS chunk.  This is most useful on
grayscale images with bit depths of 2 or 4 or if there is a multiple-image
viewing application that wishes to treat all images in the same way.

</para>

<para>    if (color_type == PNG_COLOR_TYPE_PALETTE)
        png_set_palette_to_rgb(png_ptr);

</para>

<para>    if (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp;
        bit_depth &lt; 8) png_set_gray_1_2_4_to_8(png_ptr);

</para>

<para>    if (png_get_valid(png_ptr, info_ptr,
        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);

</para>

<para>These three functions are actually aliases for png_set_expand(), added
in libpng version 1.0.4, with the function names expanded to improve code
readability.  In some future version they may actually do different
things.

</para>

<para>PNG can have files with 16 bits per channel.  If you only can handle
8 bits per channel, this will strip the pixels down to 8 bit.

</para>

<para>    if (bit_depth == 16)
        png_set_strip_16(png_ptr);

</para>

<para>If, for some reason, you don't need the alpha channel on an image,
and you want to remove it rather than combining it with the background
(but the image author certainly had in mind that you *would* combine
it with the background, so that's what you should probably do):

</para>

<para>    if (color_type &amp; PNG_COLOR_MASK_ALPHA)
        png_set_strip_alpha(png_ptr);

</para>

<para>In PNG files, the alpha channel in an image
is the level of opacity.  If you need the alpha channel in an image to
be the level of transparency instead of opacity, you can invert the
alpha channel (or the tRNS chunk data) after it's read, so that 0 is
fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
images) is fully transparent, with

</para>

<para>    png_set_invert_alpha(png_ptr);

</para>

<para>PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit
files.  This code expands to 1 pixel per byte without changing the
values of the pixels:

</para>

<para>    if (bit_depth &lt; 8)
        png_set_packing(png_ptr);

</para>

<para>PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
stored in a PNG image have been "scaled" or "shifted" up to the next
higher possible bit depth (e.g. from 5 bits/sample in the range [0,31] to
8 bits/sample in the range [0, 255]).  However, it is also possible to
convert the PNG pixel data back to the original bit depth of the image.
This call reduces the pixels back down to the original bit depth:

</para>

<para>    png_color_16p sig_bit;

</para>

<para>    if (png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit))
        png_set_shift(png_ptr, sig_bit);

</para>

<para>PNG files store 3-color pixels in red, green, blue order.  This code
changes the storage of the pixels to blue, green, red:

</para>

<para>    if (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        png_set_bgr(png_ptr);

</para>

<para>PNG files store RGB pixels packed into 3 bytes. This code expands them
into 4 bytes for windowing systems that need them in this format:

</para>

<para>    if (bit_depth == 8 &amp;&amp; color_type ==
        PNG_COLOR_TYPE_RGB) png_set_filler(png_ptr,
        filler, PNG_FILLER_BEFORE);

</para>

<para>where "filler" is the 8 or 16-bit number to fill with, and the location is
either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
you want the filler before the RGB or after.  This transformation
does not affect images that already have full alpha channels.

</para>

<para>If you are reading an image with an alpha channel, and you need the
data as ARGB instead of the normal PNG format RGBA:

</para>

<para>    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        png_set_swap_alpha(png_ptr);

</para>

<para>For some uses, you may want a grayscale image to be represented as
RGB.  This code will do that conversion:

</para>

<para>    if (color_type == PNG_COLOR_TYPE_GRAY ||
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
          png_set_gray_to_rgb(png_ptr);

</para>

<para>Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
with alpha.

</para>

<para>    if (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
          png_set_rgb_to_gray_fixed(png_ptr, error_action,
             int red_weight, int green_weight);

</para>

<para>    error_action = 1: silently do the conversion
    error_action = 2: issue a warning if the original
                      image has any pixel where
                      red != green or red != blue
    error_action = 3: issue an error and abort the
                      conversion if the original
                      image has any pixel where
                      red != green or red != blue

</para>

<para>    red_weight:       weight of red component times 100000
    green_weight:     weight of green component times 100000
                      If either weight is negative, default
                      weights (21268, 71514) are used.

</para>

<para>If you have set error_action = 1 or 2, you can
later check whether the image really was gray, after processing
the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
It will return a png_byte that is zero if the image was gray or
1 if there were any non-gray pixels.  bKGD and sBIT data
will be silently converted to grayscale, using the green channel
data, regardless of the error_action setting.

</para>

<para>With red_weight+green_weight&lt;=100000,
the normalized graylevel is computed:

</para>

<para>    int rw = red_weight * 65536;
    int gw = green_weight * 65536;
    int bw = 65536 - (rw + gw);
    gray = (rw*red + gw*green + bw*blue)/65536;

</para>

<para>The default values approximate those recommended in the Charles
Poynton's Color FAQ, &lt;http://www.inforamp.net/~poynton/&gt;
Copyright (c) 1998-01-04 Charles Poynton poynton@inforamp.net

</para>

<para>    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B

</para>

<para>Libpng approximates this with

</para>

<para>    Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B

</para>

<para>which can be expressed with integers as

</para>

<para>    Y = (6969 * R + 23434 * G + 2365 * B)/32768

</para>

<para>The calculation is done in a linear colorspace, if the image gamma
is known.

</para>

<para>If you have a grayscale and you are using png_set_expand_depth() or
png_set_expand() to change to
a higher bit-depth, you must either supply the background color as a gray
value at the original file bit-depth (need_expand = 1) or else supply the
background color as an RGB triplet at the final, expanded bit depth
(need_expand = 0).  Similarly, if you are reading a paletted image, you
must either supply the background color as a palette index (need_expand = 1)
or as an RGB triplet that may or may not be in the palette (need_expand = 0).

</para>

<para>    png_color_16 my_background;
    png_color_16p image_background;

</para>

<para>    if (png_get_bKGD(png_ptr, info_ptr, &amp;image_background))
        png_set_background(png_ptr, image_background,
          PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
    else
        png_set_background(png_ptr, &amp;my_background,
          PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);

</para>

<para>The png_set_background() function tells libpng to composite images
with alpha or simple transparency against the supplied background
color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
you may use this color, or supply another color more suitable for
the current display (e.g., the background color from a web page).  You
need to tell libpng whether the color is in the gamma space of the
display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
(PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
know why anyone would use this, but it's here).

</para>

<para>To properly display PNG images on any kind of system, the application needs
to know what the display gamma is.  Ideally, the user will know this, and
the application will allow them to set it.  One method of allowing the user
to set the display gamma separately for each system is to check for a
SCREEN_GAMMA or DISPLAY_GAMMA environment variable, which will hopefully be
correctly set.

</para>

<para>Note that display_gamma is the overall gamma correction required to produce
pleasing results, which depends on the lighting conditions in the surrounding
environment.  In a dim or brightly lit room, no compensation other than
the physical gamma exponent of the monitor is needed, while in a dark room
a slightly smaller exponent is better.

</para>

<para>   double gamma, screen_gamma;

</para>

<para>   if (/* We have a user-defined screen
       gamma value */)
   {
      screen_gamma = user_defined_screen_gamma;
   }
   /* One way that applications can share the same
      screen gamma value */
   else if ((gamma_str = getenv("SCREEN_GAMMA"))
      != NULL)
   {
      screen_gamma = (double)atof(gamma_str);
   }
   /* If we don't have another value */
   else
   {
      screen_gamma = 2.2; /* A good guess for a
           PC monitor in a bright office or a dim room */
      screen_gamma = 2.0; /* A good guess for a
           PC monitor in a dark room */
      screen_gamma = 1.7 or 1.0;  /* A good
           guess for Mac systems */
   }

</para>

<para>The png_set_gamma() function handles gamma transformations of the data.
Pass both the file gamma and the current screen_gamma.  If the file does
not have a gamma value, you can pass one anyway if you have an idea what
it is (usually 0.45455 is a good guess for GIF images on PCs).  Note
that file gammas are inverted from screen gammas.  See the discussions
on gamma in the PNG specification for an excellent description of what
gamma is, and why all applications should support it.  It is strongly
recommended that PNG viewers support gamma correction.

</para>

<para>   if (png_get_gAMA(png_ptr, info_ptr, &amp;gamma))
      png_set_gamma(png_ptr, screen_gamma, gamma);
   else
      png_set_gamma(png_ptr, screen_gamma, 0.45455);

</para>

<para>If you need to reduce an RGB file to a paletted file, or if a paletted
file has more entries then will fit on your screen, png_set_dither()
will do that.  Note that this is a simple match dither that merely
finds the closest color available.  This should work fairly well with
optimized palettes, and fairly badly with linear color cubes.  If you
pass a palette that is larger then maximum_colors, the file will
reduce the number of colors in the palette so it will fit into
maximum_colors.  If there is a histogram, it will use it to make
more intelligent choices when reducing the palette.  If there is no
histogram, it may not do as good a job.

</para>

<para>   if (color_type &amp; PNG_COLOR_MASK_COLOR)
   {
      if (png_get_valid(png_ptr, info_ptr,
         PNG_INFO_PLTE))
      {
         png_uint_16p histogram;

</para>

<para>         png_get_hIST(png_ptr, info_ptr,
            &amp;histogram);
         png_set_dither(png_ptr, palette, num_palette,
            max_screen_colors, histogram, 1);
      }
      else
      {
         png_color std_color_cube[MAX_SCREEN_COLORS] =
            { ... colors ... };

</para>

<para>         png_set_dither(png_ptr, std_color_cube,
            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
            NULL,0);
      }
   }

</para>

<para>PNG files describe monochrome as black being zero and white being one.
The following code will reverse this (make black be one and white be
zero):

</para>

<para>   if (bit_depth == 1 &amp;&amp; color_type == PNG_COLOR_GRAY)
      png_set_invert_mono(png_ptr);

</para>

<para>PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first).  This code changes the storage to the
other way (little-endian, i.e. least significant bits first, the
way PCs store them):

</para>

<para>    if (bit_depth == 16)
        png_set_swap(png_ptr);

</para>

<para>If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
need to change the order the pixels are packed into bytes, you can use:

</para>

<para>    if (bit_depth &lt; 8)
       png_set_packswap(png_ptr);

</para>

<para>Finally, you can write your own transformation function if none of
the existing ones meets your needs.  This is done by setting a callback
with

</para>

<para>    png_set_read_user_transform_fn(png_ptr,
       read_transform_fn);

</para>

<para>You must supply the function

</para>

<para>    void read_transform_fn(png_ptr ptr, row_info_ptr
       row_info, png_bytep data)

</para>

<para>See pngtest.c for a working example.  Your function will be called
after all of the other transformations have been processed.

</para>

<para>You can also set up a pointer to a user structure for use by your
callback function, and you can inform libpng that your transform
function will change the number of channels or bit depth with the
function

</para>

<para>    png_set_user_transform_info(png_ptr, user_ptr,
       user_depth, user_channels);

</para>

<para>The user's application, not libpng, is responsible for allocating and
freeing any memory required for the user structure.

</para>

<para>You can retrieve the pointer via the function
png_get_user_transform_ptr().  For example:

</para>

<para>    voidp read_user_transform_ptr =
       png_get_user_transform_ptr(png_ptr);

</para>

<para>The last thing to handle is interlacing; this is covered in detail below,
but you must call the function here if you want libpng to handle expansion
of the interlaced image.

</para>

<para>    number_of_passes = png_set_interlace_handling(png_ptr);

</para>

<para>After setting the transformations, libpng can update your png_info
structure to reflect any transformations you've requested with this
call.  This is most useful to update the info structure's rowbytes
field so you can use it to allocate your image memory.  This function
will also update your palette with the correct screen_gamma and
background if these have been given with the calls above.

</para>

<para>    png_read_update_info(png_ptr, info_ptr);

</para>

<para>After you call png_read_update_info(), you can allocate any
memory you need to hold the image.  The row data is simply
raw byte data for all forms of images.  As the actual allocation
varies among applications, no example will be given.  If you
are allocating one large chunk, you will need to build an
array of pointers to each row, as it will be needed for some
of the functions below.

</para>

<para>
</para>

<para>After you've allocated memory, you can read the image data.
The simplest way to do this is in one function call.  If you are
allocating enough memory to hold the whole image, you can just
call png_read_image() and libpng will read in all the image data
and put it in the memory area supplied.  You will need to pass in
an array of pointers to each row.

</para>

<para>This function automatically handles interlacing, so you don't need
to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_read_rows().

</para>

<para>   png_read_image(png_ptr, row_pointers);

</para>

<para>where row_pointers is:

</para>

<para>   png_bytep row_pointers[height];

</para>

<para>You can point to void or char or whatever you use for pixels.

</para>

<para>If you don't want to read in the whole image at once, you can
use png_read_rows() instead.  If there is no interlacing (check
interlace_type == PNG_INTERLACE_NONE), this is simple:

</para>

<para>    png_read_rows(png_ptr, row_pointers, NULL,
       number_of_rows);

</para>

<para>where row_pointers is the same as in the png_read_image() call.

</para>

<para>If you are doing this just one row at a time, you can do this with
a single row_pointer instead of an array of row_pointers:

</para>

<para>    png_bytep row_pointer = row;
    png_read_row(png_ptr, row_pointer, NULL);

</para>

<para>If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
get somewhat harder.  The only current (PNG Specification version 1.2)
interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7)
is a somewhat complicated 2D interlace scheme, known as Adam7, that
breaks down an image into seven smaller images of varying size, based
on an 8x8 grid.

</para>

<para>libpng can fill out those images or it can give them to you "as is".
If you want them filled out, there are two ways to do that.  The one
mentioned in the PNG specification is to expand each pixel to cover
those pixels that have not been read yet (the "rectangle" method).
This results in a blocky image for the first pass, which gradually
smooths out as more pixels are read.  The other method is the "sparkle"
method, where pixels are drawn only in their final locations, with the
rest of the image remaining whatever colors they were initialized to
before the start of the read.  The first method usually looks better,
but tends to be slower, as there are more pixels to put in the rows.

</para>

<para>If you don't want libpng to handle the interlacing details, just call
png_read_rows() seven times to read in all seven images.  Each of the
images is a valid image by itself, or they can all be combined on an
8x8 grid to form a single image (although if you intend to combine them
you would be far better off using the libpng interlace handling).

</para>

<para>The first pass will return an image 1/8 as wide as the entire image
(every 8th column starting in column 0) and 1/8 as high as the original
(every 8th row starting in row 0), the second will be 1/8 as wide
(starting in column 4) and 1/8 as high (also starting in row 0).  The
third pass will be 1/4 as wide (every 4th pixel starting in column 0) and
1/8 as high (every 8th row starting in row 4), and the fourth pass will
be 1/4 as wide and 1/4 as high (every 4th column starting in column 2,
and every 4th row starting in row 0).  The fifth pass will return an
image 1/2 as wide, and 1/4 as high (starting at column 0 and row 2),
while the sixth pass will be 1/2 as wide and 1/2 as high as the original
(starting in column 1 and row 0).  The seventh and final pass will be as
wide as the original, and 1/2 as high, containing all of the odd
numbered scanlines.  Phew!

</para>

<para>If you want libpng to expand the images, call this before calling
png_start_read_image() or png_read_update_info():

</para>

<para>    if (interlace_type == PNG_INTERLACE_ADAM7)
        number_of_passes
           = png_set_interlace_handling(png_ptr);

</para>

<para>This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.
This function can be called even if the file is not interlaced,
where it will return one pass.

</para>

<para>If you are not going to display the image after each pass, but are
going to wait until the entire image is read in, use the sparkle
effect.  This effect is faster and the end result of either method
is exactly the same.  If you are planning on displaying the image
after each pass, the "rectangle" effect is generally considered the
better looking one.

</para>

<para>If you only want the "sparkle" effect, just call png_read_rows() as
normal, with the third parameter NULL.  Make sure you make pass over
the image number_of_passes times, and you don't change the data in the
rows between calls.  You can change the locations of the data, just
not the data.  Each pass only writes the pixels appropriate for that
pass, and assumes the data from previous passes is still valid.

</para>

<para>    png_read_rows(png_ptr, row_pointers, NULL,
       number_of_rows);

</para>

<para>If you only want the first effect (the rectangles), do the same as
before except pass the row buffer in the third parameter, and leave
the second parameter NULL.

</para>

<para>    png_read_rows(png_ptr, NULL, row_pointers,
       number_of_rows);

</para>

<para>
</para>

<para>After you are finished reading the image through either the high- or
low-level interfaces, you can finish reading the file.  If you are
interested in comments or time, which may be stored either before or
after the image data, you should pass the separate png_info struct if
you want to keep the comments from before and after the image
separate.  If you are not interested, you can pass NULL.

</para>

<para>   png_read_end(png_ptr, end_info);

</para>

<para>When you are done, you can free all memory allocated by libpng like this:

</para>

<para>   png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
       &amp;end_info);

</para>

<para>It is also possible to individually free the info_ptr members that
point to libpng-allocated storage with the following function:

</para>

<para>    png_free_data(png_ptr, info_ptr, mask, n)
    mask - identifies data to be freed, a mask
           containing the logical OR of one or
           more of
             PNG_FREE_PLTE, PNG_FREE_TRNS,
             PNG_FREE_HIST, PNG_FREE_ICCP,
             PNG_FREE_PCAL, PNG_FREE_ROWS,
             PNG_FREE_SCAL, PNG_FREE_SPLT,
             PNG_FREE_TEXT, PNG_FREE_UNKN,
           or simply PNG_FREE_ALL
    n    - sequence number of item to be freed
           (-1 for all items)

</para>

<para>This function may be safely called when the relevant storage has
already been freed, or has not yet been allocated, or was allocated
by the user and not by libpng,  and will in those
cases do nothing.  The "n" parameter is ignored if only one item
of the selected data type, such as PLTE, is allowed.  If "n" is not
-1, and multiple items are allowed for the data type identified in
the mask, such as text or sPLT, only the n'th item is freed.

</para>

<para>The default behavior is only to free data that was allocated internally
by libpng.  This can be changed, so that libpng will not free the data,
or so that it will free data that was allocated by the user with png_malloc()
or png_zalloc() and passed in via a png_set_*() function, with

</para>

<para>    png_data_freer(png_ptr, info_ptr, freer, mask)
    mask   - which data elements are affected
             same choices as in png_free_data()
    freer  - one of
               PNG_DESTROY_WILL_FREE_DATA
               PNG_SET_WILL_FREE_DATA
               PNG_USER_WILL_FREE_DATA

</para>

<para>This function only affects data that has already been allocated.
You can call this function after reading the PNG data but before calling
any png_set_*() functions, to control whether the user or the png_set_*()
function is responsible for freeing any existing data that might be present,
and again after the png_set_*() functions to control whether the user
or png_destroy_*() is supposed to free the data.  When the user assumes
responsibility for libpng-allocated data, the application must use
png_free() to free it, and when the user transfers responsibility to libpng
for data that the user has allocated, the user must have used png_malloc()
or png_zalloc() to allocate it (the png_zalloc() function is the same
as png_malloc() except that it also zeroes the newly-allocated memory).

</para>

<para>If you allocated your row_pointers in a single block, as suggested above in
the description of the high level read interface, you must not transfer
responsibility for freeing it to the png_set_rows or png_read_destroy function,
because they would also try to free the individual row_pointers[i].

</para>

<para>If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
separately, do not transfer responsibility for freeing text_ptr to libpng,
because when libpng fills a png_text structure it combines these members with
the key member, and png_free_data() will free only text_ptr.key.  Similarly,
if you transfer responsibility for free'ing text_ptr from libpng to your
application, your application must not separately free those members.

</para>

<para>The png_free_data() function will turn off the "valid" flag for anything
it frees.  If you need to turn the flag off for a chunk that was freed by your
application instead of by libpng, you can use

</para>

<para>    png_set_invalid(png_ptr, info_ptr, mask);
    mask - identifies the chunks to be made invalid,
           containing the logical OR of one or
           more of
             PNG_INFO_gAMA, PNG_INFO_sBIT,
             PNG_INFO_cHRM, PNG_INFO_PLTE,
             PNG_INFO_tRNS, PNG_INFO_bKGD,
             PNG_INFO_hIST, PNG_INFO_pHYs,
             PNG_INFO_oFFs, PNG_INFO_tIME,
             PNG_INFO_pCAL, PNG_INFO_sRGB,
             PNG_INFO_iCCP, PNG_INFO_sPLT,
             PNG_INFO_sCAL, PNG_INFO_IDAT

</para>

<para>For a more compact example of reading a PNG image, see the file example.c.

</para>

<para>
</para>

<para>The progressive reader is slightly different then the non-progressive
reader.  Instead of calling png_read_info(), png_read_rows(), and
png_read_end(), you make one call to png_process_data(), which calls
callbacks when it has the info, a row, or the end of the image.  You
set up these callbacks with png_set_progressive_read_fn().  You don't
have to worry about the input/output functions of libpng, as you are
giving the library the data directly in png_process_data().  I will
assume that you have read the section on reading PNG files above,
so I will only highlight the differences (although I will show
all of the code).

</para>

<para>png_structp png_ptr;
png_infop info_ptr;

</para>

<para> /*  An example code fragment of how you would
     initialize the progressive reader in your
     application. */
 int
 initialize_png_reader()
 {
    png_ptr = png_create_read_struct
        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
         user_error_fn, user_warning_fn);
    if (!png_ptr)
        return (ERROR);
    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
    {
        png_destroy_read_struct(&amp;png_ptr, (png_infopp)NULL,
           (png_infopp)NULL);
        return (ERROR);
    }

</para>

<para>    if (setjmp(png_jmpbuf(png_ptr)))
    {
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
           (png_infopp)NULL);
        return (ERROR);
    }

</para>

<para>    /* This one's new.  You can provide functions
       to be called when the header info is valid,
       when each row is completed, and when the image
       is finished.  If you aren't using all functions,
       you can specify NULL parameters.  Even when all
       three functions are NULL, you need to call
       png_set_progressive_read_fn().  You can use
       any struct as the user_ptr (cast to a void pointer
       for the function call), and retrieve the pointer
       from inside the callbacks using the function

</para>

<para>          png_get_progressive_ptr(png_ptr);

</para>

<para>       which will return a void pointer, which you have
       to cast appropriately.
     */
    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
        info_callback, row_callback, end_callback);

</para>

<para>    return 0;
 }

</para>

<para> /* A code fragment that you call as you receive blocks
   of data */
 int
 process_data(png_bytep buffer, png_uint_32 length)
 {
    if (setjmp(png_jmpbuf(png_ptr)))
    {
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,
           (png_infopp)NULL);
        return (ERROR);
    }

</para>

<para>    /* This one's new also.  Simply give it a chunk
       of data from the file stream (in order, of
       course).  On machines with segmented memory
       models machines, don't give it any more than
       64K.  The library seems to run fine with sizes
       of 4K. Although you can give it much less if
       necessary (I assume you can give it chunks of
       1 byte, I haven't tried less then 256 bytes
       yet).  When this function returns, you may
       want to display any rows that were generated
       in the row callback if you don't already do
       so there.
     */
    png_process_data(png_ptr, info_ptr, buffer, length);
    return 0;
 }

</para>

<para> /* This function is called (as set by
    png_set_progressive_read_fn() above) when enough data
    has been supplied so all of the header has been
    read.
 */
 void
 info_callback(png_structp png_ptr, png_infop info)
 {
    /* Do any setup here, including setting any of
       the transformations mentioned in the Reading
       PNG files section.  For now, you _must_ call
       either png_start_read_image() or
       png_read_update_info() after all the
       transformations are set (even if you don't set
       any).  You may start getting rows before
       png_process_data() returns, so this is your
       last chance to prepare for that.
     */
 }

</para>

<para> /* This function is called when each row of image
    data is complete */
 void
 row_callback(png_structp png_ptr, png_bytep new_row,
    png_uint_32 row_num, int pass)
 {
    /* If the image is interlaced, and you turned
       on the interlace handler, this function will
       be called for every row in every pass.  Some
       of these rows will not be changed from the
       previous pass.  When the row is not changed,
       the new_row variable will be NULL.  The rows
       and passes are called in order, so you don't
       really need the row_num and pass, but I'm
       supplying them because it may make your life
       easier.

</para>

<para>       For the non-NULL rows of interlaced images,
       you must call png_progressive_combine_row()
       passing in the row and the old row.  You can
       call this function for NULL rows (it will just
       return) and for non-interlaced images (it just
       does the memcpy for you) if it will make the
       code easier.  Thus, you can just do this for
       all cases:
     */

</para>

<para>        png_progressive_combine_row(png_ptr, old_row,
          new_row);

</para>

<para>    /* where old_row is what was displayed for
       previously for the row.  Note that the first
       pass (pass == 0, really) will completely cover
       the old row, so the rows do not have to be
       initialized.  After the first pass (and only
       for interlaced images), you will have to pass
       the current row, and the function will combine
       the old row and the new row.
    */
 }

</para>

<para> void
 end_callback(png_structp png_ptr, png_infop info)
 {
    /* This function is called after the whole image
       has been read, including any chunks after the
       image (up to and including the IEND).  You
       will usually have the same info chunk as you
       had in the header, although some data may have
       been added to the comments and time fields.

</para>

<para>       Most people won't do much here, perhaps setting
       a flag that marks the image as finished.
     */
 }

</para>

<para>
</para>

<para>
</para>

<para></para>
</sect3>
<sect3><title>IV. Writing</title>

<para>
</para>

<para>Much of this is very similar to reading.  However, everything of
importance is repeated here, so you won't have to constantly look
back up in the reading section to understand writing.

</para>

<para>
</para>

<para>You will want to do the I/O initialization before you get into libpng,
so if it doesn't work, you don't have anything to undo. If you are not
using the standard I/O functions, you will need to replace them with
custom writing functions.  See the discussion under Customizing libpng.

</para>

<para>    FILE *fp = fopen(file_name, "wb");
    if (!fp)
    {
       return (ERROR);
    }

</para>

<para>Next, png_struct and png_info need to be allocated and initialized.
As these can be both relatively large, you may not want to store these
on the stack, unless you have stack space to spare.  Of course, you
will want to check if they return NULL.  If you are also reading,
you won't want to name your read structure and your write structure
both "png_ptr"; you can call them anything you like, such as
"read_ptr" and "write_ptr".  Look at pngtest.c, for example.

</para>

<para>    png_structp png_ptr = png_create_write_struct
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn);
    if (!png_ptr)
       return (ERROR);

</para>

<para>    png_infop info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
    {
       png_destroy_write_struct(&amp;png_ptr,
         (png_infopp)NULL);
       return (ERROR);
    }

</para>

<para>If you want to use your own memory allocation routines,
define PNG_USER_MEM_SUPPORTED and use
png_create_write_struct_2() instead of png_create_write_struct():

</para>

<para>    png_structp png_ptr = png_create_write_struct_2
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn, (png_voidp)
        user_mem_ptr, user_malloc_fn, user_free_fn);

</para>

<para>After you have these structures, you will need to set up the
error handling.  When libpng encounters an error, it expects to
longjmp() back to your routine.  Therefore, you will need to call
setjmp() and pass the png_jmpbuf(png_ptr).  If you
write the file from different routines, you will need to update
the png_jmpbuf(png_ptr) every time you enter a new routine that will
call a png_*() function.  See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp.  See
the discussion on libpng error handling in the Customizing Libpng
section below for more information on the libpng error handling.

</para>

<para>    if (setjmp(png_jmpbuf(png_ptr)))
    {
       png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
       fclose(fp);
       return (ERROR);
    }
    ...
    return;

</para>

<para>If you would rather avoid the complexity of setjmp/longjmp issues,
you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case
errors will result in a call to PNG_ABORT() which defaults to abort().

</para>

<para>Now you need to set up the output code.  The default for libpng is to
use the C function fwrite().  If you use this, you will need to pass a
valid FILE * in the function png_init_io().  Be sure that the file is
opened in binary mode.  Again, if you wish to handle writing data in
another way, see the discussion on libpng I/O handling in the Customizing
Libpng section below.

</para>

<para>    png_init_io(png_ptr, fp);

</para>

<para>
</para>

<para>At this point, you can set up a callback function that will be
called after each row has been written, which you can use to control
a progress meter or the like.  It's demonstrated in pngtest.c.
You must supply a function

</para>

<para>    void write_row_callback(png_ptr, png_uint_32 row, int pass);
    {
      /* put your code here */
    }

</para>

<para>(You can give it another name that you like instead of "write_row_callback")

</para>

<para>To inform libpng about your function, use

</para>

<para>    png_set_write_status_fn(png_ptr, write_row_callback);

</para>

<para>You now have the option of modifying how the compression library will
run.  The following functions are mainly for testing, but may be useful
in some cases, like if you need to write PNG files extremely fast and
are willing to give up some compression, or if you want to get the
maximum possible compression at the expense of slower writing.  If you
have no special needs in this area, let the library do what it wants by
not calling this function at all, as it has been tuned to deliver a good
speed/compression ratio. The second parameter to png_set_filter() is
the filter method, for which the only valid values are 0 (as of the
July 1999 PNG specification, version 1.2) or 64 (if you are writing
a PNG datastream that is to be embedded in a MNG datastream).  The third
parameter is a flag that indicates which filter type(s) are to be tested
for each scanline.  See the PNG specification for details on the specific filter
types.

</para>

<para>
</para>

<para>    /* turn on or off filtering, and/or choose
       specific filters.  You can use either a single PNG_FILTER_VALUE_NAME
       or the logical OR of one or more PNG_FILTER_NAME masks. */
    png_set_filter(png_ptr, 0,
       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |
       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |
       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |
       PNG_FILTER_AVE   | PNG_FILTER_VALUE_AVE  |
       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
       PNG_ALL_FILTERS);

</para>

<para>If an application
wants to start and stop using particular filters during compression,
it should start out with all of the filters (to ensure that the previous
row of pixels will be stored in case it's needed later), and then add
and remove them after the start of compression.

</para>

<para>If you are writing a PNG datastream that is to be embedded in a MNG
datastream, the second parameter can be either 0 or 64.

</para>

<para>The png_set_compression_*() functions interface to the zlib compression
library, and should mostly be ignored unless you really know what you are
doing.  The only generally useful call is png_set_compression_level()
which changes how much time zlib spends on trying to compress the image
data.  See the Compression Library (zlib.h and algorithm.txt, distributed
with zlib) for details on the compression levels.

</para>

<para>    /* set the zlib compression level */
    png_set_compression_level(png_ptr,
        Z_BEST_COMPRESSION);

</para>

<para>    /* set other zlib parameters */
    png_set_compression_mem_level(png_ptr, 8);
    png_set_compression_strategy(png_ptr,
        Z_DEFAULT_STRATEGY);
    png_set_compression_window_bits(png_ptr, 15);
    png_set_compression_method(png_ptr, 8);
    png_set_compression_buffer_size(png_ptr, 8192)

</para>

<para>extern PNG_EXPORT(void,png_set_zbuf_size)

</para>

<para>
</para>

<para>You now need to fill in the png_info structure with all the data you
wish to write before the actual image.  Note that the only thing you
are allowed to write after the image is the text chunks and the time
chunk (as of PNG Specification 1.2, anyway).  See png_write_end() and
the latest PNG specification for more information on that.  If you
wish to write them before the image, fill them in now, and flag that
data as being valid.  If you want to wait until after the data, don't
fill them until png_write_end().  For all the fields in png_info and
their data types, see png.h.  For explanations of what the fields
contain, see the PNG specification.

</para>

<para>Some of the more important parts of the png_info are:

</para>

<para>    png_set_IHDR(png_ptr, info_ptr, width, height,
       bit_depth, color_type, interlace_type,
       compression_type, filter_method)
    width          - holds the width of the image
                     in pixels (up to 2^31).
    height         - holds the height of the image
                     in pixels (up to 2^31).
    bit_depth      - holds the bit depth of one of the
                     image channels.
                     (valid values are 1, 2, 4, 8, 16
                     and depend also on the
                     color_type.  See also significant
                     bits (sBIT) below).
    color_type     - describes which color/alpha
                     channels are present.
                     PNG_COLOR_TYPE_GRAY
                        (bit depths 1, 2, 4, 8, 16)
                     PNG_COLOR_TYPE_GRAY_ALPHA
                        (bit depths 8, 16)
                     PNG_COLOR_TYPE_PALETTE
                        (bit depths 1, 2, 4, 8)
                     PNG_COLOR_TYPE_RGB
                        (bit_depths 8, 16)
                     PNG_COLOR_TYPE_RGB_ALPHA
                        (bit_depths 8, 16)

</para>

<para>                     PNG_COLOR_MASK_PALETTE
                     PNG_COLOR_MASK_COLOR
                     PNG_COLOR_MASK_ALPHA

</para>

<para>    interlace_type - PNG_INTERLACE_NONE or
                     PNG_INTERLACE_ADAM7
    compression_type - (must be
                     PNG_COMPRESSION_TYPE_DEFAULT)
    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT
                     or, if you are writing a PNG to
                     be embedded in a MNG datastream,
                     can also be
                     PNG_INTRAPIXEL_DIFFERENCING)

</para>

<para>    png_set_PLTE(png_ptr, info_ptr, palette,
       num_palette);
    palette        - the palette for the file
                     (array of png_color)
    num_palette    - number of entries in the palette

</para>

<para>    png_set_gAMA(png_ptr, info_ptr, gamma);
    gamma          - the gamma the image was created
                     at (PNG_INFO_gAMA)

</para>

<para>    png_set_sRGB(png_ptr, info_ptr, srgb_intent);
    srgb_intent    - the rendering intent
                     (PNG_INFO_sRGB) The presence of
                     the sRGB chunk means that the pixel
                     data is in the sRGB color space.
                     This chunk also implies specific
                     values of gAMA and cHRM.  Rendering
                     intent is the CSS-1 property that
                     has been defined by the International
                     Color Consortium
                     (http://www.color.org).
                     It can be one of
                     PNG_sRGB_INTENT_SATURATION,
                     PNG_sRGB_INTENT_PERCEPTUAL,
                     PNG_sRGB_INTENT_ABSOLUTE, or
                     PNG_sRGB_INTENT_RELATIVE.

</para>

<para>
</para>

<para>    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
       srgb_intent);
    srgb_intent    - the rendering intent
                     (PNG_INFO_sRGB) The presence of the
                     sRGB chunk means that the pixel
                     data is in the sRGB color space.
                     This function also causes gAMA and
                     cHRM chunks with the specific values
                     that are consistent with sRGB to be
                     written.

</para>

<para>    png_set_iCCP(png_ptr, info_ptr, name, compression_type,
                      profile, proflen);
    name            - The profile name.
    compression     - The compression type; always PNG_COMPRESSION_TYPE_BASE
                      for PNG 1.0.  You may give NULL to this argument
                      to ignore it.
    profile         - International Color Consortium color profile
                      data. May contain NULs.
    proflen         - length of profile data in bytes.

</para>

<para>    png_set_sBIT(png_ptr, info_ptr, sig_bit);
    sig_bit        - the number of significant bits for
                     (PNG_INFO_sBIT) each of the gray, red,
                     green, and blue channels, whichever are
                     appropriate for the given color type
                     (png_color_16)

</para>

<para>    png_set_tRNS(png_ptr, info_ptr, trans, num_trans,
       trans_values);
    trans          - array of transparent entries for
                     palette (PNG_INFO_tRNS)
    trans_values   - graylevel or color sample values of
                     the single transparent color for
                     non-paletted images (PNG_INFO_tRNS)
    num_trans      - number of transparent entries
                     (PNG_INFO_tRNS)

</para>

<para>    png_set_hIST(png_ptr, info_ptr, hist);
                    (PNG_INFO_hIST)
    hist           - histogram of palette (array of
                     png_uint_16)

</para>

<para>    png_set_tIME(png_ptr, info_ptr, mod_time);
    mod_time       - time image was last modified
                     (PNG_VALID_tIME)

</para>

<para>    png_set_bKGD(png_ptr, info_ptr, background);
    background     - background color (PNG_VALID_bKGD)

</para>

<para>    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
    text_ptr       - array of png_text holding image
                     comments
    text_ptr[i].compression - type of compression used
                 on "text" PNG_TEXT_COMPRESSION_NONE
                           PNG_TEXT_COMPRESSION_zTXt
                           PNG_ITXT_COMPRESSION_NONE
                           PNG_ITXT_COMPRESSION_zTXt
    text_ptr[i].key   - keyword for comment.  Must contain
                 1-79 characters.
    text_ptr[i].text  - text comments for current
                         keyword.  Can be NULL or empty.
    text_ptr[i].text_length - length of text string,
                 after decompression, 0 for iTXt
    text_ptr[i].itxt_length - length of itxt string,
                 after decompression, 0 for tEXt/zTXt
    text_ptr[i].lang  - language of comment (NULL or
                         empty for unknown).
    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
                         or empty for unknown).
    num_text       - number of comments

</para>

<para>    png_set_sPLT(png_ptr, info_ptr, &amp;palette_ptr, num_spalettes);
    palette_ptr    - array of png_sPLT_struct structures to be
                     added to the list of palettes in the info
                     structure.
    num_spalettes  - number of palette structures to be added.

</para>

<para>    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
        unit_type);
    offset_x  - positive offset from the left
                     edge of the screen
    offset_y  - positive offset from the top
                     edge of the screen
    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER

</para>

<para>    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
        unit_type);
    res_x       - pixels/unit physical resolution
                  in x direction
    res_y       - pixels/unit physical resolution
                  in y direction
    unit_type   - PNG_RESOLUTION_UNKNOWN,
                  PNG_RESOLUTION_METER

</para>

<para>    png_set_sCAL(png_ptr, info_ptr, unit, width, height)
    unit        - physical scale units (an integer)
    width       - width of a pixel in physical scale units
    height      - height of a pixel in physical scale units
                  (width and height are doubles)

</para>

<para>    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)
    unit        - physical scale units (an integer)
    width       - width of a pixel in physical scale units
    height      - height of a pixel in physical scale units
                 (width and height are strings like "2.54")

</para>

<para>    png_set_unknown_chunks(png_ptr, info_ptr, &amp;unknowns, num_unknowns)
    unknowns          - array of png_unknown_chunk structures holding
                        unknown chunks
    unknowns[i].name  - name of unknown chunk
    unknowns[i].data  - data of unknown chunk
    unknowns[i].size  - size of unknown chunk's data
    unknowns[i].location - position to write chunk in file
                           0: do not write chunk
                           PNG_HAVE_IHDR: before PLTE
                           PNG_HAVE_PLTE: before IDAT
                           PNG_AFTER_IDAT: after IDAT
    The "location" member is set automatically according to
    what part of the output file has already been written.
    You can change its value after calling png_set_unknown_chunks()
    as demonstrated in pngtest.c.  Within each of the "locations",
    the chunks are sequenced according to their position in the
    structure (that is, the value of "i", which is the order in which
    the chunk was either read from the input file or defined with
    png_set_unknown_chunks).

</para>

<para>A quick word about text and num_text.  text is an array of png_text
structures.  num_text is the number of valid structures in the array.
Each png_text structure holds a language code, a keyword, a text value,
and a compression type.

</para>

<para>The compression types have the same valid numbers as the compression
types of the image data.  Currently, the only valid number is zero.
However, you can store text either compressed or uncompressed, unlike
images, which always have to be compressed.  So if you don't want the
text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
Because tEXt and zTXt chunks don't have a language field, if you
specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
any language code or translated keyword will not be written out.

</para>

<para>Until text gets around 1000 bytes, it is not worth compressing it.
After the text has been written out to the file, the compression type
is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
so that it isn't written out again at the end (in case you are calling
png_write_end() with the same struct.

</para>

<para>The keywords that are given in the PNG Specification are:

</para>

<para>    Title            Short (one line) title or
                     caption for image
    Author           Name of image's creator
    Description      Description of image (possibly long)
    Copyright        Copyright notice
    Creation Time    Time of original image creation
                     (usually RFC 1123 format, see below)
    Software         Software used to create the image
    Disclaimer       Legal disclaimer
    Warning          Warning of nature of content
    Source           Device used to create the image
    Comment          Miscellaneous comment; conversion
                     from other image format

</para>

<para>The keyword-text pairs work like this.  Keywords should be short
simple descriptions of what the comment is about.  Some typical
keywords are found in the PNG specification, as is some recommendations
on keywords.  You can repeat keywords in a file.  You can even write
some text before the image and some after.  For example, you may want
to put a description of the image before the image, but leave the
disclaimer until after, so viewers working over modem connections
don't have to wait for the disclaimer to go over the modem before
they start seeing the image.  Finally, keywords should be full
words, not abbreviations.  Keywords and text are in the ISO 8859-1
(Latin-1) character set (a superset of regular ASCII) and can not
contain NUL characters, and should not contain control or other
unprintable characters.  To make the comments widely readable, stick
with basic ASCII, and avoid machine specific character set extensions
like the IBM-PC character set.  The keyword must be present, but
you can leave off the text string on non-compressed pairs.
Compressed pairs must have a text string, as only the text string
is compressed anyway, so the compression would be meaningless.

</para>

<para>PNG supports modification time via the png_time structure.  Two
conversion routines are provided, png_convert_from_time_t() for
time_t and png_convert_from_struct_tm() for struct tm.  The
time_t routine uses gmtime().  You don't have to use either of
these, but if you wish to fill in the png_time structure directly,
you should provide the time in universal time (GMT) if possible
instead of your local time.  Note that the year number is the full
year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
that months start with 1.

</para>

<para>If you want to store the time of the original image creation, you should
use a plain tEXt chunk with the "Creation Time" keyword.  This is
necessary because the "creation time" of a PNG image is somewhat vague,
depending on whether you mean the PNG file, the time the image was
created in a non-PNG format, a still photo from which the image was
scanned, or possibly the subject matter itself.  In order to facilitate
machine-readable dates, it is recommended that the "Creation Time"
tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
although this isn't a requirement.  Unlike the tIME chunk, the
"Creation Time" tEXt chunk is not expected to be automatically changed
by the software.  To facilitate the use of RFC 1123 dates, a function
png_convert_to_rfc1123(png_timep) is provided to convert from PNG
time to an RFC 1123 format string.

</para>

<para>
</para>

<para>You can use the png_set_unknown_chunks function to queue up chunks
for writing.  You give it a chunk name, raw data, and a size; that's
all there is to it.  The chunks will be written by the next following
png_write_info_before_PLTE, png_write_info, or png_write_end function.
Any chunks previously read into the info structure's unknown-chunk
list will also be written out in a sequence that satisfies the PNG
specification's ordering rules.

</para>

<para>
</para>

<para>At this point there are two ways to proceed; through the high-level
write interface, or through a sequence of low-level write operations.
You can use the high-level interface if your image data is present
in the info structure.  All defined output
transformations are permitted, enabled by the following masks.

</para>

<para>    PNG_TRANSFORM_IDENTITY      No transformation
    PNG_TRANSFORM_PACKING       Pack 1, 2 and 4-bit samples
    PNG_TRANSFORM_PACKSWAP      Change order of packed pixels to LSB first
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
    PNG_TRANSFORM_SHIFT         Normalize pixels to the sBIT depth
    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA to BGRA
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA to AG
    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity to transparency
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
    PNG_TRANSFORM_STRIP_FILLER  Strip out filler bytes.

</para>

<para>If you have valid image data in the info structure (you can use
png_set_rows() to put image data in the info structure), simply do this:

</para>

<para>    png_write_png(png_ptr, info_ptr, png_transforms, NULL)

</para>

<para>where png_transforms is an integer containing the logical OR of some set of
transformation flags.  This call is equivalent to png_write_info(),
followed the set of transformations indicated by the transform mask,
then png_write_image(), and finally png_write_end().

</para>

<para>(The final parameter of this call is not yet used.  Someday it might point
to transformation parameters required by some future output transform.)

</para>

<para>
</para>

<para>If you are going the low-level route instead, you are now ready to
write all the file information up to the actual image data.  You do
this with a call to png_write_info().

</para>

<para>    png_write_info(png_ptr, info_ptr);

</para>

<para>Note that there is one transformation you may need to do before
png_write_info().  In PNG files, the alpha channel in an image is the
level of opacity.  If your data is supplied as a level of
transparency, you can invert the alpha channel before you write it, so
that 0 is fully transparent and 255 (in 8-bit or paletted images) or
65535 (in 16-bit images) is fully opaque, with

</para>

<para>    png_set_invert_alpha(png_ptr);

</para>

<para>This must appear before png_write_info() instead of later with the
other transformations because in the case of paletted images the tRNS
chunk data has to be inverted before the tRNS chunk is written.  If
your image is not a paletted image, the tRNS data (which in such cases
represents a single color to be rendered as transparent) won't need to
be changed, and you can safely do this transformation after your
png_write_info() call.

</para>

<para>If you need to write a private chunk that you want to appear before
the PLTE chunk when PLTE is present, you can write the PNG info in
two steps, and insert code to write your own chunk between them:

</para>

<para>    png_write_info_before_PLTE(png_ptr, info_ptr);
    png_set_unknown_chunks(png_ptr, info_ptr, ...);
    png_write_info(png_ptr, info_ptr);

</para>

<para>After you've written the file information, you can set up the library
to handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
should occur.  This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths.  Even though each transformation
checks to see if it has data that it can do something with, you should
make sure to only enable a transformation if it will be valid for the
data.  For example, don't swap red and blue on grayscale data.

</para>

<para>PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
the library to strip input data that has 4 or 8 bytes per pixel down
to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2
bytes per pixel).

</para>

<para>    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);

</para>

<para>where the 0 is unused, and the location is either PNG_FILLER_BEFORE or
PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
is stored XRGB or RGBX.

</para>

<para>PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit files.
If the data is supplied at 1 pixel per byte, use this code, which will
correctly pack the pixels into a single byte:

</para>

<para>    png_set_packing(png_ptr);

</para>

<para>PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
data is of another bit depth, you can write an sBIT chunk into the
file so that decoders can recover the original data if desired.

</para>

<para>    /* Set the true bit depth of the image data */
    if (color_type &amp; PNG_COLOR_MASK_COLOR)
    {
        sig_bit.red = true_bit_depth;
        sig_bit.green = true_bit_depth;
        sig_bit.blue = true_bit_depth;
    }
    else
    {
        sig_bit.gray = true_bit_depth;
    }
    if (color_type &amp; PNG_COLOR_MASK_ALPHA)
    {
        sig_bit.alpha = true_bit_depth;
    }

</para>

<para>    png_set_sBIT(png_ptr, info_ptr, &amp;sig_bit);

</para>

<para>If the data is stored in the row buffer in a bit depth other than
one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
this will scale the values to appear to be the correct bit depth as
is required by PNG.

</para>

<para>    png_set_shift(png_ptr, &amp;sig_bit);

</para>

<para>PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first).  This code would be used if they are
supplied the other way (little-endian, i.e. least significant bits
first, the way PCs store them):

</para>

<para>    if (bit_depth &gt; 8)
       png_set_swap(png_ptr);

</para>

<para>If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
need to change the order the pixels are packed into bytes, you can use:

</para>

<para>    if (bit_depth &lt; 8)
       png_set_packswap(png_ptr);

</para>

<para>PNG files store 3 color pixels in red, green, blue order.  This code
would be used if they are supplied as blue, green, red:

</para>

<para>    png_set_bgr(png_ptr);

</para>

<para>PNG files describe monochrome as black being zero and white being
one. This code would be used if the pixels are supplied with this reversed
(black being one and white being zero):

</para>

<para>    png_set_invert_mono(png_ptr);

</para>

<para>Finally, you can write your own transformation function if none of
the existing ones meets your needs.  This is done by setting a callback
with

</para>

<para>    png_set_write_user_transform_fn(png_ptr,
       write_transform_fn);

</para>

<para>You must supply the function

</para>

<para>    void write_transform_fn(png_ptr ptr, row_info_ptr
       row_info, png_bytep data)

</para>

<para>See pngtest.c for a working example.  Your function will be called
before any of the other transformations are processed.

</para>

<para>You can also set up a pointer to a user structure for use by your
callback function.

</para>

<para>    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);

</para>

<para>The user_channels and user_depth parameters of this function are ignored
when writing; you can set them to zero as shown.

</para>

<para>You can retrieve the pointer via the function png_get_user_transform_ptr().
For example:

</para>

<para>    voidp write_user_transform_ptr =
       png_get_user_transform_ptr(png_ptr);

</para>

<para>It is possible to have libpng flush any pending output, either manually,
or automatically after a certain number of lines have been written.  To
flush the output stream a single time call:

</para>

<para>    png_write_flush(png_ptr);

</para>

<para>and to have libpng flush the output stream periodically after a certain
number of scanlines have been written, call:

</para>

<para>    png_set_flush(png_ptr, nrows);

</para>

<para>Note that the distance between rows is from the last time png_write_flush()
was called, or the first row of the image if it has never been called.
So if you write 50 lines, and then png_set_flush 25, it will flush the
output on the next scanline, and every 25 lines thereafter, unless
png_write_flush() is called before 25 more lines have been written.
If nrows is too small (less than about 10 lines for a 640 pixel wide
RGB image) the image compression may decrease noticeably (although this
may be acceptable for real-time applications).  Infrequent flushing will
only degrade the compression performance by a few percent over images
that do not use flushing.

</para>

<para>
</para>

<para>That's it for the transformations.  Now you can write the image data.
The simplest way to do this is in one function call.  If you have the
whole image in memory, you can just call png_write_image() and libpng
will write the image.  You will need to pass in an array of pointers to
each row.  This function automatically handles interlacing, so you don't
need to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_write_rows().

</para>

<para>    png_write_image(png_ptr, row_pointers);

</para>

<para>where row_pointers is:

</para>

<para>    png_byte *row_pointers[height];

</para>

<para>You can point to void or char or whatever you use for pixels.

</para>

<para>If you don't want to write the whole image at once, you can
use png_write_rows() instead.  If the file is not interlaced,
this is simple:

</para>

<para>    png_write_rows(png_ptr, row_pointers,
       number_of_rows);

</para>

<para>row_pointers is the same as in the png_write_image() call.

</para>

<para>If you are just writing one row at a time, you can do this with
a single row_pointer instead of an array of row_pointers:

</para>

<para>    png_bytep row_pointer = row;

</para>

<para>    png_write_row(png_ptr, row_pointer);

</para>

<para>When the file is interlaced, things can get a good deal more
complicated.  The only currently (as of the PNG Specification
version 1.2, dated July 1999) defined interlacing scheme for PNG files
is the "Adam7" interlace scheme, that breaks down an
image into seven smaller images of varying size.  libpng will build
these images for you, or you can do them yourself.  If you want to
build them yourself, see the PNG specification for details of which
pixels to write when.

</para>

<para>If you don't want libpng to handle the interlacing details, just
use png_set_interlace_handling() and call png_write_rows() the
correct number of times to write all seven sub-images.

</para>

<para>If you want libpng to build the sub-images, call this before you start
writing any rows:

</para>

<para>    number_of_passes =
       png_set_interlace_handling(png_ptr);

</para>

<para>This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.

</para>

<para>Then write the complete image number_of_passes times.

</para>

<para>    png_write_rows(png_ptr, row_pointers,
       number_of_rows);

</para>

<para>As some of these rows are not used, and thus return immediately,
you may want to read about interlacing in the PNG specification,
and only update the rows that are actually used.

</para>

<para>
</para>

<para>After you are finished writing the image, you should finish writing
the file.  If you are interested in writing comments or time, you should
pass an appropriately filled png_info pointer.  If you are not interested,
you can pass NULL.

</para>

<para>    png_write_end(png_ptr, info_ptr);

</para>

<para>When you are done, you can free all memory used by libpng like this:

</para>

<para>    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);

</para>

<para>It is also possible to individually free the info_ptr members that
point to libpng-allocated storage with the following function:

</para>

<para>    png_free_data(png_ptr, info_ptr, mask, n)
    mask  - identifies data to be freed, a mask
            containing the logical OR of one or
            more of
              PNG_FREE_PLTE, PNG_FREE_TRNS,
              PNG_FREE_HIST, PNG_FREE_ICCP,
              PNG_FREE_PCAL, PNG_FREE_ROWS,
              PNG_FREE_SCAL, PNG_FREE_SPLT,
              PNG_FREE_TEXT, PNG_FREE_UNKN,
            or simply PNG_FREE_ALL
    n     - sequence number of item to be freed
            (-1 for all items)

</para>

<para>This function may be safely called when the relevant storage has
already been freed, or has not yet been allocated, or was allocated
by the user  and not by libpng,  and will in those
cases do nothing.  The "n" parameter is ignored if only one item
of the selected data type, such as PLTE, is allowed.  If "n" is not
-1, and multiple items are allowed for the data type identified in
the mask, such as text or sPLT, only the n'th item is freed.

</para>

<para>If you allocated data such as a palette that you passed
in to libpng with png_set_*, you must not free it until just before the call to
png_destroy_write_struct().

</para>

<para>The default behavior is only to free data that was allocated internally
by libpng.  This can be changed, so that libpng will not free the data,
or so that it will free data that was allocated by the user with png_malloc()
or png_zalloc() and passed in via a png_set_*() function, with

</para>

<para>    png_data_freer(png_ptr, info_ptr, freer, mask)
    mask   - which data elements are affected
             same choices as in png_free_data()
    freer  - one of
               PNG_DESTROY_WILL_FREE_DATA
               PNG_SET_WILL_FREE_DATA
               PNG_USER_WILL_FREE_DATA

</para>

<para>For example, to transfer responsibility for some data from a read structure
to a write structure, you could use

</para>

<para>    png_data_freer(read_ptr, read_info_ptr,
       PNG_USER_WILL_FREE_DATA,
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
    png_data_freer(write_ptr, write_info_ptr,
       PNG_DESTROY_WILL_FREE_DATA,
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)

</para>

<para>thereby briefly reassigning responsibility for freeing to the user but
immediately afterwards reassigning it once more to the write_destroy
function.  Having done this, it would then be safe to destroy the read
structure and continue to use the PLTE, tRNS, and hIST data in the write
structure.

</para>

<para>This function only affects data that has already been allocated.
You can call this function before calling after the png_set_*() functions
to control whether the user or png_destroy_*() is supposed to free the data.
When the user assumes responsibility for libpng-allocated data, the
application must use
png_free() to free it, and when the user transfers responsibility to libpng
for data that the user has allocated, the user must have used png_malloc()
or png_zalloc() to allocate it.

</para>

<para>If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
separately, do not transfer responsibility for freeing text_ptr to libpng,
because when libpng fills a png_text structure it combines these members with
the key member, and png_free_data() will free only text_ptr.key.  Similarly,
if you transfer responsibility for free'ing text_ptr from libpng to your
application, your application must not separately free those members.
For a more compact example of writing a PNG image, see the file example.c.

</para>

<para></para>
</sect3>
<sect3><title>V. Modifying/Customizing libpng:</title>

<para>
</para>

<para>There are three issues here.  The first is changing how libpng does
standard things like memory allocation, input/output, and error handling.
The second deals with more complicated things like adding new chunks,
adding new transformations, and generally changing how libpng works.
Both of those are compile-time issues; that is, they are generally
determined at the time the code is written, and there is rarely a need
to provide the user with a means of changing them.  The third is a
run-time issue:  choosing between and/or tuning one or more alternate
versions of computationally intensive routines; specifically, optimized
assembly-language (and therefore compiler- and platform-dependent)
versions.

</para>

<para>Memory allocation, input/output, and error handling

</para>

<para>All of the memory allocation, input/output, and error handling in libpng
goes through callbacks that are user-settable.  The default routines are
in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively.  To change
these functions, call the appropriate png_set_*_fn() function.

</para>

<para>Memory allocation is done through the functions png_malloc(), png_zalloc(),
and png_free().  These currently just call the standard C functions.  If
your pointers can't access more then 64K at a time, you will want to set
MAXSEG_64K in zlib.h.  Since it is unlikely that the method of handling
memory allocation on a platform will change between applications, these
functions must be modified in the library at compile time.  If you prefer
to use a different method of allocating and freeing data, you can use

</para>

<para>    png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
      malloc_fn, png_free_ptr free_fn)

</para>

<para>This function also provides a void pointer that can be retrieved via

</para>

<para>    mem_ptr=png_get_mem_ptr(png_ptr);

</para>

<para>Your replacement memory functions must have prototypes as follows:

</para>

<para>    png_voidp malloc_fn(png_structp png_ptr, png_uint_32 size);
    void free_fn(png_structp png_ptr, png_voidp ptr);

</para>

<para>Input/Output in libpng is done through png_read() and png_write(),
which currently just call fread() and fwrite().  The FILE * is stored in
png_struct and is initialized via png_init_io().  If you wish to change
the method of I/O, the library supplies callbacks that you can set
through the function png_set_read_fn() and png_set_write_fn() at run
time, instead of calling the png_init_io() function.  These functions
also provide a void pointer that can be retrieved via the function
png_get_io_ptr().  For example:

</para>

<para>    png_set_read_fn(png_structp read_ptr,
        voidp read_io_ptr, png_rw_ptr read_data_fn)

</para>

<para>    png_set_write_fn(png_structp write_ptr,
        voidp write_io_ptr, png_rw_ptr write_data_fn,
        png_flush_ptr output_flush_fn);

</para>

<para>    voidp read_io_ptr = png_get_io_ptr(read_ptr);
    voidp write_io_ptr = png_get_io_ptr(write_ptr);

</para>

<para>The replacement I/O functions must have prototypes as follows:

</para>

<para>    void user_read_data(png_structp png_ptr,
        png_bytep data, png_uint_32 length);
    void user_write_data(png_structp png_ptr,
        png_bytep data, png_uint_32 length);
    void user_flush_data(png_structp png_ptr);

</para>

<para>Supplying NULL for the read, write, or flush functions sets them back
to using the default C stream functions.  It is an error to read from
a write stream, and vice versa.

</para>

<para>Error handling in libpng is done through png_error() and png_warning().
Errors handled through png_error() are fatal, meaning that png_error()
should never return to its caller.  Currently, this is handled via
setjmp() and longjmp() (unless you have compiled libpng with
PNG_SETJMP_NOT_SUPPORTED, in which case it is handled via PNG_ABORT()),
but you could change this to do things like exit() if you should wish.

</para>

<para>On non-fatal errors, png_warning() is called
to print a warning message, and then control returns to the calling code.
By default png_error() and png_warning() print a message on stderr via
fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined
(because you don't want the messages) or PNG_NO_STDIO defined (because
fprintf() isn't available).  If you wish to change the behavior of the error
functions, you will need to set up your own message callbacks.  These
functions are normally supplied at the time that the png_struct is created.
It is also possible to redirect errors and warnings to your own replacement
functions after png_create_*_struct() has been called by calling:

</para>

<para>    png_set_error_fn(png_structp png_ptr,
        png_voidp error_ptr, png_error_ptr error_fn,
        png_error_ptr warning_fn);

</para>

<para>    png_voidp error_ptr = png_get_error_ptr(png_ptr);

</para>

<para>If NULL is supplied for either error_fn or warning_fn, then the libpng
default function will be used, calling fprintf() and/or longjmp() if a
problem is encountered.  The replacement error functions should have
parameters as follows:

</para>

<para>    void user_error_fn(png_structp png_ptr,
        png_const_charp error_msg);
    void user_warning_fn(png_structp png_ptr,
        png_const_charp warning_msg);

</para>

<para>The motivation behind using setjmp() and longjmp() is the C++ throw and
catch exception handling methods.  This makes the code much easier to write,
as there is no need to check every return code of every function call.
However, there are some uncertainties about the status of local variables
after a longjmp, so the user may want to be careful about doing anything after
setjmp returns non-zero besides returning itself.  Consult your compiler
documentation for more details.  For an alternative approach, you may wish
to use the "cexcept" facility (see http://cexcept.sourceforge.net).

</para>

<para>
</para>

<para>If you need to read or write custom chunks, you may need to get deeper
into the libpng code.  The library now has mechanisms for storing
and writing chunks of unknown type; you can even declare callbacks
for custom chunks.  Hoewver, this may not be good enough if the
library code itself needs to know about interactions between your
chunk and existing `intrinsic' chunks.

</para>

<para>If you need to write a new intrinsic chunk, first read the PNG
specification. Acquire a first level of
understanding of how it works.  Pay particular attention to the
sections that describe chunk names, and look at how other chunks were
designed, so you can do things similarly.  Second, check out the
sections of libpng that read and write chunks.  Try to find a chunk
that is similar to yours and use it as a template.  More details can
be found in the comments inside the code.  It is best to handle unknown
chunks in a generic method, via callback functions, instead of by
modifying libpng functions.

</para>

<para>If you wish to write your own transformation for the data, look through
the part of the code that does the transformations, and check out some of
the simpler ones to get an idea of how they work.  Try to find a similar
transformation to the one you want to add and copy off of it.  More details
can be found in the comments inside the code itself.

</para>

<para>
</para>

<para>You will want to look into zconf.h to tell zlib (and thus libpng) that
it cannot allocate more then 64K at a time.  Even if you can, the memory
won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.

</para>

<para>
</para>

<para>For DOS users who only have access to the lower 640K, you will
have to limit zlib's memory usage via a png_set_compression_mem_level()
call.  See zlib.h or zconf.h in the zlib library for more information.

</para>

<para>
</para>

<para>Libpng's support for medium model has been tested on most of the popular
compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
defined, and FAR gets defined to far in pngconf.h, and you should be
all set.  Everything in the library (except for zlib's structure) is
expecting far data.  You must use the typedefs with the p or pp on
the end for pointers (or at least look at them and be careful).  Make
note that the rows of data are defined as png_bytepp, which is an
unsigned char far * far *.

</para>

<para>
</para>

<para>You will need to write new error and warning functions that use the GUI
interface, as described previously, and set them to be the error and
warning functions at the time that png_create_*_struct() is called,
in order to have them available during the structure initialization.
They can be changed later via png_set_error_fn().  On some compilers,
you may also have to change the memory allocators (png_malloc, etc.).

</para>

<para>
</para>

<para>All includes for libpng are in pngconf.h.  If you need to add/change/delete
an include, this is the place to do it.  The includes that are not
needed outside libpng are protected by the PNG_INTERNAL definition,
which is only defined for those routines inside libpng itself.  The
files in libpng proper only include png.h, which includes pngconf.h.

</para>

<para>
</para>

<para>There are special functions to configure the compression.  Perhaps the
most useful one changes the compression level, which currently uses
input compression values in the range 0 - 9.  The library normally
uses the default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests
have shown that for a large majority of images, compression values in
the range 3-6 compress nearly as well as higher levels, and do so much
faster.  For online applications it may be desirable to have maximum speed
(Z_BEST_SPEED = 1).  With versions of zlib after v0.99, you can also
specify no compression (Z_NO_COMPRESSION = 0), but this would create
files larger than just storing the raw bitmap.  You can specify the
compression level by calling:

</para>

<para>    png_set_compression_level(png_ptr, level);

</para>

<para>Another useful one is to reduce the memory level used by the library.
The memory level defaults to 8, but it can be lowered if you are
short on memory (running DOS, for example, where you only have 640K).

</para>

<para>    png_set_compression_mem_level(png_ptr, level);

</para>

<para>The other functions are for configuring zlib.  They are not recommended
for normal use and may result in writing an invalid PNG file.  See
zlib.h for more information on what these mean.

</para>

<para>    png_set_compression_strategy(png_ptr,
        strategy);
    png_set_compression_window_bits(png_ptr,
        window_bits);
    png_set_compression_method(png_ptr, method);
    png_set_compression_buffer_size(png_ptr, size);

</para>

<para>
</para>

<para>If you want to control whether libpng uses filtering or not, which
filters are used, and how it goes about picking row filters, you
can call one of these functions.  The selection and configuration
of row filters can have a significant impact on the size and
encoding speed and a somewhat lesser impact on the decoding speed
of an image.  Filtering is enabled by default for RGB and grayscale
images (with and without alpha), but not for paletted images nor
for any images with bit depths less than 8 bits/pixel.

</para>

<para>The 'method' parameter sets the main filtering method, which is
currently only '0' in the PNG 1.2 specification.  The 'filters'
parameter sets which filter(s), if any, should be used for each
scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
to turn filtering on and off, respectively.

</para>

<para>Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB,
PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
ORed together with '|' to specify one or more filters to use.
These filters are described in more detail in the PNG specification.  If
you intend to change the filter type during the course of writing
the image, you should start with flags set for all of the filters
you intend to use so that libpng can initialize its internal
structures appropriately for all of the filter types.

</para>

<para>    filters = PNG_FILTER_NONE | PNG_FILTER_SUB
              PNG_FILTER_UP | PNG_FILTER_AVE |
              PNG_FILTER_PAETH | PNG_ALL_FILTERS;
    or
    filters = one of PNG_FILTER_VALUE_NONE,
              PNG_FILTER_VALUE_SUB, PNG_FILTER_VALUE_UP,
              PNG_FILTER_VALUE_AVE, PNG_FILTER_VALUE_PAETH

</para>

<para>    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
       filters);
              The second parameter can also be PNG_INTRAPIXEL_DIFFERENCING
              if you are writing a PNG to be embedded in a MNG
              datastream.  This parameter must be the same as the
              value of filter_method used in png_set_IHDR().

</para>

<para>It is also possible to influence how libpng chooses from among the
available filters.  This is done in two ways - by telling it how
important it is to keep the same filter for successive rows, and
by telling it the relative computational costs of the filters.

</para>

<para>    double weights[3] = {1.5, 1.3, 1.1},
       costs[PNG_FILTER_VALUE_LAST] =
       {1.0, 1.3, 1.3, 1.5, 1.7};

</para>

<para>    png_set_filter_selection(png_ptr,
       PNG_FILTER_SELECTION_WEIGHTED, 3,
       weights, costs);

</para>

<para>The weights are multiplying factors that indicate to libpng that the
row filter should be the same for successive rows unless another row filter
is that many times better than the previous filter.  In the above example,
if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a
"sum of absolute differences" 1.5 x 1.3 times higher than other filters
and still be chosen, while the NONE filter could have a sum 1.1 times
higher than other filters and still be chosen.  Unspecified weights are
taken to be 1.0, and the specified weights should probably be declining
like those above in order to emphasize recent filters over older filters.

</para>

<para>The filter costs specify for each filter type a relative decoding cost
to be considered when selecting row filters.  This means that filters
with higher costs are less likely to be chosen over filters with lower
costs, unless their "sum of absolute differences" is that much smaller.
The costs do not necessarily reflect the exact computational speeds of
the various filters, since this would unduly influence the final image
size.

</para>

<para>Note that the numbers above were invented purely for this example and
are given only to help explain the function usage.  Little testing has
been done to find optimum values for either the costs or the weights.

</para>

<para>
</para>

<para>There are a bunch of #define's in pngconf.h that control what parts of
libpng are compiled.  All the defines end in _SUPPORTED.  If you are
never going to use a capability, you can change the #define to #undef
before recompiling libpng and save yourself code and data space, or
you can turn off individual capabilities with defines that begin with
PNG_NO_.

</para>

<para>You can also turn all of the transforms and ancillary chunk capabilities
off en masse with compiler directives that define
PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
or all four,
along with directives to turn on any of the capabilities that you do
want.  The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable
the extra transformations but still leave the library fully capable of reading
and writing PNG files with all known public chunks
Use of the PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive
produces a library that is incapable of reading or writing ancillary chunks.
If you are not using the progressive reading capability, you can
turn that off with PNG_NO_PROGRESSIVE_READ (don't confuse
this with the INTERLACING capability, which you'll still have).

</para>

<para>All the reading and writing specific code are in separate files, so the
linker should only grab the files it needs.  However, if you want to
make sure, or if you are building a stand alone library, all the
reading files start with pngr and all the writing files start with
pngw.  The files that don't match either (like png.c, pngtrans.c, etc.)
are used for both reading and writing, and always need to be included.
The progressive reader is in pngpread.c

</para>

<para>If you are creating or distributing a dynamically linked library (a .so
or DLL file), you should not remove or disable any parts of the library,
as this will cause applications linked with different versions of the
library to fail if they call functions not available in your library.
The size of the library itself should not be an issue, because only
those sections that are actually used will be loaded into memory.

</para>

<para>
</para>

<para>The macro definition PNG_DEBUG can be used to request debugging
printout.  Set it to an integer value in the range 0 to 3.  Higher
numbers result in increasing amounts of debugging information.  The
information is printed to the "stderr" file, unless another file
name is specified in the PNG_DEBUG_FILE macro definition.

</para>

<para>When PNG_DEBUG &gt; 0, the following functions (macros) become available:

</para>

<para>   png_debug(level, message)
   png_debug1(level, message, p1)
   png_debug2(level, message, p1, p2)

</para>

<para>in which "level" is compared to PNG_DEBUG to decide whether to print
the message, "message" is the formatted string to be printed,
and p1 and p2 are parameters that are to be embedded in the string
according to printf-style formatting directives.  For example,

</para>

<para>   png_debug1(2, "foo=%d\n", foo);

</para>

<para>is expanded to

</para>

<para>   if(PNG_DEBUG &gt; 2)
     fprintf(PNG_DEBUG_FILE, "foo=%d\n", foo);

</para>

<para>When PNG_DEBUG is defined but is zero, the macros aren't defined, but you
can still use PNG_DEBUG to control your own debugging:

</para>

<para>   #ifdef PNG_DEBUG
       fprintf(stderr, ...
   #endif

</para>

<para>When PNG_DEBUG = 1, the macros are defined, but only png_debug statements
having level = 0 will be printed.  There aren't any such statements in
this version of libpng, but if you insert some they will be printed.

</para>

<para>
</para>

<para></para>
</sect3>
<sect3><title>VI.  MNG support</title>

<para>
</para>

<para>The MNG specification (available at http://www.libpng.org/pub/mng) allows
certain extensions to PNG for PNG images that are embedded in MNG datastreams.
Libpng can support some of these extensions.  To enable them, use the
png_permit_mng_features() function:

</para>

<para>   feature_set = png_permit_mng_features(png_ptr, mask)
   mask is a png_uint_32 containing the logical OR of the
        features you want to enable.  These include
        PNG_FLAG_MNG_EMPTY_PLTE
        PNG_FLAG_MNG_FILTER_64
        PNG_ALL_MNG_FEATURES
   feature_set is a png_32_uint that is the logical AND of
      your mask with the set of MNG features that is
      supported by the version of libpng that you are using.

</para>

<para>It is an error to use this function when reading or writing a standalone
PNG file with the PNG 8-byte signature.  The PNG datastream must be wrapped
in a MNG datastream.  As a minimum, it must have the MNG 8-byte signature
and the MHDR and MEND chunks.  Libpng does not provide support for these
or any other MNG chunks; your application must provide its own support for
them.  You may wish to consider using libmng (available at
http://www.libmng.com) instead.

</para>

<para></para>
</sect3>
<sect3><title>VII.  Changes to Libpng from version 0.88</title>

<para>
</para>

<para>It should be noted that versions of libpng later than 0.96 are not
distributed by the original libpng author, Guy Schalnat, nor by
Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
distributed versions 0.89 through 0.96, but rather by another member
of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are
still alive and well, but they have moved on to other things.

</para>

<para>The old libpng functions png_read_init(), png_write_init(),
png_info_init(), png_read_destroy(), and png_write_destory() have been
moved to PNG_INTERNAL in version 0.95 to discourage their use.  These
functions will be removed from libpng version 2.0.0.

</para>

<para>The preferred method of creating and initializing the libpng structures is
via the png_create_read_struct(), png_create_write_struct(), and
png_create_info_struct() because they isolate the size of the structures
from the application, allow version error checking, and also allow the
use of custom error handling routines during the initialization, which
the old functions do not.  The functions png_read_destroy() and
png_write_destroy() do not actually free the memory that libpng
allocated for these structs, but just reset the data structures, so they
can be used instead of png_destroy_read_struct() and
png_destroy_write_struct() if you feel there is too much system overhead
allocating and freeing the png_struct for each image read.

</para>

<para>Setting the error callbacks via png_set_message_fn() before
png_read_init() as was suggested in libpng-0.88 is no longer supported
because this caused applications that do not use custom error functions
to fail if the png_ptr was not initialized to zero.  It is still possible
to set the error callbacks AFTER png_read_init(), or to change them with
png_set_error_fn(), which is essentially the same function, but with a new
name to force compilation errors with applications that try to use the old
method.

</para>

<para>Starting with version 1.0.7, you can find out which version of the library
you are using at run-time:

</para>

<para>   png_uint_32 libpng_vn = png_access_version_number();

</para>

<para>The number libpng_vn is constructed from the major version, minor
version with leading zero, and release number with leading zero,
(e.g., libpng_vn for version 1.0.7 is 10007).

</para>

<para>You can also check which version of png.h you used when compiling your
application:

</para>

<para>   png_uint_32 application_vn = PNG_LIBPNG_VER;

</para>

<para></para>
</sect3>
<sect3><title>VIII. Y2K Compliance in libpng</title>

<para>
</para>

<para>January 31, 2001

</para>

<para>Since the PNG Development group is an ad-hoc body, we can't make
an official declaration.

</para>

<para>This is your unofficial assurance that libpng from version 0.71 and
upward through 1.0.9 are Y2K compliant.  It is my belief that earlier
versions were also Y2K compliant.

</para>

<para>Libpng only has three year fields.  One is a 2-byte unsigned integer that
will hold years up to 65535.  The other two hold the date in text
format, and will hold years up to 9999.

</para>

<para>The integer is
    "png_uint_16 year" in png_time_struct.

</para>

<para>The strings are
    "png_charp time_buffer" in png_struct and
    "near_time_buffer", which is a local character string in png.c.

</para>

<para>There are seven time-related functions:

</para>

<para>    png_convert_to_rfc_1123() in png.c
      (formerly png_convert_to_rfc_1152() in error)
    png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
    png_convert_from_time_t() in pngwrite.c
    png_get_tIME() in pngget.c
    png_handle_tIME() in pngrutil.c, called in pngread.c
    png_set_tIME() in pngset.c
    png_write_tIME() in pngwutil.c, called in pngwrite.c

</para>

<para>All appear to handle dates properly in a Y2K environment.  The
png_convert_from_time_t() function calls gmtime() to convert from system
clock time, which returns (year - 1900), which we properly convert to
the full 4-digit year.  There is a possibility that applications using
libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
function, or that they are incorrectly passing only a 2-digit year
instead of "year - 1900" into the png_convert_from_struct_tm() function,
but this is not under our control.  The libpng documentation has always
stated that it works with 4-digit years, and the APIs have been
documented as such.

</para>

<para>The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
integer to hold the year, and can hold years as large as 65535.

</para>

<para>zlib, upon which libpng depends, is also Y2K compliant.  It contains
no date-related code.

</para>

<para>
</para>

<para>   Glenn Randers-Pehrson
   libpng maintainer
   PNG Development Group

</para>

<para></para>
</sect3>
<sect3><title>NOTE</title>

<para>
</para>

<para>Note about libpng version numbers:

</para>

<para>Due to various miscommunications, unforeseen code incompatibilities
and occasional factors outside the authors' control, version numbering
on the library has not always been consistent and straightforward.
The following table summarizes matters since version 0.89c, which was
the first widely used release:

</para>

<para>   source                   png.h    png.h   shared-lib
   version                  string     int   version
   -------                  ------   -----  ----------
   0.89c ("1.0 beta 3")     0.89        89  1.0.89
   0.90  ("1.0 beta 4")     0.90        90  0.90  [should have been 2.0.90]
   0.95  ("1.0 beta 5")     0.95        95  0.95  [should have been 2.0.95]
   0.96  ("1.0 beta 6")     0.96        96  0.96  [should have been 2.0.96]
   0.97b ("1.00.97 beta 7") 1.00.97     97  1.0.1 [should have been 2.0.97]
   0.97c                    0.97        97  2.0.97
   0.98                     0.98        98  2.0.98
   0.99                     0.99        98  2.0.99
   0.99a-m                  0.99        99  2.0.99
   1.00                     1.00       100  2.1.0 [100 should be 10000]
   1.0.0                    1.0.0      100  2.1.0 [100 should be 10000]
   1.0.1                    1.0.1    10001  2.1.0
   1.0.1a-e                 1.0.1a-e 10002  2.1.0.1a-e
   1.0.2                    1.0.2    10002  2.1.0.2
   1.0.2a-b                 1.0.2a-b 10003  2.1.0.2a-b
   1.0.3                    1.0.3    10003  2.1.0.3
   1.0.3a-d                 1.0.3a-d 10004  2.1.0.3a-d
   1.0.4                    1.0.4    10004  2.1.0.4
   1.0.4a-f                 1.0.4a-f 10005  2.1.0.4a-f
   1.0.5 (+ 2 patches)      1.0.5    10005  2.1.0.5
   1.0.5a-d                 1.0.5a-d 10006  2.1.0.5a-d
   1.0.5e-r                 1.0.5e-r 10100  2.1.0.5e-r (not compatible)
   1.0.5s-v                 1.0.5s-v 10006  2.1.0.5s-v (compatible)
   1.0.6 (+ 3 patches)      1.0.6    10006  2.1.0.6
   1.0.6d                   1.0.6d   10007  2.1.0.6d
   1.0.7                    1.0.7    10007  2.1.0.7    (still compatible)

</para>

<para>   Henceforth the source version will match the shared-library minor
   and patch numbers; the shared-library major version number will be
   used for changes in backward compatibility, as it is intended.  The
   PNG_PNGLIB_VER macro, which is not used within libpng but is available
   for applications, is an unsigned integer of the form xyyzz corresponding
   to the source version x.y.z (leading zeros in y and z).  Beta versions
   are given the previous public release number plus a letter or two.

</para>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para>libpngpf(3), png(5)
<emphasis>libpng :</emphasis>
ftp://ftp.uu.net/graphics/png
http://www.libpng.org/pub/png

</para>

<para><emphasis>zlib :</emphasis>
(generally) at the same location as
<emphasis>libpng</emphasis>
or at
ftp://ftp.uu.net/pub/archiving/zip/zlib
ftp://ftp.info-zip.org/pub/infozip/zlib

</para>

<para><emphasis>PNG specification: RFC 2083</emphasis>
(generally) at the same location as
<emphasis>libpng</emphasis>
or at
ftp://ds.internic.net/rfc/rfc2083.txt
or (as a W3C Recommendation) at
http://www.w3.org/TR/REC-png.html

</para>

<para>In the case of any inconsistency between the PNG specification
and this library, the specification takes precedence.

</para>

<para></para>
</sect3>
<sect3><title>AUTHORS</title>

<para>This man page: Glenn Randers-Pehrson
&lt;randeg@alum.rpi.edu&gt;

</para>

<para>The contributing authors would like to thank all those who helped
with testing, bug fixes, and patience.  This wouldn't have been
possible without all of you.

</para>

<para>Thanks to Frank J. T. Wojcik for helping with the documentation.

</para>

<para>Libpng version 1.0.9 - January 31, 2001:
Initially created in 1995 by Guy Eric Schalnat, then of Group 42, Inc.
Currently maintained by Glenn Randers-Pehrson (randeg@alum.rpi.edu).

</para>

<para>Supported by the PNG development group
(png-implement@ccrc.wustl.edu).

</para>

<para></para>
</sect3>
<sect3><title>COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:</title>

<para>
</para>

<para>(This copy of the libpng notices is provided for your convenience.  In case of
any discrepancy between this copy and the notices in the file png.h that is
included in the libpng distribution, the latter shall prevail.)

</para>

<para>If you modify libpng you may insert additional notices immediately following
this sentence.

</para>

<para>libpng versions 1.0.7, July 1, 2000, through  1.0.9, January 31, 2001, are
Copyright (c) 2000 Glenn Randers-Pehrson, and are
distributed according to the same disclaimer and license as libpng-1.0.6
with the following individuals added to the list of Contributing Authors

</para>

<para>   Simon-Pierre Cadieux
   Eric S. Raymond
   Gilles Vollant

</para>

<para>and with the following additions to the disclaimer:

</para>

<para>   There is no warranty against interference with your enjoyment of the
   library or against infringement.  There is no warranty that our
   efforts or the library will fulfill any of your particular purposes
   or needs.  This library is provided with all faults, and the entire
   risk of satisfactory quality, performance, accuracy, and effort is with
   the user.

</para>

<para>libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
Copyright (c) 1998, 1999 Glenn Randers-Pehrson
Distributed according to the same disclaimer and license as libpng-0.96,
with the following individuals added to the list of Contributing Authors:

</para>

<para>   Tom Lane
   Glenn Randers-Pehrson
   Willem van Schaik

</para>

<para>libpng versions 0.89, June 1996, through 0.96, May 1997, are
Copyright (c) 1996, 1997 Andreas Dilger
Distributed according to the same disclaimer and license as libpng-0.88,
with the following individuals added to the list of Contributing Authors:

</para>

<para>   John Bowler
   Kevin Bracey
   Sam Bushell
   Magnus Holmgren
   Greg Roelofs
   Tom Tanner

</para>

<para>libpng versions 0.5, May 1995, through 0.88, January 1996, are
Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.

</para>

<para>For the purposes of this copyright and license, "Contributing Authors"
is defined as the following set of individuals:

</para>

<para>   Andreas Dilger
   Dave Martindale
   Guy Eric Schalnat
   Paul Schmidt
   Tim Wegner

</para>

<para>The PNG Reference Library is supplied "AS IS".  The Contributing Authors
and Group 42, Inc. disclaim all warranties, expressed or implied,
including, without limitation, the warranties of merchantability and of
fitness for any purpose.  The Contributing Authors and Group 42, Inc.
assume no liability for direct, indirect, incidental, special, exemplary,
or consequential damages, which may result from the use of the PNG
Reference Library, even if advised of the possibility of such damage.

</para>

<para>Permission is hereby granted to use, copy, modify, and distribute this
source code, or portions hereof, for any purpose, without fee, subject
to the following restrictions:

</para>

<para>1. The origin of this source code must not be misrepresented.

</para>

<para>2. Altered versions must be plainly marked as such and must not
   be misrepresented as being the original source.

</para>

<para>3. This Copyright notice may not be removed or altered from any
   source or altered source distribution.

</para>

<para>The Contributing Authors and Group 42, Inc. specifically permit, without
fee, and encourage the use of this source code as a component to
supporting the PNG file format in commercial products.  If you use this
source code in a product, acknowledgment is not required but would be
appreciated.

</para>

<para>
</para>

<para>A "png_get_copyright" function is available, for convenient use in "about"
boxes and the like:

</para>

<para>   printf("%s",png_get_copyright(NULL));

</para>

<para>Also, the PNG logo (in PNG format, of course) is supplied in the
files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).

</para>

<para>Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
certification mark of the Open Source Initiative.

</para>

<para>Glenn Randers-Pehrson
randeg@alum.rpi.edu
January 31, 2001

</para>

<para><!--  end of man page -->

</para>

<para></para>
</sect3>
</sect2>
</sect1>

<sect1><title>Conclusion</title>
<para>
This chapter hasn't been as complete as the TIFF chapter, for which I apologize. I have shown you all the important things about the PNG format though -- the layout of the images on disc, how to open and read an image, how to write an image, how to use the client call backs to save data in places other than files, and I have included the libpng documentation.
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
<itemizedlist>
<listitem><para>http://www.libpng.org/pub/png/png.html: The libpng homepage.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pngintro.html: An introduction to PNG features.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pngfaq.html: The PNG FAQ.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/pnghist.html: A history of PNG.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/spec/: Version 1.2 of the PNG specification.</para></listitem>
<listitem><para>http://www.libpng.org/pub/png/libpng.html: libpng download page</para></listitem>
</itemizedlist>
</para>
</sect1>

</chapter>

<chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
In a sense this PDF chapter is the culmination of the tutorial... Many of the formats we have discussed up to this point can be included in some way in PDF files. I think that PDF is probably the most interesting imaging format in common use today.
</para>

<para>
This chapter is broken into two major sections. These are: a discussion of the PDF format, and then an introduction to Panda, a PDF generation API.
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 <9F><92><9C><9F>
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis><9F><92><9C><9F></emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a look up table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<sect4><title>Arrays</title>
<para>
An array is a one dimensional collection of other values. Unlike most programming languages, the contents of the array can be of several types, for instance we could mix integers with strings in a single array. Arrays start and end with square brackets.
</para>

<sect5><title>Examples</title>
<programlisting>
[(foo) (bar) 42.3 /AName]
</programlisting>
</sect5>
</sect4>
<sect4><title>Boolean</title>
<para>
Boolean values are represented with the words <command>true</command> and <command>false</command>.
</para>

<sect5><title>Examples</title>
<programlisting>
/ExplodeOnOpening true
/Rotate false
</programlisting>
</sect5>
</sect4>
<sect4><title>Names</title>
<para>
A name is a sequence of characters not including whitespace which follow a forward slash. Names are used in object dictionaries for the names of keys, and for some values of keys.
</para>

<sect5><title>Examples</title>
<programlisting>
</programlisting>
</sect5>
</sect4>
<sect4><title>Numbers</title>
<para>
Known as numeric types in the PDF specification (for somewhat obvious reasons), this includes all forms of numbers. These can either be integer or real
  <footnote><para>Non integer</para></footnote>
numbers.
</para>

<sect5><title>Integers</title>
<para>
Integer numbers can be either positive or negative (with a leading sign value if needed) and have a maximum value of ... and a minimum value of ... .

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
123
43445
+176
-17
0
</programlisting>
</sect5>

<sect5><title>Real numbers</title>
<para>
Real numbers can exist in the range ... to ..., and may or may not have leading zeros.

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
34.5
-3.62
+123.5
4.
-.002
0.0
</programlisting>
</sect5>

<sect5><title>Caveats</title>
<para>
The PDF specification makes the following point:

<quote>PDF does not support the PostScript syntax for numbers with non-decimal radices (such as 16#FFFE) or in exponent format (such as 6.02E23).</quote>
  <footnote><para>PDF Specification 1.3, second edition, page 27</para></footnote>
</para>
</sect5>
</sect4>
<sect4><title>Strings</title>
<para>
Strings are represented a series of unsigned bytes
  <footnote><para>That is, in the range 0 to 255.</para></footnote>
which is identical to the ASCII strings most programmers are familar with in C. There are two main representations of strings. These are:
</para>

<sect5><title>Bracket notation</title>
<para>
Strings can be wrapped in curved brackets such as () to delimit the start and end of the string. Strings may also contain brackets, so long as they are balanced or escaped with a backslash.
</para>

<para>
These are known as literal strings in the PDF specification.
</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
(hello)
(hello world)
(hello world \(the people I like\))
(hello world (the people I like))
</programlisting>
</sect5>

<sect5><title>Escaped characters</title>
<para>
There are a series of standard characters which are used with the backslash escape. These are:
</para>

<itemizedlist>
<listitem><para><emphasis>\n</emphasis>: Newline</para></listitem>
<listitem><para><emphasis>\r</emphasis>: Carriage return</para></listitem>
<listitem><para><emphasis>\t</emphasis>: Tab</para></listitem>
<listitem><para><emphasis>\b</emphasis>: Backspace</para></listitem>
<listitem><para><emphasis>\f</emphasis>: Form feed</para></listitem>
<listitem><para><emphasis>\(</emphasis>: Open bracket</para></listitem>
<listitem><para><emphasis>\)</emphasis>: Close bracket</para></listitem>
<listitem><para><emphasis>\\</emphasis>: Backslash</para></listitem>
<listitem><para><emphasis>\ddd</emphasis>: Arbitary character (ddd is a number in octal)</para></listitem>
</itemizedlist>

<para>
The backslash operator can also be used to continue text on the next line. For instance:
</para>

<programlisting>
(This is a very long string which we want to \
break over a couple of lines.)
</programlisting>

<para>
This means that we can also embed newlines without using the escape. For instance, these two text blocks are the same:
</para>

<programlisting>
(This is a 
string \
with some lines)
</programlisting>

<para>
and
</para>

<programlisting>
(This is a\nstring with some lines)
</programlisting>

<para>
More on strings in this notation can be found in the PDF specification, version 1.3, on page 30.
</para>
</sect5>

<sect5><title>Hexadecimal notation</title>
<para>
Strings can also be written in hexadecimal form, and in this case are enclosed in angle brackets.
</para>
</sect5>

<sect5><title>Examples</title>
<para>
An example of a hexidecimal string is:
</para>

<programlisting>
&lt;4E6F762073686D6F7A206B6120706F702E&gt;
</programlisting>

<para>
If the final digit is missing, then it is assumed to be zero. For instance, the following string:
</para>

<programlisting>
&lt;901FA&gt;
</programlisting>

<para>
Is the same as:
</para>

<programlisting>
&lt;901FA0&gt;
</programlisting>
</sect5>

</sect4>

<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 


The other type of information which can be stored in a stream is arbitrary information such as the content of images (which would normally be raster information). 


An in depth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<sect4><title>ASCII85Decode</title>
<para>
The ASCII85 filter takes binary data, and turns it into base 85 representation. This is needed by some email clients (among other things), because they can't handle embedding binary data into their protocols.
</para>

<para>
The <emphasis>comp.text.pdf frequently asked questions</emphasis> refers to the code examples below by way of explaination:
</para>

<programlisting>
/* encode85 -- convert to ascii85 format */

#include &lt;stdio.h&gt;
#define	atoi(s)	strtol(s, 0, 0)

static unsigned long width = 72, pos = 0, tuple = 0;
static int count = 0;

void init85(void) {
	printf("&lt;~");
	pos = 2;
}

void encode(unsigned long tuple, int count) {
	int i;
	char buf[5], *s = buf;
	i = 5;
	do {
		*s++ = tuple % 85;
		tuple /= 85;
	} while (--i &gt; 0);
	i = count;
	do {
		putchar(*--s + '!');
		if (pos++ &gt;= width) {
			pos = 0;
			putchar('\n');
		}
	} while (i-- &gt; 0);
}

void put85(unsigned c) {
	switch (count++) {
	case 0:	tuple |= (c &lt;&lt; 24); break;
	case 1: tuple |= (c &lt;&lt; 16); break;
	case 2:	tuple |= (c &lt;&lt;  8); break;
	case 3:
		tuple |= c;
		if (tuple == 0) {
			putchar('z');
			if (pos++ &gt;= width) {
				pos = 0;
				putchar('\n');
			}
		} else
			encode(tuple, count);
		tuple = 0;
		count = 0;
		break;
	}
}

void cleanup85(void) {
	if (count &gt; 0)
		encode(tuple, count);
	if (pos + 2 &gt; width)
		putchar('\n');
	printf("~&gt;\n");
}

void copy85(FILE *fp) {
	unsigned c;
	while ((c = getc(fp)) != EOF)
		put85(c);
}

void usage(void) {
	fprintf(stderr, "usage: encode85 [-w width] file ...\n");
	exit(1);
}

extern int getopt(int, char *[], const char *);
extern int optind;
extern char *optarg;

int main(int argc, char *argv[]) {
	int i;
	while ((i = getopt(argc, argv, "w:?")) != EOF)
		switch (i) {
		case 'w':
			width = atoi(optarg);
			if (width == 0)
				width = ~0;
			break;
		case '?':
			usage();
		}
	
	init85();
	if (optind == argc)
		copy85(stdin);
	else
		for (i = optind; i &lt; argc; i++) {
			FILE *fp = fopen(argv[i], "r");
			if (fp == NULL) {
				perror(argv[i]);
				return 1;
			}
			copy85(fp);
			fclose(fp);
		}
	cleanup85();
	return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/ascii85/encode85.c</emphasis></para>

<programlisting>
/* decode85 -- convert from ascii85 format */

#include &lt;stdio.h&gt;

static unsigned long pow85[] = {
	85*85*85*85, 85*85*85, 85*85, 85, 1
};

void wput(unsigned long tuple, int bytes) {
	switch (bytes) {
	case 4:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		putchar(tuple &gt;&gt;  8);
		putchar(tuple);
		break;
	case 3:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		putchar(tuple &gt;&gt;  8);
		break;
	case 2:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		break;
	case 1:
		putchar(tuple &gt;&gt; 24);
		break;
	}
}

void decode85(FILE *fp, const char *file) {
	unsigned long tuple = 0;
	int c, count = 0;
	for (;;)
		switch (c = getc(fp)) {
		default:
			if (c &lt; '!' || c &gt; 'u') {
				fprintf(stderr, "%s: bad character in ascii85 region: %#o\n", file, c);
				exit(1);
			}
			tuple += (c - '!') * pow85[count++];
			if (count == 5) {
				wput(tuple, 4);
				count = 0;
				tuple = 0;
			}
			break;
		case 'z':
			if (count != 0) {
				fprintf(stderr, "%s: z inside ascii85 5-tuple\n", file);
				exit(1);
			}
			putchar(0);
			putchar(0);
			putchar(0);
			putchar(0);
			break;
		case '~':
			if (getc(fp) == '&gt;') {
				if (count &gt; 0) {
					count--;
					tuple += pow85[count];
					wput(tuple, count);
				}
				c = getc(fp);
				return;
			}
			fprintf(stderr, "%s: ~ without &gt; in ascii85 section\n", file);
			exit(1);
		case '\n': case '\r': case '\t': case ' ':
		case '\0': case '\f': case '\b': case 0177:
			break;
		case EOF:
			fprintf(stderr, "%s: EOF inside ascii85 section\n", file);
			exit(1);
		}
}

void decode(FILE *fp, const char *file, int preserve) {
	int c;
	while ((c = getc(fp)) != EOF)
		if (c == '&lt;')
			if ((c = getc(fp)) == '~')
				decode85(fp, file);
			else {
				if (preserve)
					putchar('&lt;');
				if (c == EOF)
					break;
				if (preserve)
					putchar(c);
			}
		else
			if (preserve)
				putchar(c);
}

void usage(void) {
	fprintf(stderr, "usage: decode85 [-p] file ...\n");
	exit(1);
}

extern int getopt(int, char *[], const char *);
extern int optind;
extern char *optarg;

int main(int argc, char *argv[]) {
	int i, preserve;
	preserve = 0;
	while ((i = getopt(argc, argv, "p?")) != EOF)
		switch (i) {
		case 'p': preserve = 1; break;
		case '?': usage();
		}
	

	if (optind == argc)
		decode(stdin, "decode85", preserve);
	else
		for (i = optind; i &lt; argc; i++) {
			FILE *fp = fopen(argv[i], "r");
			if (fp == NULL) {
				perror(argv[i]);
				return 1;
			}
			decode(fp, argv[i], preserve);
			fclose(fp);
		}
	return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/ascii85/decode85.c</emphasis></para>

<para>
These two code snippets were written by Paul Haahr, http://www.webcom.com/~haahr/, and is stated to be in the public domain.
</para>

</sect4>
<sect4><title>ASCIIHexDecode</title>
<para>
For similar reasons to ASCII85, you can also represent your binary data as hexidecimal. This filter implements this.
</para>

</sect4>
<sect4><title>CCITTFaxDecode</title>
<para>
This is the compression codec known as group3 and group 4 fax in TIFF. It is about as good as compression gets for black and white images.
</para>

</sect4>
<sect4><title>DCTDecode</title>
<para>
DCT (Descrete Cosine Transform) is the compression codec used by JPEG images. As discussed elsewhere in this document, it is good for color images, but is lossy.
</para>

</sect4>
<sect4><title>FlateDecode</title>
<para>
Flate compression (which is implemented by zlib), is the compression codec using in PNG images. It is very good for colour image and textual data.
</para>

</sect4>
<sect4><title>LZWDecode</title>
<para>
LZW is the compression codec used by GIF images. No publically available libraries implement LZW compression, and it is recommended you don't use it as many Acrobat viewers don't implement LZW decompression. Even Adobe's own products stear away from using this filter.
</para>

</sect4>
<sect4><title>RunLengthDecode</title>
<para>
Run length compression is a very simple compression codec, and it not recommended for most purposes.
</para>
</sect4>

</sect3>
</sect2>

<sect2><title>Object structure</title>
<para>
The diagram below shows the basic object structure of a PDF document. It can be much more complex than this, especially if you reuse commonly used objects like the logo which is on every page of the document. In words, the structure is something like:
</para>

<sect3><title>Catalog Object</title>
<para>
Every PDF document has a catalog object. This catalog object refers to a pages object.
</para>
</sect3>

<sect3><title>Pages object</title>
<para>
The pages object stores a list of pages within the PDF document, in the form of a dictionary array with the key name <quote>/Kids</quote>. Each of these pages will have an object.
</para>
</sect3>

<sect3><title>A Page object per page</title>
<para>
Each page object will have a content object.
</para>
</sect3>

<sect3><title>Content objects</title>
<para>
Each content object will refer to the pages object, as well as referring to resources that that needed to draw this page. The resources can be used by other contents objects as well. Resources are things like fonts, and images.
</para>

<para>
A postscript-like description of the layout of the page is stored in this object's stream.
</para>
</sect3>

<sect3><title>Resources</title>
<para>
A resources object stores information you need to be able to use a given resource such as a font or image.
</para>

<para>
If the resource is an image or an embedded font, then the additional binary data (such as a raster) is stored in this objects stream.
</para>
</sect3>

<sect3><title>Typical object structure</title>
<figure><title>A typical PDF object structure</title>
<graphic format="EPS" fileref="pdf-figure1.eps">
</figure>
</sect3>
</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft Power Point presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>

<programlisting>
#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage;

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("hello.pdf", "w")) == NULL)
    {
      fprintf (stderr, "Could not open hello.pdf\n");
      exit (1);
    }

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Write some text to the page
  panda_setfont (demo, panda_createfont (demo, "Times-Roman", 1,
  					 "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300, "Hello world");

  // Finished all the demoing, close the PDF document
  panda_close (demo);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/panda/hello/hello.c</emphasis></para>

<para>
Which produces...
</para>

<figure>
<title>Panda hello world</title>
<graphic format="EPS" fileref="source/pdf/panda/hello/hello.pdf.eps">
</figure>

</sect2>

<sect2><title>Initialization</title>
<para>
Initialization of Panda is easy. Simply call <command>panda_init</command>(). You'll also need to create a PDF document, which is done with the <command>panda_open</command> function.
</para>

<refentry id="panda_init">
<refmeta>
<refentrytitle>panda_init</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_init</refname>
<refpurpose>setup Panda ready for use</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_init (void);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Performs some simple setup of Panda before it is used for the first time in your application.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_init();
</para>
</refsect1>

</refentry>
<refentry id="panda_open">
<refmeta>
<refentrytitle>panda_open</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_open</refname>
<refpurpose>open a PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_pdf * panda_open (char *filename, char *mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Open the named PDF document with the mode specified. The only mode currently supported is "w", but others will be integrated later. The interface to this function is identical in it's behaviour to the <command>fopen</command>() function call offered by the ANSI C standard IO library.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to a panda_pdf structure</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_init, panda_open_actual, panda_open_suppress, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Creating pages</title>
<para>
Pages are created in Panda using the <command>panda_newpage</command> function. You can magically be editing as many pages at a time as you like with Panda without any additional calls being needed.
</para>

<refentry id="panda_newpage">
<refmeta>
<refentrytitle>panda_newpage</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newpage</refname>
<refpurpose>create a new page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_page *panda_newpage(panda_pdf *document, char *pagesize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Create a new blank page at the end of the PDF with the specified size. Use the standard pagesize strings that are defined by Panda for most things. These are <command>panda_pagesize_a4</command>, and <command>panda_pagesize_usletter</command>. If you need to create your own page sizes, then have a look at these for hints.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Object properties</title>
<para>
Panda allows you to selectively apply properties to portions of your PDF document. The most common example is choosing which portions of your PDF document to compress.
</para>

<refentry id="panda_setobjectproperty">
<refmeta>
<refentrytitle>panda_setobjectproperty</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setobjectproperty</refname>
<refpurpose>set a property value for an object</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setobjectproperty (panda_object *target, int scope, int propid, int propval);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Properties are a way of specifing things about objects. These properties can have either a cascade scope (they affect all subsequently created objects that are children of that object) -- <command>panda_scope_cascade</command>, or local (they only occur for that object) -- <command>panda_scope_local</command>. Possible properties are defined in the <command>panda_const_properties</command> manual page.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>None</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_object *obj;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 obj = panda_newobject(document, panda_object_normal);
 panda_setproperty(obj, panda_scope_cascade, panda_object_property_compress, panda_true);
 
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newobject, panda_const_properties</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Finalizing</title>
<para>
Pages don't need to be closed in Panda. This is done when the <command>panda_close</command> function is called. This function writes the entire PDF document out to disc.
</para>

<refentry id="panda_close">
<refmeta>
<refentrytitle>panda_close</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_close</refname>
<refpurpose>write a PDF document out to disk</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_close (panda_pdf *document);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Write out the PDF document we have created to disk, clean up and free memory.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_close(document);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Inserting text</title>
<para>
One of the advantages which ClibPDF has over Panda is that it currently supported word wrap, whereas Panda doesn't. Panda does have a variety of text functionality however. The public text functions in Panda are: <command>panda_textboxrot</command>, which creates a text box at a jaunty angle, <command>panda_textbox</command>, which creates a horizontal textbox (a zero angle), and <command>panda_textdirection</command>, which sets the flow direction for text.
</para>

<refentry id="panda_textbox">
<refmeta>
<refentrytitle>panda_textbox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textbox</refname>
<refpurpose>display some text on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textbox (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textboxrot</para>
</refsect1>

</refentry>
<refentry id="panda_textboxrot">
<refmeta>
<refentrytitle>panda_textboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textboxrot</refname>
<refpurpose>display some text at a jaunty angle on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, double angle, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The text is displayed at the spefied angle. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textboxrot (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, 33.0, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textbox</para>
</refsect1>

</refentry>
<refentry id="panda_textdirection">
<refmeta>
<refentrytitle>panda_textdirection</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textdirection</refname>
<refpurpose>specify the direction that the text flows within the document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textdirection (panda_pdf *document, int dir);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the direction that the text in the document flows in. The possible values for the dir arguement are: <command>panda_textdirection_l2r</command>, text is read left to right; <command>panda_textdirection_r2l</command>, text is read right to left. The default for this value is <command>panda_textdirection_l2r</command>.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_textdirection(document, panda_textdirection_r2l);
</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Fonts</title>
<para>
Panda currently only supports the standard PDF fonts, and will not allow you to embed arbitrary fonts into your PDF documents (unlike PDFlib). Some users might find this a little limiting for the time being. In Panda, you use fonts by first creating a pointer to the font using <command>panda_createfont</command>, and then start using that font with <command>panda_setfont</command>. This allows you use efficiently create the five fonts you are going to use in the document, and then swap backwards and forwards within that set of five with no performance penalty.
</para>

<refentry id="panda_createfont">
<refmeta>
<refentrytitle>panda_createfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_createfont</refname>
<refpurpose>return a handle to the requested font</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 char * panda_createfont (panda_pdf * output, char *fontname, int type, char *encoding)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para><command>PANDA INTERNAL</command>. This funtion call creates a font object for the requested font and returns the identifier that should be used when the font is set within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A font identifier (handle) as a null terminated string.</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 fonthandle = (output, "Helventica", 3, "MacRomanEncoding");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_setfont">
<refmeta>
<refentrytitle>panda_setfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfont</refname>
<refpurpose>set the current font to be that specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfont (char *fontident);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Once you have generated a font identifier for a given font, you can then set that current font to that font using this call. Create a font identifier with the <command>panda_createfont</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open ("output.pdf", "w");
 fonthandle = panda_createfont (output, "Helventica", 3, "MacRomanEncoding");
 panda_setfont (fonthandle);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Font attributes</title>
<para>
Panda also allows you to set a variety of font attributes...
</para>

<refentry id="panda_setcharacterspacing">
<refmeta>
<refentrytitle>panda_setcharacterspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setcharacterspacing</refname>
<refpurpose>set the space between characters</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setcharacterspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between characters in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setcharacterspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setwordspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>
<refentry id="panda_setfillcolor">
<refmeta>
<refentrytitle>panda_setfillcolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfillcolor</refname>
<refpurpose>set the color to fill a close shape with</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfillcolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the color to fill a close shape with when the shape is closed. It is expressed as a combinartion of red, green, and blue. The maximum number for each value is 255 (a number greater than 255 is reduced to 255).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setfillcolor (page, 100, 200, 300);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 300);
 panda_closeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setfontmode">
<refmeta>
<refentrytitle>panda_setfontmode</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontmode</refname>
<refpurpose>set the current font mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontmode (panda_page *target, int mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the drawing mode for the current font. Valid modes are: panda_textmode_normal, panda_textmode_outline, panda_textmode_filledoutline, panda_textmode_invisible, panda_textmode_filledclipped, panda_textmode_strokedclipped, panda_textmode_filledstrokedclipped and panda_textmode_clipped.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setfontmode(output, panda_textmode_outline);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontsize, panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_setfontsize">
<refmeta>
<refentrytitle>panda_setfontsize</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontsize</refname>
<refpurpose>set the current font size</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontsize (panda_page *target, int size);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the size of the font to be used next (in points).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 setfontsize(output, 42);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontmode, panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_sethorizontalscaling">
<refmeta>
<refentrytitle>panda_sethorizontalscaling</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_sethorizontalscaling</refname>
<refpurpose>set the horizontal scaling of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_sethorizontalscaling (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the horizontal scaling factor of the text in percent.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_sethorizontalscaling(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_setleading</para>
</refsect1>

</refentry>
<refentry id="panda_setleading">
<refmeta>
<refentrytitle>panda_setleading</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setleading</refname>
<refpurpose>set the amount of space between lines of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setleading (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of space between lines of text in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setleading(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling</para>
</refsect1>

</refentry>
<refentry id="panda_setwordspacing">
<refmeta>
<refentrytitle>panda_setwordspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setwordspacing</refname>
<refpurpose>set the space between words</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setwordspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between words in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setwordspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Inserting raster images</title>
<para>
Panda probably has the best raster image support of any of the PDF libraries available (not including Adobe's libraries). This is because this is my main area of expertise, and has been the main focus of the Panda development effort. For example ClibPDF only supports TIFF images in a limited set of formats, whereas I am not aware of any TIFF files which cannot be inserting into a PDF with Panda. Panda also never creates temporary files on disc when it needs to convert between TIFF formats, unlike PDFlib.
</para>

<sect3><title>TIFF support</title>
<para>
Panda support TIFF fully.
</para>
</sect3>

<sect3><title>JPEG support</title>
<para>
Panda supports JPEG fully.
</para>
</sect3>

<sect3><title>PNG support</title>
<para>
Panda supports PNG fully.
</para>
</sect3>

<sect3><title>Inserting images onto pages</title>
<para>
In Panda you use the <command>panda_imagebox</command>, and the <command>panda_imageboxrot</command> functions to insert images.
</para>

<refentry id="panda_imagebox">
<refmeta>
<refentrytitle>panda_imagebox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imagebox</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imagebox (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location using a reasonable default for rotation (none). This call is included for backward compatability withprevious releases of the API and it is recommened that new code call <command>panda_imageboxrot</command>(). It is unlikely that this call will be retired however. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imageboxrot</para>
</refsect1>

</refentry>
<refentry id="panda_imageboxrot">
<refmeta>
<refentrytitle>panda_imageboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imageboxrot</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imageboxrot (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, double angle, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location, including the ability to rotate the image on the page. It should be noted that xpdf will sometimes make the rotated image look quite sickly. This is in fact a bug in xpdf (which has beenr eported), and not a bug in <command>Panda</command>. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, 45.0, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imagebox</para>
</refsect1>

</refentry>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>
Panda, supports the full range of PDF vector graphics commands. See the sections below for a description of the functionality available.
</para>

<sect3><title>Lines</title>
<para>
With Panda, the way you draw a line is to first create a line with <command>panda_setlinestart</command>, you then draw line segments with <command>panda_addlinesegment</command>. When you're finished, you close the line with <command>panda_closeline</command>. <command>panda_strokeline</command> is used to force the line to be drawn. You can also add curved segments to a line using <command>panda_addcubiccurvesegment</command>, <command>panda_addquadraticcurvesegmentone</command>, and <command>panda_addquadraticcurvesegmenttwo</command>. Finally, if all you want is a rectangle, then use <command>panda_rectangle</command> to do it for you.
</para>

<refentry id="panda_setlinestart">
<refmeta>
<refentrytitle>panda_setlinestart</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinestart</refname>
<refpurpose>sets the starting point of a curve</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinestart (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the starting point for the sequence of curves and lines that it to be drawn on the current page. This call is compulsory for almost all of the line drawing functions. It is not required for the <command>panda_rectangle</command> call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addlinesegment">
<refmeta>
<refentrytitle>panda_addlinesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addlinesegment</refname>
<refpurpose>add a straight segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addlinesegment (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a straight line between the current cursor location and (x,y).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_closeline">
<refmeta>
<refentrytitle>panda_closeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_closeline</refname>
<refpurpose>close off the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_closeline(panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Close the line shape we are drawing by returning to the starting point as set by <command>panda_setlinestart</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 400, 300);
 panda_closeline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_endline">
<refmeta>
<refentrytitle>panda_endline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_endline</refname>
<refpurpose>finalise the current line shape</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_endline( panda_page *target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Finalise the line shape we are drawing. Only one line shape may be drawn at any one time. There is no need for this call with the <command>panda_rectangle</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_strokeline">
<refmeta>
<refentrytitle>panda_strokeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_strokeline</refname>
<refpurpose>stroke the line shape we have just drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_strokeline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function must be called for the line shape that we have drawn to actually display on the PDF page. This process is known as 'stroking', and hence the name of this function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_strokeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry id="panda_addcubiccurvesegment">
<refmeta>
<refentrytitle>panda_addcubiccurvesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addcubiccurvesegment</refname>
<refpurpose>add a curved segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addcubiccurvesegment (panda_page * target, int x, int y, int cx1, int cy1, int cx2, int cy2);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a cubic curve between the current cursor location and (x,y). There are two control points used to generate the cubic curve. They are (cx1, cy1) and (cx2, cy2).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (currPage, 210, 210);
 panda_addcubiccurvesegment (currPage, 310, 210, 225, 300, 275, 400);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addquadraticcurvesegmentone">
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmentone</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmentone</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmentone (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmenttwo</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmentone (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addquadraticcurvesegmenttwo">
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmenttwo</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmenttwo</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmenttwo (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmentone</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmenttwo (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry id="panda_rectangle">
<refmeta>
<refentrytitle>panda_rectangle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_rectangle</refname>
<refpurpose>draw a rectangle</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_rectangle (panda_page * target, int top, int left, int bottom, int right);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Draw a rectangle on the PDF page. There is no need for the <command>panda_setlinestart</command>() or <command>panda_closeline</command>() calls.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_rectangle( page, 10, 10, 150, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
</sect3>

<sect3><title>Fills and other line attributes</title>
<para>
Once you have drawn a line, then it can be filled. You can also configure the state of the pen <emphasis>before</emphasis> you draw the line to change the way it appears...
</para>

<refentry id="panda_fillline">
<refmeta>
<refentrytitle>panda_fillline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fillline</refname>
<refpurpose>fill the closed shape we just drew</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fillline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Fill the shape we have just drawn with the previously defined fill.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 250);
 panda_endline (page);
 panda_fillline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinecap">
<refmeta>
<refentrytitle>panda_setlinecap</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecap</refname>
<refpurpose>sets the line cap for the lines we are drawing now</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecap ( panda_page *target, int cap);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line cap is used at the ends of lines that do not meet other lines. The different cap styles are defined in panda/constants.h and are: panda_linecap_butt, panda_linecap_round and panda_linecap_projectedsquare.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecap (page, panda_linecap_round);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinecolor">
<refmeta>
<refentrytitle>panda_setlinecolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecolor</refname>
<refpurpose>change the color of the line drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the color of lines being drawn using a combination of red, green and blue.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecolor (page, 100, 200, 450);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinejoin">
<refmeta>
<refentrytitle>panda_setlinejoin</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinejoin</refname>
<refpurpose>is used to set the line join style</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinejoin (panda_page *target, int join);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line join is used where the ends of two lines meet. The valid line joins are defined in panda/constants.h and are: panda_linejoin_miter, panda_linejoin_round and panda_linejoin_bevel.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinejoin (page, panda_linejoin_bevel);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinewidth">
<refmeta>
<refentrytitle>panda_setlinewidth</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinewidth</refname>
<refpurpose>sets the width of the line that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinewidth (panda_page * target, int width);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the width of the line that is being drawn... You can use <command>panda_setlinecap</command>(), <command>panda_setlinejoin</command>() and <command>panda_setlinedash</command>() to change other characteristics of the line.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinewidth (page, 42);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinedashing">
<refmeta>
<refentrytitle>panda_setlinedashing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinedashing</refname>
<refpurpose>draw the subsequent lines with the defined dashing pattern</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinedashing (panda_page *target, int on, int off, int pahse);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function allows the user to define a line dashing style, which is then applied to subsequent lines drawn on that page. The dashing style is defined as a on and off number, as well as a phase. For example, on = 2, off = 4, phase = 0 should result in a line like:</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinedash (page, 2, 4, 0);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

</sect3>
</sect2>

<sect2><title>Document meta data</title>
<para>
PDF supports embedding meta data about a document into the PDF itself, and Panda supports this through the following calls:
</para>

<refentry id="panda_setauthor">
<refmeta>
<refentrytitle>panda_setauthor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setauthor</refname>
<refpurpose>set the author string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setauthor (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the author within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setauthor(document, "Mikal");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_settitle, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_setkeywords">
<refmeta>
<refentrytitle>panda_setkeywords</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setkeywords</refname>
<refpurpose>set the keywords string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setkeywords (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the keywords string within the PDF document. The string is merely a list of keywords in the form "cats dogs hamsters chickens"</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setkeywords(document, "panda documentation pdf api generate");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setsubject, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_setsubject">
<refmeta>
<refentrytitle>panda_setsubject</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setsubject</refname>
<refpurpose>set the subject string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setsubject (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the subject within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setsubject(document, "Mikal's homework");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_settitle">
<refmeta>
<refentrytitle>panda_settitle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_settitle</refname>
<refpurpose>set the title string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_settitle (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the title within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_settitle(document, "Mikal's excellent PDF document");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_setauthor, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Presentation support</title>
<para>
PDF can be used for presentations, and therefore allows you to specify a number of interesting things which are normally associated more with Microsoft Power Point presentations...
</para>

<refentry id="panda_centerwindow">
<refmeta>
<refentrytitle>panda_centerwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_centerwindow</refname>
<refpurpose>ask the viewer to center the document's window on the screen when the PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_centerwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application center the displayed PDF document on the screen when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not center the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_centerwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_fitwindow">
<refmeta>
<refentrytitle>panda_fitwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fitwindow</refname>
<refpurpose>ask the viewer to fit the viewer window to the first page of the PDF document when it is opened</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fitwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application fit the display window to the first page of the PDF document when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not fit the document to the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fitwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_fullscreen">
<refmeta>
<refentrytitle>panda_fullscreen</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fullscreen</refname>
<refpurpose>ask the viewer to display the PDF document in fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fullscreen (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application display the document in full screen mode. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not display the PDF in fullscreen mode.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fullscreen(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidemenubar">
<refmeta>
<refentrytitle>panda_hidemenubar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidemenubar</refname>
<refpurpose>ask the viewer to hide it's menu bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidemenubar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's menu bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the menu bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidemenubar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidetoolbar">
<refmeta>
<refentrytitle>panda_hidetoolbar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidetoolbar</refname>
<refpurpose>ask the viewer to hide it's tool bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidetoolbar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's tool bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the tool bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidetoolbar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidewindowui">
<refmeta>
<refentrytitle>panda_hidewindowui</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidewindowui</refname>
<refpurpose>ask the viewer to hide it's display window user interface when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidewindowui (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's window user interface not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to display the user interface.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidewindowui(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_nfspagemodde">
<refmeta>
<refentrytitle>panda_nfspagemodde</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_nfspagemodde</refname>
<refpurpose>defines display characteristics for the PDF document if it is using non fullscreen mode after defaulting to fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_nfspagemode (panda_pdf *document, int pagemode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>If the document in question is using fullscreen mode and then exits from fullscreen mode, then this function configures the behaviour of several of the 'eye candy' options available in some viewers. The possible values for pagemode are: <command>panda_window_usenone</command>, which displays neither the outline or thumbnails (if present); <command>panda_window_useoutlines</command>, which displays only the outline for the document; <command>panda_window_usethumbs</command>, which only displays thumbnails. <command>Please note that this function will only have an effect on the viewer if the page mode has been set to fullscreen with the panda_fullscreen() function call</command></para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_nfspagemode(document, panda_window_usenone);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_fullscreen</para>
</refsect1>

</refentry>
<refentry id="panda_pageduration">
<refmeta>
<refentrytitle>panda_pageduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_pageduration</refname>
<refpurpose>specify the maximum number of seconds that a page should be displayed by the viewer before moving on</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_pageduration (panda_page *target, int seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page should be displayed within the viewer. This is useful for presentations and the like where you might like to automatically move onto the next page in the document at some point. The default value for this is to never move onto the next page automatically. If this value is changed from the default, there is currently no way to revert back to the default later. The feature may not be implemented by all viewers.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_pageduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry id="panda_transduration">
<refmeta>
<refentrytitle>panda_transduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transduration</refname>
<refpurpose>specify the number of seconds that a page transition effect should take to occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transduration (panda_page *target, double seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page transition effect should be displayed within the viewer. This is useful for presentations and the like when you realise that you are addicted to Microsoft Powerpoint...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry id="panda_transstyle">
<refmeta>
<refentrytitle>panda_transstyle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transstyle</refname>
<refpurpose>specify the type of page change transition that should occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transstyle (panda_page *target, int style);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para> his function records information within the PDF indicating the preferred page transition style to use. The following are valid styles to use:
 <orderedlist>
 <listitem><para>panda_pagetrans_split_yi -- vertical split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_yo -- vertical split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xi -- horizontal split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xo -- horizontal split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_blinds_y -- vertical blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_blinds_x -- horizontal blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_box_i -- box expanding from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_box_o -- box contracting from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_wipe_0 -- a single line wipes the page away from the left to the right</para></listitem>
 <listitem><para>panda_pagetrans_wipe_90 -- a single line wipes the page away from the bottom to the top</para></listitem>
 <listitem><para>panda_pagetrans_wipe_180 -- a single line wipes the page away from the right to the left</para></listitem>
 <listitem><para>panda_pagetrans_wipe_270 -- a single line wipes the page away from the top to the bottom</para></listitem>
 <listitem><para>panda_pagetrans_dissolve -- the old page dissolves slowly into the new page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_0 -- a glitter effect that moves from the left to the right of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_270 -- a glitter effect that moves from the top to the bottom of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_315 -- a glitter effect that moves from the top left to the bottom right of the page</para></listitem>
 <listitem><para>panda_pagetrans_none -- no transition effect</para></listitem>
 </orderedlist>
 
 </para>
 <para>
 he default transition is to have no transition at all. It should be noted that not all viewers support these transition effects.
</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Page templates</title>
<para>
A page template is created using <command>panda_newtemplate</command>. A template is just like any other page, and uses all the normal drawing functions. The cool bit is that you can then apply a template to another page using <command>panda_applytemplate</command>. This allows for the standard parts of the page to only be defined once -- which is very useful for things like letterhead.
</para>

<refentry id="panda_newtemplate">
<refmeta>
<refentrytitle>panda_newtemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newtemplate</refname>
<refpurpose>create a template page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_newtemplate(panda_pdf *document, char *pageSize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to create 'template' pages which can then be refered to on other pages. For instance, if you were creating a document that used a standard letter head, then it would make sense to construct the letterhead as a template, and then use this on all the pages. The created template looks and feels just like any other page in the document for the purposes of creating content. Refer to the <command>panda_newpage</command> man page for details on how to use pages.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to the template page</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_applytemplate</para>
</refsect1>

</refentry>
<refentry id="panda_applytemplate">
<refmeta>
<refentrytitle>panda_applytemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_applytemplate</refname>
<refpurpose>use a template page previously created</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_applytemplate (panda_pdf * output, panda_page * target,
 panda_page * template)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to use a template created with the <command>panda_newtemplate</command> function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage, *realpage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
 realpage = panda_newpage (document, panda_pagesize_a4);
 
 ... the order of the drawing commands to the two pages doesn't matter ...
 
 panda_applytemplate(document, realpage, templatepage);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_newtemplate</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>A full Panda example</title>
<para>
This section presents a full Panda example showing what the library is capable of. This code comes from the Panda distribution:
</para>

<programlisting>

#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage, *templatePage;
  int lineDepth, trans;
  char tempString[1024], *tempPtr;

  printf ("Welcome to the Panda 0.4 sample application...\n");

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("output.pdf", "w")) == NULL)
    panda_error (panda_true, "demo: could not open output.pdf to write to.");

  // These are normally commented out because they are annoying
  //panda_hidetoolbar (demo, panda_true);
  //panda_hidemenubar (demo, panda_true);
  //panda_hidewindowui (demo, panda_true);

  if ((argc &gt; 1) &amp;&amp; (strcmp (argv[1], "compressed") == 0))
    {
      printf ("Turn on compression\n");

      panda_setproperty (demo-&gt;pages, panda_scope_cascade,
			 panda_object_property_compress, panda_true);

      printf ("Just before compression level set\n");

      panda_setproperty (demo-&gt;pages, panda_scope_cascade,
			 panda_object_property_compress_level, 9);
    }
  else
    printf ("For compressed sample, use %s compressed\n", argv[0]);

  // Image functionality
  ///////////////////////////////////////////////////////////////////////////

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Put in the background images
  panda_imagebox (demo, currPage, 0, 0, currPage-&gt;height / 2,
		  currPage-&gt;width, "images/input.tif", panda_image_tiff);
  panda_imagebox (demo, currPage, currPage-&gt;height / 2, 0,
		  currPage-&gt;height, currPage-&gt;width, "images/input2.tif",
		  panda_image_tiff);

  panda_imagebox (demo, currPage, 317, 317, 434, 434, "images/gnu_box.jpg",
		  panda_image_jpeg);
  panda_imagebox (demo, currPage, 434, 434, 551, 551, "images/gnu_box.jpg",
		  panda_image_jpeg);

  // Do an panda_imageboxrot or two to test the code included by Ceasar Miquel
  panda_imageboxrot (demo, currPage, 600, 0, 717, 117, 15.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 600, 200, 717, 317, 30.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 600, 400, 717, 517, 42.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 700, 0, 817, 117, 90.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 700, 200, 817, 317, 132.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  // Insert a PNG to show that I can
  panda_imageboxrot (demo, currPage, 100, 200, 200, 300, 0.0,
		     "images/libpng.png", panda_image_png);

  panda_imageboxrot (demo, currPage, 300, 200, 400, 300, 0.0,
		     "images/gnu.png", panda_image_png);

  panda_imageboxrot (demo, currPage, 100, 420, 310, 620, 36.0,
		     "images/RedbrushAlpha.png", panda_image_png);

  // (c) statement
  panda_setfont (demo, tempPtr = panda_createfont (demo, "Times-Roman", 1,
						   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300,
		 "The background image on this page is Copyright 2000 Andrew Cagney");
  panda_textbox (demo, currPage, 620, 10, 720, 300,
		 "and is distributed under the terms of the GPL...");
  panda_textbox (demo, currPage, 310, 320, 330, 800,
		 "Flower (c) 1999 Pieter S. van der Meulen");
  free (tempPtr);

  panda_setfont (demo, tempPtr =
		 panda_createfont (demo, "Helvetica-Bold", 1,
				   "MacRomanEncoding"));
  panda_textboxrot (demo, currPage, 200, 30, 230,
		 30, 45.0, "With new improved angled text!");
  free (tempPtr);

  ///////////////////////////////////////////////////////////////////////////
  // Text functionality (with a few images thrown in as well)
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);

  // I am not drawing a multiline string here because I am not sure how to 
  // represent this in the PDF at the moment
  sprintf (tempString,
	   "Hello %c5World! %cMy name %c5is Panda!\nAnd I am a PDF generator\nI handle multiple line text ok .once you have set a leading.",
	   4, 6, 5);
  panda_textbox (demo, currPage, 10, 10, 100, 30, tempString);

  panda_setfont (demo, tempPtr = panda_createfont (demo, "Symbol", 1,
						   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 50, 10, 100, 30, "Symbol");
  free (tempPtr);

  panda_setfont (demo, tempPtr =
		 panda_createfont (demo, "Helvetica-Bold", 1,
				   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 70, 30, 100, 30, "A line in Helvetica-Bold");
  free (tempPtr);

  panda_imagebox (demo, currPage, 100, 100, 150, 150, "images/gnu-head.jpg",
		  panda_image_jpeg);
  panda_textbox (demo, currPage, 90, 110, 200, 200, "INFRONTINFRONTINFRONT");

  panda_textbox (demo, currPage, 190, 210, 300, 300, "BEHINDBEHINDBEHIND");
  panda_imagebox (demo, currPage, 200, 200, 317, 317, "images/gnu_box.jpg",
		  panda_image_jpeg);

  panda_textbox (demo, currPage, 300, 10, 400, 50,
		 "A second textbox on the page");

  ///////////////////////////////////////////////////////////////////////////
  // Demonstrate the supported text modes
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);
  panda_setleading (demo, 16.0);

  for (lineDepth = 0; lineDepth &lt; 8; lineDepth++)
    {
      panda_setfontmode (demo, panda_textmode_normal);

      switch (lineDepth)
	{
	case panda_textmode_normal:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Normal");
	  break;

	case panda_textmode_outline:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Outline");
	  break;

	case panda_textmode_filledoutline:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "FilledOutline");
	  break;

	case panda_textmode_invisible:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Invisible");
	  break;

	case panda_textmode_filledclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "FilledClipped");
	  break;

	case panda_textmode_strokedclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Stroked Clipped");
	  break;

	case panda_textmode_filledstrokedclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400,
			 "Filled Stroked Clipped");
	  break;

	case panda_textmode_clipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Clipped");
	  break;
	}

      panda_setcharacterspacing (demo, (double) lineDepth);
      panda_setwordspacing (demo, (double) lineDepth * 10);
      panda_sethorizontalscaling (demo, (double) 1 - (lineDepth * 0.1));

      panda_setfontmode (demo, lineDepth);
      panda_textbox (demo, currPage, 20 + (lineDepth * 20), 200,
		     40 + (lineDepth * 20), 400,
		     "Demonstration of a text mode");
    }

  ///////////////////////////////////////////////////////////////////////////
  // Demonstrate the supported lines and curve thingies -- note that no
  // graphics state is held from the previous set of lines, so you'll need
  // to rebuild it each time.
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);

  panda_setfontmode (demo, panda_textmode_normal);
  panda_textbox (demo, currPage, 40, 10, 55, 200,
		 "Please note that these shapes are lines, and there is no");
  panda_textbox (demo, currPage, 60, 10, 75, 200,
		 "requirement to have the shapes closed...");

  // Straight lines of all types -- stroked
  panda_setlinestart (currPage, 110, 110);
  panda_addlinesegment (currPage, 160, 130);
  panda_addlinesegment (currPage, 210, 186);
  panda_addlinesegment (currPage, 96, 22);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Now some curves -- stroked
  panda_setlinestart (currPage, 210, 210);
  panda_addcubiccurvesegment (currPage, 310, 210, 225, 300, 275, 400);
  panda_addquadraticcurvesegmentone (currPage, 160, 160, 200, 225);
  panda_addquadraticcurvesegmenttwo (currPage, 210, 210, 250, 375);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Rectangles -- stroked
  panda_rectangle (currPage, 210, 210, 310, 310);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Straight lines of all types -- stroked and filled
  panda_setlinecolor (currPage, 99, 33, 255);
  panda_setfillcolor (currPage, 112, 38, 300);
  panda_setlinestart (currPage, 110, 310);
  panda_setlinewidth (currPage, 5);
  panda_addlinesegment (currPage, 160, 330);
  panda_addlinesegment (currPage, 210, 386);
  panda_addlinesegment (currPage, 96, 222);
  panda_closeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Now some curves -- stroked and filled
  panda_setfillcolor (currPage, 112, 138, 37);
  panda_setlinestart (currPage, 210, 410);
  panda_setlinewidth (currPage, 5);
  panda_addcubiccurvesegment (currPage, 310, 410, 225, 500, 275, 600);
  panda_addquadraticcurvesegmentone (currPage, 160, 360, 200, 425);
  panda_addquadraticcurvesegmenttwo (currPage, 210, 410, 250, 575);
  panda_closeline (currPage);
  //panda_strokeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Rectangles -- stroked filled
  panda_setfillcolor (currPage, 38, 38, 38);
  panda_setlinewidth (currPage, 5);
  panda_rectangle (currPage, 410, 210, 510, 310);
  //panda_strokeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Straight lines of all types -- stroked and capped
  panda_setlinewidth (currPage, 10);
  panda_setlinestart (currPage, 100, 600);
  panda_addlinesegment (currPage, 200, 600);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_butt);
  panda_setlinestart (currPage, 100, 625);
  panda_addlinesegment (currPage, 200, 625);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_round);
  panda_setlinestart (currPage, 100, 650);
  panda_addlinesegment (currPage, 200, 650);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_projectedsquare);
  panda_setlinestart (currPage, 100, 675);
  panda_addlinesegment (currPage, 200, 675);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Mitre joints
  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_butt);
  panda_setlinestart (currPage, 300, 600);
  panda_addlinesegment (currPage, 350, 650);
  panda_addlinesegment (currPage, 400, 600);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_miter);
  panda_setlinestart (currPage, 300, 625);
  panda_addlinesegment (currPage, 350, 675);
  panda_addlinesegment (currPage, 400, 625);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_round);
  panda_setlinestart (currPage, 300, 650);
  panda_addlinesegment (currPage, 350, 700);
  panda_addlinesegment (currPage, 400, 650);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_bevel);
  panda_setlinestart (currPage, 300, 675);
  panda_addlinesegment (currPage, 350, 725);
  panda_addlinesegment (currPage, 400, 675);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Do some work with line dashing
  panda_setlinedash (currPage, 1, 0, 0);
  panda_setlinejoin (currPage, panda_linejoin_round);

  panda_setlinestart (currPage, 100, 800);
  panda_addlinesegment (currPage, 100, 750);
  panda_addlinesegment (currPage, 140, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinedash (currPage, 3, 3, 0);
  panda_setlinestart (currPage, 150, 800);
  panda_addlinesegment (currPage, 150, 750);
  panda_addlinesegment (currPage, 190, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinedash (currPage, 2, 1, 1);
  panda_setlinestart (currPage, 200, 800);
  panda_addlinesegment (currPage, 200, 750);
  panda_addlinesegment (currPage, 240, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  ///////////////////////////////////////////////////////////////////////////
  // Why not have some annotations as well?
  ///////////////////////////////////////////////////////////////////////////

  panda_textannotation(demo, currPage, panda_true, "Hello", "Text annotation",
		       10, 10, 50, 50, 1.0, 0.0, 0.0,
		       panda_icon_comment, 0);
  panda_lineannotation(demo, currPage, "Line annotation", "Line annotation",
		       50, 50, 150, 150, 
		       150, 150, 200, 200, 
		       0.0, 1.0, 0.0, 0);

  ///////////////////////////////////////////////////////////////////////////
  // We can also setup template pages to make life a little easier (and the
  // document a little smaller)
  ///////////////////////////////////////////////////////////////////////////

  templatePage = panda_newtemplate(demo, panda_pagesize_a4);
  panda_setlinestart (templatePage, 100, 800);
  panda_addlinesegment (templatePage, 100, 750);
  panda_addlinesegment (templatePage, 140, 800);
  panda_closeline (templatePage);
  panda_strokeline (templatePage);
  panda_endline (templatePage);

  panda_setlinedash (templatePage, 3, 3, 0);
  panda_setlinestart (templatePage, 150, 800);
  panda_addlinesegment (templatePage, 150, 750);
  panda_addlinesegment (templatePage, 190, 800);
  panda_closeline (templatePage);
  panda_strokeline (templatePage);
  panda_endline (templatePage);

  currPage = panda_newpage(demo, panda_pagesize_a4);
  panda_applytemplate(demo, currPage, templatePage);

  ///////////////////////////////////////////////////////////////////////////
  // Let's try some transitions
  ///////////////////////////////////////////////////////////////////////////
  
  for(trans = 0; trans &lt; panda_pagetrans_none; trans++)
    {
      currPage = panda_newpage(demo, panda_pagesize_a4);
      panda_pageduration(demo, currPage, 5);
      panda_transduration(demo, currPage, 5.0);
      panda_transstyle(demo, currPage, trans);
      
      panda_setlinecolor (currPage, trans * 20, 0, trans * 10);
      panda_setfillcolor (currPage, trans * 20, 0, trans * 10);
      panda_setlinestart (currPage, 0, 0);
      panda_setlinewidth (currPage, 5);
      panda_addlinesegment (currPage, 1000, 0);
      panda_addlinesegment (currPage, 1000, 1000);
      panda_addlinesegment (currPage, 0, 1000);
      panda_closeline (currPage);
      panda_fillline (currPage);
      panda_endline (currPage);
    }

  currPage = panda_newpage(demo, panda_pagesize_a4);

  // Finished all the demoing, close the PDF document
  panda_close (demo);

  // We should return a value here
  return 0;
}

// Allow a callback to be setup to display a dialog box for an error or
// whatever before we terminate the application
void
panda_errorCallback (char *description)
{
  fprintf (stderr, "Callback: %s\n", description);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/panda/examples/main.c</emphasis></para>

<para>
It produces output like:
</para>

</sect2>

</sect1>




























<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
<programlisting>
%{
#include "parser.h"
#include "lexinterface.h"
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

void debuglex(char *, int, char *);
char *returnStr(char *, int);
void *pandalex_xmalloc(size_t);
void *pandalex_xrealloc(void *, size_t);
char *pandalex_xsnprintf(char *, ...);
void pandalex_error(char *);

void *
pandalex_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pandalex_error ("pandalex_xmalloc failed to allocate memory");
    }

  return buffer;
}
void *
pandalex_xrealloc (void *memory, size_t size)
{
  void *buffer;

  if ((buffer = realloc (memory, size)) == NULL)
    {
      pandalex_error ("pandalex_xrealloc failed to allocate memory");
    }

  return buffer;
}

char *
pandalex_xsnprintf (char *format, ...)
{
  char *output = NULL;
  int size, result;
  va_list ap;

  /* We start with the size of the format string as a guess */
  size = strlen (format);
  va_start (ap, format);

  while (1)
    {
      output = pandalex_xrealloc (output, size);
      result = vsnprintf (output, size, format, ap);

      if (result == -1)
        {
          /* Up to glibc 2.0.6 and Microsoft's implementation*/
          size += 100;
        }
      else
        {
          /* Check if we are done */
      if (result &lt; size)
            break;

          /* Glibc from now on */
          size = result + 1;
        }
  }

  va_end (ap);
  return output;
}

void
pandalex_error(char *msg){
fprintf(stderr, "%s\n", msg);
exit(42);
}
%}

%x BINARY
%%

&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { debuglex(yytext, -1, "version");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return VERSION;
                                                                             }

&lt;INITIAL&gt;[ \t\r\n]+              { debuglex(yytext, -1, "whitespace");
                                                                          }

&lt;INITIAL&gt;xref                    { debuglex(yytext, -1, "xref");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return XREF;
                                                                             }

&lt;INITIAL&gt;trailer                 { debuglex(yytext, -1, "trailer");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return TRAILER;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+,]+ { debuglex(yytext, -1, "name");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;\/[#a-zA-Z\-_0-9\.\+]+ { debuglex(yytext, -1, "dbllt-name");
                            yyless(2);
                            return DBLLT;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+]+\&gt;\&gt;     { debuglex(yytext, -1, "name-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
}

                        /* --- stuff required for objects ---               */
&lt;INITIAL&gt;R                       { debuglex(yytext, -1, "object reference");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\&gt;\&gt;                       { debuglex(yytext, -1, "object-reference-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\/                       { debuglex(yytext, -1, "object-reference-namestart");
                            yyless(yyleng - 1);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;obj                     { debuglex(yytext, -1, "obj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJ; 
                                                                             }

&lt;INITIAL&gt;endobj                  { debuglex(yytext, -1, "endobj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return ENDOBJ; 
                                                                             }

&lt;INITIAL&gt;stream                  { debuglex(yytext, -1, "stream");
                          BEGIN(BINARY);
                          return STREAM;                                     }

&lt;INITIAL&gt;[+-]?[0-9]+             { debuglex(yytext, -1, "integer");
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\&gt;\&gt;             { debuglex(yytext, -1, "integer-dblgt");
                            yyless(yyleng - 2);
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }


&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { debuglex(yytext, -1, "floating point");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return FP; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt;     { debuglex(yytext, -1, "floating point");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return FP; 
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;                    { debuglex(yytext, -1, "&lt;&lt;");
                            return DBLLT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;");
                            return DBLGT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;&gt;&gt;");
                            yyless(yyleng - 2);
                            return DBLGT; 
                                                                             }


&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\]*)+ { 
                          debuglex(yytext, -1, "string");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;

                            if(strcmp(yytext, "endstream") == 0){
                              BEGIN(INITIAL);
                              return ENDSTREAM;
                              }

                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\[(([^\[\]])|(\\\[)|(\\\]))*\] {
                          debuglex(yytext, -1, "bracketted string v1");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng); 
                            yylval.sval.len = yyleng;
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\((([^\(\)])|(\\\()|(\\\)))*\) {
                          debuglex(yytext, -1, "bracketted string v2");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\&lt;(([^\&lt;\&gt;])|(\\\&lt;)|(\\\&gt;))*\&gt; {
                          debuglex(yytext, -1, "bracketted string v3");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\\/]*)+\&gt;\&gt; { 
                          debuglex(yytext, -1, "string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;[\[\(][#&lt;&gt;a-zA-Z0-9\.\ :'+\-_\\\(\)]+[\)\]]\&gt;\&gt; {
                          debuglex(yytext, -1, "bracketted-string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

                        /* --- Array handling ---                           */

&lt;INITIAL&gt;\[                      { debuglex(yytext, -1, "[");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ARRAY; 
                                                                             }

&lt;INITIAL&gt;\]                      { debuglex(yytext, -1, "]");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

&lt;INITIAL&gt;\]\&gt;\&gt;                      { debuglex(yytext, -1, "]");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

                        /* --- Stuff needed for the xref and trailer ---    */

&lt;INITIAL&gt;\%\%EOF                 { debuglex(yytext, -1, "end of file");
                            return PDFEOF; 
                                                                             }

                        /* --- Stuff used to match binary streams --- 

                               The following amazing production is
                               used to deal with the massive
                               streams that images can create              */

&lt;BINARY&gt;[^end]+           { debuglex(yytext, yyleng, "binary mode");
                          yylval.sval.data = (char *) returnStr(yytext, yyleng);
                          yylval.sval.len = yyleng;
                          return ANYTHING;
                                                                             }

.                       { debuglex("!", -1, "the catch all");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return ANYTHING; 
                                                                             }

%%

void debuglex(char *text, int len, char *desc){
#if defined DEBUG
  int i;

  printf("Lexer rule is \"%s\", match is \"", desc);  

  for(i = 0; i &lt; ((len == -1) ? strlen(text) : len); i++){
    if(text[i] == '\n') printf(" \\n " );
    else if(text[i] == '\t') printf(" \\t ");
    else if(text[i] == '\r') printf(" \\r ");
    else if(text[i] == ' ') printf(" sp ");
    else if(isprint(text[i])) printf("%c", text[i]);
    else printf(" \\%d ", (unsigned char) text[i]);
    }

  printf("\"\n");
#endif
}

char *returnStr(char *yytext, int len){
  char *lval;

  if((lval = malloc(sizeof(char) * 
    ((len == -1) ? strlen(yytext) : len) + 1)) == NULL)
    error("Could not make space for lexer return.");
  memcpy(lval, yytext, ((len == -1) ? strlen(yytext) : len) + 1);

  return lval;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexer.l</emphasis></para>
</sect2>

<sect2><title>lexinterface.h</title>
<programlisting>
// This file defines the callbacks that users can setup to use PandaLex

#include &lt;stdarg.h&gt;

enum{
  pandalex_event_begindocument = 0,
    pandalex_event_specver,
    pandalex_event_entireheader,
    pandalex_event_objstart,
    pandalex_event_objend,
    pandalex_event_dictitem_string,
    pandalex_event_dictitem_name,
    pandalex_event_dictitem_arraystart,
    pandalex_event_dictitem_arrayitem,
    pandalex_event_dictitem_arrayend,
    pandalex_event_dictitem_object,
    pandalex_event_dictitem_dict,
    pandalex_event_dictitem_dictend,
    pandalex_event_dictitem_int,
    pandalex_event_stream,
    pandalex_event_dictint,
    pandalex_event_xrefstart,
    pandalex_event_xrefitem,
    pandalex_event_xrefend,
    pandalex_event_trailerstart,
    pandalex_event_trailerend,
    pandalex_event_enddocument,
    pandalex_event_max
    };

// Callbacks are defined so that they have a type for the arguments they
// possess associated with them. Where possible the arguments created by the
// lexer will be converted into the types needed by the callback. If not,
// an error is returned
typedef void (*pandalex_callback_type)(int, va_list);


void pandalex_setupcallback(int, pandalex_callback_type);
void pandalex_callback(int, ...);

</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexinterface.h</emphasis></para>
</sect2>

<sect2><title>pandalex.h</title>
<programlisting>
char *pandalex_strmcat(char *, int, char *, int);
char *pandalex_strmcpy(char *, int);
int pandalex_intlen(int);
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/pandalex.h</emphasis></para>
</sect2>

<sect2><title>parser.y</title>
<programlisting>
%{
  #include "lexinterface.h"
  #include "samples.h"
  #include "pandalex.h"

  #include &lt;stdarg.h&gt;

  #define YYMAXDEPTH 50000
  #define YYERROR_VERBOSE 1

  // The callbacks
  pandalex_callback_type pandalex_callbacks[pandalex_event_max];
%}

          /* Define the possible yylval values */
%union {
  int        intVal;

  struct streamVal{
    char *data;
    int len;
  } sval;
}

%token &lt;sval&gt; VERSION
%token &lt;sval&gt; NAME
%token &lt;sval&gt; STRING
%token &lt;sval&gt; OBJREF &lt;sval&gt; OBJ &lt;sval&gt; ENDOBJ 
%token &lt;intVal&gt; INT
%token &lt;sval&gt; FP
%token &lt;sval&gt; DBLLT &lt;sval&gt; DBLGT
%token &lt;sval&gt; STREAM &lt;sval&gt; ENDSTREAM
%token &lt;sval&gt; ARRAY &lt;sval&gt; ENDARRAY &lt;sval&gt; ENDARRAYDBLGT
%token &lt;sval&gt; PDFEOF XREF TRAILER
%token &lt;sval&gt; ANYTHING

%type &lt;sval&gt; binary
%type &lt;sval&gt; header
%type &lt;sval&gt; objref
%type &lt;sval&gt; arrayvals

%type &lt;intVal&gt; dictionary
%type &lt;intVal&gt; subdictionary

%%

// completely implemented
pdf       : { pandalex_callback(pandalex_event_begindocument, ""); } 
            header { pandalex_callback(pandalex_event_entireheader, $2.data); } 
            object linear objects xref trailer endcrap
          ;

// completely implemented
header    : VERSION { pandalex_callback(pandalex_event_specver, $1.data); }
            binary { $$.data = pandalex_strmcat($1.data, $1.len, $3.data, $3.len); $$.len = $1.len + $3.len + 1; }
          ;

linear    : xref trailer { }
          |
          ;

// Clibpdf sometimes puts some binary crap at the end of the file (pointer
// problems?)
// completely implemented
endcrap   : binary { }
          |
          ;

// completely implemented
objects   : object objects
          | 
          ;

// todo_mikal: might need a .data here
object    : INT INT OBJ { pandalex_callback(pandalex_event_objstart, $1, $2); } 
            dictionary { if($5 != -1) pandalex_callback(pandalex_event_dictint, $1, $2, $5); } 
            stream ENDOBJ { pandalex_callback(pandalex_event_objend, $1, $2); }
          ;

dictionary: DBLLT dict DBLGT { $$ = -1; }
          | INT { $$ = $1; }
          | ARRAY arrayvals ENDARRAY { $$ = -1; }
          | objref { $$ = -1; }
          | NAME { $$ = -1; }
          | STRING { $$ = -1 };
          | { $$ = -1; }
          ;

subdictionary: DBLLT dict DBLGT { $$ = -1 };

dict      : NAME STRING { pandalex_callback(pandalex_event_dictitem_string, $1.data, $2.data); } dict
          | NAME NAME { pandalex_callback(pandalex_event_dictitem_name, $1.data, $2.data); } dict
          | NAME ARRAY { pandalex_callback(pandalex_event_dictitem_arraystart, $1.data); } 
              arrayvals ENDARRAY { pandalex_callback(pandalex_event_dictitem_arrayend, $1.data); } dict
          | NAME objref { pandalex_callback(pandalex_event_dictitem_object, $1.data, $2.data); } dict
          | NAME { pandalex_callback(pandalex_event_dictitem_dict, $1.data); } 
              subdictionary { pandalex_callback(pandalex_event_dictitem_dictend, $1.data); } dict
          | NAME INT { pandalex_callback(pandalex_event_dictitem_int, $1.data, $2); } dict
          | NAME FP {} dict
          | 
          ;

arrayvals : objref { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals 
          | INT { /*todo*/ } arrayvals
          | NAME { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | STRING { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | ARRAY { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | DBLLT { pandalex_callback(pandalex_event_dictitem_dict, "array-dictitem"); } 
              dict DBLGT { pandalex_callback(pandalex_event_dictitem_dictend, "array-dictitem"); } arrayvals
          | {}
          ;

// completely implemented
objref    : INT INT OBJREF { if(($$.data = (char *) malloc((pandalex_intlen($1) + pandalex_intlen($2) + 5) * sizeof(char))) == NULL){
			       fprintf(stderr, "Could not allocate enough space for objref\n");
			       exit(42);
                               }
			     
			     sprintf($$.data, "%d %d R", $1, $2);
			     $$.len = strlen($$.data) + 1;
			                       }
          ;

// completely implemented
stream    : STREAM binary ENDSTREAM { pandalex_callback(pandalex_event_stream, $2.data, $2.len); free($2); }
          |
          ;

// completely implemented: callbacks are handled in the callers to this
binary    : ANYTHING binary { $$.data = pandalex_strmcat($1.data, $1.len, $2.data, $2.len); $$.len = $1.len + $2.len; free($2); }
          | STRING binary { $$.data = pandalex_strmcpy($1.data, -1); $$.len = strlen($1.data); }
          | { $$.data = pandalex_strmcpy("", -1); $$.len = 0; }
          ;

// completely implemented
xref      : XREF INT INT { pandalex_callback(pandalex_event_xrefstart); }
              xrefitems {}
          ;

// completely implemented
xrefitems : INT INT STRING { pandalex_callback(pandalex_event_xrefitem, $1, $2, $3); }
              xrefitems
          | { pandalex_callback(pandalex_event_xrefend); }
          ;

// completely implemented
trailer   : TRAILER { pandalex_callback(pandalex_event_trailerstart); } 
              DBLLT dict DBLGT STRING INT { pandalex_callback(pandalex_event_trailerend, $6, $7); } 
              PDFEOF { pandalex_callback(pandalex_event_enddocument); }
          ;

%%

void pandalex_init(){
  int i;

  // Make sure that the callbacks default to nothing
  for(i = 0; i &lt; pandalex_event_max; ++i){
    pandalex_callbacks[i] = NULL;
  }
}

void pandalex_setupcallback(int callback, pandalex_callback_type functoid){
  pandalex_callbacks[callback] = functoid;
}

// Here we call the callbacks. This includes converting to the types that the
// callback function expects.
void pandalex_callback(int event, ...){
  va_list argptr;

  // Start accessing the arguements from the end
  va_start(argptr, event);
  
  // If no event handler is setup, then we ignore the event
  if(pandalex_callbacks[event] != NULL){
    pandalex_callbacks[event] (event, argptr);
  }
  
  // Stop with the arguements
  va_end(argptr);
}

int pandalex_parse(){
  // We are not looking into a stream at the moment
  yyparse();
}

int yyerror(char *s){
  fprintf(stderr, "\n---------------------------------------------------------------\n");
  fprintf(stderr, "PandaLex parser error (%s):\n", s);
  fprintf(stderr, "  Please send this error text, along with a copy of your PDF\n");
  fprintf(stderr, "  document (if possible) to mikal@stillhq.com, so that this can\n");
  fprintf(stderr, "  be fixed for the next release...\n\n");
  fprintf(stderr, "version = 0.4\n");
  fprintf(stderr, "last token = \"%s\" (%d) or %d\n", yylval.sval.data, yylval.sval.len, yylval.intVal);
  fprintf(stderr, "\n---------------------------------------------------------------\n");

  exit(42);
}

// Buffer overrun safe strcat
char *pandalex_strmcat(char *dest, int destLen, char *append, int appendLen){
  char *new;
  int count, len;

  // What length do we need?
  if((new = (char *) malloc(sizeof(char) * 
			    (((destLen == -1) ? strlen(dest) : destLen) + 
			    ((appendLen == -1) ? strlen(append) : appendLen) + 
			    2))) == NULL){
    fprintf(stderr, "Could not malloc enough space\n");
    exit(42);
  }
  
  if((destLen == -1) &amp;&amp; (appendLen == -1))
    sprintf(new, "%s%s", dest, append);
  else{
    // We need to copy characters the hard way -- change this to a memcpy
    count = 0;

    for(len = 0; len &lt; ((destLen == -1) ? strlen(dest) : destLen); len++){
      new[count] = dest[len];
      count++;
    }

    for(len = 0; len &lt; ((appendLen == -1) ? strlen(append) : appendLen); len++){
      new[count] = append[len];
      count++;
    }

    new[count] = '\0';
  }
  return new;
}

// Buffer overrun safe strcpy
char *pandalex_strmcpy(char *data, int len){
  return pandalex_strmcat(data, len, "", 0);
}

int pandalex_intlen(int number){
  int length = 0;

  while(number &gt; 0){
    length ++;
    number /= 10;
  }

  return number;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/parser.y</emphasis></para>
</sect2>

<sect2><title>samples.c</title>
<programlisting>
/* A sample application using pandalex -- this is pdfdump */

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;zlib.h&gt;
#include "samples.h"
#include "lexinterface.h"

enum{
  pdfdump_dump = 0,
    pdfdump_meta
    };
int pdfdump_application;

pdfdump_dictint_list *dictint_list;

// Some demo code for how to use PandaLex
int main(int argc, char *argv[]){
  pandalex_init();

  // Parse the command line to find out what we are doing today -- this needs more thought
  if(strcmp(argv[0], "pdfmeta") == 0){
    pdfdump_application = pdfdump_meta;
  }
  else
    pdfdump_application = pdfdump_dump;

  // Setup the callbacks
  pandalex_setupcallback(pandalex_event_begindocument, pdfdump_begindocument);

  pandalex_setupcallback(pandalex_event_specver, pdfdump_specversion);
  pandalex_setupcallback(pandalex_event_entireheader, pdfdump_entireheader);
  pandalex_setupcallback(pandalex_event_objstart, pdfdump_objstart);
  pandalex_setupcallback(pandalex_event_objend, pdfdump_objend);

  pandalex_setupcallback(pandalex_event_dictitem_string, pdfdump_dictitem_string);
  pandalex_setupcallback(pandalex_event_dictitem_name, pdfdump_dictitem_name);
  pandalex_setupcallback(pandalex_event_dictitem_arraystart, pdfdump_dictitem_arraystart);
  pandalex_setupcallback(pandalex_event_dictitem_arrayitem, pdfdump_dictitem_arrayitem);
  pandalex_setupcallback(pandalex_event_dictitem_arrayend, pdfdump_dictitem_arrayend);
  pandalex_setupcallback(pandalex_event_dictitem_object, pdfdump_dictitem_object);
  pandalex_setupcallback(pandalex_event_dictitem_dict, pdfdump_dictitem_dict);
  pandalex_setupcallback(pandalex_event_dictitem_dictend, pdfdump_dictitem_dictend);
  pandalex_setupcallback(pandalex_event_dictitem_int, pdfdump_dictitem_int);

  pandalex_setupcallback(pandalex_event_stream, pdfdump_stream);
  pandalex_setupcallback(pandalex_event_dictint, pdfdump_dictint);
  
  // Initialise the dictint_list structure;
  if((dictint_list = (pdfdump_dictint_list *)
      malloc(sizeof(pdfdump_dictint_list))) == NULL){
    fprintf(stderr, "Could not initialise the dictint list\n");
    exit(42);
  }

  dictint_list-&gt;next = NULL;

  // Start parsing
  pandalex_parse();

  return 0;
}

char *pandalex_xsnprintf(char *, ...);

// Arguement is the name of the file as a char *
void pdfdump_begindocument(int event, va_list argptr){
  char *filename;

  filename = va_arg(argptr, char *);
  printf("Information for document: \"%s\"\n\n", filename);
}

void pdfdump_specversion(int event, va_list argptr){
  printf("Specification version is: %s\n", (char *) va_arg(argptr, char *));
}

void pdfdump_entireheader(int event, va_list argptr){
  int    i;
  char   *textMatch = (char *) va_arg(argptr, char *);

  printf("Entire document header is: ");

  for(i = 0; i &lt; strlen(textMatch); i++){
    if(isprint(textMatch[i])) printf("%c ", textMatch[i]);
    else printf("\\%d ", textMatch[i]);
  }

  printf("\n");
}

void pdfdump_objstart(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d started (generation %d)\n",
	 number, generation);
}

void pdfdump_objend(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d ended (generation %d)\n",
	 number, generation);
}

void pdfdump_dictitem_string(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [String] %s = \"%s\"\n", name, value);
}

void pdfdump_dictitem_name(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Name] %s = %s\n", name, value);
}

void pdfdump_dictitem_arraystart(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s starts\n", name);
}

void pdfdump_dictitem_arrayitem(int event, va_list argptr){
  char *value;
  
  value = va_arg(argptr, char *);
  printf("  [Array] %s\n", value);
}

void pdfdump_dictitem_arrayend(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s ends\n", name);
}

void pdfdump_dictitem_object(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Object reference] %s = %s\n", name, value);
}

void pdfdump_dictitem_dict(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" starts\n", name);
}

void pdfdump_dictitem_dictend(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" ends\n", name);
}

void pdfdump_dictitem_int(int event, va_list argptr){
  int value;
  char *name;

  name = va_arg(argptr, char *);
  value = va_arg(argptr, int);

  printf("  [Integer] %s = %d\n", name, value);
}

void pdfdump_stream(int event, va_list argptr){
  char *filter;
  int length;
  char *lengthObj;
  char *streamData;
  int streamDataLen;
  pdfdump_dictint_list  *now;
  int found;

  printf("  [Stream]\n");

  filter = va_arg(argptr, char *);
  length = (int) va_arg(argptr, char *);
  lengthObj = va_arg(argptr, char *);
  streamData = va_arg(argptr, char *);
  streamDataLen = va_arg(argptr, int);

  // Determine if we know the length
  switch(length){
  case -2:
    // We don't - have we seen the obj already?
    printf("    Length is stored in object\n");
    break;

  case -1:
    // It was never defined
    printf("    Length field not defined\n");
    break;

  default:
    printf("    Length is stated to be %d\n", length);
    pdfdump_procstream(filter, length, streamData, streamDataLen);
    break;
  }
}

void pdfdump_dictint(int event, va_list argptr){
  int found;
  int objnum, objgen, value;
  char *objref;
  pdfdump_dictint_list *now;

  // Get the passed information
  objnum = va_arg(argptr, int);
  objgen = va_arg(argptr, int);
  value = va_arg(argptr, int);

  printf("Do something with the dictint %d %d R = %d\n", objnum, objgen, value);

  // Information is handed to this event in a slightly different manner to
  // the stream event handler. Fix this.
  if((objref = (char *) malloc((pandalex_intlen(objnum) + pandalex_intlen(objgen) + 5) * sizeof(char))) == NULL){
    fprintf(stderr, "Could not allocate enough space for objref\n");
    exit(42);
  }
  
  sprintf(objref, "%d %d R", objnum, objgen);

  // Are we already waiting?
  now = dictint_list;
  found = 0;

  while((now-&gt;next != NULL) &amp;&amp; (found == 0)){
    if(strcmp(objref, now-&gt;value) == 0){
      // Yes -- do something
      pdfdump_procstream(now-&gt;filter, value, now-&gt;stream, now-&gt;streamlen);
      found = 1;
    }

    now = now-&gt;next;
  }

  // No -- save data and wait
  if(found == 0){
    // now is already the end of the list
    if((now-&gt;next = (pdfdump_dictint_list *)
	malloc(sizeof(pdfdump_dictint_list))) == NULL){
      fprintf(stderr, "Could not add to list of waiting streams\n");
      exit(42);
    }
    
    now-&gt;value = (char *) pandalex_strmcpy(objref, -1);
    now-&gt;filter = NULL;
    now-&gt;stream = NULL;
    now-&gt;waiting = 2;
    now = now-&gt;next;
    now-&gt;next = NULL;
  }
}

void pdfdump_procstream(char *filter, int length, char *data, int dataLen){
  char *uncompressed, *dataPtr, *linhintdesc[17];
  uLong srcLen, dstLen = 512;
  int result, i, linhintlens[17], number, count;

  linhintlens[0] = 32;
  linhintdesc[0] = pandalex_xsnprintf("Least number of objects in a page");
  linhintlens[1] = 32;
  linhintdesc[1] = pandalex_xsnprintf("Location of the first page object");
  linhintlens[2] = 16;
  linhintdesc[2] = pandalex_xsnprintf("Page objects delta bits");
  linhintlens[3] = 32;
  linhintdesc[3] = pandalex_xsnprintf("Least page length");
  linhintlens[4] = 16;
  linhintdesc[4] = pandalex_xsnprintf("Page length delta bits");
  linhintlens[5] = 32;
  linhintdesc[5] = pandalex_xsnprintf("Least content stream offset");
  linhintlens[6] = 16;
  linhintdesc[6] = pandalex_xsnprintf("Content stream offset delta bits");
  linhintlens[7] = 32;
  linhintdesc[7] = pandalex_xsnprintf("Least content stream length");
  linhintlens[8] = 16;
  linhintdesc[8] = pandalex_xsnprintf("Contents stream length delta bits");
  linhintlens[9] = 16;
  linhintdesc[9] = pandalex_xsnprintf("Greatest shared object number bits");
  linhintlens[10] = 16;
  linhintdesc[10] = pandalex_xsnprintf("Numerically greatest shared object number bits");
  linhintlens[11] = 16;
  linhintdesc[11] = pandalex_xsnprintf("Numeration object fraction bits");
  linhintlens[12] = 16;
  linhintdesc[12] = pandalex_xsnprintf("Denominator object fraction bits");
  linhintlens[13] = 16;
  linhintdesc[13] = pandalex_xsnprintf("?????");

  // Check length
  if(length &lt; 1){
    fprintf(stderr, "Stream length is not believable\n");
    return;
  }

  // Check there is a filter at all
  if(filter == NULL){
    fprintf(stderr, "This stream is not compressed!\n");
    return;
  }

  // If the stream starts with a \r or a \n or a \r\n, then these should be stripped off
  dataPtr = data;
  while((dataPtr[0] == '\r') || (dataPtr[0] == '\n')) dataPtr++;

  // Do something with the stream
  if(strcmp(filter, "FlateDecode") == 0){
    printf("Do something involving Flate\n");
    
    //    printf("--------------------------------------------------");
    //for(i = 0; i &lt; dataLen; i++)
    //  printf("%c", data[i]);
    //printf("--------------------------------------------------");


    // - 1
    for(i = -10; i &lt; 1; i++){
      srcLen = dataLen + i;
      dstLen = 512;
      printf("[%d] ", i);
     
      if((uncompressed = (char *) malloc(sizeof(char) * dstLen)) == NULL){
	fprintf(stderr, "Could not make enough space to decompress Flate stream\n");
	exit(42);
      }
      
      // We grow the output buffer until we no longer get buffer size errors
      while((result = uncompress(uncompressed, &amp;dstLen, dataPtr, srcLen)) == Z_BUF_ERROR){
	printf(".");
	fflush(stdout);
	
	dstLen *= 2;
	if(((uncompressed = (char *) realloc(uncompressed, dstLen)) == NULL) ||
	   (dstLen &gt; 10000000)){
	  // We could not grow the buffer, so we exit
	  printf("!");
	  fflush(stdout);
	  free(uncompressed);
	  break;
	}
      }

      if(result == Z_OK) printf(" HIT");
      printf(" *\n");
    }
    
    if(result != Z_OK){
      fprintf(stderr, "Flate decompression failed because of ");
      
      switch(result){
      case Z_MEM_ERROR:
	fprintf(stderr, "not enough memory\n");
	break;
	
      case Z_DATA_ERROR:
	fprintf(stderr, "corrupt input data\n");
	break;

      case Z_BUF_ERROR:
	fprintf(stderr, "buffer error\n");
	break;

      default:
	fprintf(stderr, "unknown error (%d)\n", result);
	break;
      }
      
      debuglex(data, srcLen, "Flate compression failure", 0);
      exit(46);
    }
    
    printf("\n");
    printf("----------- UNCOMPRESSED STREAM IS -------------------------------------------\n");
    // printf("%s\n", uncompressed);
    printf("Total uncompressed size: %d\n\n", dstLen);

    count = 0;

    for(i = 0; count &lt; 13;){
      number = 0;
      if(linhintlens[count] == 16){
	number = uncompressed[i] &lt;&lt; 8 | uncompressed[i + 1];
	i += 2;
      }
      else{
	number = uncompressed[i] &lt;&lt; 24 | uncompressed[i + 1] &lt;&lt; 16 |
	  uncompressed[i + 2] &lt;&lt; 8 | uncompressed[i + 3];
	i += 4;
      }

      printf("%s [%d]: %d\n", linhintdesc[count], linhintlens[count], number);
      count++;
    }

    printf("\nTotal bytes used: %d\n", i);
    printf("\n------------------------------------------------------------------------------\n");
  }
  else if(strcmp(filter, "LZWDecode") == 0){
    printf("LZW compression is encumbered by Patents and therefore not supported\n"); 
  }
  else if(strcmp(filter, "CCITTFaxDecode") == 0){
    printf("Do something involving CCITTFax compression (TIFF)\n");
  }
  else{
    printf("Unknown filter \"%s\"\n", filter);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.c</emphasis></para>
</sect2>

<sect2><title>samples.h</title>
<programlisting>
void pdfdump_begindocument(int, va_list);
void pdfdump_specversion(int, va_list);
void pdfdump_entireheader(int, va_list);
void pdfdump_objstart(int, va_list);
void pdfdump_objend(int, va_list);

void pdfdump_dictitem_string(int, va_list);
void pdfdump_dictitem_name(int, va_list);
void pdfdump_dictitem_arraystart(int, va_list);
void pdfdump_dictitem_arrayitem(int, va_list);
void pdfdump_dictitem_arrayend(int, va_list);
void pdfdump_dictitem_object(int, va_list);
void pdfdump_dictitem_dict(int, va_list);
void pdfdump_dictitem_dictend(int, va_list);
void pdfdump_dictitem_int(int, va_list);

void pdfdump_stream(int, va_list);
void pdfdump_dictint(int, va_list);
void pdfdump_procstream(char *, int, char *, int);

// This data type is needed for pdfdump_stream and 
// pdfdump_dictint
typedef struct pdfdump_internal_dictint_list{
  char *value;
  int waiting;
  int number;

  char *stream;
  int streamlen;
  char *filter;

  struct pdfdump_internal_dictint_list  *next; 
} pdfdump_dictint_list;
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.h</emphasis></para>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we have discussed the inner workings of the PDF format, which is quite different to the other formats we have discussed in this document. We have also examined Panda, and seen how to use it to generate our PDF documents.
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the two libraries discussed here).</para></listitem>
<listitem><para>http://www.stillhq.com: has the comp.text.pdf frequently asked questions, as well as the Panda pages.</para></listitem>
</itemizedlist>
</sect1>

</chapter>
</book>
