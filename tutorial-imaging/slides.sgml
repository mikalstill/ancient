<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<book><bookinfo>
<title>AUUG 2002: Imaging Tutorial</title>
<authorgroup>
<author><firstname>Michael</firstname><surname>Still</surname></author>
</authorgroup>

<slidetext>
Welcome to the image programming tutorial for AUUG 2002...


<figure><title>Port Arthur, Tasmania</title>
<graphic format="jpg" fileref="gen-tutorial-figure1.jpg">
</figure>

</bookinfo>

<chapter id="chap-introduction"><title>Introduction</title>
<para>
This document is the manual associated with my tutorial on imaging programming presented at the <emphasis>Australian Unix User's Group</emphasis> 2002 Winter Conference in Melbourne Australia. It is intended to serve as the basis for discussions during this day long tutorial, as well as being a reference for the attendees once they return to their every day lives.
</para>

<para>
Please note that all the information in this tutorial is copyright, as described elsewhere in this document.
</para>

<slidetext>
<li>This set of slides will cover the material for the tutorial
<li>It is available online at http://www.stillhq.com
<li>I strongly prefer that people interrupt with questions as we go along...
<li>If something isn't clear to you, then it is probably unclear to other people as well
<li>It also eases the boredom associated with having to listen to me all day long

<sect1><title>About the author</title>
<para>
Michael has been working in the image processing field for several years, including a couple of years managing and developing large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at mikal@stillhq.com.
</para>

<para>
Michael also has a whole bunch of code (most of which relates to imaging) at his website: http://www.stillhq.com
</para>

<slidetext>
Michael Still<br>
Senior Software Engineer<br>
TOWER Software<br>
<br>
Architecture and Data Services Group,<br>
Research and Development Section<br>
<br>
<li>TOWER is an Australian ISV developing document management software

<br><br>

<li>I can be contacted at: mikal@stillhq.com
<li>There is heaps of sample code, including the samples from this tutorial at http://www.stillhq.com
</sect1>

<sect1><title>Motivation for this tutorial</title>
<para>
This tutorial started life as a series of articles about the TIFF image format, which were published by IBM DeveloperWorks (http://www.ibm.com/developerworks) in April and June 2002. This logically grew into the tutorial you see before you today. This tutorial is based on my several years experience as an imaging developer, and the common mistakes that people seem to make over and over. Perhaps this tutorial will go some way to correcting some common misconceptions.
</para>

<slidetext>
<li>This tutorial started life as two articles on TIFF for IBM DeveloperWorks
<li>I came to the conclusion that I couldn't explain everything I wanted to in 7,000 words

<br><br>

<li>It's the start of the manual I wished I had had when I started image programming
<li>It isn't finished yet -- there is always so much more to tell
</sect1>

<sect1><title>Assumed knowledge</title>
<para>
There are some things which I assume you know, and which are outside the scope of this tutorial.
</para>

<para>
This tutorial discusses code. Almost all of the code discussed is written in C. It is therefore safe to assume that if you don't have a good working knowledge of C, then you're likely to get a lot less out of this tutorial as those who do know some C. On the other hand, don't worry about the more esoteric syntax, I'll explain this as we need it.
</para>

<para>
It should also be noted that the code samples in this tutorial are not optimal. They have been written to be as readable as possible, and not necessarily the most efficient possible. Please bear this in mind before blindly copying them.
</para>

<slidetext>
<li>C
</sect2>

<para>
It is outside the scope of this document to teach you how to compile and link source code into an executable form on your chosen architecture and operating system. You will need to understand this before you will be able to use any of the code in this document.
</para>

<para>
For those of you using gcc on a unix (or unix-like) operating system, then the following points might be all you need to know. If you need more information, then a http://www.google.com search will serve you well.

<orderedlist>
<listitem><para>Libraries are added to the link command using the -l command line option. For instance, to compile and link the source file foo, with the tiff library, you would use a command line along the lines of <command>gcc foo.c -o foo -ltiff -lm</command>.</para></listitem>

<listitem><para>You need to include -lm almost always. When you compile a c program using gcc without specifying any libraries, you get a -lm for free. As soon as you start specifying any libraries (for instance in this case -ltiff), then you also need to explicitly specify the math library as well.</para></listitem>

<listitem><para>You will almost certainly also need to add the library and include paths for the installed version of the relevant library to the compile command line as well. Directories are added to the library search path using the -L command line option. Include directories are added with the -I option.</para></listitem>

<listitem><para>The make files included with the samples in this tutorial a probably a bad place to look for introductory compile examples, as they use automake and autoconf to try to detect where the various required libraries are installed...</para></listitem>
</orderedlist>
</para>

<slidetext>
<li>How to compile and link
</sect2>
</sect1>

<sect1><title>Credits</title>
<para>
There are many people who need to be thanked when one attempts a project of this size. I would specifically like to thank my wife and son, who put up with me being geeky so very often.
</para>

<slidetext>
<li>I should thank the following people:
  <ul>
  <li>My wife Catherine, and my son Andrew
  <li>Doug Jackson
  <li>Tony Green
  <li>Michael Smith
  <li>Greg Lehey
  <li>Lenny Muellner  

<figure><title>Catherine and Andrew</title>
<graphic format="jpg" fileref="gen-introduction-figure1.jpg">
</figure>

<para>
I should also thank the following people:
</para>

<itemizedlist>
<listitem><para>Doug Jackson (doug_jackson@citadel.com.au), for proof reading and getting me interested in this whole topic to start with</para></listitem>
<listitem><para>Tony Green (greeno@bandcamp.tv), for occasional DocBook wrangling</para></listitem>
<listitem><para>Michael Smith (smith@xml-doc.org), for DocBook hints</para></listitem>
<listitem><para>Greg Lehey, for giving me access to his docbook environment when I was having jade pain</para></listitem>
<listitem><para>Lenny Muellner, of O'Reilly, for helping me with my gmat problems</para></listitem>
</itemizedlist>

</sect1>

</chapter>
<chapter id="chap-concepts"><title>Imaging concepts</title>
<para>
There are some core terms which are used throughout this tutorial. This section defines these terms -- it's probably therefore worth bookmarking this section for reference throughout the rest of the day. This section presents these things in alphabetical order, for ease of reference.
</para>

<para>
These terms are presented in alphabetical order. Some of them might seem a bit odd, but they're here because they are interesting...
</para>

<slidetext>
<li>There are some core terms which we need to define before we continue
<li>These terms are all in the manual
<li>So you can refer back to that if you get confused later
<li><b>If these are too basic, and I am wasting your time, then please let me know</b>

<sect1><title>Anti-aliasing</title>
<para>
Imagine that you are drawing a triangle across an image (or on the screen for that matter). The triangle is sometimes going to cross pixels in a way which makes them not totally turned on. Have a look at the figure below to see what I mean...
</para>

</chapter>
<chapter id="chap-tiff"><title>TIFF</title>
<para>
<quote>With great power comes great responsibility</quote> -- Spiderman
</para>

<para>
In this chapter we will discuss the Tagged Image File Format, which is one of the most common raster image formats for professional imaging -- especially scanned images and faxes. Unfortunately, it is not supported by web browsers, so isn't used as much as it might otherwise be.
</para>

<sect1><title>Introduction</title>
<para>
TIFF (Tagged Image File Format) is a raster image format which was originally produced by Aldus and Microsoft. Aldus was later acquired by Adobe, who manage the TIFF specification to this day. At the time of writing of this chapter, the current version of the TIFF specification is TIFF version 6.0. The TIFF specification can be downloaded from http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf. The TIFF technical notes at http://partners.adobe.com/asn/developer/technotes/main.html
</para>

<slidetext>
<li><b>T</b>agged <b>I</b>mage <b>F</b>ile <b>F</b>ormat
<li>Developed by Aldus (remember them?) and Microsoft
<li>Aldus was acquired by Adobe, who still administer the TIFF specification
<li>Download the spec from:

  <a href="http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf">http://partners.adobe.com/asn/developer/pdfs/tn/TIFF6.pdf</a>

<li>Technical implementation notes can be found at:

  <a href="http://partners.adobe.com/asn/developer/technotes/main.html">http://partners.adobe.com/asn/developer/technotes/main.html</a>

<slidebreak>

<para>Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. All of the examples in this chapter refer to libtiff.
</para>

<slidetext>
<li>Libtiff is an open implementation of the TIFF specification
<li>It is not GPL
<li>More like a BSD license
<li>There is documentation in the manual on how to install libtiff
</sect1>


<sect1><title>The TIFF on disc format</title>
<para>
It is useful for use to know something about how TIFF images are laid out on disc. For a fuller discussion of this, have a look at the TIFF specification version 6, which is referenced in the further reading section of this chapter
  <footnote><para>From page 13 onwards...</para></footnote>
.
</para>

<slidetext>
<li>We should talk about how TIFF images are laid out on disc
<li>This will help us understand the inner workings of the format better
<li>There are more details on this in the TIFF specification if you need them

<sect2><title>File header</title>
<table frame='all'><title>TIFF on disc: the file header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Byte order for this file: ll (ASCII) for little endian, or MM (ASCII) for big endian</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Magic number = 42, in the byte order specified above</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Offset in bytes to the first IFD
  <footnote><para>IFD: Image File Directory</para></footnote>
</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory</title>
<table frame='all'><title>TIFF on disc: the image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Number of entries in the IFD</entry>
</row>

<row>
<entry>???</entry>
<entry>The entries in the IFD (all are 12 bytes long)</entry>
</row>

<row>
<entry>4 bytes at end</entry>
<entry>Offset in bytes to the next IFD (four zero bytes if this is the last IFD)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>




<sect2><title>Image File Directory Entries</title>
<table frame='all'><title>TIFF on disc: an image file directory</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 1</entry>
<entry>Tag that identifies the entry. Have a look at tiff.h</entry>
</row>

<row>
<entry>2 - 3</entry>
<entry>Field type</entry>
</row>

<row>
<entry>4 - 7</entry>
<entry>Count of the number of type size fields used. For instance, if the type is an ASCII string, then this field will store the length of the string, including the NULL terminating byte that C strings have. The count does not include padding (if any).</entry>
</row>

<row>
<entry>8 - 11</entry>
<entry>The number of bytes inside the file that the value is stored at. Because the value must be stored on a word boundary, it will always be an even number. This file offset may point anywhere in the file, even after the image data.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
These entries have a type associated with them, possible types are:
</para>

<slidebreak>

<slidetext>
<li>These entries have a type
<li>Options are:
  <br>
  <ul>

<itemizedlist>
<listitem><para>1: BYTE 8 bit unsigned integer</para></listitem>
<listitem><para>2: ASCII 8 bit byte that contains a 7 bit ASCII code</para></listitem>
<listitem><para>3: SHORT 16 bit (2 byte) unsigned integer</para></listitem>
<listitem><para>4: LONG 32 bit (4 byte) unsigned integer</para></listitem>
<listitem><para>5: RATIONAL Two LONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
</itemizedlist>

<para>
TIFF version 6 added the following fields:
</para>

<itemizedlist>
<listitem><para>6: SBYTE An 8 bit signed integer</para></listitem>
<listitem><para>7: UNDEFINED An 8 bit byte that may contain anything</para></listitem>
<listitem><para>8: SSHORT A 16 bit (2 byte) signed integer</para></listitem>
<listitem><para>9: SLONG A 32 bit (4 byte) signed integer</para></listitem>
<listitem><para>10: SRATIONAL Two SLONGs: the first represents the numerator of a fraction; the second, the denominator</para></listitem>
<listitem><para>11: FLOAT Singled precision (4 byte) IEEE format</para></listitem>
<listitem><para>12: DOUBLE Double precision (8 byte) IEEE format</para></listitem>
</itemizedlist>

<para>
Sign is implemented using two's complement notation. New field types may be added later, although it seems unlikely at this stage, given the TIFF specification hasn't changed in quite a long time. Image readers should ignore types they don't understand
  <footnote><para>You need not worry about this, because libtiff worries about all of this for you.</para></footnote>
.
</para>

<slidetext>
<br><br>
<li>Sign is implemented using 2's complement
<li>Adobe reserve the right to add new types later
</sect2>


<sect2><title>So where's the image data?</title>
<para>
Interestingly, the image data itself is just stored as another tag value... The tag value StripOffsets stores where in the file the image data strips start. The tag value StripByteCounts stores the size of each strip.
</para>
</sect2>
</sect1>


<sect1><title>Coding for TIFF can be hard</title>
<para>	
Most file format specifications define some basic rules for the representation of the file. For instance, PNG (a competitor to TIFF) documents are always big endian. TIFF doesn't mandate things like this though, here is a list of some of the seemingly basic things that it doesn't define:

<slidetext>
<li>Most file formats lay down basic rules covering:
  <ul>

<orderedlist>
  <listitem><para>The byte order -- big endian, or little endian</para></listitem>
  <listitem><para>The fill order of the bit within the image bytes -- most significant bit first, or least significant</para></listitem>
  <listitem><para>The meaning of a given pixel value for black and white -- is 0 black, or white?</para></listitem>
  <listitem><para>...and so on</para></listitem>
</orderedlist>
</para>

<slidetext>
  </ul>
<li>TIFF doesn't

<para>
This means that creating a TIFF can be very easy, because it is rare to have to do any conversion of the data that you already have. It does mean, on the other hand, that being able to read in random TIFFs created by other applications can be very hard -- you have to code for all these possible combinations in order to be reasonably certain of having a reliable product.
</para>
	
<slidetext>
<li>This makes it very easy to create TIFFs
<li>Your current internal format is probably good enough
<li>Very hard to read in TIFF files well however

<para>
So how do you write an application which can read in all these different possible permutations of the TIFF format? The most important thing to remember is to <emphasis>never make assumptions about the format of the image data you are reading in</emphasis>.
</para>

<slidetext>
<br><br>
<li><i>Try to avoid making assumptions...</i>
</sect1>

<sect1><title>Writing Black and White TIFF files</title>
<para>
The first thing I want to do is show you how to write a TIFF file out. We'll then get onto how to read a TIFF file back into your program.
</para>

<slidetext>
<li>It must be time to see some code by now...
	

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int
main (int argc, char *argv[])
{
  char buffer[32 * 9];
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-infrastructure.c</emphasis></para>

<slidetext>
<BR><BR>
<li>Is this the most boring code example <b>every</b> or what?

<para>
The code above is pretty simple. All you need to use libtiff is to include the tiffio.h header file. The char buffer that we have defined here is going to be our black and white image, so we should define one of those next...
</para>
</sect2>

<sect2><title>Writing the image</title>
<para>
To make up for how boring that example was, I am now pleased to present you with possibly the worst picture of the Sydney Harbor Bridge ever drawn. In the example below, the image is already in the image buffer, and all we have to do is save it to the file on disc. The example first opens a TIFF image in write mode, and then places the image into that file.
</para>

<para>
Please note, that for clarity I have omitted the actual hex for the image, this is available in the download version of this code for those who are interested.
</para>

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  // Define an image -- this is 32 pixels by 9 pixels
  char buffer[25 * 144] = { ...boring hex omitted... };

  TIFF *image;

  // Open the TIFF file
  if((image = TIFFOpen("output.tif", "w")) == NULL){
    printf("Could not open output.tif for writing\n");
    exit(42);
  }

  // We need to set some values for basic tags before we can add any data
  TIFFSetField(image, TIFFTAG_IMAGEWIDTH, 25 * 8);
  TIFFSetField(image, TIFFTAG_IMAGELENGTH, 144);
  TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 1);
  TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);
  TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 144);

  TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
  TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);
  TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
  TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);

  TIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);
  TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
  
  // Write the information to the file
  TIFFWriteEncodedStrip(image, 0, buffer, 25 * 144);

  // Close the file
  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-write/write-nohex.c</emphasis></para>

<para>
There are some interesting things to note in this example. The most interesting of these is that the output image will not display using the xview command on my Linux machine. In fact, I couldn't find an example of a group 4 fax compressed black and white image which would display using that program. See the sidebar for more detail.
</para>


<para>
The sample code shows the basics of using the libtiff API. The following interesting points should be noted...
</para>

<slidebreak>
<slidetext>
<li>Things to note from this example:
  <ul>

<orderedlist>
<listitem><para>The buffers presented to and returned from libtiff each contain 8 pixels in a single byte. This means that you have to be able to extract the pixels you are interested in. The use of masks, and the right and left shift operators come in handy here.</para></listitem>

<listitem><para>The TIFFOpen function is very similar to the fopen function we are all familiar with.</para></listitem>

<listitem><para>We need to set the value for quite a few fields before we can start writing the image out. These fields give libtiff information about the size and shape of the image, as well as the way that data will be compressed within the image. These fields need to be set before you can start handing image data to libtiff. There are many more fields for which a value could be set, I have used close to the bar minimum in this example.</para></listitem>

<listitem><para>TIFFWriteEncodedStrip is the function call which actually inserts the image into the file. This call inserts uncompressed image data into the file. This means that libtiff will compress the image data for you before writing it to the file. If you have already compressed data, then have a look at the TIFFWriteRawStrip instead.</para></listitem>

<listitem><para>Finally, we close the file with TIFFClose.</para></listitem>
</orderedlist>

<slidetext>
  </ul>


<slidebreak>

<figure><title>The Sydney Harbor Bridge, by Michael Still</title>
<graphic format="jpg" fileref="gen-tiff-figure1.jpg">
</figure>
</sect2>
</sect1>

<sect1><title>Reading Black and White TIFF files</title>
<para>
Reading TIFF files reliably is much harder than writing them. The issue that complicates reading black and white TIFF images the most is the several different storage schemes which are possible within the TIFF file itself. libtiff doesn't hold your hand much with these schemes, so you have to be able to handle them yourself. The three schemes TIFF supports are single stripped images, stripped images, and tiled images.
</para>

<slidetext>
<li>As I said before, reliable reading is much harder than writing
<li>First let's talk about stripping, and tiling of images...

<orderedlist>
<listitem><para>A single strip image is as the name suggests -- a special case of a stripped image. In this case, all of the bitmap is stored in one large block. I have experienced reliability issues with images which are single strip on Windows machines. The general recommendation is that no one strip should take more than 8 kilobytes uncompressed which with black and white images limits us to 65,536 pixels in a single strip.</para></listitem>

<slidetext>
<li>Single strip is where all the image data is in one block (a strip)
<li>This can be unreliable if the strip is bigger than 8kb

<listitem><para>A multiple strip image is where horizontal blocks of the image are stored together. More than one strip is joined vertically to make the entire bitmap. Figure 2 shows this concept.</para></listitem>

<slidetext>
<BR><BR>
<li>Multiple strip images have many horizontal strips

<listitem><para>A tiled image is like your bathroom wall, it is composed of tiles. This representation is show in Figure 3, and is useful for extremely large images -- this is especially true when you might only want to manipulate a small portion of the image at any one time.</para></listitem>
</orderedlist>

<figure><title>The Sydney Harbor Bridge, in strips</title>
<graphic format="jpg" fileref="gen-tiff-figure2.jpg">
</figure>

<slidebreak>

<slidetext>
<li>A tiled image is like your bathroom wall...
<li>This is often used for extremely large images such as maps

<figure><title>The Sydney Harbor Bridge, in tiles</title>
<graphic format="jpg" fileref="gen-tiff-figure3.jpg">
</figure>

<para>
Tiled images are comparatively uncommon, so I will focus on stripped images in this chapter. Remember as we go along, that the single stripped case is merely a subset of a multiple strip images.
</para>

<slidetext>
<li>Tiled images are not very common
<li>So we'll focus on stripped images

<sect2><title>Infrastructure for reading</title>
<para>
The most important thing to remember when reading in TIFF images is to be flexible. The example below has the same basic concepts as the writing example above, with the major difference being that it needs to deal with many possible input images. Apart from stripping and tiling, the most important thing to remember to be flexible about is photo metric interpretation. Luckily, with black and white images there are only two photo metric interpretations to worry about (with color and to a certain extent gray scale images there are many more).
</para>

<slidetext>
<li>We need to remember to be flexible in the input that we accept
<BR><BR>
<li>Be flexible about:
  <ul>
  <li>Stipping / tiling
  <li>Strip sizes
  <li>Photometric interpretation
  </ul>

<para>
What is photo metric interpretation? Well, the representation of the image in the buffer is really a very arbitrary thing. I might code my bitmaps so that 0 means black (PHOTOMETRIC_MINISBLACK), whilst you might find black being 1 (PHOTOMETRIC_MINISWHITE) more convenient. TIFF allows both (in the TIFFTAG_PHOTOMETRIC tag), so our code has to be able to handle both cases. In the example below, I have assumed that the internal buffers need to be in PHOTOMETRIC_MINISWHITE so we will convert images which are in PHOTOMETRIC_MINISBLACK.
</para>

<slidebreak>
<slidetext>
<li>What is photometric interpretation?
<li>It's the representation of the image in the raster
<BR><BR>
<li>For example, I might code my bitmaps so black is represented by 1
<li>... you might use 0 for black
<li>TIFF allows both in the TIFFTAG_PHOTOMETRIC tag
  <ul>
  <li>PHOTOMETRIC_MINISWHITE
  <li>PHOTOMETRIC_MINISBLACK
  </ul>
<BR><BR>
<li>In the examples here I have assumed we need PHOTOMETRIC_MINISWHITE, so we will convert PHOTOMETRIC_MINISBLACK as required.

<BR><BR>
<i>Note that some versions of this tutorial had the tag names wrong...</i>


<para>
The other big thing to bear in mind is fill order (whether the first bit in the byte is the highest value, or the lowest). The example below also handles both of these correctly. I have assumed that we want the buffer to have the most significant bit first. TIFF images can be either big endian or little endian, but libtiff handles this for us. Thankfully, libtiff also supports the various compression algorithms without you having to worry about those. These are by far the scariest area of TIFF, so it is still worth your time to use libtiff.
</para>

<slidebreak>
<slidetext>
<li>The other thing to bear in mind is the fill order of the bytes
<li>This is whether the first bit in the byte has the highest value or the lowest
<li>This is subtly different from endianness
<BR><BR>
<li>Libtiff deals with endian issues for us automatically

<slidebreak>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint16 photo, bps, spp, fillorder;
  uint32 width;
  tsize_t stripSize;
  unsigned long imageOffset, result;
  int stripMax, stripCount;
  char *buffer, tempbyte;
  unsigned long bufferSize, count;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Check that it is of a type that we support
  if((TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &amp;bps) == 0) || (bps != 1)){
    fprintf(stderr, "Either undefined or unsupported number of bits per sample\n");
    exit(42);
  }

  if((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &amp;spp) == 0) || (spp != 1)){
    fprintf(stderr, "Either undefined or unsupported number of samples per pixel\n");
    exit(42);
  }

  // Read in the possibly multile strips
  stripSize = TIFFStripSize (image);
  stripMax = TIFFNumberOfStrips (image);
  imageOffset = 0;
  
  bufferSize = TIFFNumberOfStrips (image) * stripSize;
  if((buffer = (char *) malloc(bufferSize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory for the uncompressed image\n");
    exit(42);
  }
  
  for (stripCount = 0; stripCount &lt; stripMax; stripCount++){
    if((result = TIFFReadEncodedStrip (image, stripCount,
				      buffer + imageOffset,
				      stripSize)) == -1){
      fprintf(stderr, "Read error on input strip number %d\n", stripCount);
      exit(42);
    }

    imageOffset += result;
  }

  // Deal with photometric interpretations
  if(TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &amp;photo) == 0){
    fprintf(stderr, "Image has an undefined photometric interpretation\n");
    exit(42);
  }
  
  if(photo != PHOTOMETRIC_MINISWHITE){
    // Flip bits
    printf("Fixing the photometric interpretation\n");

    for(count = 0; count &lt; bufferSize; count++)
      buffer[count] = ~buffer[count];
  }

  // Deal with fillorder
  if(TIFFGetField(image, TIFFTAG_FILLORDER, &amp;fillorder) == 0){
    fprintf(stderr, "Image has an undefined fillorder\n");
    exit(42);
  }
  
  if(fillorder != FILLORDER_MSB2LSB){
    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA
    printf("Fixing the fillorder\n");

    for(count = 0; count &lt; bufferSize; count++){
      tempbyte = 0;
      if(buffer[count] &amp; 128) tempbyte += 1;
      if(buffer[count] &amp; 64) tempbyte += 2;
      if(buffer[count] &amp; 32) tempbyte += 4;
      if(buffer[count] &amp; 16) tempbyte += 8;
      if(buffer[count] &amp; 8) tempbyte += 16;
      if(buffer[count] &amp; 4) tempbyte += 32;
      if(buffer[count] &amp; 2) tempbyte += 64;
      if(buffer[count] &amp; 1) tempbyte += 128;
      buffer[count] = tempbyte;
    }
  }
     
  // Do whatever it is we do with the buffer -- we dump it in hex
  if(TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width) == 0){
    fprintf(stderr, "Image does not define its width\n");
    exit(42);
  }
  
  for(count = 0; count &lt; bufferSize; count++){
    printf("%02x", (unsigned char) buffer[count]);
    if((count + 1) % (width / 8) == 0) printf("\n");
    else printf(" ");
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-bw-read/read.c</emphasis></para>

<para>
This code works by first opening the image and checking that it is one that we can handle. It then reads in all the strip for the image, and appends them together in one large memory block. If required, it also flips bits until the photo metric interpretation the one we handle, and deals with having to swap bits if the fill order is wrong. Finally, our sample outputs the image as a series of lines composed of hex values. Remember that each of the values represents 8 pixels in the actual image.
</para>

<slidebreak>
<slidetext>
<li>This code works by opening an image
<li>Checking that it is one that we support
<li>Reading in all the strips and appending them together
<li>Twiddling bits if required
<li>Output the hex representation of the image
</sect2>

<sect2><title>Compression algorithms in libtiff</title>	
<para>
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?
</para>

<para>
<emphasis>Please note that all the tags in this table should be preceded by COMPRESSION, for example COMPRESSION_CCITTFAXG4...</emphasis>. The compression option is stored in the tag TIFFTAG_COMPRESSION.
</para>

<slidetext>
<li>Stored in TIFFTAG_COMPRESSION
<BR><BR>

<table frame='all'><title>Libtiff compression algorithms</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Compression algorithm</entry>
  <entry>Well suited for</entry>
  <entry>COMPRESSION</entry>
</row>
</thead>
<tbody>
<row>
<entry>CCITT Group 4 Fax and Group 3 Fax</entry>
<entry>If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</entry>
<entry>_CCITTFAX3, _CCITTFAX4</entry>
</row>

<row>
<entry>JPEG</entry>
<entry>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the loss section below for more information about this.</entry>
<entry>_JPEG</entry>
</row>

<row>
<entry>LZW</entry>
<entry><emphasis>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</emphasis></entry>
<entry>_LZW</entry>
</row>

<row>
<entry>Deflate</entry>
<entry>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</entry>
<entry>_DEFLATE</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Accumulating loss?</title>
<para>
Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a bar code to the image, so you uncompress the image, add the bar code, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.
</para>

<slidetext>
<li>JPEG compression can be a bad choice for some forms of data
<li>This is because it is lossy
<li>This loss accumulates through repeated compression and decompression

<para>
Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.
</para>

<slidebreak>
<figure><title>The picture before we compressed it</title>
<graphic format="jpg" fileref="gen-tiff-figure4.jpg">
</figure>

<slidebreak>
<figure><title>The sample text before we compressed it</title>
<graphic format="jpg" fileref="gen-tiff-figure5.jpg">
</figure>

<para>
The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</para>

<slidebreak>
<figure><title>The picture after it has been recompressed 200 times</title>
<graphic format="jpg" fileref="gen-tiff-figure6.jpg">
</figure>

<slidebreak>
<figure><title>The text after it has been recompressed 200 times</title>
<graphic format="jpg" fileref="gen-tiff-figure7.jpg">
</figure>

<para>
The code for the repeated compression example is at the end of this chapter.
</para>

<slidebreak>
<slidetext>
<li>I cheated here, and had a quality of 25% set on the JPEG compression
<li>The default is 75%
<BR><BR>
<li>The code for repeated compression is the the printed manual
</sect2>
</sect1>




<sect1><title>Writing a color image</title>
<para>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</para>

<slidetext>
<li>It's time to show you a color example

<programlisting>
#include &lt;tiffio.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]){
  TIFF *output;
  uint32 width, height;
  char *raster;

  // Open the output image
  if((output = TIFFOpen("output.tif", "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // We need to know the width and the height before we can malloc
  width = 42;
  height = 42;

  if((raster = (char *) malloc(sizeof(char) * width * height * 3)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Magical stuff for creating the image
  // ...

  // Write the tiff tags to the file
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster, width * height * 3) == 0){
    fprintf(stderr, "Could not write image\n");
    exit(42);
  }

  TIFFClose(output);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-write/write.c</emphasis></para>

<slidebreak>

<para>
You can see from this code some of the things that we have discussed in theory. The image has three samples per pixel, each of eight bits. This means that the image is a 24 bit RGB image. If this was a black and white or gray scale image, then this value would be one. The tag PHOTOMETRIC_RGB says that the image data is stored within the strips themselves (as opposed to being paletted) -- more about this in a second.
</para>

<slidetext>
<li>There are some things we should pay attention to in this code:
  <ul>
  <li>The image has three (red, green and blue) samples per pixel
  <li>Each of these samples is 8 bits
  <li>This is therefore a 24 bit color image
  </ul>

<sidebar><title>Other values for samples per pixel?</title>
<para>
In this example, we have three samples per pixel. If this was a black and white image, or a gray scale image, then we would have one sample per pixel. There are other valid values for here as well -- for instance, sometimes people will store a transparency value for a given pixel, which is called an alpha channel. This would result in having four samples per pixel. It is possible to have an arbitrary number of samples per pixel, which is good if you need to pack in extra information about a pixel. <emphasis>Note that doing this can break image viewers which make silly assumptions -- I once had to write code for a former employer to strip out alpha channels and the like so that their PDF generator wouldn't crash.</emphasis>
</para>

<slidetext>
<li>Now is probably as good a time as any to tell you that you're not limited to three samples per pixel
<li>You can have an arbitary number
<li>For instance, this is where alpha channel information is stored in almost all image formats
<li>Having more than three samples per pixel can break viewers which make ugly assumptions
</sidebar>

<para>The other interesting thing to discuss here is the planar configuration of the image. Here we have specified PLANARCONFIG_CONTIG, which means that the red green and blue information for a given pixel is grouped together in the strips of image data. The other option is PLANARCONFIG_SEPARATE, where the red samples for the image are stored together, then the blue samples, and finally the green samples.</para>

<slidebreak>
<slidetext>
<li>The other interesting thing we should talk about now is planar configuration
<li>You don't have to have your image data grouped like:

<pre>
RGBRGBRGBRGBRGB
</pre>

<li>Grouping all the red samples together is equally valid, for instance:

<pre>
RRRRRGGGGGBBBBB
</pre>

<li>Have a look at the libtiff documentation on TIFFTAG_PLANARCONFIG for more details
</sect1>

<sect1><title>Writing a paletted color image</title>
<para>
So how do we write a paletted version of this image? Well, libtiff makes this really easy -- all we need to do is change the value of TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE. It's not really worth including an example in this chapter, given it's a one word change.</para>

<slidetext>
<li>Writing a paletted image with libtiff is really easy...
<li>Just change TIFFTAG_PHOTOMETRIC to PHOTOMETRIC_PALETTE
</sect1>





<sect1><title>Reading a color image</title>
<para>
Now all we have to do is work out how to read other people's color and gray scale images reliably, and we're home free. Initially I was very tempted to not tell you about the TIFFReadRGBAStrip() and TIFFReadRGBBSTile() calls, which hide some of the potential ugliness from the caller. These functions have some limitations I'm not astoundingly happy with. To quote the TIFFReadRGBAStrip() man page:</para>

<slidetext>
<li>Now we just need to work out how to read color images in
<li>Here's why I'm not telling you about TIFFReadRGBAStrip() and TIFFReadRGBATile()

<para><emphasis>
   TIFFReadRGBAStrip reads a single strip of a strip-based image into memory,
   storing  the  result  in  the  user supplied RGBA raster. The raster is assumed to be an array of
   width   times   rowsperstrip   32-bit   entries,   where   width   is  the  width  of  the  image
   (TIFFTAG_IMAGEWIDTH) and rowsperstrip is the maximum lines in a strip (TIFFTAG_ROWSPERSTRIP).
</emphasis></para>

<para><emphasis>
   The  strip  value  should  be  the  strip  number  (strip  zero  is the first) as returned by the
   TIFFComputeStrip function, but always for sample 0.
</emphasis></para>

<para><emphasis>
   Note  that  the  raster  is  assume  to  be  organized  such  that the pixel at location (x,y) is
   raster[y*width+x];  with  the  raster  origin in the lower-left hand corner of the strip. That is
   bottom  to  top  organization. When reading a partial last strip in the file the last line of the
   image will begin at the beginning of the buffer.
</emphasis></para>

<slidebreak>
<para><emphasis>
   Raster  pixels  are  8-bit packed red, green, blue, alpha samples. The macros TIFFGetR, TIFFGetG,
   TIFFGetB,  and  TIFFGetA  should  be used to access individual samples. Images without Associated
   Alpha matting information have a constant Alpha of 1.0 (255).
</emphasis></para>

<para><emphasis>
   See  the TIFFRGBAImage(3T) page for more details on how various image types are converted to RGBA
   values.
</emphasis></para>

<para><emphasis>
<command>NOTES</command>
</emphasis></para>

<para><emphasis>
   Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be either 1, 3, or
   4 (i.e. SamplesPerPixel minus ExtraSamples).
</emphasis></para>

<para><emphasis>
   Palette  image  colormaps that appear to be incorrectly written as 8-bit values are automatically
   scaled to 16-bits.
</emphasis></para>

<para><emphasis>
   TIFFReadRGBAStrip  is  just  a wrapper around the more general TIFFRGBAImage(3T) facilities. It's
   main  advantage  over  the similar TIFFReadRGBAImage() function is that for large images a single
   buffer  capable  of  holding  the  whole  image doesn't need to be allocated, only enough for one
   strip. The TIFFReadRGBATile() function does a similar operation for tiled images.
</emphasis></para>

<slidebreak>
<para>There are a couple of odd things about this function -- it defines (0, 0) to be in a different location from all the other code that we have been writing. In all the previous code we have written, the (0, 0) point has been in the top left of the image. This call defines (0, 0) to be in the bottom left. The other limitation to be aware of is that not all valid values for bits per sample are supported. If you find these quirks unacceptable, then remember that you can still use TIFFReadEncodedStrip() in the same manner that we did for the black and white images in the previous chapter...</para>

<slidetext>
<li>So what's wrong with this function?
  <ul>
  <li>It defines the origin (0,0) in a different way from <b>all</b> the other libtiff calls
  <li>Not all valid values for bits per sample are handled
  </ul>

<BR><BR>

<li>We're going to use it anyway, because it makes the code clearer...
<li>Remember that you can always use TIFFReadEncodedStrip() like we did for the black and white images -- although you then have to interpret the image data yourself

<slidebreak>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;

int main(int argc, char *argv[]){
  TIFF *image;
  uint32 width, height, *raster;
  tsize_t stripSize;
  unsigned long imagesize, c, d, e;

  // Open the TIFF image
  if((image = TIFFOpen(argv[1], "r")) == NULL){
    fprintf(stderr, "Could not open incoming image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &amp;height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

  // Read the image into the memory buffer
  if(TIFFReadRGBAStrip(image, 0, raster) == 0){
    fprintf(stderr, "Could not read image\n");
    exit(42);
  }

  // Here I fix the reversal of the image (vertically) and show you how to get the color values from each pixel
  d = 0;
  for(e = height - 1; e != -1; e--){
    for(c = 0; c &lt; width; c++){
      // Red = TIFFGetR(raster[e * width + c]);
      // Green = TIFFGetG(raster[e * width + c]);
      // Blue = TIFFGetB(raster[e * width + c]);
    }
  }

  TIFFClose(image);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-color-read/read.c</emphasis></para>
</sect1>




<sect1><title>Storing TIFF data in places other than files</title>
<para>
All of these examples that I have included to this point have read and written with files. There are many scenarios when you wouldn't want to store your image data in a file, but would still want to use libtiff and TIFF. For example, you might have customer pictures for id cards, and these would be stored in a database.
</para>

<slidetext>
<li>There are times when it isn't appropriate to store your image data in files
<li>There are lots of examples of when you might want to put the data in a database instead
<li>Perhaps the image data is going to be embedded into another file format

<para>
The example which I am most familiar with is PDF documents. In PDF files, you can embed images into the document. These images can be in a subset of TIFF if desired, and TIFF is quite clearly the choice for black and white images.
</para>

<slidetext>
<BR><BR>
<li>The example I am most familiar with is the PDF specification
<li>The PDF format is basically ASCII (as we will see later)
<li>But has embedded binary "streams" such as TIFF data
<li>So we would like to be able to create these streams with libtiff
<li>...instead of having to implement our own TIFF library


<slidebreak>
<para>libtiff allows you to replace the file input and output functions in the library with your own. This is done with the TIFFClientOpen() method. Here's an example (please note this code wont compile, and is just to describe the main concepts:</para>

<slidetext>
<li>Use the TIFFClientOpen() function...


<programlisting>
// Please note that this code wont compile, and is intended to only show you 
// the sturcture of TIFFClient* calls

#include &lt;tiffio.h&gt;
#include &lt;pthread.h&gt;

// Function prototypes
static tsize_t libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size);
static tsize_t libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size);
static toff_t libtiffDummySeekProc (thandle_t fd, toff_t off, int i);
static int libtiffDummyCloseProc (thandle_t fd);

// We need globals because of the callbacks (they don't allow us to pass state)
char *globalImageBuffer;
unsigned long globalImageBufferOffset;

// This mutex keeps the globals safe by ensuring only one user at a time
pthread_mutex_t convMutex = PTHREAD_MUTEX_INITIALIZER;

TIFF *conv;

// Lock the mutex
pthread_mutex_lock (&amp;convMutex);

globalImageBuffer = NULL;
globalImageBufferOffset = 0;

// Open the dummy document (which actually only exists in memory)
conv = TIFFClientOpen ("dummy", "w", (thandle_t) - 1, libtiffDummyReadProc,
            libtiffDummyWriteProc, libtiffDummySeekProc,
            libtiffDummyCloseProc, NULL, NULL, NULL);

// Setup the image as if it was any other tiff image here, including setting tags


// Actually do the client open
TIFFWriteEncodedStrip (conv, 0, stripBuffer, imageOffset);

// Unlock the mutex
pthread_mutex_unlock (&amp;convMutex);

//...

/////////////////// Callbacks to libtiff

static tsize_t
libtiffDummyReadProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // Return the amount of data read, which we will always set as 0 because
  // we only need to be able to write to these in-memory tiffs
  return 0;
}

static tsize_t
libtiffDummyWriteProc (thandle_t fd, tdata_t buf, tsize_t size)
{
  // libtiff will try to write an 8 byte header into the tiff file. We need
  // to ignore this because PDF does not use it...
  if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'I') &amp;&amp; (((char *) buf)[1] == 'I')
     &amp;&amp; (((char *) buf)[2] == 42))
    {
    // Skip the header -- little endian
    }
  else if ((size == 8) &amp;&amp; (((char *) buf)[0] == 'M') &amp;&amp;
       (((char *) buf)[1] == 'M') &amp;&amp;y (((char *) buf)[2] == 42))
    {
    // Skip the header -- big endian
    }
  else
    {
    // Have we done anything yet?
    if (globalImageBuffer == NULL)
    if((globalImageBuffer = (char *) malloc (size * sizeof (char))) == NULL)
        {
          fprintf(stderr, "Memory allocation error\n");
          exit(42);
        }

    // Otherwise, we need to grow the memory buffer
    else
    {
      if ((globalImageBuffer = (char *) realloc (globalImageBuffer,
                             (size * sizeof (char)) +
                             globalImageBufferOffset)) == NULL)
        fprintf(stderr, "Could not grow the tiff conversion memory buffer\n");
            exit(42);
    }

    // Now move the image data into the buffer
    memcpy (globalImageBuffer + globalImageBufferOffset, buf, size);
    globalImageBufferOffset += size;
    }

  return (size);
}

static toff_t
libtiffDummySeekProc (thandle_t fd, toff_t off, int i)
{
  // This appears to return the location that it went to
  return off;
}

static int
libtiffDummyCloseProc (thandle_t fd)
{
  // Return a zero meaning all is well
  return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-client/client.c</emphasis></para>
</sect1>




<sect1><title>Storing more than one image inside a TIFF</title>
<para>
A common request is to be able to store more than one image inside a single TIFF file. This is done with multiple directories, which is one of the reasons they're described at the start of this chapter.
</para>

<slidetext>
<li>People commonly want to be able to store more than one image in a TIFF file
<li>TIFF and libtiff support this
<li>This is called multipage / multidirectory TIFF
<li>Multidirectory because there is more than one IFD
<li>There is in fact one per image

<para>
<emphasis>Before embarking on a multiple image per TIFF solution, it is important to remember that the TIFF specification doesn't require TIFF image viewers to implement support for multiple images per TIFF, and many viewers in fact do not
  <footnote><para>Refer to page 16 of the TIFF specification, version 6.</para></footnote>
.</emphasis>
</para>

<slidetext>
<BR><BR>
<li><i>Before writing heaps of code for multipage TIFFs, remember that the specification doesn't require viewers to support this feature, so you might end up with a whole heap of data that no-one can look at...</i>

<slidebreak>
<para>
Anyway, now that I've nagged you, putting multiple images into one TIFF file is really easy, just call the <command>TIFFWriteDirectory</command>(), which writes out the current image so you can move onto the next one. The following sample program is an example of this...
</para>

<slidetext>
<li>Actually doing it is quite easy...
<li>Just use the TIFFWriteDirectory() call between the images

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff, optchar;
  int count = 4, i;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:c:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'c':
	  count = atoi(optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file, we do this c times
  for(i = 0; i &lt; count; i++){
    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    

    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    // Flush this subfile and move onto the next one
    if(TIFFWriteDirectory(output) == 0){
      fprintf(stderr, "Error writing subfile %d\n", i);
      exit(44);
    }
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/create.c</emphasis></para>

<slidebreak>
<figure><title>Four pictures of my son Andrew</title>
<graphic format="jpg" fileref="gen-tiff-figure8.jpg">
</figure>

</sect1>

<sect1><title>Reading more than one image inside a TIFF</title>
<para>
We should also probably know how to get to these images once we have more than one image inside a single TIFF file...
</para>

<para>
This example below demonstrates how to do this.
</para>


<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, 
    outputFilenameActual[200], *raster, *roff, optchar;
  int count;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage(argv[0], 0);
	  break;
	}
    }

  // Check the output parent name
  if(outputFilename == NULL){
    fprintf(stderr, \
	    "You need to specify a name for the series of output files\n");
    usage(argv[0], 42);
  }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Grab a sub file from the input image and move it to a separate file. We do
  // this forever (until we break down below)...
  for(count = 0;; count++){
    // Find the width and height of the input
    TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
    TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

    ///////////////////////////////////////////////////////////////////////////
    // Grab some memory
    if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == 
	NULL)
      {
	fprintf (stderr, 
		 "Could not allocate enough memory for input raster\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Read the input into the memory buffer
    // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
    stripSize = TIFFStripSize (input);
    roff = raster;
    for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
	 stripNumber++)
      {
	roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
      }
    
    ///////////////////////////////////////////////////////////////////////////
    // Open the output TIFF
    snprintf(outputFilenameActual, 200, "%s-%d.tif", outputFilename, count);
    if ((output = TIFFOpen (outputFilenameActual, "w")) == NULL)
      {
	fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
	usage (argv[0], 42);
      }

    printf(".");
    fflush(stdout);

    // todo: We need to copy tags from the input image to the output image
    TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
    TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
    // todo: balance this off with having 8 kb per strip...
    TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);
    
    // Copy the subfile to a output location
    if (TIFFWriteEncodedStrip (output, 0, raster,
			       width * height * 3 * sizeof (char)) == 0)
      {
	fprintf (stderr, "Could not write the output image\n");
	exit (42);
      }

    ///////////////////////////////////////////////////////////////////////////
    // Flush this subfile and move onto the next one
    if(TIFFReadDirectory(input) == 0){
      printf(" No more subfiles");
      break;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Doing correct cleanup with a loop like this is important...
    free(raster);
  }
  printf("\n");
    
  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -c &lt;count&gt;\n", 
	   cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-directories/read.c</emphasis></para>

</sect1>


<sect2><title>tiffcp</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.8 2002-09-04 23:06:45 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffcp - copy (and possibly convert) a
<emphasis>TIFF</emphasis>
file
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffcp</command>
[
<emphasis>options</emphasis>
]
<emphasis>"src1.tif ... srcN.tif dst.tif"</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffcp</emphasis>
combines one or more files created according
to the Tag Image File Format, Revision 6.0
into a single
<emphasis>TIFF</emphasis>
file.
Because the output file may be compressed using a different
algorithm than the input files,
<emphasis>tiffcp</emphasis>
is most often used to convert between different compression
schemes.

</para>

<para>By default,
<emphasis>tiffcp</emphasis>
will copy all the understood tags in a
<emphasis>TIFF</emphasis>
directory of an input
file to the associated directory in the output file.

</para>

<para><emphasis>tiffcp</emphasis>
can be used to reorganize the storage characteristics of data
in a file, but it is explicitly intended to not alter or convert
the image data content in any way.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-b image</command>
subtract the following monochrome image from all others
processed.  This can be used to remove a noise bias
from a set of images.  This bias image is typlically an
image of noise the camera saw with its shutter closed.
</para>
</listitem>
<listitem>

<para><command>-B</command>
Force output to be written with Big-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-C</command>
Suppress the use of ``strip chopping'' when reading images
that have a single strip/tile of uncompressed data.
</para>
</listitem>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>jpeg</command>
for baseline JPEG compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffcp</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB.</emphasis>
</para>
</listitem>
<listitem>

<para><command>-l</command>
Specify the length of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-L</command>
Force output to be written with Little-Endian byte order.
This option only has an effect when the output file is created or
overwritten and not when it is appended to.
</para>
</listitem>
<listitem>

<para><command>-M</command>
Suppress the use of memory-mapped files when reading images.
</para>
</listitem>
<listitem>

<para><command>-p</command>
Specify the planar configuration to use in writing image data
that has one 8-bit sample per pixel.
By default,
<emphasis>tiffcp</emphasis>
will create a new file with the same planar configuration as
the original.
Specifying
<command>"-p contig"</command>
will force data to be written with multi-sample data packed
together, while
<command>"-p separate"</command>
will force samples to be written in separate planes.
</para>
</listitem>
<listitem>

<para><command>-r</command>
Specify the number of rows (scanlines) in each strip of data
written to the output file.
By default,
<emphasis>tiffcp</emphasis>
attempts to set the rows/strip
that no more than 8 kilobytes of data appear in a strip.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Force the output file to be written with data organized in strips
(rather than tiles).
</para>
</listitem>
<listitem>

<para><command>-t</command>
Force the output file to be written wtih data organized in tiles
(rather than strips).
options can be used to force the resultant image to be written
as strips or tiles of data, respectively.
</para>
</listitem>
<listitem>

<para><command>-w</command>
Specify the width of a tile (in pixels).
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
<emphasis>tiffcp</emphasis>
attempts to set the tile dimensions so
that no more than 8 kilobytes of data appear in a tile.
</para>
</listitem>
<listitem>

<para><command>-,={character}</command>
substitute {character} for ',' in parsing image directory indices
in files.  This is necessary if filenames contain commas.
Note that ',=' with whitespace immediately following will disable
the special meaning of the ',' entirely.  See examples.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>EXAMPLES</title>

<para>The following concatenates two files and writes the result using
<emphasis>LZW</emphasis>
encoding:
tiffcp -c lzw a.tif b.tif result.tif

</para>

<para>To convert a G3 1d-encoded
<emphasis>TIFF</emphasis>
to a single strip of G4-encoded data the following might be used:
tiffcp -c g4 -r 10000 g3.tif g4.tif
(1000 is just a number that is larger than the number of rows in
the source file.)

</para>

<para>To extract a selected set of images from a multi-image
TIFF file, the file name may be immediately followed by a ','
separated list of image directory indices.  The first image
is always in directory 0.  Thus, to copy the 1st and 3rd
images of image file "album.tif" to "result.tif":
tiffcp album.tif,0,2 result.tif

</para>

<para>Given file "CCD.tif" whose first image is a noise bias
followed by images which include that bias,
subtract the noise from all those images following it
(while decompressing) with the command:
tiffcp -c none -b CCD.tif CCD.tif,1, result.tif

</para>

<para>If the file above were named "CCD,X.tif", the "-,=" option would
be required to correctly parse this filename with image numbers,
as follows:
tiffcp -c none -,=% -b CCD,X.tif CCD,X%1%.tif result.tif
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>tiffsplit (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>
</sect2>


<sect2><title>tiffdither</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.8 2002-09-04 23:06:45 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1990-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdither - convert a greyscale image to bilevel using dithering
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdither</command>
[
<emphasis>options</emphasis>
]
<emphasis>input.tif</emphasis>
<emphasis>output.tif</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdither</emphasis>
converts a single channel 8-bit greyscale image to a bilevel image
using Floyd-Steinberg error propagation with threholding.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Specify the compression to use for data written to the output file:
<command>none </command>
for no compression,
<command>packbits</command>
for PackBits compression,
<command>lzw</command>
for Lempel-Ziv &amp; Welch compression,
<command>zip</command>
for Deflate compression,
<command>g3</command>
for CCITT Group 3 (T.4) compression,
and
<command>g4</command>
for CCITT Group 4 (T.6) compression.
By default
<emphasis>tiffdither</emphasis>
will compress data according to the value of the
<emphasis>Compression</emphasis>
tag found in the source file.
The
<emphasis>CCITT</emphasis>
Group 3 and Group 4 compression algorithms can only
be used with bilevel data.
Group 3 compression can be specified together with several
T.4-specific options:
<command>1d</command>
for 1-dimensional encoding,
<command>2d</command>
for 2-dimensional encoding,
and
<command>fill</command>
to force each encoded scanline to be zero-filled so that the
terminating EOL code lies on a byte boundary.
Group 3-specific options are specified by appending a ``:''-separated
list to the ``g3'' option; e.g.
<command>"-c g3:2d:fill"</command>
to get 2D-encoded data with byte-aligned EOL codes.
<emphasis>LZW</emphasis>
compression can be specified together with a
<emphasis>predictor</emphasis>
value.
A predictor value of 2 causes
each scanline of the output image to undergo horizontal
differencing before it is encoded; a value
of 1 forces each scanline to be encoded without differencing.
LZW-specific options are specified by appending a ``:''-separated
list to the ``lzw'' option; e.g.
<command>"-c lzw:2"</command>
for
<emphasis>LZW</emphasis>
compression with horizontal differencing.
</para>
</listitem>
<listitem>

<para><command>-f</command>
Specify the bit fill order to use in writing output data.
By default,
<emphasis>tiffdither</emphasis>
will create a new file with the same fill order as the original.
Specifying
<command>"-f lsb2msb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>LSB2MSB ,</emphasis>
while
<command>"-f msb2lsb"</command>
will force data to be written with the FillOrder tag set to
<emphasis>MSB2LSB .</emphasis>
</para>
</listitem>
<listitem>

<para><command>-t</command>
Set the threshold value for dithering.
By default the threshold value is 128.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>NOTES</title>

<para>The dither algorithm is taken from the
<emphasis>tiffmedian (1)</emphasis>
program (written by Paul Heckbert).
</para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>fax2tiff (1),</emphasis>
<emphasis>tiffinfo (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiff2bw (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<para>
<command>tiffdither</command> takes gray scale images and dithers them into black and white images. For instance, the gray scale example from earlier in this tutorial produced the following image:
</para>

<slidebreak>
<figure><title>The gray scale input image</title>
<graphic format="jpg" fileref="gen-tiff-figure9.jpg">
</figure>

<para>
This image, after being pushed through <command>tiffdither</command> looks something like:
</para>

<slidebreak>
<figure><title>The dithered output image</title>
<graphic format="jpg" fileref="gen-tiff-figure10.jpg">
</figure>
</sect3>
</sect2>

<sect2><title>tiffdump</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.8 2002-09-04 23:06:45 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffdump - print verbatim information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffdump</command>
[
<emphasis>options</emphasis>
]
<emphasis>"name ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>tiffdump</emphasis>
displays directory information from files created according
to the Tag Image File Format, Revision 6.0.
The header of each
<emphasis>TIFF</emphasis>
file (magic number, version, and first directory offset)
is displayed, followed by the tag contents of each directory in the file.
For each tag, the name, datatype, count, and value(s) is displayed.
When the symbolic name for a tag or datatype is known, the symbolic
name is displayed followed by it's numeric (decimal) value.
Tag values are displayed enclosed in ``&lt;&gt;'' characters immediately
preceded by the value of the count field.
For example, an
<emphasis>ImageWidth</emphasis>
tag might be displayed as ``ImageWidth (256) SHORT (3) 1&lt;800&gt;''.

</para>

<para><emphasis>tiffdump</emphasis>
is particularly useful for investigating the contents of
<emphasis>TIFF</emphasis>
files that
<emphasis>libtiff</emphasis>
does not understand.
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-h</command>
Force numeric data to be printed in hexadecimal rather than the
default decimal.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Dump the contents of the
<emphasis>IFD</emphasis>
at the a particular file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>tiffinfo (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffdump</command> shows you heaps of useful things about a TIFF image, basically anything stored in a tag. Some sample output is:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffdump tiff-figure10.tif 
tiff-figure10.tif:
Magic: 0x4949 &lt;little-endian&gt; Version: 0x2a
Directory 0: offset 38228 (0x9554) next 0 (0)
ImageWidth (256) SHORT (3) 1&lt;640&gt;
ImageLength (257) SHORT (3) 1&lt;479&gt;
BitsPerSample (258) SHORT (3) 1&lt;1&gt;
Compression (259) SHORT (3) 1&lt;32773&gt;
Photometric (262) SHORT (3) 1&lt;1&gt;
ImageDescription (270) ASCII (2) 41&lt;Dithered B&amp;W version of  ...&gt;
StripOffsets (273) LONG (4) 5&lt;8 8141 16315 24528 32662&gt;
SamplesPerPixel (277) SHORT (3) 1&lt;1&gt;
RowsPerStrip (278) SHORT (3) 1&lt;102&gt;
StripByteCounts (279) LONG (4) 5&lt;8133 8174 8213 8134 5566&gt;
PlanarConfig (284) SHORT (3) 1&lt;1&gt;
[mikal@localhost tutorial-imaging]$ 
</programlisting>
</sect3>
</sect2>


<sect2><title>tiffinfo</title>
<!-- 	$Header: /usr/local/google/home/mikal/cvs/tutorial-imaging/slides.sgml,v 1.8 2002-09-04 23:06:45 mikal Exp $ -->
<!--  -->
<!--  Copyright (c) 1988-1997 Sam Leffler -->
<!--  Copyright (c) 1991-1997 Silicon Graphics, Inc. -->
<!--  -->
<!--  Permission to use, copy, modify, distribute, and sell this software and  -->
<!--  its documentation for any purpose is hereby granted without fee, provided -->
<!--  that (i) the above copyright notices and this permission notice appear in -->
<!--  all copies of the software and related documentation, and (ii) the names of -->
<!--  Sam Leffler and Silicon Graphics may not be used in any advertising or -->
<!--  publicity relating to the software without the specific, prior written -->
<!--  permission of Sam Leffler and Silicon Graphics. -->
<!--   -->
<!--  THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,  -->
<!--  EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY  -->
<!--  WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   -->
<!--   -->
<!--  IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR -->
<!--  ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, -->
<!--  OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, -->
<!--  WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  -->
<!--  LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE  -->
<!--  OF THIS SOFTWARE. -->
<!--  -->
<sect3><title>NAME</title>

<para>tiffinfo - print information about
<emphasis>TIFF</emphasis>
files
</para>
</sect3>
<sect3><title>SYNOPSIS</title>

<para><command>tiffinfo</command>
[
<emphasis>options</emphasis>
]
<emphasis>"input.tif ..."</emphasis>
</para>
</sect3>
<sect3><title>DESCRIPTION</title>

<para><emphasis>Tiffinfo</emphasis>
displays information about files created according
to the Tag Image File Format, Revision 6.0.
By default, the contents of each
<emphasis>TIFF</emphasis>
directory in each file
is displayed, with the value of each tag shown symbolically
(where sensible).
</para>
</sect3>
<sect3><title>OPTIONS</title>

<para></para>
<itemizedlist>
<listitem>

<para><command>-c</command>
Display the colormap and color/gray response curves, if present.
</para>
</listitem>
<listitem>

<para><command>-D</command>
In addition to displaying the directory tags,
read and decompress all the data in each image (but not display it).
</para>
</listitem>
<listitem>

<para><command>-d</command>
In addition to displaying the directory tags,
print each byte of decompressed data in hexadecimal.
</para>
</listitem>
<listitem>

<para><command>-j</command>
Display any \s-2JPEG\s0-related tags that are present.
</para>
</listitem>
<listitem>

<para><command>-o</command>
Set the initial
<emphasis>TIFF</emphasis>
directory according to the specified file offset.
The file offset may be specified using the usual C-style syntax;
i.e. a leading ``0x'' for hexadecimal and a leading ``0'' for octal.
</para>
</listitem>
<listitem>

<para><command>-s</command>
Display the offsets and byte counts for each data strip in a directory.
</para>
</listitem>
<listitem>

<para><command>-z</command>
Enable strip chopping when reading image data.
</para>
</listitem>
<listitem>

<para><command>-#</command>
Set the initial
<emphasis>TIFF</emphasis>
directory to
<emphasis># .</emphasis>
</para>
</listitem>
</itemizedlist>

<para></para>
</sect3>
<sect3><title>SEE ALSO</title>

<para><emphasis>pal2rgb (1),</emphasis>
<emphasis>tiffcp (1),</emphasis>
<emphasis>tiffcmp (1),</emphasis>
<emphasis>tiffmedian (1),</emphasis>
<emphasis>libtiff (3)</emphasis>
</para>
</sect3>

<sect3><title>Sample output</title>
<para>
<command>tiffinfo</command> is probably the most useful command which comes with libtiff... In normal operation, it shows you nicely formatted information about the TIFF image, like so:
</para>

<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo tiff-figure9.tif 
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
[mikal@localhost tutorial-imaging]$ 
</programlisting>

<para>
When you ask nicely (with a -d), then you're shown random tiff data, which can be very handy:
</para>

<slidebreak>
<programlisting>
[mikal@localhost tutorial-imaging]$ tiffinfo -d tiff-figure9.tif
TIFF Directory at offset 0x40f7c
  Image Width: 640 Image Length: 480
  Bits/Sample: 8
  Compression Scheme: Deflate
  Photometric Interpretation: min-is-black
  Samples/Pixel: 1
  Rows/Strip: 100000
  Planar Configuration: single image plane
Strip 0:
 59 5d 5c 55 4f 51 58 5d 5a 5a 57 51 4d 4d 4e 4d 58 54 55 5f 6c 76 7a 7c
 86 83 89 89 7f 7c 79 6e 61 57 70 7a 64 6f 7d 62 60 61 68 75 82 85 7e 76
 78 79 80 7a 66 5f 62 61 53 5b 62 6d 77 75 7a 8e a0 91 7a 66 5d 5d 61 62
 6f 69 65 64 63 61 63 68 76 79 74 76 86 8b 86 85 83 83 66 6a a0 b8 a7 a1
 94 a7 9d 72 5b 69 7b 7c 88 84 7f 7a 73 72 7e 8c 94 96 8a 75 6f 77 75 6a
 73 7d 85 85 84 89 90 94 8b 7d 74 7a 84 8a 8e 91 9c 99 87 7e 8d 93 85 79
 73 7e 88 87 80 7e 88 92 96 93 95 9d a1 9c 94 91 9c 8f 90 9e 9e 8a 7b 7b
 89 7a 68 5d 58 5b 66 71 81 82 7c 71 6c 6f 70 6e 5f 62 60 60 65 66 6f 84
 85 93 a4 a8 98 86 81 86 88 7e 83 7a 73 74 6f 7e 78 72 73 74 71 75 73 67
 72 73 77 85 90 8a 8f a7 ba cc cc c0 c1 c8 cf d7 dd e6 ec e5 e2 ef ed d4
 e4 e6 ea ee f1 f2 f1 ef f3 f3 f3 f2 f2 f2 f1 f1 f2 f1 f0 ef ee ed ec eb
 ... and so on
</programlisting>
</sect3>
</sect2>




</sect1>






<sect1><title>API Man Pages</title>
<para>
It is also useful to have the man pages for the libtiff API man pages to refer to...
</para>

<slidetext>
<li>There are also extensive man pages for the API -- check yout manual










<sect1><title>Example: Pixel enlargement</title>
<para>
In the introduction to this tutorial I promised that I would include the code to draw the demonstration that raster images are made up of pixels. Well, this example is that code.
</para>

<slidetext>
<li>In the early stages of this tutorial I showed you a pixel enlargement...
<li>Here's the code that did that

<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

#define EOFFSET 150

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2, xs = 0, ys = 0, xe = -1, ye = -1;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    *enlarged, *rout, optchar;
  int xrep, yrep;
  float m;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	case 'x':
	  xs = atoi (optarg);
	  break;

	case 'y':
	  ys = atoi (optarg);
	  break;

	case 'w':
	  xe = xs + atoi (optarg);
	  break;

	case 'l':
	  ye = ys + atoi (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Make sure we have reasonable defaults
  if (xe == -1)
    xe = xs + 10;

  if (ye == -1)
    ye = ys + 10;

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  // Sanity check some of our arguements
  if (xe &gt; width)
    {
      fprintf (stderr,
	       "You choice of starting x position, or width, results in the enlargement falling off the edge of the input image\n");
      usage (argv[0], 43);
    }

  if (ye &gt; height)
    {
      fprintf (stderr,
	       "You choice of starting y position, or length, results in the enlargement falling off the end of the input image\n");
      usage (argv[0], 43);
    }

  printf ("Enlarging a %d by %d portion of the image\n", xe - xs, ye - ys);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  // todo: crap assumption about the data being 8 bps, 3 spp
  if ((enlarged = (char *) malloc (sizeof (char) * (xe - xs) * (ye - ys) * 3 *
				   121)) == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  if ((rout = (char *) malloc (sizeof (char) * (width + EOFFSET) * height * 3))
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for output raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width + EOFFSET);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 3);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Actually do the enlargement of the portion of the image specified
  offset = offset2 = 0;
  for (y = ys; y &lt; ye; y++)
    {
      for (yrep = 0; yrep &lt; 10; yrep++)
	{
	  for (x = xs; x &lt; xe; x++)
	    {
	      offset = (x + (y * width)) * 3;
	      for (xrep = 0; xrep &lt; 10; xrep++)
		{
		  memcpy (enlarged + offset2, raster + offset, 3);
		  offset2 += 3;
		}

	      // The white border to the left of the pixel
	      memset (enlarged + offset2, 255, 3);
	      offset2 += 3;
	    }
	}

      // The white line at the bottom of these pixels
      memset (enlarged + offset2, 255, (ye - ys) * 3 * 11);
      offset2 += (ye - ys) * 3 * 11;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Now we assemble the two parts of the image together into a big output
  // raster
  memset (rout, 255, sizeof (char) * (width + EOFFSET) * height * 3);

  // The original image
  offset = 0;
  offset2 = 0;
  for (y = 0; y &lt; height; y++)
    {
      memcpy (rout + offset2, raster + offset, width * 3);
      offset += width * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  // Box the bit that was enlarged in the original image, can't use memset here
  // Top line
  offset = (((width + EOFFSET) * (ys - 1)) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Bottom line
  offset = (((width + EOFFSET) * ye) + xs - 1) * 3;
  for (x = 0; x &lt; xe - xs + 2; x++)
    {
      rout[offset++] = 255;
      rout[offset++] = 0;
      rout[offset++] = 0;
    }

  // Vertical lines
  offset = (((width + EOFFSET) * ys) + xs - 1) * 3;
  for (y = 0; y &lt; ye - ys + 1; y++)
    {
      rout[offset] = 255;
      rout[offset + 1] = 0;
      rout[offset + 2] = 0;

      rout[offset + ((ye - ys + 1) * 3)] = 255;
      rout[offset + ((ye - ys + 1) * 3) + 1] = 0;
      rout[offset + ((ye - ys + 1) * 3) + 2] = 0;

      offset += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Box the enlarged portion of the image

  /////////////////////////////////////////////////////////////////////////////
  // Draw the two diagonal lines between the original and the enlarged
  //    this bit is based on the premis that y = mx + b
  //    and m = (y2 - y1) / (x2 - x1) and that geometry hasn't significantly
  //    changed since my high school days
  //
  //    if we assume that the first point is the origin, then the maths is
  //    even easier
  // 
  //    which I think is probably a fairly safe set of assumptions at this
  //    stage...
  // todo
  //  printf("ye = %d, xe = %d\n", ye, xe);
  //  m = (ye - ys) / (xe - xs);
  //  for(x = 0; x &lt; (xe - xs); x++){
  //    y = m * x;
  //    
  //    printf("%d, %d (%f = %f)\n", x, y, m, ye / xe);
  //  }

  /////////////////////////////////////////////////////////////////////////////
  // Copy the enlarged portion across

  offset = 0;
  offset2 = (((((height / 2) - ((ye - ys) * 11 / 2)) *
	       (width + EOFFSET)) + width + 20) * 3);
  for (y = 0; y &lt; (ye - ys) * 11; y++)
    {
      memcpy (rout + offset2, enlarged + offset, (ye - ys) * 11 * 3);
      offset += (ye - ys) * 11 * 3;
      offset2 += (width + EOFFSET) * 3;
    }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     (width + EOFFSET) * height * 3 * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (enlarged);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt; -x &lt;start x&gt; -y &lt;start y&gt; -w &lt;width&gt; -l &lt;length&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-pixels/pixel.c</emphasis></para>
</sect1>

<sect1><title>Example: Converting a color image to gray scale</title>
<para>
In one of the previous chapters I also promised to provide the source code for the gray scale conversion examples. Here it is, there are two versions -- a broken algorithm (averaging color values), and a non-broken algorithm (using the NTSC recommended color coefficients).
</para>

<slidetext>
<li>Earlier on I also promised some grayscale conversion code...

<sect2><title>A broken algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.333 + 
		       (unsigned char) (raster[offset + 1]) * 0.333 + 
		       (unsigned char) (raster[offset + 2]) * 0.333);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-wrong.c</emphasis></para>

<para>
Which produces:
</para>

<figure><title>An average of the color values for each pixel</title>
<graphic format="jpg" fileref="gen-grayscale-figure2.jpg">
</figure>
</sect2>

<sect2><title>A sensible algorithm</title>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;tiffio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

void usage (char *, int);

int
main (int argc, char *argv[])
{
  TIFF *input, *output;
  uint32 width, height, offset, offset2;
  tsize_t stripSize, stripNumber;
  unsigned long x, y;
  char *inputFilename = NULL, *outputFilename = NULL, *raster, *roff,
    optchar;
  unsigned char *rout;

  /////////////////////////////////////////////////////////////////////////////
  // Parse the command line options
  while ((optchar = getopt (argc, argv, "i:o:x:y:w:l:")) != -1)
    {
      switch (optchar)
	{
	case 'i':
	  inputFilename = (char *) strdup (optarg);
	  break;

	case 'o':
	  outputFilename = (char *) strdup (optarg);
	  break;

	default:
	  usage (argv[0], 0);
	  break;
	}
    }

  // Open the input TIFF image
  if ((inputFilename == NULL) ||
      (input = TIFFOpen (inputFilename, "r")) == NULL)
    {
      fprintf (stderr, "Could not open incoming input %s\n", inputFilename);
      usage (argv[0], 42);
    }

  // Open the output TIFF
  if ((outputFilename == NULL) ||
      (output = TIFFOpen (outputFilename, "w")) == NULL)
    {
      fprintf (stderr, "Could not open outgoing input %s\n", outputFilename);
      usage (argv[0], 42);
    }

  // Find the width and height of the input
  TIFFGetField (input, TIFFTAG_IMAGEWIDTH, &amp;width);
  TIFFGetField (input, TIFFTAG_IMAGELENGTH, &amp;height);

  /////////////////////////////////////////////////////////////////////////////
  // Grab some memory
  if ((raster = (char *) malloc (sizeof (char) * width * height * 3)) == NULL)
    {
      fprintf (stderr, "Could not allocate enough memory for input raster\n");
      exit (42);
    }

  if ((rout = (unsigned char *) malloc (sizeof (char) * width * height)) 
      == NULL)
    {
      fprintf (stderr,
	       "Could not allocate enough memory for enlarged raster\n");
      exit (42);
    }

  // todo: We need to copy tags from the input image to the output image
  TIFFSetField (output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField (output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField (output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField (output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField (output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
  TIFFSetField (output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField (output, TIFFTAG_SAMPLESPERPIXEL, 1);
  // todo: balance this off with having 8 kb per strip...
  TIFFSetField (output, TIFFTAG_ROWSPERSTRIP, 100000);

  /////////////////////////////////////////////////////////////////////////////
  // Read the input into the memory buffer
  // todo: I couldn't use TIFFReadRGBAStrip here, because it gets confused
  stripSize = TIFFStripSize (input);
  roff = raster;
  for (stripNumber = 0; stripNumber &lt; TIFFNumberOfStrips (input);
       stripNumber++)
    {
      roff += TIFFReadEncodedStrip (input, stripNumber, roff, stripSize);
    }

  /////////////////////////////////////////////////////////////////////////////
  // Convert to grayscale
  offset2 = 0;
  for(offset = 0; offset &lt; width * height * 3; offset += 3){
    rout[offset2++] = ((unsigned char) (raster[offset]) * 0.299 + 
		       (unsigned char) (raster[offset + 1]) * 0.587 + 
		       (unsigned char) (raster[offset + 2]) * 0.114);
  }

  /////////////////////////////////////////////////////////////////////////////
  // Write the image buffer to the file
  if (TIFFWriteEncodedStrip (output, 0, rout,
			     width * height * sizeof (char)) == 0)
    {
      fprintf (stderr, "Could not write the output image\n");
      exit (42);
    }

  // Cleanup
  TIFFClose (input);
  TIFFClose (output);
  free (raster);
  free (rout);
}

void
usage (char *cmd, int exitamt)
{
  fprintf (stderr, "Bad command line arguements...\n\n");
  fprintf (stderr, "Usage: %s -i &lt;inputfile&gt; -o &lt;outputfile&gt;\n", cmd);
  exit (exitamt);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/tiff-grayscale/gray-good.c</emphasis></para>

<para>
Which gives us:
</para>

<figure><title>A correct conversion to gray scale</title>
<graphic format="jpg" fileref="gen-grayscale-figure3.jpg">
</figure>

<para>
Now, just to justify that the second algorithm is better, have a look at the shadows on the hill and the trees in the background. The contrast and darkness of the second picture is might better than the averaging algorithm...
</para>
</sect2>
</sect1>


<sect1><title>Conclusion</title>
<para>
In this chapter we've discussed the TIFF file format, how to program with libtiff for black and white, gray scale and color images. We haven't been through an exhaustive discussion of the possible settings, or all the calls available in libtiff, but you should be ready to start exploring further.
</para>

<slidetext>
<li>So what have we learnt?
  <ul>
  <li>Something about the TIFF file format
  <li>Black and white images with libtiff
  <li>Color images with libtiff
  <li>You should now have enough information to at least start to use libtiff...
  </ul>
</sect1>


<sect1><title>Portions first published by IBM DeveloperWorks</title>
<para>
The basis of this chapter was two articles, first published by IBM DeveloperWorks at http://www.ibm.com/developerworks/ in April and May 2002. This material has been expanded in these chapters from the original 5,000 words.
</para>
</sect1>
</chapter>
<chapter id="chap-gif"><title>GIF</title>
<para>
<quote>
Between 1987 and 1994, GIF (Graphics Interchange Format) peacefully became the most popular file format for archiving and exchanging computer images. At the end of December 1994, CompuServe Inc. and Unisys Corporation announced to the public that developers would have to pay a license fee in order to continue to use technology patented by Unisys in certain categories of software supporting the GIF format. These first statements caused immediate reactions and some confusion. As a longer term consequence, it appears likely that GIF will be replaced and extended by new file formats, but not so before the expiration of the patent which caused so much debate.
</quote> -- http://www.cloanto.com/users/mcb/19950127giflzw.html (The GIF Controversy: A Software Developer's Perspective)
</para>

<slidebreak>
<para>
GIF was once the image format of choice for the Internet, in web browsers at least. This is not nearly as much the case today. The main reason for this is because Unisys has only relatively recently started enforcing the Patent they hold on LZW compression.
</para>

<para>
The disappearance of GIF from the scene is not a major loss, especially as the format was not particularly extensible.
</para>







<sect1><title>The GIF on disc format</title>
<para>
The GIF file format is much simpler than that used for TIFF files. Pay attention to this description though, because it will help explain PNG images when we get to them in a later chapter.
</para>

<slidetext>
<li>The GIF format is quite simple -- the entire specification is only a few pages
<li>We only describe the format
<li>Mainly because it will help with the explaination of PNG


<sect2><title>The data stream</title>
<para>
The outer body of a GIF image is called a data stream, for reasons described in the last few paragraphs. This data stream can be thought of as a file for the purposes of this discussion. The data stream is composed of header, a section called the logical screen, the image data, and a trailer. These elements are described individually below.
</para>

<slidetext>
<li>We're going to refer to the term data stream a bit in the coming slides...
<li>The GIF specification doesn't refer to files
<li>The equivalent concept is a data stream
<li>A data stream doesn't have to be a file
</sect2>

<sect2><title>The header</title>
<table frame='all'><title>GIF on disc: the data stream header</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
<entry>0 - 2</entry>
<entry>A magic number identifying that this is a GIF image. This should be the ASCII characters "GIF".</entry>
</row>

<row>
<entry>3 - 5</entry>
<entry>The version number of the GIF specification this image uses. See below for a list of possible version numbers.</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
There are two main version numbers which are in common use for GIF images. These are:
</para>

<slidetext>
<li>Version number options are:
  <ul>

<itemizedlist>
<listitem><para>87a (released in May 1987)</para></listitem>
<listitem><para>89a (released in July 1989)</para></listitem>
</itemizedlist>

<sect3><title>Version numbers</title>
<para>
The GIF specification makes it quite clear that the image generator should use the lowest version number which matches the functionality required to correctly decode the image. This makes the generation of images a little more complex, as the generator needs to know the specification version number of each feature, but it ensures the maximum possible level of backwards compatability, without sacraficing accuracy of decoding of the image. To quote the GIF specification:
</para>

<slidetext>
<li>The GIF specification states that the image generator should use the lowest version number possible
<li>Whilst still having the image make sense
<li>This makes the generation of images a little more complex
<li>It ensures the maximum backwards compatability

<para>
<quote>The version number in the Header of a Data Stream is intended to identify the minimum set of capabilities required of a decoder in order to fully process the Data Stream. An encoder should use the earliest possible version number that includes all the blocks used in the Data Stream. ... The encoder should make every attempt to use the earliest version number covering all the blocks in the Data Stream; the unnecessary use of later version numbers will hinder processing by some decoders.</quote>
</para>

<slidetext>
<BR><BR>
<li>The version number in the header identifies the minimum set of capabilities required to view that image
</sect3>
</sect2>

<sect2><title>Logical Screen</title>
<para>
The logical screen is the area on which the image will be painted. This block defines the characteristics of this virtual screen:
</para>

<slidetext>
<li>The logical screen is the area on which the image will be painted
<BR><BR>

<table frame='all'><title>GIF on disc: the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0 - 1</entry>
  <entry>Width</entry>
</row>

<row>
  <entry>2 - 3</entry>
  <entry>Height</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

<row>
  <entry>5</entry>
  <entry>Background color index. If a global color table exists, then this indicates the index into that table to use for pixels which are transparent. For instance, the author of the GIF image might have specified a certain shade of blue as representing a transparent pixel. If the global color table is not supported by this image, this value should be zero.</entry>
</row>

<row>
  <entry>6</entry>
  <entry>Pixel aspect ratio -- of the original image. The default value is zero, but if desired, this value can be used to calculate the original image aspect ratio using the formula <emphasis>aspect ratio = (pixel aspect ratio + 15) / 64</emphasis></entry>
</row>
</tbody>
</tgroup>
</table>

<slidebreak>
<para>
The packed fields in byte 4 of the logical screen block are as follows:
</para>

<slidetext>
<li>The packed fields in byte 4 are:
<BR><BR>

<table frame='all'><title>GIF on disc: fields packed into byte 4 of the logical screen block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Global color table flag -- this indicates if there is a global color table in the image file (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>1 - 3</entry>
  <entry>The color resolution (bits per primary color minus one), of the original image before it was converted to GIF. Therefore, for a 24 bit color image which is converted to GIF, this value would be seven.</entry>
</row>

<row>
  <entry>4</entry>
  <entry>Sort flag -- indicates if the global color table is sorted (0 for no, 1 for yes).</entry>
</row>

<row>
  <entry>5 - 7</entry>
  <entry>Size of the global color table. Please note that this is not a simple number representing the size of the table, but must be converted using a formula described below.</entry>
</row>

</tbody>
</tgroup>
</table>

<slidebreak>
<slidetext>
<li><i>
<para>
We have now mentioned the global color table, but haven't defined what it actually means. Don't panic, we'll get there in just a second.
</para>

<slidetext>
</i>

<sect3><title>Formula for global color table size</title>
<para>
To determine the size of the of the global color table, simply apply this formula: <emphasis>size of global color table = 2 ^ (size in table + 1)</emphasis>. The maximum size of the global color table is therefore <emphasis>2 ^ (7 + 1)</emphasis>, or 255 items.
</para>

<slidetext>
<pre>
size of global color table = 2 ^ (size in table + 1)
</pre>

<li>The maximum size is therefore:

<pre>
2 ^ (7 + 1)
</pre>

<li>Which is 255 items
<li>There will actually be three times that number of color bytes in the global color table
<li>... Because colors are 24 bit per pixel

<para>
There will actually be three times that number of color bytes in the global color table, because each color is 24 bit per pixel.
</para>
</sect3>
</sect2>

<sect2><title>Global color table</title>
<para>
If the logical screen block of the image specified that a global color table is present in the image, then this is the next part of the GIF data stream. The global color table is a palette -- in other words, it maps the values actually stored in the image data to the 24 bit values which are the colors.
</para>

<slidetext>
<li>If the logical screen section specified the presence of a global color table, then that is next
<li>The global color table is a palette
<li>The format is very simple
  <ul>
  <li>Just the red, green and blue values
  <li>No header or footer
  </ul>

<para>
The format of the global color table is very simple, it is simply the red, green and blue values stored without any header or footer.
</para>

<slidebreak>
<table frame='all'><title>GIF on disc: the global color table</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Colour 1 red entry</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Colour 1 green entry</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Colour 1 blue entry</entry>
</row>

<row>
  <entry>...</entry>
  <entry></entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x red entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x green entry</entry>
</row>

<row>
  <entry></entry>
  <entry>Colour x blue entry</entry>
</row>

</tbody>
</tgroup>
</table>
</sect2>

<sect2><title>Data</title>
<para>
Next comes the images that are stored in the GIF data stream. GIF data streams are valid, even if there are no images stored within the data stream.
</para>

<slidetext>
<li>Now we get each of the images stored in the GIF file...

<sect3><title>Image descriptors</title>
<para>
<quote>Each image in the Data Stream is composed of an Image Descriptor, an optional Local Color Table, and the image data. Each image must fit within the boundaries of the Logical Screen, as defined in the Logical Screen Descriptor.</quote> -- GIF 89a specification
</para>

<para>
The image descriptor is stored at the start of each image within the data stream. The image description stores information which is specific to that single image, unlike the logical screen section, which has a global scope over all images in the data stream. The image descriptor has the following layout:
</para>

<slidetext>
<BR><BR>
<li>The image descriptor is stored at the start of each image
<li>It stores information which is specific to that single image

<slidebreak>
<table frame='all'><title>GIF on disc: the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x2C -- marks the start of this image</entry>
</row>

<row>
  <entry>1 - 2</entry>
  <entry>Image left position (on the logical screen)</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry>Image top postion (on the logical screen)</entry>
</row>

<row>
  <entry>5 - 6</entry>
  <entry>Image width</entry>
</row>

<row>
  <entry>7 - 8</entry>
  <entry>Image height</entry>
</row>

<row>
  <entry>9</entry>
  <entry>Packed fields. See below for a description.</entry>
</row>

</tbody>
</tgroup>
</table>

<slidebreak>
<para>
The packed field byte stores the following information:
</para>

<slidetext>
<li>The packed field byte stores the following information:
<BR><BR>

<table frame='all'><title>GIF on disc: fields packed into byte 9 of the image descriptor</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bits</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Logical color table flag (0 for no, 1 for yes). If present, this local color table with override the global color table. If there is no global color table in this data stream, then a local color table <emphasis>must</emphasis> be present.</entry>
</row>

<row>
  <entry>1</entry>
  <entry>Interlace flag (0 for no, 1 for yes). See the interlaced images sections below for more information.</entry>
</row>

<row>
  <entry>2</entry>
  <entry>Sort flag (0 for no, 1 for yes). This indicates if the local color table is sorted. <quote>Indicates whether the Local Color Table is sorted. If the flag is set, the Local Color Table is sorted, in order of decreasing importance. Typically, the order would be decreasing frequency, with most frequent color first. This assists a decoder, with fewer available colors, in choosing the best subset of colors; the decoder may use an initial segment of the table to render the graphic.</quote> -- GIF 89a specification</entry>
</row>

<row>
  <entry>3 - 4</entry>
  <entry><emphasis>Reserved for future use</emphasis></entry>
</row>

<row>
  <entry>5 - 8</entry>
  <entry>Size of the local color table. This value obeys the same rules as the size field for the global color table.</entry>
</row>

</tbody>
</tgroup>
</table>
</sect3>

<sect3><title>Local color table</title>
<para>
The format rules for the local color table are identical to those for the global color table.
</para>

<slidetext>
<li>The local color table is the same as the global color table
</sect3>

<sect3><title>Image data</title>
<para>
The raster information for the image is stored in a series of image data blocks, each block having a maximum size of 255 bytes, which works well on machines with very little memory. Each byte is an index into whatever color table entry is active for this image (remembering that the local color table overrides the global color table). Each of these image data blocks is LZW compressed as part of one big buffer. The format of the image data blocks is:
</para>

<slidetext>
<li>The raster information is stored in a series of image data blocks
<li>These have a maximum size of 255 bytes
<li>...This works well on memory limited machines
<li>Each byte is an index into the global or local color table
<li>Each of these data blocks is LZW compressed as part of one big buffer
<BR><BR>

<table frame='all'><title>GIF on disc: the image data block</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>LZW minimum code size (outside the scope of this tutorial)</entry>
</row>

<row>
  <entry>...</entry>
  <entry>Image data subblocks</entry>
</row>
</tbody>
</tgroup>
</table>


<sect4><title>Image data sub blocks</title>
<para>
The format of these image data subblocks is:
</para>

<slidetext>
<li>The format of these image data subblocks is:
<BR><BR>

<table frame='all'><title>GIF on disc: the image data subblocks</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>Block size, in bytes, not including this byte. The maxiumum size if 255 bytes.</entry>
</row>

<row>
  <entry>1 - blocksize</entry>
  <entry>Image data (indices into the relevant color table)</entry>
</row>

</tbody>
</tgroup>
</table>
</sect4>

<sect4><title>Terminating subblock</title>
<para>
The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
</para>

<slidetext>
<li>The last block in the chain of image data subblocks will be a terminating subblock. It will have the format:
<BR><BR>

<table frame='all'><title>GIF on disc: the terminating image subblock</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Bytes</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
  <entry>0</entry>
  <entry>0x0 (i.e. a length of zero)</entry>
</row>

</tbody>
</tgroup>
</table>

</sect4>
</sect3>
</sect2>


<sect2><title>Trailer</title>
<para>
This portion of the GIF image format specifies the end of the data stream. It is really quite simple and doesn't justify a table. It is simply a byte with the value 0x3B.
</para>

<slidetext>
<li>The end of the data stream is signified by the byte 0x3B
</sect2>


</sect1>


<sect1><title>Conclusion</title>
<para>
In this chapter we have learnt how the GIF format is laid out internally. This will be useful when it is time to dicsuss the PNG format...
</para>

<slidetext>
<li>In this chapter we have learnt about the internal layout of the GIF format
</sect1>
</chapter>
<chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
In a sense this PDF chapter is the culmination of the tutorial... Many of the formats we have discussed up to this point can be included in some way in PDF files. I think that PDF is probably the most interesting imaging format in common use today.
</para>

<para>
This chapter is broken into two major sections. These are: a discussion of the PDF format, and then an introduction to Panda, a PDF generation API.
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 <9F><92><9C><9F>
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis><9F><92><9C><9F></emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a look up table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<sect4><title>Arrays</title>
<para>
An array is a one dimensional collection of other values. Unlike most programming languages, the contents of the array can be of several types, for instance we could mix integers with strings in a single array. Arrays start and end with square brackets.
</para>

<sect5><title>Examples</title>
<programlisting>
[(foo) (bar) 42.3 /AName]
</programlisting>
</sect5>
</sect4>
<sect4><title>Boolean</title>
<para>
Boolean values are represented with the words <command>true</command> and <command>false</command>.
</para>

<sect5><title>Examples</title>
<programlisting>
/ExplodeOnOpening true
/Rotate false
</programlisting>
</sect5>
</sect4>
<sect4><title>Names</title>
<para>
A name is a sequence of characters not including whitespace which follow a forward slash. Names are used in object dictionaries for the names of keys, and for some values of keys.
</para>

<sect5><title>Examples</title>
<programlisting>
</programlisting>
</sect5>
</sect4>
<sect4><title>Numbers</title>
<para>
Known as numeric types in the PDF specification (for somewhat obvious reasons), this includes all forms of numbers. These can either be integer or real
  <footnote><para>Non integer</para></footnote>
numbers.
</para>

<sect5><title>Integers</title>
<para>
Integer numbers can be either positive or negative (with a leading sign value if needed) and have a maximum value of ... and a minimum value of ... .

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
123
43445
+176
-17
0
</programlisting>
</sect5>

<sect5><title>Real numbers</title>
<para>
Real numbers can exist in the range ... to ..., and may or may not have leading zeros.

</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
34.5
-3.62
+123.5
4.
-.002
0.0
</programlisting>
</sect5>

<sect5><title>Caveats</title>
<para>
The PDF specification makes the following point:

<quote>PDF does not support the PostScript syntax for numbers with non-decimal radices (such as 16#FFFE) or in exponent format (such as 6.02E23).</quote>
  <footnote><para>PDF Specification 1.3, second edition, page 27</para></footnote>
</para>
</sect5>
</sect4>
<sect4><title>Strings</title>
<para>
Strings are represented a series of unsigned bytes
  <footnote><para>That is, in the range 0 to 255.</para></footnote>
which is identical to the ASCII strings most programmers are familar with in C. There are two main representations of strings. These are:
</para>

<sect5><title>Bracket notation</title>
<para>
Strings can be wrapped in curved brackets such as () to delimit the start and end of the string. Strings may also contain brackets, so long as they are balanced or escaped with a backslash.
</para>

<para>
These are known as literal strings in the PDF specification.
</para>
</sect5>

<sect5><title>Examples</title>
<programlisting>
(hello)
(hello world)
(hello world \(the people I like\))
(hello world (the people I like))
</programlisting>
</sect5>

<sect5><title>Escaped characters</title>
<para>
There are a series of standard characters which are used with the backslash escape. These are:
</para>

<itemizedlist>
<listitem><para><emphasis>\n</emphasis>: Newline</para></listitem>
<listitem><para><emphasis>\r</emphasis>: Carriage return</para></listitem>
<listitem><para><emphasis>\t</emphasis>: Tab</para></listitem>
<listitem><para><emphasis>\b</emphasis>: Backspace</para></listitem>
<listitem><para><emphasis>\f</emphasis>: Form feed</para></listitem>
<listitem><para><emphasis>\(</emphasis>: Open bracket</para></listitem>
<listitem><para><emphasis>\)</emphasis>: Close bracket</para></listitem>
<listitem><para><emphasis>\\</emphasis>: Backslash</para></listitem>
<listitem><para><emphasis>\ddd</emphasis>: Arbitary character (ddd is a number in octal)</para></listitem>
</itemizedlist>

<para>
The backslash operator can also be used to continue text on the next line. For instance:
</para>

<programlisting>
(This is a very long string which we want to \
break over a couple of lines.)
</programlisting>

<para>
This means that we can also embed newlines without using the escape. For instance, these two text blocks are the same:
</para>

<programlisting>
(This is a 
string \
with some lines)
</programlisting>

<para>
and
</para>

<programlisting>
(This is a\nstring with some lines)
</programlisting>

<para>
More on strings in this notation can be found in the PDF specification, version 1.3, on page 30.
</para>
</sect5>

<sect5><title>Hexadecimal notation</title>
<para>
Strings can also be written in hexadecimal form, and in this case are enclosed in angle brackets.
</para>
</sect5>

<sect5><title>Examples</title>
<para>
An example of a hexidecimal string is:
</para>

<programlisting>
&lt;4E6F762073686D6F7A206B6120706F702E&gt;
</programlisting>

<para>
If the final digit is missing, then it is assumed to be zero. For instance, the following string:
</para>

<programlisting>
&lt;901FA&gt;
</programlisting>

<para>
Is the same as:
</para>

<programlisting>
&lt;901FA0&gt;
</programlisting>
</sect5>

</sect4>

<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 


The other type of information which can be stored in a stream is arbitrary information such as the content of images (which would normally be raster information). 


An in depth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<sect4><title>ASCII85Decode</title>
<para>
The ASCII85 filter takes binary data, and turns it into base 85 representation. This is needed by some email clients (among other things), because they can't handle embedding binary data into their protocols.
</para>

<para>
The <emphasis>comp.text.pdf frequently asked questions</emphasis> refers to the code examples below by way of explaination:
</para>

<programlisting>
/* encode85 -- convert to ascii85 format */

#include &lt;stdio.h&gt;
#define	atoi(s)	strtol(s, 0, 0)

static unsigned long width = 72, pos = 0, tuple = 0;
static int count = 0;

void init85(void) {
	printf("&lt;~");
	pos = 2;
}

void encode(unsigned long tuple, int count) {
	int i;
	char buf[5], *s = buf;
	i = 5;
	do {
		*s++ = tuple % 85;
		tuple /= 85;
	} while (--i &gt; 0);
	i = count;
	do {
		putchar(*--s + '!');
		if (pos++ &gt;= width) {
			pos = 0;
			putchar('\n');
		}
	} while (i-- &gt; 0);
}

void put85(unsigned c) {
	switch (count++) {
	case 0:	tuple |= (c &lt;&lt; 24); break;
	case 1: tuple |= (c &lt;&lt; 16); break;
	case 2:	tuple |= (c &lt;&lt;  8); break;
	case 3:
		tuple |= c;
		if (tuple == 0) {
			putchar('z');
			if (pos++ &gt;= width) {
				pos = 0;
				putchar('\n');
			}
		} else
			encode(tuple, count);
		tuple = 0;
		count = 0;
		break;
	}
}

void cleanup85(void) {
	if (count &gt; 0)
		encode(tuple, count);
	if (pos + 2 &gt; width)
		putchar('\n');
	printf("~&gt;\n");
}

void copy85(FILE *fp) {
	unsigned c;
	while ((c = getc(fp)) != EOF)
		put85(c);
}

void usage(void) {
	fprintf(stderr, "usage: encode85 [-w width] file ...\n");
	exit(1);
}

extern int getopt(int, char *[], const char *);
extern int optind;
extern char *optarg;

int main(int argc, char *argv[]) {
	int i;
	while ((i = getopt(argc, argv, "w:?")) != EOF)
		switch (i) {
		case 'w':
			width = atoi(optarg);
			if (width == 0)
				width = ~0;
			break;
		case '?':
			usage();
		}
	
	init85();
	if (optind == argc)
		copy85(stdin);
	else
		for (i = optind; i &lt; argc; i++) {
			FILE *fp = fopen(argv[i], "r");
			if (fp == NULL) {
				perror(argv[i]);
				return 1;
			}
			copy85(fp);
			fclose(fp);
		}
	cleanup85();
	return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/ascii85/encode85.c</emphasis></para>

<programlisting>
/* decode85 -- convert from ascii85 format */

#include &lt;stdio.h&gt;

static unsigned long pow85[] = {
	85*85*85*85, 85*85*85, 85*85, 85, 1
};

void wput(unsigned long tuple, int bytes) {
	switch (bytes) {
	case 4:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		putchar(tuple &gt;&gt;  8);
		putchar(tuple);
		break;
	case 3:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		putchar(tuple &gt;&gt;  8);
		break;
	case 2:
		putchar(tuple &gt;&gt; 24);
		putchar(tuple &gt;&gt; 16);
		break;
	case 1:
		putchar(tuple &gt;&gt; 24);
		break;
	}
}

void decode85(FILE *fp, const char *file) {
	unsigned long tuple = 0;
	int c, count = 0;
	for (;;)
		switch (c = getc(fp)) {
		default:
			if (c &lt; '!' || c &gt; 'u') {
				fprintf(stderr, "%s: bad character in ascii85 region: %#o\n", file, c);
				exit(1);
			}
			tuple += (c - '!') * pow85[count++];
			if (count == 5) {
				wput(tuple, 4);
				count = 0;
				tuple = 0;
			}
			break;
		case 'z':
			if (count != 0) {
				fprintf(stderr, "%s: z inside ascii85 5-tuple\n", file);
				exit(1);
			}
			putchar(0);
			putchar(0);
			putchar(0);
			putchar(0);
			break;
		case '~':
			if (getc(fp) == '&gt;') {
				if (count &gt; 0) {
					count--;
					tuple += pow85[count];
					wput(tuple, count);
				}
				c = getc(fp);
				return;
			}
			fprintf(stderr, "%s: ~ without &gt; in ascii85 section\n", file);
			exit(1);
		case '\n': case '\r': case '\t': case ' ':
		case '\0': case '\f': case '\b': case 0177:
			break;
		case EOF:
			fprintf(stderr, "%s: EOF inside ascii85 section\n", file);
			exit(1);
		}
}

void decode(FILE *fp, const char *file, int preserve) {
	int c;
	while ((c = getc(fp)) != EOF)
		if (c == '&lt;')
			if ((c = getc(fp)) == '~')
				decode85(fp, file);
			else {
				if (preserve)
					putchar('&lt;');
				if (c == EOF)
					break;
				if (preserve)
					putchar(c);
			}
		else
			if (preserve)
				putchar(c);
}

void usage(void) {
	fprintf(stderr, "usage: decode85 [-p] file ...\n");
	exit(1);
}

extern int getopt(int, char *[], const char *);
extern int optind;
extern char *optarg;

int main(int argc, char *argv[]) {
	int i, preserve;
	preserve = 0;
	while ((i = getopt(argc, argv, "p?")) != EOF)
		switch (i) {
		case 'p': preserve = 1; break;
		case '?': usage();
		}
	

	if (optind == argc)
		decode(stdin, "decode85", preserve);
	else
		for (i = optind; i &lt; argc; i++) {
			FILE *fp = fopen(argv[i], "r");
			if (fp == NULL) {
				perror(argv[i]);
				return 1;
			}
			decode(fp, argv[i], preserve);
			fclose(fp);
		}
	return 0;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/ascii85/decode85.c</emphasis></para>

<para>
These two code snippets were written by Paul Haahr, http://www.webcom.com/~haahr/, and is stated to be in the public domain.
</para>

</sect4>
<sect4><title>ASCIIHexDecode</title>
<para>
For similar reasons to ASCII85, you can also represent your binary data as hexidecimal. This filter implements this.
</para>

</sect4>
<sect4><title>CCITTFaxDecode</title>
<para>
This is the compression codec known as group3 and group 4 fax in TIFF. It is about as good as compression gets for black and white images.
</para>

</sect4>
<sect4><title>DCTDecode</title>
<para>
DCT (Descrete Cosine Transform) is the compression codec used by JPEG images. As discussed elsewhere in this document, it is good for color images, but is lossy.
</para>

</sect4>
<sect4><title>FlateDecode</title>
<para>
Flate compression (which is implemented by zlib), is the compression codec using in PNG images. It is very good for colour image and textual data.
</para>

</sect4>
<sect4><title>LZWDecode</title>
<para>
LZW is the compression codec used by GIF images. No publically available libraries implement LZW compression, and it is recommended you don't use it as many Acrobat viewers don't implement LZW decompression. Even Adobe's own products stear away from using this filter.
</para>

</sect4>
<sect4><title>RunLengthDecode</title>
<para>
Run length compression is a very simple compression codec, and it not recommended for most purposes.
</para>
</sect4>

</sect3>
</sect2>

<sect2><title>Object structure</title>
<para>
The diagram below shows the basic object structure of a PDF document. It can be much more complex than this, especially if you reuse commonly used objects like the logo which is on every page of the document. In words, the structure is something like:
</para>

<sect3><title>Catalog Object</title>
<para>
Every PDF document has a catalog object. This catalog object refers to a pages object.
</para>
</sect3>

<sect3><title>Pages object</title>
<para>
The pages object stores a list of pages within the PDF document, in the form of a dictionary array with the key name <quote>/Kids</quote>. Each of these pages will have an object.
</para>
</sect3>

<sect3><title>A Page object per page</title>
<para>
Each page object will have a content object.
</para>
</sect3>

<sect3><title>Content objects</title>
<para>
Each content object will refer to the pages object, as well as referring to resources that that needed to draw this page. The resources can be used by other contents objects as well. Resources are things like fonts, and images.
</para>

<para>
A postscript-like description of the layout of the page is stored in this object's stream.
</para>
</sect3>

<sect3><title>Resources</title>
<para>
A resources object stores information you need to be able to use a given resource such as a font or image.
</para>

<para>
If the resource is an image or an embedded font, then the additional binary data (such as a raster) is stored in this objects stream.
</para>
</sect3>

<sect3><title>Typical object structure</title>
<figure><title>A typical PDF object structure</title>
<graphic format="jpg" fileref="gen-pdf-figure1.jpg">
</figure>
</sect3>
</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft Power Point presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>

<programlisting>
#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage;

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("hello.pdf", "w")) == NULL)
    {
      fprintf (stderr, "Could not open hello.pdf\n");
      exit (1);
    }

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Write some text to the page
  panda_setfont (demo, panda_createfont (demo, "Times-Roman", 1,
  					 "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300, "Hello world");

  // Finished all the demoing, close the PDF document
  panda_close (demo);
  return 0;
}
</programlisting>
<para><emphasis>Code: source/pdf/panda/hello/hello.c</emphasis></para>

<para>
Which produces...
</para>

<figure>
<title>Panda hello world</title>
<graphic format="EPS" fileref="source/pdf/panda/hello/hello.pdf.eps">
</figure>

</sect2>

<sect2><title>Initialization</title>
<para>
Initialization of Panda is easy. Simply call <command>panda_init</command>(). You'll also need to create a PDF document, which is done with the <command>panda_open</command> function.
</para>

<refentry id="panda_init">
<refmeta>
<refentrytitle>panda_init</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_init</refname>
<refpurpose>setup Panda ready for use</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_init (void);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Performs some simple setup of Panda before it is used for the first time in your application.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_init();
</para>
</refsect1>

</refentry>
<refentry id="panda_open">
<refmeta>
<refentrytitle>panda_open</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_open</refname>
<refpurpose>open a PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_pdf * panda_open (char *filename, char *mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Open the named PDF document with the mode specified. The only mode currently supported is "w", but others will be integrated later. The interface to this function is identical in it's behaviour to the <command>fopen</command>() function call offered by the ANSI C standard IO library.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to a panda_pdf structure</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_init, panda_open_actual, panda_open_suppress, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Creating pages</title>
<para>
Pages are created in Panda using the <command>panda_newpage</command> function. You can magically be editing as many pages at a time as you like with Panda without any additional calls being needed.
</para>

<refentry id="panda_newpage">
<refmeta>
<refentrytitle>panda_newpage</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newpage</refname>
<refpurpose>create a new page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 panda_page *panda_newpage(panda_pdf *document, char *pagesize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Create a new blank page at the end of the PDF with the specified size. Use the standard pagesize strings that are defined by Panda for most things. These are <command>panda_pagesize_a4</command>, and <command>panda_pagesize_usletter</command>. If you need to create your own page sizes, then have a look at these for hints.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open, panda_close</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Object properties</title>
<para>
Panda allows you to selectively apply properties to portions of your PDF document. The most common example is choosing which portions of your PDF document to compress.
</para>

<refentry id="panda_setobjectproperty">
<refmeta>
<refentrytitle>panda_setobjectproperty</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setobjectproperty</refname>
<refpurpose>set a property value for an object</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setobjectproperty (panda_object *target, int scope, int propid, int propval);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Properties are a way of specifing things about objects. These properties can have either a cascade scope (they affect all subsequently created objects that are children of that object) -- <command>panda_scope_cascade</command>, or local (they only occur for that object) -- <command>panda_scope_local</command>. Possible properties are defined in the <command>panda_const_properties</command> manual page.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>None</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_object *obj;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 obj = panda_newobject(document, panda_object_normal);
 panda_setproperty(obj, panda_scope_cascade, panda_object_property_compress, panda_true);
 
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newobject, panda_const_properties</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Finalizing</title>
<para>
Pages don't need to be closed in Panda. This is done when the <command>panda_close</command> function is called. This function writes the entire PDF document out to disc.
</para>

<refentry id="panda_close">
<refmeta>
<refentrytitle>panda_close</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_close</refname>
<refpurpose>write a PDF document out to disk</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_close (panda_pdf *document);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Write out the PDF document we have created to disk, clean up and free memory.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_close(document);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_open</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Inserting text</title>
<para>
One of the advantages which ClibPDF has over Panda is that it currently supported word wrap, whereas Panda doesn't. Panda does have a variety of text functionality however. The public text functions in Panda are: <command>panda_textboxrot</command>, which creates a text box at a jaunty angle, <command>panda_textbox</command>, which creates a horizontal textbox (a zero angle), and <command>panda_textdirection</command>, which sets the flow direction for text.
</para>

<refentry id="panda_textbox">
<refmeta>
<refentrytitle>panda_textbox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textbox</refname>
<refpurpose>display some text on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textbox (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textboxrot</para>
</refsect1>

</refentry>
<refentry id="panda_textboxrot">
<refmeta>
<refentrytitle>panda_textboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textboxrot</refname>
<refpurpose>display some text at a jaunty angle on the PDF page specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textbox (panda_pdf * output, panda_page * thisPage, int top, int left, int bottom, int right, double angle, char *text);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call creates a textbox on the specified page, and then displays the specified text within that page. The text is displayed at the spefied angle. The current font mode and style et cetera will be used. Sometime in the near future, line wrapping will be used...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 panda_textboxrot (demo, currPage, 20 + (lineDepth * 20), 200, 40 + (lineDepth * 20), 400, 33.0, "Demonstration of a text mode");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont, panda_setfont, panda_panda_setfontsize, panda_getfontobj, panda_setfontmode, panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling, panda_setleading, panda_textbox</para>
</refsect1>

</refentry>
<refentry id="panda_textdirection">
<refmeta>
<refentrytitle>panda_textdirection</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_textdirection</refname>
<refpurpose>specify the direction that the text flows within the document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_textdirection (panda_pdf *document, int dir);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the direction that the text in the document flows in. The possible values for the dir arguement are: <command>panda_textdirection_l2r</command>, text is read left to right; <command>panda_textdirection_r2l</command>, text is read right to left. The default for this value is <command>panda_textdirection_l2r</command>.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_textdirection(document, panda_textdirection_r2l);
</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Fonts</title>
<para>
Panda currently only supports the standard PDF fonts, and will not allow you to embed arbitrary fonts into your PDF documents (unlike PDFlib). Some users might find this a little limiting for the time being. In Panda, you use fonts by first creating a pointer to the font using <command>panda_createfont</command>, and then start using that font with <command>panda_setfont</command>. This allows you use efficiently create the five fonts you are going to use in the document, and then swap backwards and forwards within that set of five with no performance penalty.
</para>

<refentry id="panda_createfont">
<refmeta>
<refentrytitle>panda_createfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_createfont</refname>
<refpurpose>return a handle to the requested font</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 char * panda_createfont (panda_pdf * output, char *fontname, int type, char *encoding)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para><command>PANDA INTERNAL</command>. This funtion call creates a font object for the requested font and returns the identifier that should be used when the font is set within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A font identifier (handle) as a null terminated string.</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 fonthandle = (output, "Helventica", 3, "MacRomanEncoding");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_setfont">
<refmeta>
<refentrytitle>panda_setfont</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfont</refname>
<refpurpose>set the current font to be that specified</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfont (char *fontident);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Once you have generated a font identifier for a given font, you can then set that current font to that font using this call. Create a font identifier with the <command>panda_createfont</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 char *fonthandle;
 
 panda_init();
 output = panda_open ("output.pdf", "w");
 fonthandle = panda_createfont (output, "Helventica", 3, "MacRomanEncoding");
 panda_setfont (fonthandle);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_createfont</para>
</refsect1>

</refentry>
</sect2>

<sect2><title>Font attributes</title>
<para>
Panda also allows you to set a variety of font attributes...
</para>

<refentry id="panda_setcharacterspacing">
<refmeta>
<refentrytitle>panda_setcharacterspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setcharacterspacing</refname>
<refpurpose>set the space between characters</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setcharacterspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between characters in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setcharacterspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setwordspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>
<refentry id="panda_setfillcolor">
<refmeta>
<refentrytitle>panda_setfillcolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfillcolor</refname>
<refpurpose>set the color to fill a close shape with</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfillcolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the color to fill a close shape with when the shape is closed. It is expressed as a combinartion of red, green, and blue. The maximum number for each value is 255 (a number greater than 255 is reduced to 255).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setfillcolor (page, 100, 200, 300);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 300);
 panda_closeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setfontmode">
<refmeta>
<refentrytitle>panda_setfontmode</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontmode</refname>
<refpurpose>set the current font mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontmode (panda_page *target, int mode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the drawing mode for the current font. Valid modes are: panda_textmode_normal, panda_textmode_outline, panda_textmode_filledoutline, panda_textmode_invisible, panda_textmode_filledclipped, panda_textmode_strokedclipped, panda_textmode_filledstrokedclipped and panda_textmode_clipped.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setfontmode(output, panda_textmode_outline);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontsize, panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_setfontsize">
<refmeta>
<refentrytitle>panda_setfontsize</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setfontsize</refname>
<refpurpose>set the current font size</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setfontsize (panda_page *target, int size);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the size of the font to be used next (in points).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 setfontsize(output, 42);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setfontmode, panda_setfont</para>
</refsect1>

</refentry>
<refentry id="panda_sethorizontalscaling">
<refmeta>
<refentrytitle>panda_sethorizontalscaling</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_sethorizontalscaling</refname>
<refpurpose>set the horizontal scaling of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_sethorizontalscaling (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the horizontal scaling factor of the text in percent.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_sethorizontalscaling(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_setleading</para>
</refsect1>

</refentry>
<refentry id="panda_setleading">
<refmeta>
<refentrytitle>panda_setleading</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setleading</refname>
<refpurpose>set the amount of space between lines of text</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setleading (panda_pdf *output, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of space between lines of text in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setleading(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_setwordspacing, panda_sethorizontalscaling</para>
</refsect1>

</refentry>
<refentry id="panda_setwordspacing">
<refmeta>
<refentrytitle>panda_setwordspacing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setwordspacing</refname>
<refpurpose>set the space between words</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setwordspacing (panda_page *target, double amount);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the amount of additional space between words in points.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *output;
 
 panda_init();
 output = panda_open("output.pdf", "w");
 panda_setwordspacing(output, 42.3);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setcharacterspacing, panda_sethorizontalscaling, panda_setleading</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Inserting raster images</title>
<para>
Panda probably has the best raster image support of any of the PDF libraries available (not including Adobe's libraries). This is because this is my main area of expertise, and has been the main focus of the Panda development effort. For example ClibPDF only supports TIFF images in a limited set of formats, whereas I am not aware of any TIFF files which cannot be inserting into a PDF with Panda. Panda also never creates temporary files on disc when it needs to convert between TIFF formats, unlike PDFlib.
</para>

<sect3><title>TIFF support</title>
<para>
Panda support TIFF fully.
</para>
</sect3>

<sect3><title>JPEG support</title>
<para>
Panda supports JPEG fully.
</para>
</sect3>

<sect3><title>PNG support</title>
<para>
Panda supports PNG fully.
</para>
</sect3>

<sect3><title>Inserting images onto pages</title>
<para>
In Panda you use the <command>panda_imagebox</command>, and the <command>panda_imageboxrot</command> functions to insert images.
</para>

<refentry id="panda_imagebox">
<refmeta>
<refentrytitle>panda_imagebox</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imagebox</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imagebox (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location using a reasonable default for rotation (none). This call is included for backward compatability withprevious releases of the API and it is recommened that new code call <command>panda_imageboxrot</command>(). It is unlikely that this call will be retired however. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imageboxrot</para>
</refsect1>

</refentry>
<refentry id="panda_imageboxrot">
<refmeta>
<refentrytitle>panda_imageboxrot</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_imageboxrot</refname>
<refpurpose>insert an image into the PDF document at the specified location</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_panda_imageboxrot (panda_pdf * output, panda_page * target, int top, int left, int bottom, int right, double angle, char *filename, int type);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function call inserts an image into the PDF document at the specified location, including the ability to rotate the image on the page. It should be noted that xpdf will sometimes make the rotated image look quite sickly. This is in fact a bug in xpdf (which has beenr eported), and not a bug in <command>Panda</command>. The image types accepted by this call are: panda_image_tiff, panda_image_jpeg and panda_image_png.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *demo;
 panda_page *currPage;
 
 panda_init ();
 
 if ((demo = panda_open ("output.pdf", "w")) == NULL)
 panda_error (panda_true, "demo: could not open output.pdf to write to.");
 
 currPage = panda_newpage (demo, panda_pagesize_a4);
 
 panda_imagebox (demo, currPage, 0, 0, currPage->height / 2,
 currPage->width, 45.0, "input.tif", panda_image_tiff);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_imagebox</para>
</refsect1>

</refentry>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>
Panda, supports the full range of PDF vector graphics commands. See the sections below for a description of the functionality available.
</para>

<sect3><title>Lines</title>
<para>
With Panda, the way you draw a line is to first create a line with <command>panda_setlinestart</command>, you then draw line segments with <command>panda_addlinesegment</command>. When you're finished, you close the line with <command>panda_closeline</command>. <command>panda_strokeline</command> is used to force the line to be drawn. You can also add curved segments to a line using <command>panda_addcubiccurvesegment</command>, <command>panda_addquadraticcurvesegmentone</command>, and <command>panda_addquadraticcurvesegmenttwo</command>. Finally, if all you want is a rectangle, then use <command>panda_rectangle</command> to do it for you.
</para>

<refentry id="panda_setlinestart">
<refmeta>
<refentrytitle>panda_setlinestart</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinestart</refname>
<refpurpose>sets the starting point of a curve</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinestart (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the starting point for the sequence of curves and lines that it to be drawn on the current page. This call is compulsory for almost all of the line drawing functions. It is not required for the <command>panda_rectangle</command> call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addlinesegment">
<refmeta>
<refentrytitle>panda_addlinesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addlinesegment</refname>
<refpurpose>add a straight segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addlinesegment (panda_page * target, int x, int y);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a straight line between the current cursor location and (x,y).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_closeline">
<refmeta>
<refentrytitle>panda_closeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_closeline</refname>
<refpurpose>close off the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_closeline(panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Close the line shape we are drawing by returning to the starting point as set by <command>panda_setlinestart</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 400, 300);
 panda_closeline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_endline">
<refmeta>
<refentrytitle>panda_endline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_endline</refname>
<refpurpose>finalise the current line shape</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_endline( panda_page *target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Finalise the line shape we are drawing. Only one line shape may be drawn at any one time. There is no need for this call with the <command>panda_rectangle</command>() call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_strokeline">
<refmeta>
<refentrytitle>panda_strokeline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_strokeline</refname>
<refpurpose>stroke the line shape we have just drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_strokeline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function must be called for the line shape that we have drawn to actually display on the PDF page. This process is known as 'stroking', and hence the name of this function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_strokeline (page);
 panda_endline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry id="panda_addcubiccurvesegment">
<refmeta>
<refentrytitle>panda_addcubiccurvesegment</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addcubiccurvesegment</refname>
<refpurpose>add a curved segment to the line shape we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addcubiccurvesegment (panda_page * target, int x, int y, int cx1, int cy1, int cx2, int cy2);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Add a point to the shape we are currently drawing with a cubic curve between the current cursor location and (x,y). There are two control points used to generate the cubic curve. They are (cx1, cy1) and (cx2, cy2).</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (currPage, 210, 210);
 panda_addcubiccurvesegment (currPage, 310, 210, 225, 300, 275, 400);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addquadraticcurvesegmentone">
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmentone</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmentone</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmentone (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmenttwo</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmentone (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_addquadraticcurvesegmenttwo">
<refmeta>
<refentrytitle>panda_addquadraticcurvesegmenttwo</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_addquadraticcurvesegmenttwo</refname>
<refpurpose>add a curved segment to the line shape that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_addquadraticcurvesegmenttwo (panda_page * target, int x, int y, int cx1, int cy1);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function adds a curved segment to the line shape that we are drawing. The curved segment has a control point, namely (cx1, cy1). This call creates slightly different curves from <command>panda_addquadraticcurvesegmentone</command>();</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addquadraticcurvesegmenttwo (page, 200, 200, 12, 32);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

<refentry id="panda_rectangle">
<refmeta>
<refentrytitle>panda_rectangle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_rectangle</refname>
<refpurpose>draw a rectangle</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_rectangle (panda_page * target, int top, int left, int bottom, int right);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Draw a rectangle on the PDF page. There is no need for the <command>panda_setlinestart</command>() or <command>panda_closeline</command>() calls.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_rectangle( page, 10, 10, 150, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart,  panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
</sect3>

<sect3><title>Fills and other line attributes</title>
<para>
Once you have drawn a line, then it can be filled. You can also configure the state of the pen <emphasis>before</emphasis> you draw the line to change the way it appears...
</para>

<refentry id="panda_fillline">
<refmeta>
<refentrytitle>panda_fillline</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fillline</refname>
<refpurpose>fill the closed shape we just drew</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fillline (panda_page * target);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Fill the shape we have just drawn with the previously defined fill.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_addlinesegment (page, 200, 200);
 panda_addlinesegment (page, 250, 250);
 panda_endline (page);
 panda_fillline (page);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinecap">
<refmeta>
<refentrytitle>panda_setlinecap</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecap</refname>
<refpurpose>sets the line cap for the lines we are drawing now</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecap ( panda_page *target, int cap);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line cap is used at the ends of lines that do not meet other lines. The different cap styles are defined in panda/constants.h and are: panda_linecap_butt, panda_linecap_round and panda_linecap_projectedsquare.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecap (page, panda_linecap_round);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinecolor">
<refmeta>
<refentrytitle>panda_setlinecolor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinecolor</refname>
<refpurpose>change the color of the line drawn</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinecolor (panda_page *target, int red, int green, int blue);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the color of lines being drawn using a combination of red, green and blue.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinecolor (page, 100, 200, 450);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinejoin">
<refmeta>
<refentrytitle>panda_setlinejoin</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinejoin</refname>
<refpurpose>is used to set the line join style</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinejoin (panda_page *target, int join);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>A line join is used where the ends of two lines meet. The valid line joins are defined in panda/constants.h and are: panda_linejoin_miter, panda_linejoin_round and panda_linejoin_bevel.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinejoin (page, panda_linejoin_bevel);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinewidth">
<refmeta>
<refentrytitle>panda_setlinewidth</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinewidth</refname>
<refpurpose>sets the width of the line that we are drawing</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinewidth (panda_page * target, int width);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>Set the width of the line that is being drawn... You can use <command>panda_setlinecap</command>(), <command>panda_setlinejoin</command>() and <command>panda_setlinedash</command>() to change other characteristics of the line.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinewidth (page, 42);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinecap, panda_setlinejoin, panda_setlinedash, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>
<refentry id="panda_setlinedashing">
<refmeta>
<refentrytitle>panda_setlinedashing</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setlinedashing</refname>
<refpurpose>draw the subsequent lines with the defined dashing pattern</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setlinedashing (panda_page *target, int on, int off, int pahse);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function allows the user to define a line dashing style, which is then applied to subsequent lines drawn on that page. The dashing style is defined as a on and off number, as well as a phase. For example, on = 2, off = 4, phase = 0 should result in a line like:</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_setlinestart (page, 100, 200);
 panda_setlinedash (page, 2, 4, 0);
 panda_addlinesegment (page, 200, 200);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_setlinestart, panda_addlinesegment, panda_addcubiccurvesegment, panda_addquadraticsegmentone, panda_addquadraticcurvesegmenttwo, panda_closeline, panda_rectangle, panda_endline, panda_strokeline, panda_fillline, panda_setlinewidth, panda_setlinecap, panda_setlinejoin, panda_setfillcolor, panda_setlinecolor</para>
</refsect1>

</refentry>

</sect3>
</sect2>

<sect2><title>Document meta data</title>
<para>
PDF supports embedding meta data about a document into the PDF itself, and Panda supports this through the following calls:
</para>

<refentry id="panda_setauthor">
<refmeta>
<refentrytitle>panda_setauthor</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setauthor</refname>
<refpurpose>set the author string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setauthor (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the author within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setauthor(document, "Mikal");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_settitle, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_setkeywords">
<refmeta>
<refentrytitle>panda_setkeywords</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setkeywords</refname>
<refpurpose>set the keywords string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setkeywords (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the keywords string within the PDF document. The string is merely a list of keywords in the form "cats dogs hamsters chickens"</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setkeywords(document, "panda documentation pdf api generate");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setsubject, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_setsubject">
<refmeta>
<refentrytitle>panda_setsubject</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_setsubject</refname>
<refpurpose>set the subject string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_setsubject (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the subject within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_setsubject(document, "Mikal's homework");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setauthor, panda_setcreator, panda_settitle, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>
<refentry id="panda_settitle">
<refmeta>
<refentrytitle>panda_settitle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_settitle</refname>
<refpurpose>set the title string for the PDF document</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_settitle (panda_pdf *output, char *value);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function sets the value of the title within the PDF document.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_settitle(document, "Mikal's excellent PDF document");
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_checkinfo, panda_setcreator, panda_setauthor, panda_setsubject, panda_setkeywords, panda_setid</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Presentation support</title>
<para>
PDF can be used for presentations, and therefore allows you to specify a number of interesting things which are normally associated more with Microsoft Power Point presentations...
</para>

<refentry id="panda_centerwindow">
<refmeta>
<refentrytitle>panda_centerwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_centerwindow</refname>
<refpurpose>ask the viewer to center the document's window on the screen when the PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_centerwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application center the displayed PDF document on the screen when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not center the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_centerwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_fitwindow">
<refmeta>
<refentrytitle>panda_fitwindow</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fitwindow</refname>
<refpurpose>ask the viewer to fit the viewer window to the first page of the PDF document when it is opened</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fitwindow (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application fit the display window to the first page of the PDF document when it is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not fit the document to the window.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fitwindow(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_fullscreen">
<refmeta>
<refentrytitle>panda_fullscreen</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_fullscreen</refname>
<refpurpose>ask the viewer to display the PDF document in fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_fullscreen (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application display the document in full screen mode. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to not display the PDF in fullscreen mode.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_fullscreen(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidemenubar">
<refmeta>
<refentrytitle>panda_hidemenubar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidemenubar</refname>
<refpurpose>ask the viewer to hide it's menu bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidemenubar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's menu bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the menu bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidemenubar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidetoolbar">
<refmeta>
<refentrytitle>panda_hidetoolbar</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidetoolbar</refname>
<refpurpose>ask the viewer to hide it's tool bar when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidetoolbar (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's tool bar not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to show the tool bar.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidetoolbar(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_hidewindowui">
<refmeta>
<refentrytitle>panda_hidewindowui</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_hidewindowui</refname>
<refpurpose>ask the viewer to hide it's display window user interface when this PDF is displayed</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_hidewindowui (panda_pdf *document, int onoroff);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information in the output PDF document requesting that the viewing application's window user interface not be displayed when this PDF is opened. This option is not supported by all viewers, and therefore should not be relied upon. The on or off arguement is a panda_true value, which does the obvious thing. The default is to display the user interface.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_hidewindowui(document, panda_true);
</para>
</refsect1>

</refentry>
<refentry id="panda_nfspagemodde">
<refmeta>
<refentrytitle>panda_nfspagemodde</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_nfspagemodde</refname>
<refpurpose>defines display characteristics for the PDF document if it is using non fullscreen mode after defaulting to fullscreen mode</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_nfspagemode (panda_pdf *document, int pagemode);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>If the document in question is using fullscreen mode and then exits from fullscreen mode, then this function configures the behaviour of several of the 'eye candy' options available in some viewers. The possible values for pagemode are: <command>panda_window_usenone</command>, which displays neither the outline or thumbnails (if present); <command>panda_window_useoutlines</command>, which displays only the outline for the document; <command>panda_window_usethumbs</command>, which only displays thumbnails. <command>Please note that this function will only have an effect on the viewer if the page mode has been set to fullscreen with the panda_fullscreen() function call</command></para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 panda_nfspagemode(document, panda_window_usenone);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_fullscreen</para>
</refsect1>

</refentry>
<refentry id="panda_pageduration">
<refmeta>
<refentrytitle>panda_pageduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_pageduration</refname>
<refpurpose>specify the maximum number of seconds that a page should be displayed by the viewer before moving on</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_pageduration (panda_page *target, int seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page should be displayed within the viewer. This is useful for presentations and the like where you might like to automatically move onto the next page in the document at some point. The default value for this is to never move onto the next page automatically. If this value is changed from the default, there is currently no way to revert back to the default later. The feature may not be implemented by all viewers.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_pageduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry id="panda_transduration">
<refmeta>
<refentrytitle>panda_transduration</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transduration</refname>
<refpurpose>specify the number of seconds that a page transition effect should take to occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transduration (panda_page *target, double seconds);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function records information within the PDF indicating the maximum number of seconds that the given page transition effect should be displayed within the viewer. This is useful for presentations and the like when you realise that you are addicted to Microsoft Powerpoint...</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>
<refentry id="panda_transstyle">
<refmeta>
<refentrytitle>panda_transstyle</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_transstyle</refname>
<refpurpose>specify the type of page change transition that should occur</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_transstyle (panda_page *target, int style);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para> his function records information within the PDF indicating the preferred page transition style to use. The following are valid styles to use:
 <orderedlist>
 <listitem><para>panda_pagetrans_split_yi -- vertical split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_yo -- vertical split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xi -- horizontal split from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_split_xo -- horizontal split from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_blinds_y -- vertical blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_blinds_x -- horizontal blinds effect</para></listitem>
 <listitem><para>panda_pagetrans_box_i -- box expanding from the inside of the page</para></listitem>
 <listitem><para>panda_pagetrans_box_o -- box contracting from the outside of the page</para></listitem>
 <listitem><para>panda_pagetrans_wipe_0 -- a single line wipes the page away from the left to the right</para></listitem>
 <listitem><para>panda_pagetrans_wipe_90 -- a single line wipes the page away from the bottom to the top</para></listitem>
 <listitem><para>panda_pagetrans_wipe_180 -- a single line wipes the page away from the right to the left</para></listitem>
 <listitem><para>panda_pagetrans_wipe_270 -- a single line wipes the page away from the top to the bottom</para></listitem>
 <listitem><para>panda_pagetrans_dissolve -- the old page dissolves slowly into the new page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_0 -- a glitter effect that moves from the left to the right of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_270 -- a glitter effect that moves from the top to the bottom of the page</para></listitem>
 <listitem><para>panda_pagetrans_glitter_315 -- a glitter effect that moves from the top left to the bottom right of the page</para></listitem>
 <listitem><para>panda_pagetrans_none -- no transition effect</para></listitem>
 </orderedlist>
 
 </para>
 <para>
 he default transition is to have no transition at all. It should be noted that not all viewers support these transition effects.
</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *page;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 page = panda_newpage (document, panda_pagesize_a4);
 
 panda_transduration (page, 30.5);
</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>Page templates</title>
<para>
A page template is created using <command>panda_newtemplate</command>. A template is just like any other page, and uses all the normal drawing functions. The cool bit is that you can then apply a template to another page using <command>panda_applytemplate</command>. This allows for the standard parts of the page to only be defined once -- which is very useful for things like letterhead.
</para>

<refentry id="panda_newtemplate">
<refmeta>
<refentrytitle>panda_newtemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_newtemplate</refname>
<refpurpose>create a template page in the PDF</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_newtemplate(panda_pdf *document, char *pageSize);

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to create 'template' pages which can then be refered to on other pages. For instance, if you were creating a document that used a standard letter head, then it would make sense to construct the letterhead as a template, and then use this on all the pages. The created template looks and feels just like any other page in the document for the purposes of creating content. Refer to the <command>panda_newpage</command> man page for details on how to use pages.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>A pointer to the template page</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_applytemplate</para>
</refsect1>

</refentry>
<refentry id="panda_applytemplate">
<refmeta>
<refentrytitle>panda_applytemplate</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>panda_applytemplate</refname>
<refpurpose>use a template page previously created</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>
 #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 void panda_applytemplate (panda_pdf * output, panda_page * target,
 panda_page * template)

</synopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>This function is used to use a template created with the <command>panda_newtemplate</command> function call.</para>
</refsect1>

<refsect1>
<title>RETURNS</title>
<para>Nothing</para>
</refsect1>

<refsect1>
<title>EXAMPLE</title>
<para> #include&lt;panda/constants.h&gt;
 #include&lt;panda/functions.h&gt;
 
 panda_pdf *document;
 panda_page *templatepage, *realpage;
 
 panda_init();
 
 document = panda_open("filename.pdf", "w");
 templatepage = panda_newtemplate (document, panda_pagesize_a4);
 realpage = panda_newpage (document, panda_pagesize_a4);
 
 ... the order of the drawing commands to the two pages doesn't matter ...
 
 panda_applytemplate(document, realpage, templatepage);
</para>
</refsect1>

<refsect1>
<title>SEE ALSO</title>
<para>panda_newpage, panda_newtemplate</para>
</refsect1>

</refentry>

</sect2>

<sect2><title>A full Panda example</title>
<para>
This section presents a full Panda example showing what the library is capable of. This code comes from the Panda distribution:
</para>

<programlisting>

#include  &lt;panda/functions.h&gt;
#include  &lt;panda/constants.h&gt;

int
main (int argc, char *argv[])
{
  panda_pdf *demo;
  panda_page *currPage, *templatePage;
  int lineDepth, trans;
  char tempString[1024], *tempPtr;

  printf ("Welcome to the Panda 0.4 sample application...\n");

  // Initialise the library
  panda_init ();

  // Open our demo PDF
  if ((demo = panda_open ("output.pdf", "w")) == NULL)
    panda_error (panda_true, "demo: could not open output.pdf to write to.");

  // These are normally commented out because they are annoying
  //panda_hidetoolbar (demo, panda_true);
  //panda_hidemenubar (demo, panda_true);
  //panda_hidewindowui (demo, panda_true);

  if ((argc &gt; 1) &amp;&amp; (strcmp (argv[1], "compressed") == 0))
    {
      printf ("Turn on compression\n");

      panda_setproperty (demo-&gt;pages, panda_scope_cascade,
			 panda_object_property_compress, panda_true);

      printf ("Just before compression level set\n");

      panda_setproperty (demo-&gt;pages, panda_scope_cascade,
			 panda_object_property_compress_level, 9);
    }
  else
    printf ("For compressed sample, use %s compressed\n", argv[0]);

  // Image functionality
  ///////////////////////////////////////////////////////////////////////////

  // Create a page
  currPage = panda_newpage (demo, panda_pagesize_a4);

  // Put in the background images
  panda_imagebox (demo, currPage, 0, 0, currPage-&gt;height / 2,
		  currPage-&gt;width, "images/input.tif", panda_image_tiff);
  panda_imagebox (demo, currPage, currPage-&gt;height / 2, 0,
		  currPage-&gt;height, currPage-&gt;width, "images/input2.tif",
		  panda_image_tiff);

  panda_imagebox (demo, currPage, 317, 317, 434, 434, "images/gnu_box.jpg",
		  panda_image_jpeg);
  panda_imagebox (demo, currPage, 434, 434, 551, 551, "images/gnu_box.jpg",
		  panda_image_jpeg);

  // Do an panda_imageboxrot or two to test the code included by Ceasar Miquel
  panda_imageboxrot (demo, currPage, 600, 0, 717, 117, 15.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 600, 200, 717, 317, 30.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 600, 400, 717, 517, 42.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 700, 0, 817, 117, 90.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  panda_imageboxrot (demo, currPage, 700, 200, 817, 317, 132.0,
		     "images/gnu_box.jpg", panda_image_jpeg);

  // Insert a PNG to show that I can
  panda_imageboxrot (demo, currPage, 100, 200, 200, 300, 0.0,
		     "images/libpng.png", panda_image_png);

  panda_imageboxrot (demo, currPage, 300, 200, 400, 300, 0.0,
		     "images/gnu.png", panda_image_png);

  panda_imageboxrot (demo, currPage, 100, 420, 310, 620, 36.0,
		     "images/RedbrushAlpha.png", panda_image_png);

  // (c) statement
  panda_setfont (demo, tempPtr = panda_createfont (demo, "Times-Roman", 1,
						   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 600, 10, 700, 300,
		 "The background image on this page is Copyright 2000 Andrew Cagney");
  panda_textbox (demo, currPage, 620, 10, 720, 300,
		 "and is distributed under the terms of the GPL...");
  panda_textbox (demo, currPage, 310, 320, 330, 800,
		 "Flower (c) 1999 Pieter S. van der Meulen");
  free (tempPtr);

  panda_setfont (demo, tempPtr =
		 panda_createfont (demo, "Helvetica-Bold", 1,
				   "MacRomanEncoding"));
  panda_textboxrot (demo, currPage, 200, 30, 230,
		 30, 45.0, "With new improved angled text!");
  free (tempPtr);

  ///////////////////////////////////////////////////////////////////////////
  // Text functionality (with a few images thrown in as well)
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);

  // I am not drawing a multiline string here because I am not sure how to 
  // represent this in the PDF at the moment
  sprintf (tempString,
	   "Hello %c5World! %cMy name %c5is Panda!\nAnd I am a PDF generator\nI handle multiple line text ok .once you have set a leading.",
	   4, 6, 5);
  panda_textbox (demo, currPage, 10, 10, 100, 30, tempString);

  panda_setfont (demo, tempPtr = panda_createfont (demo, "Symbol", 1,
						   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 50, 10, 100, 30, "Symbol");
  free (tempPtr);

  panda_setfont (demo, tempPtr =
		 panda_createfont (demo, "Helvetica-Bold", 1,
				   "MacRomanEncoding"));
  panda_textbox (demo, currPage, 70, 30, 100, 30, "A line in Helvetica-Bold");
  free (tempPtr);

  panda_imagebox (demo, currPage, 100, 100, 150, 150, "images/gnu-head.jpg",
		  panda_image_jpeg);
  panda_textbox (demo, currPage, 90, 110, 200, 200, "INFRONTINFRONTINFRONT");

  panda_textbox (demo, currPage, 190, 210, 300, 300, "BEHINDBEHINDBEHIND");
  panda_imagebox (demo, currPage, 200, 200, 317, 317, "images/gnu_box.jpg",
		  panda_image_jpeg);

  panda_textbox (demo, currPage, 300, 10, 400, 50,
		 "A second textbox on the page");

  ///////////////////////////////////////////////////////////////////////////
  // Demonstrate the supported text modes
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);
  panda_setleading (demo, 16.0);

  for (lineDepth = 0; lineDepth &lt; 8; lineDepth++)
    {
      panda_setfontmode (demo, panda_textmode_normal);

      switch (lineDepth)
	{
	case panda_textmode_normal:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Normal");
	  break;

	case panda_textmode_outline:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Outline");
	  break;

	case panda_textmode_filledoutline:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "FilledOutline");
	  break;

	case panda_textmode_invisible:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Invisible");
	  break;

	case panda_textmode_filledclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "FilledClipped");
	  break;

	case panda_textmode_strokedclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Stroked Clipped");
	  break;

	case panda_textmode_filledstrokedclipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400,
			 "Filled Stroked Clipped");
	  break;

	case panda_textmode_clipped:
	  panda_textbox (demo, currPage, 20 + (lineDepth * 20), 10,
			 40 + (lineDepth * 20), 400, "Clipped");
	  break;
	}

      panda_setcharacterspacing (demo, (double) lineDepth);
      panda_setwordspacing (demo, (double) lineDepth * 10);
      panda_sethorizontalscaling (demo, (double) 1 - (lineDepth * 0.1));

      panda_setfontmode (demo, lineDepth);
      panda_textbox (demo, currPage, 20 + (lineDepth * 20), 200,
		     40 + (lineDepth * 20), 400,
		     "Demonstration of a text mode");
    }

  ///////////////////////////////////////////////////////////////////////////
  // Demonstrate the supported lines and curve thingies -- note that no
  // graphics state is held from the previous set of lines, so you'll need
  // to rebuild it each time.
  ///////////////////////////////////////////////////////////////////////////

  currPage = panda_newpage (demo, panda_pagesize_a4);

  panda_setfontmode (demo, panda_textmode_normal);
  panda_textbox (demo, currPage, 40, 10, 55, 200,
		 "Please note that these shapes are lines, and there is no");
  panda_textbox (demo, currPage, 60, 10, 75, 200,
		 "requirement to have the shapes closed...");

  // Straight lines of all types -- stroked
  panda_setlinestart (currPage, 110, 110);
  panda_addlinesegment (currPage, 160, 130);
  panda_addlinesegment (currPage, 210, 186);
  panda_addlinesegment (currPage, 96, 22);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Now some curves -- stroked
  panda_setlinestart (currPage, 210, 210);
  panda_addcubiccurvesegment (currPage, 310, 210, 225, 300, 275, 400);
  panda_addquadraticcurvesegmentone (currPage, 160, 160, 200, 225);
  panda_addquadraticcurvesegmenttwo (currPage, 210, 210, 250, 375);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Rectangles -- stroked
  panda_rectangle (currPage, 210, 210, 310, 310);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Straight lines of all types -- stroked and filled
  panda_setlinecolor (currPage, 99, 33, 255);
  panda_setfillcolor (currPage, 112, 38, 300);
  panda_setlinestart (currPage, 110, 310);
  panda_setlinewidth (currPage, 5);
  panda_addlinesegment (currPage, 160, 330);
  panda_addlinesegment (currPage, 210, 386);
  panda_addlinesegment (currPage, 96, 222);
  panda_closeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Now some curves -- stroked and filled
  panda_setfillcolor (currPage, 112, 138, 37);
  panda_setlinestart (currPage, 210, 410);
  panda_setlinewidth (currPage, 5);
  panda_addcubiccurvesegment (currPage, 310, 410, 225, 500, 275, 600);
  panda_addquadraticcurvesegmentone (currPage, 160, 360, 200, 425);
  panda_addquadraticcurvesegmenttwo (currPage, 210, 410, 250, 575);
  panda_closeline (currPage);
  //panda_strokeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Rectangles -- stroked filled
  panda_setfillcolor (currPage, 38, 38, 38);
  panda_setlinewidth (currPage, 5);
  panda_rectangle (currPage, 410, 210, 510, 310);
  //panda_strokeline (currPage);
  panda_fillline (currPage);
  panda_endline (currPage);

  // Straight lines of all types -- stroked and capped
  panda_setlinewidth (currPage, 10);
  panda_setlinestart (currPage, 100, 600);
  panda_addlinesegment (currPage, 200, 600);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_butt);
  panda_setlinestart (currPage, 100, 625);
  panda_addlinesegment (currPage, 200, 625);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_round);
  panda_setlinestart (currPage, 100, 650);
  panda_addlinesegment (currPage, 200, 650);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_projectedsquare);
  panda_setlinestart (currPage, 100, 675);
  panda_addlinesegment (currPage, 200, 675);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Mitre joints
  panda_setlinewidth (currPage, 10);
  panda_setlinecap (currPage, panda_linecap_butt);
  panda_setlinestart (currPage, 300, 600);
  panda_addlinesegment (currPage, 350, 650);
  panda_addlinesegment (currPage, 400, 600);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_miter);
  panda_setlinestart (currPage, 300, 625);
  panda_addlinesegment (currPage, 350, 675);
  panda_addlinesegment (currPage, 400, 625);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_round);
  panda_setlinestart (currPage, 300, 650);
  panda_addlinesegment (currPage, 350, 700);
  panda_addlinesegment (currPage, 400, 650);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinewidth (currPage, 10);
  panda_setlinejoin (currPage, panda_linejoin_bevel);
  panda_setlinestart (currPage, 300, 675);
  panda_addlinesegment (currPage, 350, 725);
  panda_addlinesegment (currPage, 400, 675);
  panda_strokeline (currPage);
  panda_endline (currPage);

  // Do some work with line dashing
  panda_setlinedash (currPage, 1, 0, 0);
  panda_setlinejoin (currPage, panda_linejoin_round);

  panda_setlinestart (currPage, 100, 800);
  panda_addlinesegment (currPage, 100, 750);
  panda_addlinesegment (currPage, 140, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinedash (currPage, 3, 3, 0);
  panda_setlinestart (currPage, 150, 800);
  panda_addlinesegment (currPage, 150, 750);
  panda_addlinesegment (currPage, 190, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  panda_setlinedash (currPage, 2, 1, 1);
  panda_setlinestart (currPage, 200, 800);
  panda_addlinesegment (currPage, 200, 750);
  panda_addlinesegment (currPage, 240, 800);
  panda_closeline (currPage);
  panda_strokeline (currPage);
  panda_endline (currPage);

  ///////////////////////////////////////////////////////////////////////////
  // Why not have some annotations as well?
  ///////////////////////////////////////////////////////////////////////////

  panda_textannotation(demo, currPage, panda_true, "Hello", "Text annotation",
		       10, 10, 50, 50, 1.0, 0.0, 0.0,
		       panda_icon_comment, 0);
  panda_lineannotation(demo, currPage, "Line annotation", "Line annotation",
		       50, 50, 150, 150, 
		       150, 150, 200, 200, 
		       0.0, 1.0, 0.0, 0);

  ///////////////////////////////////////////////////////////////////////////
  // We can also setup template pages to make life a little easier (and the
  // document a little smaller)
  ///////////////////////////////////////////////////////////////////////////

  templatePage = panda_newtemplate(demo, panda_pagesize_a4);
  panda_setlinestart (templatePage, 100, 800);
  panda_addlinesegment (templatePage, 100, 750);
  panda_addlinesegment (templatePage, 140, 800);
  panda_closeline (templatePage);
  panda_strokeline (templatePage);
  panda_endline (templatePage);

  panda_setlinedash (templatePage, 3, 3, 0);
  panda_setlinestart (templatePage, 150, 800);
  panda_addlinesegment (templatePage, 150, 750);
  panda_addlinesegment (templatePage, 190, 800);
  panda_closeline (templatePage);
  panda_strokeline (templatePage);
  panda_endline (templatePage);

  currPage = panda_newpage(demo, panda_pagesize_a4);
  panda_applytemplate(demo, currPage, templatePage);

  ///////////////////////////////////////////////////////////////////////////
  // Let's try some transitions
  ///////////////////////////////////////////////////////////////////////////
  
  for(trans = 0; trans &lt; panda_pagetrans_none; trans++)
    {
      currPage = panda_newpage(demo, panda_pagesize_a4);
      panda_pageduration(demo, currPage, 5);
      panda_transduration(demo, currPage, 5.0);
      panda_transstyle(demo, currPage, trans);
      
      panda_setlinecolor (currPage, trans * 20, 0, trans * 10);
      panda_setfillcolor (currPage, trans * 20, 0, trans * 10);
      panda_setlinestart (currPage, 0, 0);
      panda_setlinewidth (currPage, 5);
      panda_addlinesegment (currPage, 1000, 0);
      panda_addlinesegment (currPage, 1000, 1000);
      panda_addlinesegment (currPage, 0, 1000);
      panda_closeline (currPage);
      panda_fillline (currPage);
      panda_endline (currPage);
    }

  currPage = panda_newpage(demo, panda_pagesize_a4);

  // Finished all the demoing, close the PDF document
  panda_close (demo);

  // We should return a value here
  return 0;
}

// Allow a callback to be setup to display a dialog box for an error or
// whatever before we terminate the application
void
panda_errorCallback (char *description)
{
  fprintf (stderr, "Callback: %s\n", description);
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/panda/examples/main.c</emphasis></para>

<para>
It produces output like:
</para>

</sect2>

</sect1>




























<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
<programlisting>
%{
#include "parser.h"
#include "lexinterface.h"
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

void debuglex(char *, int, char *);
char *returnStr(char *, int);
void *pandalex_xmalloc(size_t);
void *pandalex_xrealloc(void *, size_t);
char *pandalex_xsnprintf(char *, ...);
void pandalex_error(char *);

void *
pandalex_xmalloc (size_t size)
{
  void *buffer;

  if ((buffer = malloc (size)) == NULL)
    {
      pandalex_error ("pandalex_xmalloc failed to allocate memory");
    }

  return buffer;
}
void *
pandalex_xrealloc (void *memory, size_t size)
{
  void *buffer;

  if ((buffer = realloc (memory, size)) == NULL)
    {
      pandalex_error ("pandalex_xrealloc failed to allocate memory");
    }

  return buffer;
}

char *
pandalex_xsnprintf (char *format, ...)
{
  char *output = NULL;
  int size, result;
  va_list ap;

  /* We start with the size of the format string as a guess */
  size = strlen (format);
  va_start (ap, format);

  while (1)
    {
      output = pandalex_xrealloc (output, size);
      result = vsnprintf (output, size, format, ap);

      if (result == -1)
        {
          /* Up to glibc 2.0.6 and Microsoft's implementation*/
          size += 100;
        }
      else
        {
          /* Check if we are done */
      if (result &lt; size)
            break;

          /* Glibc from now on */
          size = result + 1;
        }
  }

  va_end (ap);
  return output;
}

void
pandalex_error(char *msg){
fprintf(stderr, "%s\n", msg);
exit(42);
}
%}

%x BINARY
%%

&lt;INITIAL&gt;\%PDF-[0-9]+\.[0-9]+    { debuglex(yytext, -1, "version");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return VERSION;
                                                                             }

&lt;INITIAL&gt;[ \t\r\n]+              { debuglex(yytext, -1, "whitespace");
                                                                          }

&lt;INITIAL&gt;xref                    { debuglex(yytext, -1, "xref");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return XREF;
                                                                             }

&lt;INITIAL&gt;trailer                 { debuglex(yytext, -1, "trailer");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return TRAILER;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+,]+ { debuglex(yytext, -1, "name");
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;\/[#a-zA-Z\-_0-9\.\+]+ { debuglex(yytext, -1, "dbllt-name");
                            yyless(2);
                            return DBLLT;
                                                                             }

&lt;INITIAL&gt;\/[#a-zA-Z\-_0-9\.\+]+\&gt;\&gt;     { debuglex(yytext, -1, "name-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext + 1, -1);
                            yylval.sval.len = yyleng - 1;
                            return NAME;
}

                        /* --- stuff required for objects ---               */
&lt;INITIAL&gt;R                       { debuglex(yytext, -1, "object reference");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\&gt;\&gt;                       { debuglex(yytext, -1, "object-reference-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;R\/                       { debuglex(yytext, -1, "object-reference-namestart");
                            yyless(yyleng - 1);
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJREF; 
                                                                             }

&lt;INITIAL&gt;obj                     { debuglex(yytext, -1, "obj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return OBJ; 
                                                                             }

&lt;INITIAL&gt;endobj                  { debuglex(yytext, -1, "endobj");
                            yylval.sval.data = (char *) returnStr(yytext, -1);
                            yylval.sval.len = yyleng;
                            return ENDOBJ; 
                                                                             }

&lt;INITIAL&gt;stream                  { debuglex(yytext, -1, "stream");
                          BEGIN(BINARY);
                          return STREAM;                                     }

&lt;INITIAL&gt;[+-]?[0-9]+             { debuglex(yytext, -1, "integer");
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\&gt;\&gt;             { debuglex(yytext, -1, "integer-dblgt");
                            yyless(yyleng - 2);
                            yylval.intVal = atoi(yytext);
                            return INT; 
                                                                             }


&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+     { debuglex(yytext, -1, "floating point");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return FP; 
                                                                             }

&lt;INITIAL&gt;[+-]?[0-9]+\.[0-9]+\&gt;\&gt;     { debuglex(yytext, -1, "floating point");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return FP; 
                                                                             }

&lt;INITIAL&gt;\&lt;\&lt;                    { debuglex(yytext, -1, "&lt;&lt;");
                            return DBLLT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;");
                            return DBLGT; 
                                                                             }

&lt;INITIAL&gt;\&gt;\&gt;\&gt;\&gt;                    { debuglex(yytext, -1, "&gt;&gt;&gt;&gt;");
                            yyless(yyleng - 2);
                            return DBLGT; 
                                                                             }


&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\]*)+ { 
                          debuglex(yytext, -1, "string");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;

                            if(strcmp(yytext, "endstream") == 0){
                              BEGIN(INITIAL);
                              return ENDSTREAM;
                              }

                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\[(([^\[\]])|(\\\[)|(\\\]))*\] {
                          debuglex(yytext, -1, "bracketted string v1");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng); 
                            yylval.sval.len = yyleng;
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\((([^\(\)])|(\\\()|(\\\)))*\) {
                          debuglex(yytext, -1, "bracketted string v2");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;\&lt;(([^\&lt;\&gt;])|(\\\&lt;)|(\\\&gt;))*\&gt; {
                          debuglex(yytext, -1, "bracketted string v3");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;([#a-zA-Z0-9\.:'+\-!_]+[a-zA-Z0-9\.:'+\-!_\\\/]*)+\&gt;\&gt; { 
                          debuglex(yytext, -1, "string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

&lt;INITIAL,BINARY&gt;[\[\(][#&lt;&gt;a-zA-Z0-9\.\ :'+\-_\\\(\)]+[\)\]]\&gt;\&gt; {
                          debuglex(yytext, -1, "bracketted-string-dblgt");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return STRING; 
                                                                             }

                        /* --- Array handling ---                           */

&lt;INITIAL&gt;\[                      { debuglex(yytext, -1, "[");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ARRAY; 
                                                                             }

&lt;INITIAL&gt;\]                      { debuglex(yytext, -1, "]");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

&lt;INITIAL&gt;\]\&gt;\&gt;                      { debuglex(yytext, -1, "]");
                            yyless(yyleng - 2);
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng; 
                            return ENDARRAY; 
                                                                             }

                        /* --- Stuff needed for the xref and trailer ---    */

&lt;INITIAL&gt;\%\%EOF                 { debuglex(yytext, -1, "end of file");
                            return PDFEOF; 
                                                                             }

                        /* --- Stuff used to match binary streams --- 

                               The following amazing production is
                               used to deal with the massive
                               streams that images can create              */

&lt;BINARY&gt;[^end]+           { debuglex(yytext, yyleng, "binary mode");
                          yylval.sval.data = (char *) returnStr(yytext, yyleng);
                          yylval.sval.len = yyleng;
                          return ANYTHING;
                                                                             }

.                       { debuglex("!", -1, "the catch all");
                            yylval.sval.data = (char *) returnStr(yytext, yyleng);
                            yylval.sval.len = yyleng;
                            return ANYTHING; 
                                                                             }

%%

void debuglex(char *text, int len, char *desc){
#if defined DEBUG
  int i;

  printf("Lexer rule is \"%s\", match is \"", desc);  

  for(i = 0; i &lt; ((len == -1) ? strlen(text) : len); i++){
    if(text[i] == '\n') printf(" \\n " );
    else if(text[i] == '\t') printf(" \\t ");
    else if(text[i] == '\r') printf(" \\r ");
    else if(text[i] == ' ') printf(" sp ");
    else if(isprint(text[i])) printf("%c", text[i]);
    else printf(" \\%d ", (unsigned char) text[i]);
    }

  printf("\"\n");
#endif
}

char *returnStr(char *yytext, int len){
  char *lval;

  if((lval = malloc(sizeof(char) * 
    ((len == -1) ? strlen(yytext) : len) + 1)) == NULL)
    error("Could not make space for lexer return.");
  memcpy(lval, yytext, ((len == -1) ? strlen(yytext) : len) + 1);

  return lval;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexer.l</emphasis></para>
</sect2>

<sect2><title>lexinterface.h</title>
<programlisting>
// This file defines the callbacks that users can setup to use PandaLex

#include &lt;stdarg.h&gt;

enum{
  pandalex_event_begindocument = 0,
    pandalex_event_specver,
    pandalex_event_entireheader,
    pandalex_event_objstart,
    pandalex_event_objend,
    pandalex_event_dictitem_string,
    pandalex_event_dictitem_name,
    pandalex_event_dictitem_arraystart,
    pandalex_event_dictitem_arrayitem,
    pandalex_event_dictitem_arrayend,
    pandalex_event_dictitem_object,
    pandalex_event_dictitem_dict,
    pandalex_event_dictitem_dictend,
    pandalex_event_dictitem_int,
    pandalex_event_stream,
    pandalex_event_dictint,
    pandalex_event_xrefstart,
    pandalex_event_xrefitem,
    pandalex_event_xrefend,
    pandalex_event_trailerstart,
    pandalex_event_trailerend,
    pandalex_event_enddocument,
    pandalex_event_max
    };

// Callbacks are defined so that they have a type for the arguments they
// possess associated with them. Where possible the arguments created by the
// lexer will be converted into the types needed by the callback. If not,
// an error is returned
typedef void (*pandalex_callback_type)(int, va_list);


void pandalex_setupcallback(int, pandalex_callback_type);
void pandalex_callback(int, ...);

</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/lexinterface.h</emphasis></para>
</sect2>

<sect2><title>pandalex.h</title>
<programlisting>
char *pandalex_strmcat(char *, int, char *, int);
char *pandalex_strmcpy(char *, int);
int pandalex_intlen(int);
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/pandalex.h</emphasis></para>
</sect2>

<sect2><title>parser.y</title>
<programlisting>
%{
  #include "lexinterface.h"
  #include "samples.h"
  #include "pandalex.h"

  #include &lt;stdarg.h&gt;

  #define YYMAXDEPTH 50000
  #define YYERROR_VERBOSE 1

  // The callbacks
  pandalex_callback_type pandalex_callbacks[pandalex_event_max];
%}

          /* Define the possible yylval values */
%union {
  int        intVal;

  struct streamVal{
    char *data;
    int len;
  } sval;
}

%token &lt;sval&gt; VERSION
%token &lt;sval&gt; NAME
%token &lt;sval&gt; STRING
%token &lt;sval&gt; OBJREF &lt;sval&gt; OBJ &lt;sval&gt; ENDOBJ 
%token &lt;intVal&gt; INT
%token &lt;sval&gt; FP
%token &lt;sval&gt; DBLLT &lt;sval&gt; DBLGT
%token &lt;sval&gt; STREAM &lt;sval&gt; ENDSTREAM
%token &lt;sval&gt; ARRAY &lt;sval&gt; ENDARRAY &lt;sval&gt; ENDARRAYDBLGT
%token &lt;sval&gt; PDFEOF XREF TRAILER
%token &lt;sval&gt; ANYTHING

%type &lt;sval&gt; binary
%type &lt;sval&gt; header
%type &lt;sval&gt; objref
%type &lt;sval&gt; arrayvals

%type &lt;intVal&gt; dictionary
%type &lt;intVal&gt; subdictionary

%%

// completely implemented
pdf       : { pandalex_callback(pandalex_event_begindocument, ""); } 
            header { pandalex_callback(pandalex_event_entireheader, $2.data); } 
            object linear objects xref trailer endcrap
          ;

// completely implemented
header    : VERSION { pandalex_callback(pandalex_event_specver, $1.data); }
            binary { $$.data = pandalex_strmcat($1.data, $1.len, $3.data, $3.len); $$.len = $1.len + $3.len + 1; }
          ;

linear    : xref trailer { }
          |
          ;

// Clibpdf sometimes puts some binary crap at the end of the file (pointer
// problems?)
// completely implemented
endcrap   : binary { }
          |
          ;

// completely implemented
objects   : object objects
          | 
          ;

// todo_mikal: might need a .data here
object    : INT INT OBJ { pandalex_callback(pandalex_event_objstart, $1, $2); } 
            dictionary { if($5 != -1) pandalex_callback(pandalex_event_dictint, $1, $2, $5); } 
            stream ENDOBJ { pandalex_callback(pandalex_event_objend, $1, $2); }
          ;

dictionary: DBLLT dict DBLGT { $$ = -1; }
          | INT { $$ = $1; }
          | ARRAY arrayvals ENDARRAY { $$ = -1; }
          | objref { $$ = -1; }
          | NAME { $$ = -1; }
          | STRING { $$ = -1 };
          | { $$ = -1; }
          ;

subdictionary: DBLLT dict DBLGT { $$ = -1 };

dict      : NAME STRING { pandalex_callback(pandalex_event_dictitem_string, $1.data, $2.data); } dict
          | NAME NAME { pandalex_callback(pandalex_event_dictitem_name, $1.data, $2.data); } dict
          | NAME ARRAY { pandalex_callback(pandalex_event_dictitem_arraystart, $1.data); } 
              arrayvals ENDARRAY { pandalex_callback(pandalex_event_dictitem_arrayend, $1.data); } dict
          | NAME objref { pandalex_callback(pandalex_event_dictitem_object, $1.data, $2.data); } dict
          | NAME { pandalex_callback(pandalex_event_dictitem_dict, $1.data); } 
              subdictionary { pandalex_callback(pandalex_event_dictitem_dictend, $1.data); } dict
          | NAME INT { pandalex_callback(pandalex_event_dictitem_int, $1.data, $2); } dict
          | NAME FP {} dict
          | 
          ;

arrayvals : objref { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals 
          | INT { /*todo*/ } arrayvals
          | NAME { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | STRING { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | ARRAY { pandalex_callback(pandalex_event_dictitem_arrayitem, $1.data); } arrayvals
          | DBLLT { pandalex_callback(pandalex_event_dictitem_dict, "array-dictitem"); } 
              dict DBLGT { pandalex_callback(pandalex_event_dictitem_dictend, "array-dictitem"); } arrayvals
          | {}
          ;

// completely implemented
objref    : INT INT OBJREF { if(($$.data = (char *) malloc((pandalex_intlen($1) + pandalex_intlen($2) + 5) * sizeof(char))) == NULL){
			       fprintf(stderr, "Could not allocate enough space for objref\n");
			       exit(42);
                               }
			     
			     sprintf($$.data, "%d %d R", $1, $2);
			     $$.len = strlen($$.data) + 1;
			                       }
          ;

// completely implemented
stream    : STREAM binary ENDSTREAM { pandalex_callback(pandalex_event_stream, $2.data, $2.len); free($2); }
          |
          ;

// completely implemented: callbacks are handled in the callers to this
binary    : ANYTHING binary { $$.data = pandalex_strmcat($1.data, $1.len, $2.data, $2.len); $$.len = $1.len + $2.len; free($2); }
          | STRING binary { $$.data = pandalex_strmcpy($1.data, -1); $$.len = strlen($1.data); }
          | { $$.data = pandalex_strmcpy("", -1); $$.len = 0; }
          ;

// completely implemented
xref      : XREF INT INT { pandalex_callback(pandalex_event_xrefstart); }
              xrefitems {}
          ;

// completely implemented
xrefitems : INT INT STRING { pandalex_callback(pandalex_event_xrefitem, $1, $2, $3); }
              xrefitems
          | { pandalex_callback(pandalex_event_xrefend); }
          ;

// completely implemented
trailer   : TRAILER { pandalex_callback(pandalex_event_trailerstart); } 
              DBLLT dict DBLGT STRING INT { pandalex_callback(pandalex_event_trailerend, $6, $7); } 
              PDFEOF { pandalex_callback(pandalex_event_enddocument); }
          ;

%%

void pandalex_init(){
  int i;

  // Make sure that the callbacks default to nothing
  for(i = 0; i &lt; pandalex_event_max; ++i){
    pandalex_callbacks[i] = NULL;
  }
}

void pandalex_setupcallback(int callback, pandalex_callback_type functoid){
  pandalex_callbacks[callback] = functoid;
}

// Here we call the callbacks. This includes converting to the types that the
// callback function expects.
void pandalex_callback(int event, ...){
  va_list argptr;

  // Start accessing the arguements from the end
  va_start(argptr, event);
  
  // If no event handler is setup, then we ignore the event
  if(pandalex_callbacks[event] != NULL){
    pandalex_callbacks[event] (event, argptr);
  }
  
  // Stop with the arguements
  va_end(argptr);
}

int pandalex_parse(){
  // We are not looking into a stream at the moment
  yyparse();
}

int yyerror(char *s){
  fprintf(stderr, "\n---------------------------------------------------------------\n");
  fprintf(stderr, "PandaLex parser error (%s):\n", s);
  fprintf(stderr, "  Please send this error text, along with a copy of your PDF\n");
  fprintf(stderr, "  document (if possible) to mikal@stillhq.com, so that this can\n");
  fprintf(stderr, "  be fixed for the next release...\n\n");
  fprintf(stderr, "version = 0.4\n");
  fprintf(stderr, "last token = \"%s\" (%d) or %d\n", yylval.sval.data, yylval.sval.len, yylval.intVal);
  fprintf(stderr, "\n---------------------------------------------------------------\n");

  exit(42);
}

// Buffer overrun safe strcat
char *pandalex_strmcat(char *dest, int destLen, char *append, int appendLen){
  char *new;
  int count, len;

  // What length do we need?
  if((new = (char *) malloc(sizeof(char) * 
			    (((destLen == -1) ? strlen(dest) : destLen) + 
			    ((appendLen == -1) ? strlen(append) : appendLen) + 
			    2))) == NULL){
    fprintf(stderr, "Could not malloc enough space\n");
    exit(42);
  }
  
  if((destLen == -1) &amp;&amp; (appendLen == -1))
    sprintf(new, "%s%s", dest, append);
  else{
    // We need to copy characters the hard way -- change this to a memcpy
    count = 0;

    for(len = 0; len &lt; ((destLen == -1) ? strlen(dest) : destLen); len++){
      new[count] = dest[len];
      count++;
    }

    for(len = 0; len &lt; ((appendLen == -1) ? strlen(append) : appendLen); len++){
      new[count] = append[len];
      count++;
    }

    new[count] = '\0';
  }
  return new;
}

// Buffer overrun safe strcpy
char *pandalex_strmcpy(char *data, int len){
  return pandalex_strmcat(data, len, "", 0);
}

int pandalex_intlen(int number){
  int length = 0;

  while(number &gt; 0){
    length ++;
    number /= 10;
  }

  return number;
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/parser.y</emphasis></para>
</sect2>

<sect2><title>samples.c</title>
<programlisting>
/* A sample application using pandalex -- this is pdfdump */

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;zlib.h&gt;
#include "samples.h"
#include "lexinterface.h"

enum{
  pdfdump_dump = 0,
    pdfdump_meta
    };
int pdfdump_application;

pdfdump_dictint_list *dictint_list;

// Some demo code for how to use PandaLex
int main(int argc, char *argv[]){
  pandalex_init();

  // Parse the command line to find out what we are doing today -- this needs more thought
  if(strcmp(argv[0], "pdfmeta") == 0){
    pdfdump_application = pdfdump_meta;
  }
  else
    pdfdump_application = pdfdump_dump;

  // Setup the callbacks
  pandalex_setupcallback(pandalex_event_begindocument, pdfdump_begindocument);

  pandalex_setupcallback(pandalex_event_specver, pdfdump_specversion);
  pandalex_setupcallback(pandalex_event_entireheader, pdfdump_entireheader);
  pandalex_setupcallback(pandalex_event_objstart, pdfdump_objstart);
  pandalex_setupcallback(pandalex_event_objend, pdfdump_objend);

  pandalex_setupcallback(pandalex_event_dictitem_string, pdfdump_dictitem_string);
  pandalex_setupcallback(pandalex_event_dictitem_name, pdfdump_dictitem_name);
  pandalex_setupcallback(pandalex_event_dictitem_arraystart, pdfdump_dictitem_arraystart);
  pandalex_setupcallback(pandalex_event_dictitem_arrayitem, pdfdump_dictitem_arrayitem);
  pandalex_setupcallback(pandalex_event_dictitem_arrayend, pdfdump_dictitem_arrayend);
  pandalex_setupcallback(pandalex_event_dictitem_object, pdfdump_dictitem_object);
  pandalex_setupcallback(pandalex_event_dictitem_dict, pdfdump_dictitem_dict);
  pandalex_setupcallback(pandalex_event_dictitem_dictend, pdfdump_dictitem_dictend);
  pandalex_setupcallback(pandalex_event_dictitem_int, pdfdump_dictitem_int);

  pandalex_setupcallback(pandalex_event_stream, pdfdump_stream);
  pandalex_setupcallback(pandalex_event_dictint, pdfdump_dictint);
  
  // Initialise the dictint_list structure;
  if((dictint_list = (pdfdump_dictint_list *)
      malloc(sizeof(pdfdump_dictint_list))) == NULL){
    fprintf(stderr, "Could not initialise the dictint list\n");
    exit(42);
  }

  dictint_list-&gt;next = NULL;

  // Start parsing
  pandalex_parse();

  return 0;
}

char *pandalex_xsnprintf(char *, ...);

// Arguement is the name of the file as a char *
void pdfdump_begindocument(int event, va_list argptr){
  char *filename;

  filename = va_arg(argptr, char *);
  printf("Information for document: \"%s\"\n\n", filename);
}

void pdfdump_specversion(int event, va_list argptr){
  printf("Specification version is: %s\n", (char *) va_arg(argptr, char *));
}

void pdfdump_entireheader(int event, va_list argptr){
  int    i;
  char   *textMatch = (char *) va_arg(argptr, char *);

  printf("Entire document header is: ");

  for(i = 0; i &lt; strlen(textMatch); i++){
    if(isprint(textMatch[i])) printf("%c ", textMatch[i]);
    else printf("\\%d ", textMatch[i]);
  }

  printf("\n");
}

void pdfdump_objstart(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d started (generation %d)\n",
	 number, generation);
}

void pdfdump_objend(int event, va_list argptr){
  int generation, number;

  number = va_arg(argptr, int);
  generation = va_arg(argptr, int);

  printf("Object %d ended (generation %d)\n",
	 number, generation);
}

void pdfdump_dictitem_string(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [String] %s = \"%s\"\n", name, value);
}

void pdfdump_dictitem_name(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Name] %s = %s\n", name, value);
}

void pdfdump_dictitem_arraystart(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s starts\n", name);
}

void pdfdump_dictitem_arrayitem(int event, va_list argptr){
  char *value;
  
  value = va_arg(argptr, char *);
  printf("  [Array] %s\n", value);
}

void pdfdump_dictitem_arrayend(int event, va_list argptr){
  char *name;
  
  name = va_arg(argptr, char *);
  printf("  Array %s ends\n", name);
}

void pdfdump_dictitem_object(int event, va_list argptr){
  char *name, *value;
  
  name = va_arg(argptr, char *);
  value = va_arg(argptr, char *);
  printf("  [Object reference] %s = %s\n", name, value);
}

void pdfdump_dictitem_dict(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" starts\n", name);
}

void pdfdump_dictitem_dictend(int event, va_list argptr){
  char *name;

  name = va_arg(argptr, char *);
  printf("Subdictionary \"%s\" ends\n", name);
}

void pdfdump_dictitem_int(int event, va_list argptr){
  int value;
  char *name;

  name = va_arg(argptr, char *);
  value = va_arg(argptr, int);

  printf("  [Integer] %s = %d\n", name, value);
}

void pdfdump_stream(int event, va_list argptr){
  char *filter;
  int length;
  char *lengthObj;
  char *streamData;
  int streamDataLen;
  pdfdump_dictint_list  *now;
  int found;

  printf("  [Stream]\n");

  filter = va_arg(argptr, char *);
  length = (int) va_arg(argptr, char *);
  lengthObj = va_arg(argptr, char *);
  streamData = va_arg(argptr, char *);
  streamDataLen = va_arg(argptr, int);

  // Determine if we know the length
  switch(length){
  case -2:
    // We don't - have we seen the obj already?
    printf("    Length is stored in object\n");
    break;

  case -1:
    // It was never defined
    printf("    Length field not defined\n");
    break;

  default:
    printf("    Length is stated to be %d\n", length);
    pdfdump_procstream(filter, length, streamData, streamDataLen);
    break;
  }
}

void pdfdump_dictint(int event, va_list argptr){
  int found;
  int objnum, objgen, value;
  char *objref;
  pdfdump_dictint_list *now;

  // Get the passed information
  objnum = va_arg(argptr, int);
  objgen = va_arg(argptr, int);
  value = va_arg(argptr, int);

  printf("Do something with the dictint %d %d R = %d\n", objnum, objgen, value);

  // Information is handed to this event in a slightly different manner to
  // the stream event handler. Fix this.
  if((objref = (char *) malloc((pandalex_intlen(objnum) + pandalex_intlen(objgen) + 5) * sizeof(char))) == NULL){
    fprintf(stderr, "Could not allocate enough space for objref\n");
    exit(42);
  }
  
  sprintf(objref, "%d %d R", objnum, objgen);

  // Are we already waiting?
  now = dictint_list;
  found = 0;

  while((now-&gt;next != NULL) &amp;&amp; (found == 0)){
    if(strcmp(objref, now-&gt;value) == 0){
      // Yes -- do something
      pdfdump_procstream(now-&gt;filter, value, now-&gt;stream, now-&gt;streamlen);
      found = 1;
    }

    now = now-&gt;next;
  }

  // No -- save data and wait
  if(found == 0){
    // now is already the end of the list
    if((now-&gt;next = (pdfdump_dictint_list *)
	malloc(sizeof(pdfdump_dictint_list))) == NULL){
      fprintf(stderr, "Could not add to list of waiting streams\n");
      exit(42);
    }
    
    now-&gt;value = (char *) pandalex_strmcpy(objref, -1);
    now-&gt;filter = NULL;
    now-&gt;stream = NULL;
    now-&gt;waiting = 2;
    now = now-&gt;next;
    now-&gt;next = NULL;
  }
}

void pdfdump_procstream(char *filter, int length, char *data, int dataLen){
  char *uncompressed, *dataPtr, *linhintdesc[17];
  uLong srcLen, dstLen = 512;
  int result, i, linhintlens[17], number, count;

  linhintlens[0] = 32;
  linhintdesc[0] = pandalex_xsnprintf("Least number of objects in a page");
  linhintlens[1] = 32;
  linhintdesc[1] = pandalex_xsnprintf("Location of the first page object");
  linhintlens[2] = 16;
  linhintdesc[2] = pandalex_xsnprintf("Page objects delta bits");
  linhintlens[3] = 32;
  linhintdesc[3] = pandalex_xsnprintf("Least page length");
  linhintlens[4] = 16;
  linhintdesc[4] = pandalex_xsnprintf("Page length delta bits");
  linhintlens[5] = 32;
  linhintdesc[5] = pandalex_xsnprintf("Least content stream offset");
  linhintlens[6] = 16;
  linhintdesc[6] = pandalex_xsnprintf("Content stream offset delta bits");
  linhintlens[7] = 32;
  linhintdesc[7] = pandalex_xsnprintf("Least content stream length");
  linhintlens[8] = 16;
  linhintdesc[8] = pandalex_xsnprintf("Contents stream length delta bits");
  linhintlens[9] = 16;
  linhintdesc[9] = pandalex_xsnprintf("Greatest shared object number bits");
  linhintlens[10] = 16;
  linhintdesc[10] = pandalex_xsnprintf("Numerically greatest shared object number bits");
  linhintlens[11] = 16;
  linhintdesc[11] = pandalex_xsnprintf("Numeration object fraction bits");
  linhintlens[12] = 16;
  linhintdesc[12] = pandalex_xsnprintf("Denominator object fraction bits");
  linhintlens[13] = 16;
  linhintdesc[13] = pandalex_xsnprintf("?????");

  // Check length
  if(length &lt; 1){
    fprintf(stderr, "Stream length is not believable\n");
    return;
  }

  // Check there is a filter at all
  if(filter == NULL){
    fprintf(stderr, "This stream is not compressed!\n");
    return;
  }

  // If the stream starts with a \r or a \n or a \r\n, then these should be stripped off
  dataPtr = data;
  while((dataPtr[0] == '\r') || (dataPtr[0] == '\n')) dataPtr++;

  // Do something with the stream
  if(strcmp(filter, "FlateDecode") == 0){
    printf("Do something involving Flate\n");
    
    //    printf("--------------------------------------------------");
    //for(i = 0; i &lt; dataLen; i++)
    //  printf("%c", data[i]);
    //printf("--------------------------------------------------");


    // - 1
    for(i = -10; i &lt; 1; i++){
      srcLen = dataLen + i;
      dstLen = 512;
      printf("[%d] ", i);
     
      if((uncompressed = (char *) malloc(sizeof(char) * dstLen)) == NULL){
	fprintf(stderr, "Could not make enough space to decompress Flate stream\n");
	exit(42);
      }
      
      // We grow the output buffer until we no longer get buffer size errors
      while((result = uncompress(uncompressed, &amp;dstLen, dataPtr, srcLen)) == Z_BUF_ERROR){
	printf(".");
	fflush(stdout);
	
	dstLen *= 2;
	if(((uncompressed = (char *) realloc(uncompressed, dstLen)) == NULL) ||
	   (dstLen &gt; 10000000)){
	  // We could not grow the buffer, so we exit
	  printf("!");
	  fflush(stdout);
	  free(uncompressed);
	  break;
	}
      }

      if(result == Z_OK) printf(" HIT");
      printf(" *\n");
    }
    
    if(result != Z_OK){
      fprintf(stderr, "Flate decompression failed because of ");
      
      switch(result){
      case Z_MEM_ERROR:
	fprintf(stderr, "not enough memory\n");
	break;
	
      case Z_DATA_ERROR:
	fprintf(stderr, "corrupt input data\n");
	break;

      case Z_BUF_ERROR:
	fprintf(stderr, "buffer error\n");
	break;

      default:
	fprintf(stderr, "unknown error (%d)\n", result);
	break;
      }
      
      debuglex(data, srcLen, "Flate compression failure", 0);
      exit(46);
    }
    
    printf("\n");
    printf("----------- UNCOMPRESSED STREAM IS -------------------------------------------\n");
    // printf("%s\n", uncompressed);
    printf("Total uncompressed size: %d\n\n", dstLen);

    count = 0;

    for(i = 0; count &lt; 13;){
      number = 0;
      if(linhintlens[count] == 16){
	number = uncompressed[i] &lt;&lt; 8 | uncompressed[i + 1];
	i += 2;
      }
      else{
	number = uncompressed[i] &lt;&lt; 24 | uncompressed[i + 1] &lt;&lt; 16 |
	  uncompressed[i + 2] &lt;&lt; 8 | uncompressed[i + 3];
	i += 4;
      }

      printf("%s [%d]: %d\n", linhintdesc[count], linhintlens[count], number);
      count++;
    }

    printf("\nTotal bytes used: %d\n", i);
    printf("\n------------------------------------------------------------------------------\n");
  }
  else if(strcmp(filter, "LZWDecode") == 0){
    printf("LZW compression is encumbered by Patents and therefore not supported\n"); 
  }
  else if(strcmp(filter, "CCITTFaxDecode") == 0){
    printf("Do something involving CCITTFax compression (TIFF)\n");
  }
  else{
    printf("Unknown filter \"%s\"\n", filter);
  }
}
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.c</emphasis></para>
</sect2>

<sect2><title>samples.h</title>
<programlisting>
void pdfdump_begindocument(int, va_list);
void pdfdump_specversion(int, va_list);
void pdfdump_entireheader(int, va_list);
void pdfdump_objstart(int, va_list);
void pdfdump_objend(int, va_list);

void pdfdump_dictitem_string(int, va_list);
void pdfdump_dictitem_name(int, va_list);
void pdfdump_dictitem_arraystart(int, va_list);
void pdfdump_dictitem_arrayitem(int, va_list);
void pdfdump_dictitem_arrayend(int, va_list);
void pdfdump_dictitem_object(int, va_list);
void pdfdump_dictitem_dict(int, va_list);
void pdfdump_dictitem_dictend(int, va_list);
void pdfdump_dictitem_int(int, va_list);

void pdfdump_stream(int, va_list);
void pdfdump_dictint(int, va_list);
void pdfdump_procstream(char *, int, char *, int);

// This data type is needed for pdfdump_stream and 
// pdfdump_dictint
typedef struct pdfdump_internal_dictint_list{
  char *value;
  int waiting;
  int number;

  char *stream;
  int streamlen;
  char *filter;

  struct pdfdump_internal_dictint_list  *next; 
} pdfdump_dictint_list;
</programlisting>
<para><emphasis>Code: /home/mikal/opensource/pandalex/samples.h</emphasis></para>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
In this chapter we have discussed the inner workings of the PDF format, which is quite different to the other formats we have discussed in this document. We have also examined Panda, and seen how to use it to generate our PDF documents.
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the two libraries discussed here).</para></listitem>
<listitem><para>http://www.stillhq.com: has the comp.text.pdf frequently asked questions, as well as the Panda pages.</para></listitem>
</itemizedlist>
</sect1>

</chapter>
</book>
