<chapter id="chap-pdf"><title>PDF</title>
<para>
<quote>
THE ORIGINS OF THE Portable Document Format and the Adobe Acrobat product family date to early 1990. At that time, the PostScript page description language was rapidly becoming the worldwide standard for the production of the printed page. PDF builds on the PostScript page description language by layering a document structure and interactive navigation features on PostScript's underlying imaging model, providing a convenient, efficient mechanism enabling documents to be reliably viewed and printed anywhere. The PDF specification was first published at the same time the first Acrobat products were introduced in 1993.
</quote>
 -- PDF Specification
</para>

<para>
Portable Document Format (PDF) isn't strictly an image format. However, people are increasingly asking for PDF functionality in applications -- especially those on the Internet.
</para>

<para>
This chapter will focus on PDF 1.3 (second edition), because that is the specification version which I am most familiar with at the moment.
</para>

<sect1><title>Introduction</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>

<para>
This chapter is broken into five major sections. These are:

<itemizedlist>
<listitem><para>Discussion of the PDF format itself</para></listitem>
<listitem><para>An introduction to ClibPDF</para></listitem>
<listitem><para>An introduction to PDFLib</para></listitem>
<listitem><para>An introduction to Panda</para></listitem>
<listitem><para>Discussion of the Adobe PDF tools</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>All about the PDF format</title>
<para>
The PDF file format is broken into a tree structure. This tree is made up of combinations of a few possible objects. We'll start by describing these objects, and then move onto how they fit together.
</para>

<sect2><title>File header</title>
<para>
Every PDF file starts with a simple header which declares the file to be a valid PDF file. This header will look something like this:
</para>

<programlisting>
%PDF-1.3 ∞<9F><92><9C><9F>‘‡Œ–––
</programlisting>

<para>
This header had the following parts:
</para>

<itemizedlist>
<listitem><para><emphasis>%PDF-</emphasis>: this is a PDF document.</para></listitem>
<listitem><para><emphasis>1.3</emphasis>: it meets version 1.3 of the PDF specification.</para></listitem>
<listitem><para><emphasis>∞<9F><92><9C><9F>‘‡Œ–––</emphasis>: random binary stuff. This is just here so that <quote>smart</quote> FTP clients don't decide the file is an ASCII file in error
  <footnote><para>Whilst the vast majority of PDF structure is represented with ASCII text, this doesn't stop you from embedding binary into the file</para></footnote>
.</para></listitem>
</itemizedlist>

<sect3><title>Specification versions</title>
<para>
There have been five versions of the PDF specification released at the time of writing this document. They are:
</para>

<itemizedlist>
<listitem><para><emphasis>1.0</emphasis>: maps functionality available in Adobe Acrobat 1.0</para></listitem>
<listitem><para><emphasis>1.1</emphasis>: maps functionality available in Adobe Acrobat 2.0</para></listitem>
<listitem><para><emphasis>1.2</emphasis>: maps functionality available in Adobe Acrobat 3.0</para></listitem>
<listitem><para><emphasis>1.3 (both first and second editions)</emphasis>: maps functionality available in Adobe Acrobat 4.0</para></listitem>
<listitem><para><emphasis>1.4</emphasis>: maps functionality available in Adobe Acrobat 5.0</para></listitem>
</itemizedlist>

<para>
In theory at least, the PDF specification versions should be backwards compatible -- viewers should ignore object types and dictionary entries that they don't understand. This means that you can also insert your own information into the PDF document without breaking its ability to be viewed in other applications.
</para>
</sect3>
</sect2>

<sect2><title>Objects</title>
<para>
Objects in PDF files have a number, and a generation (version) number. They are represented as an ASCII text sequence in the file, for instance:
</para>

<programlisting>
1 0 obj
&lt;&lt;
        /Type /Catalog
        /Pages 2 0 R
&gt;&gt;
endobj
</programlisting>

<para>
This object is the 0th version of object number 1. The text between the &lt;&lt; and the &gt;&gt; is discussed in the next section.
</para>

<sidebar><title>Order of objects in the file</title>
<para>
Note that objects can appear in the file in any order, because there is a lookup table called an XREF table at the end of the file that they can be looked up from.
</para>
</sidebar>
</sect2>

<sect2><title>Dictionaries</title>
<para>
Objects have associated with them a (key, value) pair database. This stores properties of the object -- these would normally include things like the dimensions of the page, or the name of the author of the document, and other interesting things like that.
</para>

<para>
In the example object above, we had the following dictionary items...
</para>

<programlisting>
        /Type /Catalog
        /Pages 2 0 R
</programlisting>

<para>
This dictionary specifies that the key <quote>Type</quote> has the value <quote>Catalog</quote>, and that the value <quote>Pages</quote> has the value <quote>2 0 R</quote>. This last value is an object reference, which we discuss in the Redirection section a little bit later in this chapter.
</para>

<sect3><title>Dictionary data types</title>
<para>
What data types are valid in dictionaries? Well, version 1.3 of the PDF specification names the following data types:
</para>

<execute><cmd>todo</cmd><input>Do these</input></execute>
<execute><cmd>insertall.sh</cmd><args>pdf-type-*.sgml</args></execute>

<sect4><title>A lexer for PDF</title>
<para>
Refer to the lexer for PDF documents at the end of this chapter if you are more interested in the format of data types.
</para>
</sect4>
</sect3>

<sect3><title>Minimal dictionaries</title>
<para>
In addition to having full dictionaries, it is possible to have very simple objects which only have one value in the dictionary, these objects look a little different than a normal object, for instance:
</para>

<programlisting>
17 0 obj
203
endobj
</programlisting>

<para>
In this example, the object stores a simple integer value. Why would you want to do this? Well, the answer is that in a dictionary you can have the value for the key stored in another object:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
endobj

24 0 obj
462
endobj
</programlisting>

<para>
Here, we don't know the length of the stream associated with the object (I describe these in a second) at the time we wrote the object out, so we can simply insert it later in the document. This is called an object reference, which is in the form:
</para>

<programlisting>
objectnumber revision R
</programlisting>
</sect3>
</sect2>

<sect2><title>Streams</title>
<para>
The other type of data that an object can have associated with it is a stream. Streams are used to store less structured data, for instance descriptions of the items on a page, or random binary data. The form for a stream is:
</para>

<programlisting>
42 0 obj
&lt;&lt;
  /Length 24 0 R
&gt;&gt;
stream
...stream data...
endstream
endobj
</programlisting>

<para>
A description for the page layout descriptions is outside the scope of this document. 

<execute><cmd>nextedition</cmd><input>We should include information about the page description</input></execute> 

The other type of information which can be stored in a stream is arbitary information such as the content of images (which would normally be raster information). 

<execute><cmd>nextedition</cmd><input>In depth discussion</input></execute> 

An indepth discussion of the formatting of the raster information is also outside the scope of this document.
</para>

<sect3><title>Filters on streams</title>
<para>
Streams can be filtered. A filter is an operation which occurs on the stream contents before they are saved into the PDF document, examples include compression, and ASCII85 encoding
  <footnote><para>ASCII85 encoding is when you take binary data (which will be in the range 0x00 to 0xFF per byte, and force it into the range 0x00 to 0x55. This is done because some transport mediums (such as email), cannot handle binary data, so the data is made to look more like ASCII information. Note that this bloats the size of the data somewhat.</para></footnote>
, which can't really be called compression.
</para>

<para>
So what are the possible filters? Well, as of PDF 1.3
  <footnote><para>More have been added to this list in PDF 1.4</para></footnote>
, they are:
</para>

<execute><cmd>insertall.sh</cmd><args>pdf-filter-*.sgml</args></execute>
<execute><cmd>todo</cmd><input>Do these</input></execute>

</sect3>
</sect2>

<sect2><title>Object structure</title>
<execute><cmd>todo</cmd><input>Detail here</input></execute>
</sect2>
</sect1>

<sect1><title>Support for presentations</title>
<para>
PDF documents can be used to create presentation slide shows. There are two main features which support this use of PDF -- page duration, and page transitions. The page duration is the amount of time that the page will appear on the screen before the PDF viewer automatically moves onto the next page. The transition is the effect applied to the PDF pages when they are being swapped between -- this is very similar to the Microsoft PowerPoint presentations.
</para>

<para>
It is important to note that not all PDF viewers support this functionality.
</para>
</sect1>

<sect1><title>On with the libraries</title>
<para>
Now that we've discussed the format of the PDF file format, we can talk about the different options for building PDF files. The three main options are ClibPDF, PDFlib, and Panda. Adobe also sells a PDf library, but it has a reputation for being extremely expensive.
</para>

<para>
In our discussion of the three libraries, we will work through the same set of programs, to give you an opportunity to compare the three libraries. After all, they all have their own strengths, and weaknesses.
</para>
</sect1>

<sect1><title>ClibPDF</title>
<para>
ClibPDF was my first introduction to PDF generation APIs. It is available from http://www.fastio.com, and was last updated in December 1999, so it is starting to get a little old. There are still many people who use ClibPDF however.
</para>

<para>
Note that ClibPDF is not free software. The license is included below for your reference:
</para>

<execute><cmd>pdf2db.sh</cmd><args>clibpdf-license.pdf "ClibPDF license"</args></execute>

<para>
To summarise the license, this quote from the ClibPDF README page sums it up:
</para>

<programlisting>
This package is released under:
FastIO ClibPDF Software License 1.30, January 27, 2000.

ClibPDF and Premium ClibPDF are not public-domain or free software.
</programlisting>

<para>
This almost certainly limits what you can do with the library, and means that using the library will cost you money.
</para>

<sect2><title>Installation</title>
<para>
The first step to installing ClibPDF is to download the source from http://www.fastio.com. At the time of writing the source download is on the front page, about half way down. I can't guarantee that this wont have changed by the time you come to download the library, but then again the page hasn't changed in several years now, so it doesn't strike me a likely.
</para>

<sect3><title>Unix</title>
<para>
ClibPDF does not use configure scripts. The first step of the installation is to therefore copy your operating system's Makefile over the top of the sample Makefile. The various distributed Makefiles are:
</para>

<itemizedlist>
<listitem><para>Makefile.AIX42</para></listitem>
<listitem><para>Makefile.BSDI</para></listitem>
<listitem><para>Makefile.Cygwin</para></listitem>
<listitem><para>Makefile.FreeBSD</para></listitem>
<listitem><para>Makefile.HPUX</para></listitem>
<listitem><para>Makefile.irix62gcc</para></listitem>
<listitem><para>Makefile.MacOSX</para></listitem>
<listitem><para>Makefile.NetBSD</para></listitem>
<listitem><para>Makefile.NEXTSTEP</para></listitem>
<listitem><para>Makefile.SolarisGCC</para></listitem>
<listitem><para>Makefile.SolarisSunCC</para></listitem>
<listitem><para>Makefile.SunOS5x</para></listitem>
</itemizedlist>

<para>
If your operating system isn't listed in the available Makefiles, you'll need to copy the closest one and then edit it until the compile works.
</para>

<para>
Once you have copied your Makefile to the file named <emphasis>Makefile</emphasis>, then follow these steps to install ClibPDF...
</para>

<itemizedlist>
<listitem><para>make</para></listitem>
<listitem><para>make lib</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
You might need to edit parts of the Makefile to make the install work properly for your system.
</para>
</sect3>

<sect3><title>win32</title>
<para>
ClibPDF doesn't support win32 directly. It is however written in ANSI C, so a port shouldn't be very hard at all.

<execute><cmd>todo</cmd><input>Port ClibPDF</input></execute>
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the ClibPDF iteration:
</para>

<execute><cmd>code2db.pl</cmd><input>source/pdf/clibpdf/hello/hello.c</input></execute>

<para>
This produces a PDF which looks like (somewhat reduced from it's real size)...
</para>

<execute><cmd>pdf2db.sh</cmd><args>source/pdf/clibpdf/hello/hello.pdf "ClibPDF hello world"</args></execute>

<para>
The first block initializes ClibPDF, then we create a page, put some text on it, and then close the document.
</para>
</sect2>

<sect2><title>Initialization</title>
<programlisting>
CPDFdoc *cpdf_open(int pspdf, CPDFdocLimits *docLimits);
void cpdf_init(CPDFdoc *pdf);

char  *cpdf_getOutputFilename(CPDFdoc *pdf);
void cpdf_setOutputFilename(CPDFdoc *pdf, const char *file);
</programlisting>

<para>
ClibPDF requires multiple initialization calls. As seen in the hello world example above, we needed to call <command>cpdf_open</command> and <command>cpdf_init</command> at the start of our application. <command>cpdf_open</command> initializes ClibPDF itself, and returns a pointer to a <command>CPDFdoc</command>, which will represent our document. This pointer must then be initialized with a call to <command>cpdf_init</command>. The <command>*OutputFilename</command> functions are used to get and set the filename that the PDF document will be written to when finalized.
</para>

<execute><cmd>todo</cmd><input>Can you be creating multiple PDF files at once?</input></execute>
</sect2>

<sect2><title>Creating pages</title>
<programlisting>
int cpdf_pageInit(CPDFdoc *pdf, int pagenum, int rot, const char *mediaboxstr, const char *cropboxstr);
int cpdf_setCurrentPage(CPDFdoc *pdf, int page);
</programlisting>

<para>
Creating pages in ClibPDF is done with the <command>cpdf_pageInit</command> function. This function takes some arguements:
</para>

<itemizedlist>
<listitem><para><emphasis>CPDFdoc *pdf</emphasis>: the PDF document to add the page to</para></listitem>
<listitem><para><emphasis>int pagenum</emphasis>: the page number for the new page (the first page of a PDF is page 1)</para></listitem>
<listitem><para><emphasis>int rot</emphasis>: whether the page is PORTRAIT or LANDSCAPE (defined in the cpdflib header)</para></listitem>
<listitem><para><emphasis>const char *mediaboxstr</emphasis>: the page size string, see below</para></listitem>
<listitem><para><emphasis>const char *cropboxstr</emphasis>: the crop box for the page</para></listitem>
</itemizedlist>

<execute><cmd>todo</cmd><input>Define crop box in the PDF intro</input></execute>

<para>
There are some default page size strings provided by ClibPDF, although it is possible to use your own as well. The sizes provided by ClibPDF are:
</para>

<itemizedlist>
<listitem><para>LETTER</para></listitem>
<listitem><para>LEGAL</para></listitem>
<listitem><para>A4</para></listitem>
<listitem><para>B5</para></listitem>
<listitem><para>C5</para></listitem>
</itemizedlist>

<para>
There are also the following other page sizes, which for some reason aren't documented in the manual...
</para>

<itemizedlist>
<listitem><para>DL</para></listitem>
<listitem><para>EXECUTIVE</para></listitem>
<listitem><para>COMM10</para></listitem>
<listitem><para>MONARCH</para></listitem>
<listitem><para>FILM35MM</para></listitem>
</itemizedlist>

<para>
Page size strings are as embedded into the PDF document (which matches how Panda uses these strings as well). The format of the string is left, top, right, bottom. For example:
</para>

<programlisting>
0 0 612 792
</programlisting>

<para>
You can also be working on multiple pages at once. Use the <command>cpdf_setCurrentPage</command> function to switch between pages (compare this with how PDFlib and Panda implement this).
</para>
</sect2>

<sect2><title>Finalization</title>
<programlisting>
void cpdf_finalizePage(CPDFdoc *pdf, int page);
void cpdf_finalizeAll(CPDFdoc *pdf);
int cpdf_savePDFmemoryStreamToFile(CPDFdoc *pdf, const char *file);
char *cpdf_getBufferForPDF(CPDFdoc *pdf, int *length);
</programlisting>

<para>
These functions are used to finalize the PDF document. Use the <command>cpdf_finalizePage</command> function to force a page to be generated immediately. This may decrease resource usage for the PDF document. This function call is optional. <command>cpdf_finalizeAll</command> is called to write the PDF document out to the memory stream or the file on disc. If this function is not called, then the PDF file will be empty. You cannot add items to the PDF file once it has been finalized. <command>cpdf_close</command> closes the PDF file and deallocates resources which were consumed by the file.
</para>


</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<programlisting>
void cpdf_setPageDuration(CPDFdoc *pdf, float seconds);
int cpdf_setPageTransition(CPDFdoc *pdf, int type, float duration, float direction, int HV, int IO);
</programlisting>

<para>
<command>cpdf_setPageDuration</command> is self explainatory. The arguements to the <command>cpdf_setPageTransition</command> are not as obvious. They are:
</para>

<itemizedlist>
<listitem><para><empahsis>CPDFdoc *pdf</emphasis>: </para></listitem>
<listitem><para><empahsis>int type</emphasis>: </para></listitem>
<listitem><para><empahsis>float duration</emphasis>: </para></listitem>
<listitem><para><empahsis>float direction</emphasis>: </para></listitem>
<listitem><para><empahsis>int HV</emphasis>: </para></listitem>
<listitem><para><empahsis>int IO</emphasis>: </para></listitem>
</itemizedlist>

</sect2>

<sect2><title>Cool features</title>
<para>
ClibPDF has some cool features which aren't available in the other PDF generation libraries discussed in this tutorial. In brief, these are:
</para>

<itemizedlist>
<listitem><para>ClibPDF allows you to write the PDF to a memory stream, or a file, which would work well if you were byte serving the PDF on the web, or if you wanted to embed it into something like a database.</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>

<programlisting>
CPDFerrorHandler cpdf_setErrorHandler(CPDFdoc *pdf, CPDFerrorHandler handler);
void cpdf_Error(CPDFdoc *pdf, int level, const char* module, const char* fmt, ...);
CPDFglobalErrorHandler cpdf_setGlobalErrorHandler(CPDFglobalErrorHandler handler);
void cpdf_GlobalError(int level, const char* module, const char* fmt, ...);
</programlisting>

<para>
Error handling
</para>

<programlisting>
void cpdf_enableCompression(CPDFdoc *pdf, int cmpON);
</programlisting>

<para>
This function will enable compression of page descriptions, which can quite significantly reduce the size of the PDF document. This function simply enables a Flate filter on these page description streams.
</para>

<programlisting>
void cpdf_setDefaultDomainUnit(CPDFdoc *pdf, float defunit);
... and a variety of other domain function calls ...
</programlisting>

<para>
Explain domains
</para>

<programlisting>
void cpdf_useContentMemStream(CPDFdoc *pdf, int flag);
</programlisting>

<para>
This function call can be called if you want to use temporary files instead of memory buffers. This can be useful for machines which don't have much memory, but it is quite slow. You might find that you are better off simply increasing the amount of swap space allocated on the system. The ClibPDF documentation also implies that this function call is not thread safe.
</para>
</sect2>

<sect2><title>Room for improvement</title>
<programlisting>
void cpdf_setGlobalDocumentLimits(int maxPages, int maxFonts, int maxImages, int maxAnnots, int maxObjects);
</programlisting>

<para>
ClibPDF has internal limitations for the sizes of various data structures. These must be explicitly changed before the library is used if they don't fit your needs. The defaults are:
</para>

<itemizedlist>
<listitem><para><emphasis>Maximum number of pages</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of fonts</emphasis>: default value is 180</para></listitem>
<listitem><para><emphasis>Maximum number of images (rasters)</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of annotations</emphasis>: default value is 100</para></listitem>
<listitem><para><emphasis>Maximum number of objects</emphasis>: default value is 5,000 (it is strange that this value is exposed to the user)</para></listitem>
</itemizedlist>

<para>
These values can be changed using the <command>CPDFdocLimits</command> structure, which is passed to many of the ClibPDF function calls. It is interesting to note that this gives us a perspective on the internal coding style of ClibPDF. Many of the internal structures are based on fixed size arrays, which is why the size must be known from the start. These arrays will allow for ClibPDF to be marginally faster than implementations that use linked lists, but it also decreases the utility of the library.
</para>
</sect2>






</sect1>










<sect1><title>PDFlib</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>

<sect2><title>Installation</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>

<sect3><title>Unix</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>
</sect3>

<sect3><title>win32</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>
</sect3>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>



<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>






</sect1>





















<sect1><title>Panda</title>
<para>
Panda is my own PDF generation library. I wrote it because I was not happy with the license and some of the limitations with ClibPDF, and the license for PDFlib wasn't acceptable. To be honest, the best way to learn about something is also to build an implementation of it, which was an additional motivation.
</para>

<para>
You can get Panda from http://www.stillhq.com, and is licensed under the GNU GPL, which can be found at the start of this tutorial.
</para>

<sect2><title>Installation</title>
<para>
First, download Panda from http://www.stillhq.com, and then follow these simple steps:
</para>

<sect3><title>Unix</title>
<para>
Follow these simple steps to install Panda on your unix system:
</para>

<itemizedlist>
<listitem><para>Extract the tarball</para></listitem>
<listitem><para>Change into the Panda directory</para></listitem>
<listitem><para>./configure</para></listitem>
<listitem><para>make</para></listitem>
<listitem><para>make install</para></listitem>
</itemizedlist>

<para>
This will also build the examples in the examples directory.
</para>
</sect3>

<sect3><title>win32</title>
<para>
Panda currently compiles quite happily on Windows, and if you download the right version of the tarball even includes a Microsoft Visual Studio project file. Note that the current version of Panda (0.5.1), doesn't include a COM wrapper for Panda, so you either need to be programing in C or C++, or a language which can import DLL symbols (for instance Microsoft Visual Basic).
</para>
</sect3>
</sect2>

<sect2><title>Hello world example</title>
<para>
The most basic PDF example is the hello world application. Here is the Panda iteration:
</para>

<execute><cmd>code2db.pl</cmd><input>source/pdf/panda/hello/hello.c</input></execute>

<para>
Which produces...
</para>

<execute><cmd>pdf2db.sh</cmd><args>source/pdf/panda/hello/hello.pdf "Panda hello world"</args></execute>

<para>
The calling order here is very similar to ClibPDF and PDFlib, so I wont go into incredibly verbose explainations here.
</para>
</sect2>

<sect2><title>Initialization</title>
<para>

</para>
</sect2>

<sect2><title>Creating pages</title>
<para>
paper sizes
</para>
</sect2>

<sect2><title>Finalization</title>
<para>

</para>
</sect2>

<sect2><title>Inserting text</title>
<para>
rotation, word wrap support
</para>
</sect2>

<sect2><title>Fonts</title>
<para>
embedded / other
</para>
</sect2>

<sect2><title>Inserting raster images</title>
<para>

</para>

<sect3><title>TIFF support</title>
<para>

</para>
</sect3>

<sect3><title>JPEG support</title>
<para>

</para>
</sect3>

<sect3><title>PNG support</title>
<para>

</para>
</sect3>

<sect3><title>Other raster formats</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Vector graphics</title>
<para>

</para>

<sect3><title>Lines</title>
<para>

</para>
</sect3>

<sect3><title>Fills</title>
<para>

</para>
</sect3>

<sect3><title>Dashing</title>
<para>

</para>
</sect3>
</sect2>

<sect2><title>Document metadata</title>
<para>

</para>
</sect2>

<sect2><title>Presentation support</title>
<para>

</para>
</sect2>


<sect2><title>Cool features</title>
<para>

</para>
</sect2>

<sect2><title>Room for improvement</title>
<para>

</para>
</sect2>







</sect1>




























<sect1><title>Adobe products</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>
</sect1>


<sect1><title>Summary of the differences between PDF libraries</title>
<para>
It seems useful to provide a summary of the differences we have learnt about the various PDF libraries which are available as we worked through this chapter.
</para>

<table frame='all'><title>Differences between the PDF libraries</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Feature</entry>
  <entry>ClibPDF</entry>
  <entry>PDFlib</entry>
  <entry>Panda</entry>
  <entry>Adobe</entry>
</row>
</thead>
<tbody>

<row>
<entry>License</entry>
<entry>FastIO license. Not opensource / free software / public domain</entry>
<entry></entry>
<entry>GNU GPL Version 2</entry>
<entry></entry>
</row>

<row>
<entry>Cost</entry>
<entry>$1,000 USD+</entry>
<entry></entry>
<entry>$0</entry>
<entry></entry>
</row>


<row>
<entry>Free for non commercial use?</entry>
<entry>Yes, with conditions</entry>
<entry></entry>
<entry>Always free</entry>
<entry></entry>
</row>


<row>
<entry>DeleteMe</entry>
<entry></entry>
<entry></entry>
<entry></entry>
<entry></entry>
</row>



</tbody>
</tgroup>
</table>
</sect1>

<sect1><title>A lexer for PDF</title>
<para>
Part of my Panda work has been the development of a lexer for PDF documents known as Panda<emphasis>Lex</emphasis>. Whilst Panda<emphasis>Lex</emphasis> is by no means complete, it might prove to be useful for your understanding of the PDF document structure. I have therefore included it here. The lexer takes the form of several components: a lexer for the grammar, a grammar, and some c code to hold it all together.
</para>

<sect2><title>lexer.l</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/lexer.l</input></execute>
</sect2>

<sect2><title>lexinterface.h</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/lexinterface.h</input></execute>
</sect2>

<sect2><title>pandalex.h</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/pandalex.h</input></execute>
</sect2>

<sect2><title>parser.y</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/parser.y</input></execute>
</sect2>

<sect2><title>samples.c</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/samples.c</input></execute>
</sect2>

<sect2><title>samples.h</title>
<execute><cmd>code2db.pl</cmd><input>~mikal/opensource/pandalex/samples.h</input></execute>
</sect2>

</sect1>

<sect1><title>Conclusion</title>
<para>
<execute><cmd>todo</cmd><input>Content</input></execute>
</para>
</sect1>

<sect1><title>Further reading</title>
<para>
The following resources might be of use if you need more information:
</para>

<itemizedlist>
<listitem><para>http://developer.adobe.com has many useful resources, including the PDF specification (at the time of writing the latest version is 1.4, although this chapter is based on 1.3, because this is what is supported by the three libraries discussed here).</para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
<listitem><para></para></listitem>
</itemizedlist>
</sect1>

</chapter>
