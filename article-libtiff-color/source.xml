<?xml version="1.0" encoding="UTF-8"?>
<article ratings="auto" toc="auto">

   <seriestitle>[Optional series title]</seriestitle>
   <papertitle>Graphics programming with libtiff</papertitle>
   <subtitle>Color</subtitle>
   <author company="TOWER Software Engineering" email="mikal@stillhq.com" jobtitle="Senior Software Engineer" name="Michael Still">Michael has been working in the image processing field for several years, including a couple of years managing and dveloping large image databases for an Australian government department. He currently works for TOWER Software, who manufacture a world leading EDMS and Records Management package named TRIM. Michael is also the developer of Panda, an open source PDF generation API, as well as being the maintainer of the comp.text.pdf USENET frequently asked questions document. You can contact Michael at <a href="mailto:mikal@stillhq.com">mikal@stillhq.com</a>.</author>

   <date month="April" year="2002"></date>
   <zone name="linux"></zone>
   <pdf url="ftp://www6.software.ibm.com/software/developer/library/[xxx.pdf]" size="xxKB"></pdf>
   <zip url="ftp://www6.software.ibm.com/software/developer/library/xxx.zip"></zip>

   <meta name="KEYWORDS" content="tiff libtiff image imaging raster bitmap color colour" />	
   <meta name="LASTUPDATE" content="20020425 MBS"/>

   <relatedlist>
   <a href="">[Link 1 to related content]</a>
   <a href="">[Link 2 to related content]</a>
   </relatedlist>			
		
   <abstract>TIFF is an extremely common, but quite complex raster image format. Libtiff is a standard implementation of the TIFF specification, which is free and works on many operating systems. This article discusses some of the pitfalls of TIFF, and guides the reader through use of the libtiff library. This article provides examples on how to use libtiff for your grayscale and color imaging needs.
</abstract>

<sidebar>
<heading refname="" type="sidebar" toc="no">Did you read the previous article?</heading>
<p>This article is a follow up to my previous article on black and white graphics programming with libtiff. This article covers grayscale and color imaging, but it assumes that you have read and understood the code from the black and white article. It might be helpful to refer to that article before going too far here.</p>
</sidebar>

<p>With this article, I will discuss some of the theory required to understand how the image data is stored for color and grayscale. This theory applies to all imaging formats. We'll then discuss some of the specifics of using libtiff.</p>

<p><heading refname="h1" type="major" toc="yes">Terminology</heading>	
We need to get some terminology out of the way before we can discuss much. Images are made up of pixels. In black and white imaging, the pixel has one of two values -- 0 or 1. This can be represented in a single bit. For grayscale and color images however, the pixel needs to be able to store a much greater range of values for a pixel -- if a pixel was to have 255 levels of gray, then we would need 8 bits to store that pizel. Each of these values are called a sample. TIFF expresses the size of the value in a tag called TIFFTAG_BITSPERSAMPLE. This will be 1 for black and white, and some larger number for grayscale.</p>

<p>For color images, we need to store even more information. For each pixel we will need to store a red, green, and blue value. Each of these values are stored in a separate 'sample'. Therefore, we will need to define TIFFTAG_SAMPLESPERPIXEL -- this will be 1 for black and white or grayscale, but will normally be 3 for color images. We also need to define the size of each sample, so you'll still need to set a value for TIFFTAG_BITSPERSAMPLE.</p>

<p><heading refname="h1" type="major" toc="yes">Theory of color and grayscale storage</heading>	
The first thing that we need to understand to be able to support color and grayscale images is the format of the image data within memory. There are two main representations for color and grayscale images. I'll explain these by describing grayscale, and then extend it to color.</p>

<p><heading refname="h2" type="minor" toc="yes">Direct storage of pixel data</heading>
If you think back to the way pixel information was stored in the black and white images from the previous article, the information was just in the strips. This concept is described in the <TODO figure> figure below. You can also do this with grayscale <TODO figure> and color images, and shown in <TODO figure>. This representation of image data is quite inefficient, because for the scenario when the image has a solid background (for example), there are many pixels with the same value. If the pixel data is stored in the strips, then this value will waste a large amount of space.
</p>

<figure>
<heading refname="strip-bandw" type="figure" toc="no">Figure x. In strip black and white data</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<figure>
<heading refname="strip-gray" type="figure" toc="no">Figure x. In strip grayscale data</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<figure>
<heading refname="strip-color" type="figure" toc="no">Figure x. In strip color data</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<figure>
<heading refname="strip-palette" type="figure" toc="no">Figure x. Paletted image data</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<p>Thankfully, there is a more efficient way to store image data. Imagine a simple four color 24 bit per pixel image. If we build a lookup table of the four color values (the 24 bit values which represent those colors), then we just need to store the relevant entry number of the color in the image strip itself. This can be done in only two bits, instead of the full 24. The maths looks something like this:</p>

<p>A 24 bit color image which is 1,000 by 1,000 pixels will take 24 million bits to store. The same image, if it was a four color image, would take 4,000,000 bits for the strip data, and 98 bits for the color table. Neither of these numbers includes header and footer information for the file format, and the numbers are for uncompressed bitmaps. The advantages of the lookup table should be obvious. There is a name for this style of lookup table, it is called a <i>palette</i> -- probably because of those things painters carry around.</p>

<p>This concept works for grayscale images as well. The only difference is that the colors in the palette are not just shades of gray.</p>






<p><heading refname="h1" type="minor" toc="yes">Compression algorithms in libtiff</heading>	
There are several compression algorithms available within libtiff. How do you select which one is right for your imaging needs?</p>

<b>Libtiff compression algorithms</b>
<htmlinsert><![CDATA[

<table width="100%" cellspacing="0" cellpadding="3" border="1">
<tr valign="top">
<td><b>Compression algorithm</b></td>
<td><b>Well suited for</b></td>
</tr>

<tr valign="top">
<td>CCITT Group 4 Fax and Group 3 Fax</td>
<td>This entry is here for completeness. If your coding for black and white images, then you're probably using the CCITT fax compression methods. These compression algorithms don't support color.</td>
</tr>

<tr valign="top">
<td>JPEG</td>
<td>JPEG compression is great for large images such as photos. However, the compression is normally lossy (in that image data is thrown away as part of the compression process). This makes JPEG very poor for compressing text which needs to remain readable. The other thing to bear in mind is that the loss is accumulative -- see the sidebar for more information about this.</td>
</tr>

<tr valign="top">
<td>LZW</td>
<td><i>This is the compression algorithm used in GIF images. Because of the licensing requirements from Unisys, support for this compression codec has been removed from libtiff. There are patches available if you would like to add it back, but the majority of programs your code will integrate with no linger support LZW.</i></td>
</tr>

<tr valign="top">
<td>Deflate</td>
<td>This is the gzip compression algorithm, which is also used for PNG. It is the compression algorithm I would recommend for color images.</td>
</tr>

<tr valign="top">
<td>Content A3</td>
<td>Content B3</td>
</tr>
</table>

]]></htmlinsert>

<sidebar>
<heading refname="" type="sidebar" toc="no">Accumulating loss?</heading>
<p>Why does the loss in lossy compression algorithms such as JPEG accumulate? Imagine that you compress an image using JPEG. You then need to add say a barcode to the image, so you uncompress the image, add the barcode, and recompress it. When the recompression occurs, then a new set of loss is introduced. You can imagine that if you do this enough, then you'll end up with an image which is a big blob.</p>

<p>Whether this is a problem depends on the type of your data. To test how much of a problem this is, I wrote a simple libtiff program which repeatedly uncompresses and recompresses an image. What I found was that with pictures, the data is much more resilient to repeated compression.</p>

<figure>
<heading refname="picture-start" type="figure" toc="no">Figure x. The picture before we compressed it</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<figure>
<heading refname="text-start" type="figure" toc="no">Figure x. The picture before we compressed it</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<p>The code I used had a 'quality' rating of 25% on the JPEG compression, which is a way of tweaking the loss of the compression algorithm. The lower the quality, the higher the compression ratio. The default is 75%.</p>

<figure>
<heading refname="picture-200" type="figure" toc="no">Figure x. The picture after it has been recompressed 200 times</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>

<figure>
<heading refname="text-200" type="figure" toc="no">Figure x. The picture after it has been recompressed 200 times</heading>
<img src="xxx.jpg" width="500" height="200" alt="[Sample figure; code correct height and width"/>
</figure>
</sidebar>





<p><heading refname="h1" type="major" toc="yes">Writing a color image</heading>
It time to show you how to write a color image to disc. Remember that this is a simple example, which can be elaborated on greatly.
</p>

<heading refname="write-example-simple" type="code" toc="no">Writing a color image</heading>
#include <tiffio.h>
#include <stdio.h>

int main(int argc, char *argv[]){
  TIFF *output;
  uint32 width, height;
  char *raster;

  // Open the output image
  if((output = TIFFOpen("output.tif", "w")) == NULL){
    fprintf(stderr, "Could not open outgoing image\n");
    exit(42);
  }

  // Find the width and height of the image
  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);
  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);
  imagesize = height * width + 1;
  
  if((raster = (uint32 *) malloc(sizeof(uint32) * imagesize)) == NULL){
    fprintf(stderr, "Could not allocate enough memory\n");
    exit(42);
  }

// Magical stuff for creating the image


  // Write the tiff tags to the file
  TIFFSetField(output, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(output, TIFFTAG_IMAGELENGTH, height);
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
  TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
  TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
  TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, 8);
  TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 3);

  // Actually write the image
  if(TIFFWriteEncodedStrip(output, 0, raster, width * height * 3) == 0){
    fprintf(stderr, "Could not write image\n");
    exit(42);
  }

  TIFFClose(output);
}
</code>



TIFFReadRGBAStrip pain
Alpha channels





<!-- CODE SECTION WITH HEADING:  PLACE HEADING INSIDE CODE TAG WITH TYPE="CODE".  DO NOT SURROUND CODE SECTION WITH PARAGRAPH TAGS.  THE TOC ATTRIBUTE DETERMINES IF THIS HEADING IS INCLUDED IN THE TOC.   DEFAULT IS TOC="NO".-->
<code type="section">
<heading refname="code1" type="code" toc="no">[Caption for sample code section or code listing]</heading>
[Code goes here.  &lt;pre&gt; tags will be added automatically.

Use the b tag to surround <b>bolded code</b>.

To specify colors, use the class attribute on the b tag:
        code &lt;b class="red"&gt; for <b class="red">red</b>.
        code &lt;b class="green"&gt; for <b class="green">green</b>.
        code &lt;b class="blue"&gt; for <b class="blue">blue</b>.

Use the space key to indent lines.]
</code>

<p>[Next paragraph goes here]</p>

<!-- CODE SECTION WITHOUT HEADING:  DO NOT SURROUND CODE SECTION WITH PARAGRAPH TAGS.  THE TOC ATTRIBUTE DETERMINES IF THIS HEADING IS INCLUDED IN THE TOC.   DEFAULT IS TOC="NO".-->
<code type="section">
[This code example does not have a code heading]
</code>

<p><heading refname="h3" type="major" toc="yes">[Major heading 2]</heading>
[Insert paragraph text here and end with an end paragraph tag.]</p>



<p>[Refer to figure using the reference name (refname) assigned to the figure, as follows: <a href="#figure1">Figure 1</a>. ]</p>

[Insert paragraph text here and end the paragraph with an end paragraph tag.  To include inline code in a paragraph, surround the code snippet with a
code tag that has the attribute: type="inline".  This is an <code type="inline">inline code snippet</code> .

<!-- THIRD-LEVEL HEADING:  PRECEDE ALL THIRD-LEVEL HEADINGS WITH A PARAGRAPH TAG.  FOLLOW THE HEADING WITH A BREAK TAG.-->
<p><b>[Third-level heading]</b><br />
[The third-level heading above is created using bold tags and is followed by a break tag to separate it from the paragraph text.]</p>

<p>[Next paragraph goes here with unordered list.  If you end the paragraph tag before the list, you get a space separating the text from the list.]</p>
<ul>
<li>[List item one]</li>
<li>[List item two]</li>
<li>[List item three]</li>
</ul>

<resourcelist>
<p><heading refname="" type="resourcelist" toc="no">Source code used in this article</heading></p>
<ul>
<li>Repeated compression source</li>
<li>Repeated compression script</li>
<li>Tarball of recompressed sample images</li>
</ul>

<ul>
<li>[First resource item and link without a heading]</li>
<li>[Second resource item and link without a heading]</li>
</ul>
</resourcelist>

</article>
