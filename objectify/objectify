#!/usr/bin/perl

# Take a C library, and turn it into something else:
# $1 -> output style: c++, idl

use strict;
my($incomment, $origline, $code, $possfunction, $arg, %pointers, $class,
   %creates, %parents, %suppress, $temp, $methodid);

$incomment = 0;
$code = "";

print STDERR "Objectify started\n";

print <<EOF;
// This code was automatically generated by objectify, which is
// available from http://www.stillhq.com -- edit this file at your
// own risk

EOF

if($ARGV[0] eq "idl"){
    print <<EOF;
import "oaidl.idl";
import "ocidl.idl";

EOF
}
elsif($ARGV[0] eq "c++"){
}
else{
  print STDERR "Usage: objectify [c++ | idl] < input > output\n";
  exit;
}

# Prepare the input
print STDERR "Simplifying input code\n";
while(<STDIN>){
    if((!/^\#define/) && (/SUPPRESS[ \t]*\((.*)\)/)){
	$suppress{$1} = "yes";
	print STDERR "Suppressing: $1\n";
    }

    # Remove comments from the line
    s/\/\/.*$//;
    s/\/\*.*\*\///;
    s/\r//g;
    s/^[ \t]+//;
    $origline = $_;
    s/\/\*.*$//;
    s/^.*\*\///;

    # We want the newlines to stay for cpp directives
    if(!/\#/){
	chomp;
    }

    if($incomment == 0){
	$code = "$code$_";
    }

    $_ = $origline;
    # Block comment closed?
    if(/.*\*\//){
	$incomment = 0;
    }

    # Comments which dangle over to the next line
    if(/\/\*.*/){
	$incomment = 1;
    }
}

$code =~ s/[ \t]+/ /g;

# We now go through each line in the code, looking for functions...
print STDERR "Processing functions\n";
foreach $possfunction (split(/;/, $code)){
    $_ = $possfunction;
    my($processed, $rval, $fval, $aval, $bestarg);

    $processed = 0;
    if(!(/INTERNAL/) && 
       (/([a-zA-Z0-9_\*]+) ([a-zA-Z0-9_\*]+) \(([^\(\)]*)\)/)){
	($rval, $fval, $aval) = ($1, $2, $3);
	$_ = $aval;
	$bestarg = "";
	s/ //g;
	foreach $arg (split(/,/)){
	  # The arg might have a name attached to it, we split this off
	  $arg =~ s/ [^ ]*$//;

	  # If the last character is a * then this is a pointer
	  # ignore some boring pointers which are too common
	  $_ = $arg;
	  if(($arg ne "char*") && ($arg ne "int*") && ($arg ne "void*") && 
	     (/\*$/)){
	    print STDERR "  Candidate pointer: $arg\n";
	    $arg =~ s/\*$//;
	    $bestarg = $arg;
	    $processed = 1;
	  }
	}

	if($bestarg ne ""){
	    $pointers{$bestarg} = $pointers{$bestarg}."$rval!$fval!$aval;";
	}
	
	# If there is a * in the combination of the return value and the 
	# function name, then this is a creation function
	$_ = "$rval$fval";
	if(($rval ne "char") && ($rval ne "void") && ($rval ne "int") &&
	   (/.*\*.*/)){
	    print STDERR "  Creates: $rval\n";
	    $creates{$rval} = $creates{$rval}."$fval;";
	}
    }
    else{
	$processed = 1;
    }

    if($processed == 0){
	# I am not sure this ever gets called
	print STDERR "Processing skipped item\n";
	my($libname);
	$libname = $fval;
	$libname =~ s/_.*$//;
	$libname =~ s/\*//;
	$pointers{$libname} = $pointers{$libname}."$rval!$fval!$aval;";
    }
}

# Determine the parent relationships between classes
print STDERR "Processing classes\n";
foreach $class (keys %pointers){
    print STDERR "Class $class\n";
    if($suppress{$class} eq ""){
	# We need to output all the functions which use one of these pointers
	print STDERR "  Is not suppressed\n";
	my($rval, $fval, $aval, @argsarray);
	@argsarray = split(/;/, $pointers{$class});
	
	while($argsarray[0] ne ""){
	    ($rval, $fval, $aval) = split(/!/, shift @argsarray);
	    $aval =~ s/$class[ \t\*]+[, ]*//;
	    $fval =~ s/\*//;

	    # We only support one parent at the moment
	    if(($parents{$rval} eq "") && ($suppress{$rval} eq "")){
		print STDERR "  Parent: $rval\n";
		$parents{$rval} = $parents{$rval}."$class";
	    }
	}
    }
}

# We need forward declarations -- we just do it for all classes
if($ARGV[0] eq "c++"){
    print STDERR "Generating forward declarations\n";
    foreach $class (keys %pointers){
	print "class C$class;\n";
    }
    print "\n";
}

# We now know the commonly passed pointers
print STDERR "Outputing classes\n";
foreach $class (keys %pointers){
    $methodid = 1;
    if($suppress{$class} eq ""){
	if($ARGV[0] eq "c++"){
	    print "class C$class\n{
public:\n";

	    if($creates{$class} ne ""){
		# The constructor needs to take the parent
		print "  C$class($class *passed_ptr";
		if(($parents{$class} ne "") && 
		   ($creates{$parents{$class}} ne "")){
		  print ", $parents{$class}* passed_$parents{$class}) :
    m_$parents{$class}(passed_$parents{$class})
    { m_ptr = passed_ptr; }\n";
		}
		else{
		    print ")
    { m_ptr = passed_ptr; }\n";
		}
		
		print "  ~C$class() { panda_xfree(m_ptr); }\n\n";
	    }
	}
	else{
	    print <<EOF;
[
object,
uuid(INSERTUUID),
dual,
pointer_default(unique)
]
interface I$class : IDispatch
{
EOF
	}

	# We need to output all the functions which use one of these pointers
	my($rval, $fval, $aval, $origargs, @argsarray);
	@argsarray = split(/;/, $pointers{$class});

	while($argsarray[0] ne ""){
	    ($rval, $fval, $aval) = split(/!/, shift @argsarray);
	    $origargs = $aval;
	    print STDERR "  Function: $fval\n";

	    # Do we have a child relationship because of this function?
	    $aval =~ s/$class[ \t\*]+[, ]*//;
	    if($parents{$class} ne ""){
		$temp = $parents{$class};
		$aval =~ s/$temp[ \t\*]+[, ]*//;
	    }

	    $_ = $fval;
	    s/[^_*]*_//;
	    if($ARGV[0] eq "c++"){
		# Sometimes instead of returning a straight pointer, 
		# we will want to return a class
		if($pointers{$rval} ne ""){
		    s/\*//;
		    print "  C$rval $_ (";
		}
		else{
		    print "  $rval $_ (";
		}
	    }
	    else{
		print "  [id($methodid)] HRESULT $_(";
		$methodid++;
	    }

	    my($argcount);
	    $argcount = 0;
	    foreach $temp (split/,/, $aval){
		if($argcount > 0){
		    print ", ";
		}
		$temp =~ s/^ //;
		if($ARGV[0] eq "c++"){
		    print "$temp a$argcount";
		}
		else{
		    print "[in] $temp a$argcount";
		}
		    
		# Feed in the passed args
		$origargs =~ s/ *$temp *\**/ a$argcount/;
		$argcount++;
	    }

	    if($ARGV[0] eq "c++"){
		print ") {";

		# Subst our class's pointer
		$origargs =~ s/$class *\*/m_ptr/g;
		
		# How about a parent pointer?
		if($parents{$class} ne ""){
		    $origargs =~ s/$parents{$class} \*/$parents{$class}/;
		    $origargs =~ s/$parents{$class}/m_$parents{$class}/;
		}
		
		$fval =~ s/^\*//;
		if($rval ne "void"){
		    print " return";
		}
		
		# If we are building a class, then do it here
		if($pointers{$rval} ne ""){
		    print " C$rval($fval($origargs)";
		    if($creates{$class} ne ""){
			print ", m_ptr";
		    }
		    print "); ";
		}
		else{
		    print " $fval($origargs); ";
		}
		print "}\n";
	    }
	    else{
		print ");\n";
	    }

	}

	if($ARGV[0] eq "c++"){
	    if($creates{$class} ne ""){
		print "\n";
		print "private:\n";
		print "  $class *m_ptr;\n";
	    }

	    if(($parents{$class} ne "") && ($creates{$parents{$class}} ne "")){
		print "  $parents{$class} *m_$parents{$class};\n";
	    }
	}
	
	print "};\n\n";
    }
}

if($ARGV[0] eq "idl"){
    print <<EOF;
[
uuid(INSERTUUID),
version(1.0),
]
library OBJECTIFYLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(INSERTUUID),
    ]
    coclass Cfoo
    {
	[default] interface Ifoo,
    };
};

EOF
}

print "\n\n// End of file\n";


exit;
