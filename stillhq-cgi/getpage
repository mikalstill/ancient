#!/usr/bin/perl

# This script is used to generate the page that the user has requested.
# The following things are of interest:
#   area = the name of the 'directory' e.g. panda or gpg or gcc
#   page = the name of the page        e.g. index.htm or timetrials
#
# The data is currently stored in the following hashing structure
#   /common = shared page elements     e.g. the table layout for news blocks
#   /<area> = data elements for a given area
#   /<area>/<page> = the layout description for that page
#
# Big commands currently have their own code at the end of this file, smaller
# commands are just dealt with in the config file parser

use strict;
use CGI;

# Dodgy setup stuff for the regexps
local($1, $2, $3, $4);

###############################################################################
# Setup the result of the CGI
my($result, $area, $page, $path, $titleElement, $CONFIG, $dateString, $NEWS, 
   $NEWSITEM, $newsroot, $newsitemsmax, $numnewsitems, $newspath, $archive, 
   $elapsedtime, $days, $ANS, $landf, $filename, $hostname, 
   $editmode, $item, $conffile);

$result = new CGI();

# The path is where to find the information to build the pages
#$path = "/var/www/html/stillhq/";
#$path = "/home/httpd/html/";
#$path = "/var/www/html/";
$path = "/home/s/stillhq/public_html/";

$hostname = `hostname`;

$area = $result->param('area');
if($area eq ""){
  $area = "main";
}
$page = $result->param('page');
$page =~ s/\.\.//g;
if($page eq ""){
  $page = "index.htm";
}

$archive = $result->param('archive');
$editmode = $result->param('editmode');
$item = $result->param('item');

# Output the standard HTML prelude, which includes stuff like the page title
print $result->header;

# What if there was no archive arguement?
if($archive eq ""){
  $archive=0;
  }

# What if there was no editmode arguement?
if($editmode eq ""){
  $editmode=0;
  }

# Get the title element
if($item ne ""){
    $conffile="$path/$area/$page.item";
}
else{
    $conffile="$path/$area/$page.conf";
}

$titleElement=gettitle($conffile);

# We must have a title to be willing to display the page
# If there are no arguements, then output an error message
if($titleElement eq ""){
  error("$path", 
	"Either the page you requested was misconfigured, or does not exist.");
  exit;
  }

#<BODY bgcolor="#CCCCCC" text="#FFFFFF" link="#FF9966" background="copper02.jpg">
print $result->start_html(
			  -title=>"$titleElement",
			  -bgcolor=>"#CCCCCC",
#			  -link=>"#FF9966",
			  -background=>"/common/copper02.jpg"
#			  -script=>"function doMoveBrowser(form) {parent.location.href = form.list.options[getSelectedValue()].value;}\nfunction getSelectedValue() {return document.quickmenu.list.selectedIndex;}"
			  );

# Output the content of the page -- this is based on the lines in the conf file
# (where we got the title from before)
open CONFIG, "grep -v TITLE $conffile |" or die;

while (<CONFIG>){
  if(/^#.*/){
    # This is a comment, so we ignore it
    }
  elsif(/^FILE:[ \t]*(.*)/){
    # If the line starts with FILE: then it is a request to include the 
    # content of that file $1 is the filename that we matched, output it
    chomp $1;
    dumpfile("$path/$1");
    }
  elsif(/^GETPAGE.*/){
    # This prints out a message about who generated the page and when 
    # (useful for debugging)
    $dateString=`date`;
    print "<BR><BR><i>Generated by <a href=\"http://www.stillhq.com/cgi-bin/getpage?area=getpage&page=index.htm\">getpage</a> on $dateString. ";

    # We also put in the date the config file was last changed so that we can 
    # debug versions
    $days=int -M CONFIG;

    # And we comment on how long we spent executing
    $elapsedtime=time - $^T;
    print "Generation of this page took $elapsedtime second(s).</i>";
    }
  elsif(/^LOCATION.*/){
    # This is used to build the site navigation option
    print " : <a href=\"/cgi-bin/getpage?area=$area&page=index.htm\">$area</a> : $titleElement ";
    }
  elsif(/^CONTENT:[ \t]*(.*)[ \t]+(.*)/){
    # $1 is the name of the content file, and $2 is the name of the leader 
    # for look and feel elements
    chomp $2;
    newsitemdisplay($path, "$path/$area/$1", $2, "DODATE");
    }
  elsif(/^CONTENTX:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
    # $1 is the name of the content file, and $2 is the name of the leader 
    # for look and feel elements $3 is whether we should show the date on the 
    # headline (NODATE means NO)
    chomp $3;
    newsitemdisplay($path, "$path/$area/$1", $2, $3);
    }
  elsif(/^ITEM.*/){
    # Dump the item from the index
    newsitemdisplay($path, "$path/$area/$item", "common/indexitem", "DODATE");
    }
  elsif(/^NEWS:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
      cmdNEWS($1, $2, $3);
  }
  elsif(/^INDEX:[ \t]*(.*)[ \t]+(.*)/){
      cmdINDEX($1, $2);
  }
  else{
    # This is a line of content
    print $_;
    }
  }

# Close the config file
close(CONFIG);

# Finish off the page
print $result->end_html;

exit;

###############################################################################
# Get the title element from a page description
sub gettitle{
    my($filename) = @_;

    return `cat $filename | grep TITLE | sed 's/TITLE:[ \t]*//'`;
}

###############################################################################
# Get the postdate element from a page description
sub getdate{
    my($filename) = @_;

    return `cat $filename | grep POSTDATE | sed 's/POSTDATE:[ \t]*//'`;
}

###############################################################################
# Dump the named file to stdout
sub dumpfile{
  my($file) = @_;
  my($FILEBIT);

  print "\n<! $file >\n";
  open FILEBIT, $file;

  while(<FILEBIT>){
    print "$_";
    }

  print "\n";
  close(FILEBIT);
  }

###############################################################################
# Display an error message to the user
sub error{
  my($path, $message) = @_;
  my($email);

  dumpfile("$path/common/stdnews-start");
  print "Error!";
  dumpfile("$path/common/stdnews-divider");
  print "$message\n";
  print "</b><BR><BR>\n";
  print "Please contact <a href=\"mailto:mikal\@stillhq.com\">mikal\@stillhq.com</a> and let him know the URL you were trying to access (normally at the top of the page), and what link you clicked on to get here (if there was one).\n";
  dumpfile("$path/common/stdnews-end");

  # Send an email informing Mikal of the error
  $email = "An error occured on stillhq.com: ".$result->self_url."\n\n".
    "The message was:\n".$message."\n\n\n";
  `echo "$email" | mail -s "Stillhq.com error" mikal`;

  print $result->end_html;
}

###############################################################################
# Display a news item to the user
sub newsitemdisplay{
    my($path, $filename, $newsroot, $dateit) = @_;
    my($NEWSITEM, $temp); 

    if($editmode == 1){
	print $result->start_form(-action=>"/cgi-bin/auth/editnews");

	# Remember where we are adding the news items to
	print $result->input(
			     {-type=>'hidden', -name=>'newsitem', -value=>"$filename"});
    }

    open NEWSITEM, $filename;

    # Output the news starter
    dumpfile("$path/$newsroot-start");

    # Output the given news item
    while(<NEWSITEM>){
	if(/^TITLE:[ \t]*(.*)/){
	    if($editmode == 1){
		$temp = $1;
		$temp =~ s/\"/&quot\;/g;
		print $result->input(
				     {-type=>'text', -size=>100, -name=>"title", -value=>$temp});
	    }
	    else{
		print "$1\n";
	    }

	    dumpfile("$path/$newsroot-divider");
	}
	elsif(/POSTDATE:[ \t]*(.*)/){
	    if($dateit ne "NODATE"){
		print "$1 - ";
	    }

	    if($editmode == 1){
		$temp = $1;
		print $result->input(
				     {-type=>'hidden', -name=>"postdate", -value=>$temp});
	    }
	}
	elsif(/POSTER:[ \t]*(.*)/){
	    if($dateit ne "NODATE"){
		print "<a href=\"mailto:$1\">";
	    }

	    if($editmode == 1){
		$temp = $1;
		print $result->input(
				     {-type=>'hidden', -name=>"postemail", -value=>$temp});
	    }
	}
	elsif(/POSTERNAME:[ \t]*(.*)/){
	    if($dateit ne "NODATE"){
		print "$1</a></b><BR><BR>\n";
	    }
	    else{
		print "</b>\n";
	    }

	    if($editmode == 1){
		$temp = $1;
		print $result->input(
				     {-type=>'hidden', -name=>"poster", -value=>$temp});
		
	    }
	}
	elsif(/BEGIN CONTENT/){
	    $temp = "";
	    while(<NEWSITEM>){
		if($editmode == 1){
		    $temp = "$temp$_";
		    }
		else{
		    print "$_";
		}
	    }
	    
	    if($editmode == 1){
		print $result->textarea(
					{-rows=>10, -cols=>70, -wrap=>'physical', -name=>"content", -default=>"$temp"});
	    }

	    if($editmode == 1){
		print "<BR><HR><BR><BR>";
		print $result->submit(-value=>" Are you sure? ", -name=>"commit");
		print $result->end_form;
	    }

	    dumpfile("$path/$newsroot-end");
	}
    }
    
    close(NEWSITEM);
}

###############################################################################
# Display news items on the output page
sub cmdNEWS{
    my($name, $number, $landf) = @_;
    my(@newsareas);

    if($editmode == 1){
      # We are in add mode, at which time we need to add some empty fields to 
      # the page
      print $result->start_form(-action=>"/cgi-bin/auth/commitnews");

      $_ = `ls $path/news/`;
      @newsareas = split; 

      # Output the news starter
      dumpfile("$path/$landf-start");
      print "Add an item to $name <BR> <I>(displays $number with look and feel from $landf)</I> <BR><BR> ";
      print "Cross post to (multiple selections allowed):<BR>";
      print $result->scrolling_list(
			   {-name=>'crosspost', -values=>\@newsareas,
			    -size=>5, -multiple=>'true'});
      print "<BR>";

      # Remember where we are adding the news items to
      print $result->input(
			   {-type=>'hidden', -name=>'newsitem', -value=>$name});

      # News title
      print $result->input(
			   {-type=>'text', -size=>50, -name=>"title"});

      dumpfile("$path/$landf-divider");

      # Entry date
      print $result->input(
			   {-type=>'text', -size=>20, -name=>"postdate",
			    -value=>`date "+%d %B %Y"`});

      print " - ";

      # Name of the person who added the entry and their email address
      print $result->input(
			   {-type=>'text', -size=>10, -name=>"poster"});

      print " @ ";

      print $result->input(
			   {-type=>'text', -size=>30, -name=>"postemail"});

      print "<BR><BR>";

      # And finally the entry itself
      print $result->textarea(
			      {-rows=>10, -cols=>70, -wrap=>'physical', -name=>"content"});

      # Finish the entry and then ask for a confirmation
      print "<BR><HR><BR>";
      print $result->submit(-value=>" Are you sure? ", -name=>"commit");
      dumpfile("$path/$landf-end");
      
      # And finish the form
      print $result->end_form;
      }

    if($archive == 0){
      open NEWS, "ls $path/news/$name | sort -r | head -$number |";
      }
    else{
      open NEWS, "ls $path/news/$name | sort -r |";
      }

    $newsroot=$landf;
    $newsitemsmax=$number;
    $newspath=$name;

    # For each news item, output it
    while(<NEWS>){
      chomp $_;

      newsitemdisplay($path, "$path/news/$name/$_", $newsroot);
      }

    close(NEWS);

    # We check to see if there were any news items that were not displayed, because
    # we make an archive available
    $numnewsitems=`ls $path/news/$newspath | wc -l | tr -d " "`;

    if(($numnewsitems > $newsitemsmax) && ($archive == 0)){
      dumpfile("$path/common/endnews-start");
      print "More News...\n";
      dumpfile("$path/common/endnews-divider");
      print "</B>There are more items than were displayed. Would you like to <a href=\"/cgi-bin/getpage?area=$area&page=$page&archive=1\">read more</a>?";
      dumpfile("$path/common/endnews-end");
      }
}

sub cmdINDEX{
    my($indexname, $landf) = @_;
    my($indexitem, %indexhash, $indexentry, $temp, $cellcount);

    # For each file's keywords
    open NEWS, "grep KEYWORDS $path/$indexname/* | sed 's/KEYWORDS:[ \t]*//' |";
    while(<NEWS>){
	# The bit before the colon is the filename, the bit after is the space
	# delimited list of keywords
	/(.*)\/(.*):(.*)/;

	foreach $indexitem (split(/ /, $3)){
	    if($indexhash{$indexitem} ne ""){
		$indexhash{$indexitem} = "$indexhash{$indexitem}!";
	    }

	    $indexhash{$indexitem} = "$indexhash{$indexitem}$2";
	}
    }
    close NEWS;

    # Now we dump the index we just built
    foreach $indexitem (sort(keys(%indexhash))){
        dumpfile("$path/$landf-start");
	print "$indexitem";
	dumpfile("$path/$landf-divider");

	foreach $indexentry (split(/!/, $indexhash{$indexitem})){
	    print "<A href=\"getpage?area=$indexname&page=$indexname&item=$indexentry\">";

	    $temp = gettitle("$path/$indexname/$indexentry");
	    $_ = $temp;
	    /(.*)[ \t]*/;
	    print "<B>$1</B></a> ";

	    $temp = getdate("$path/$indexname/$indexentry");
	    $_ = $temp;
	    /(.*)[ \t]*/;
	    print "($1)<BR>";
	}

	dumpfile("$path/$landf-end");
    }
}
