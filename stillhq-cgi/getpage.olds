#!/usr/bin/perl

# This script is used to generate the page that the user has requested.
# The following things are of interest:
#   area = the name of the 'directory' e.g. panda or gpg or gcc
#   page = the name of the page        e.g. index.htm or timetrials

# The data is currently stored in the following hashing structure
#   /common = shared page elements     e.g. the table layout for news blocks
#   /<area> = data elements for a given area
#   /<area>/<page> = the layout description for that page

# Please don't laugh at my perl, this was all developed as a perl learning
# exercise.

use strict;
use CGI;

# Setup the result of the CGI
my($result, $area, $page, $path, $titleElement, $CONFIG, $dateString, $NEWS, $NEWSITEM,
  $newsroot, $newsitemsmax, $numnewsitems, $newspath, $archive, $elapsedtime, $days, $ANS,
  $landf, $faqdir, $filename, $hostname);
$result = new CGI();

# The path is where to find the information to build the pages
$path = "/var/www/html/stillhq/";
$hostname = "wibble";

$area = $result->param('area');
$page = $result->param('page');
$archive = $result->param('archive');

# Output the standard HTML prelude, which includes stuff like the page title
print $result->header;

# If there are no arguements, then output an error message
if(($area eq "") || ($page eq "")){
  error("$path", "The address that was passed as input was malformed");
  exit;
  }

# What if there was no archive arguement?
if($archive eq ""){
  $archive=0;
  }

# Get the title element
$titleElement=`cat $path/$area/$page.conf | grep TITLE | sed 's/TITLE:[ \t]*//'`;

# We must have a title to be willing to display the page
# If there are no arguements, then output an error message
if($titleElement eq ""){
  error("$path", "Either the page you requested was misconfigured, or does not exist");
  exit;
  }

print $result->start_html(
 -title=>"$titleElement",
 -bgcolor=>"FFFFFF");

# Output the content of the page -- this is based on the lines in the conf file
# (where we got the title from before)
open CONFIG, "grep -v TITLE $path/$area/$page.conf |" or die;

while (<CONFIG>){
  if(/^#.*/){
    # This is a comment, so we ignore it
    }
  elsif(/^FILE:[ \t]*(.*)/){
    # If the line starts with FILE: then it is a request to include the content of that file
    # $1 is the filename that we matched, output it
    chomp $1;
    dumpfile("$path/$1");
    }
  elsif(/^GETPAGE.*/){
    # This prints out a message about who generated the page and when (useful for debugging)
    $dateString=`date`;
    print "<BR><BR><i>Generated by getpage on $dateString. ";

    # We also put in the date the config file was last changed so that we can debug versions
    $days=int -M CONFIG;

#    if($days < 1){
#      print "This page was changed today ";
#      }
#    elsif($days < 2){
#      print "This page was changed yesterday ";
#      }
#    else{
#      print "The content of this page was last changed $days days ago ";
#      }

#    $days=int -A CONFIG;
#    if($days < 1){
#      print "and has had other vistors today. ";
#      }
#    elsif($days < 2){
#      print "and was last visited yesterday. ";
#      }
#    else{
#      print "and was last visited $days days ago. ";
#      }

    # And we comment on how long we spent executing
    $elapsedtime=time - $^T;
    print "Generation of this page took $elapsedtime second(s).</i>";
    }
  elsif(/^LOCATION.*/){
    # This is used to build the site navigation option
    print " : <a href=\"/cgi-bin/getpage?area=$area&page=index.htm\">$area</a> : $titleElement ";
    }
  elsif(/^CONTENT:[ \t]*(.*)[ \t]+(.*)/){
    # $1 is the name of the content file, and $2 is the name of the leader for look and feel elements
    chomp $2;
    newsitemdisplay($path, "$path/$area/$1", $2, "DODATE");
    }
  elsif(/^CONTENTX:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
    # $1 is the name of the content file, and $2 is the name of the leader for look and feel elements
    # $3 is whether we should show the date on the headline (NODATE means NO)
    chomp $3;

    newsitemdisplay($path, "$path/$area/$1", $2, $3);
    }
  elsif(/^FAQ:[ \t]*(.*)[ \t]+(.*)/){
    # $1 is the location of the faq data directory, and $2 is the look and feel elements
    chomp $2;
    $landf = $2;
    $faqdir = $1;

    open NEWS, "ls $path/$1 | grep -v 'a' | sort -r |";
    #open NEWS, "grep TITLE $path/$1 | egrep -v 'a[0-9]+:' | cut -f 2 -d ' ' |";
    while(<NEWS>){
      chomp $_;

      $filename = `grep TITLE $path/$1 | grep $_ | sed 's/:.*//'`;

      # Display the question...
      faqitemdisplay($path, "$path/$1/$filename", $landf, "Q");
      
      open ANS, "ls $path/$1/$filename* | sort |";
      while(<ANS>){
	if(/^.*\/(.*)-a(.*)/){
	  faqitemdisplay($path, "$path/$faqdir/$1-a$2", $landf, "A");
          }
        }

      close(ANS);
      dumpfile("$path/$landf-end");
      }

    close(NEWS);
    }
  elsif(/^NEWS:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
    # $1 is the name of the news type, $2 is the number of news items is display, and $3
    # is the leader for the look and feel elements
    
    if($archive == 0){
      open NEWS, "ls $path/news/$1 | sort -r | head -$2 |";
      }
    else{
      open NEWS, "ls $path/news/$1 | sort -r |";
      }

    $newsroot=$3;
    $newsitemsmax=$2;
    $newspath=$1;

    # For each news item, output it
    while(<NEWS>){
      chomp $_;

      newsitemdisplay($path, "$path/news/$1/$_", $newsroot);
      }

    close(NEWS);

    # We check to see if there were any news items that were not displayed, because
    # we make an archive available
    $numnewsitems=`ls $path/news/$newspath | wc -l | tr -d " "`;

    if(($numnewsitems > $newsitemsmax) && ($archive == 0)){
      dumpfile("$path/common/endnews-start");
      print "More News...\n";
      dumpfile("$path/common/endnews-divider");
      print "</B>There are more items than were displayed. Would you like to <a href=\"/cgi-bin/getpage?area=$area&page=$page&archive=1\">read more</a>?";
      dumpfile("$path/common/endnews-end");
      }
    }
  else{
    # This is a line of content
    print $_;
    }
  }

# Close the config file
close(CONFIG);

# Finish off the page
print $result->end_html;

exit;

# Dump the named file to stdout
sub dumpfile{
  my($file) = @_;
  my($FILEBIT);

  print "\n<! $file >\n";
  open FILEBIT, $file;

  while(<FILEBIT>){
    print "$_";
    }

  print "\n";
  close(FILEBIT);
  }

# Display an error message to the user
sub error{
  my($path, $message) = @_;

  dumpfile("$path/common/stdnews-start");
  print "Error!";
  dumpfile("$path/common/stdnews-divider");
  print "$message\n";
  print "</b><BR><BR>\n";
  print "Please contact <a href=\"mailto:mikal\@stillhq.com\">mikal\@stillhq.com</a> and let him know the URL you were trying to access (normally at the top of the page), and what link you clicked on to get here (if there was one).\n";
  dumpfile("$path/common/stdnews-end");
  print $result->end_html;
}

# Display a news item to the user
sub newsitemdisplay{
  my($path, $filename, $newsroot, $dateit) = @_;
  my($NEWSITEM); 

  open NEWSITEM, $filename;

  # Output the news starter
  dumpfile("$path/$newsroot-start");

  # Output the given news item
  while(<NEWSITEM>){
    if(/^TITLE:[ \t]*(.*)/){
      print "$1\n";

      # This is new and allows for editting is we are running on
      # my laptop

      dumpfile("$path/$newsroot-divider");
      }
    elsif(/POSTDATE:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "$1 - ";
        }
      }
    elsif(/POSTER:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "<a href=\"mailto:$1\">";
        }
      }
    elsif(/POSTERNAME:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "$1</a></b><BR><BR>\n";
        }
      else{
	print "</b>\n";
        }
      }
    elsif(/BEGIN CONTENT/){
      while(<NEWSITEM>){
        print "$_";
        }

      dumpfile("$path/$newsroot-end");
      }
    }

  close(NEWSITEM);
  }

# Display a news item to the user
sub faqitemdisplay{
  my($path, $filename, $newsroot, $state) = @_;
  my($NEWSITEM); 

  open NEWSITEM, $filename or die "Could not open $filename";

  # Output the news starter
  if($state eq "Q"){
    dumpfile("$path/$newsroot-start");
    }
  else{
    dumpfile("$path/$newsroot-ans-start");
    }

  # Output the given news item
  while(<NEWSITEM>){
    if(/^TITLE:[ \t]*(.*)/){
      if($state eq "Q"){
        print "$1\n";
        dumpfile("$path/$newsroot-divider");
        }
      }
    elsif(/POSTDATE:[ \t]*(.*)/){
      if($state ne "Q"){
        print "$1 - ";
        }
      }
    elsif(/POSTER:[ \t]*(.*)/){
      if($state ne "Q"){
        print "<a href=\"mailto:$1\">";
        }
      }
    elsif(/POSTERNAME:[ \t]*(.*)/){
      if($state ne "Q"){
        print "$1</a></b><BR><BR>\n";
        }
      else{
	print "</b>\n";
        }
      }
    elsif(/BEGIN CONTENT/){
      while(<NEWSITEM>){
        print "$_";
        }
      }
    }

  if($state ne "Q"){
    dumpfile("$path/$newsroot-ans-end");
    }

  close(NEWSITEM);
  }

