package getpage;
require Exporter;

###############################################################################
# This simple module just contains utility stuff for getpage that we use all 
# over the place...
###############################################################################

# Export some symbols
@ISA = qw(Exporter);
@EXPORT = qw(init gettitle getdate dumpfile error processfile processline newsitemdisplay);

use strict;

my($path, $ftppath, $dateString, $area, $page, $days, $titleElement,
   $item, $elapsedtime, $result, $archive, $editmode);

###############################################################################
# Initialise the module
sub init{
    ($path, $ftppath, $dateString, $area, $page, $days, $titleElement,
     $item, $elapsedtime, $result, $archive, $editmode) = @_;
}

###############################################################################
# Get the title element from a page description
sub gettitle{
    my($filename) = @_;

    return `cat $filename | grep TITLE | sed 's/TITLE:[ \t]*//'`;
}

###############################################################################
# Get the postdate element from a page description
sub getdate{
    my($filename) = @_;

    return `cat $filename | grep POSTDATE | sed 's/POSTDATE:[ \t]*//'`;
}

###############################################################################
# Dump the named file to stdout
sub dumpfile{
  my($file) = @_;
  my($FILEBIT);

  print "\n<! $file >\n";
  open FILEBIT, $file;

  while(<FILEBIT>){
    print "$_";
    }

  print "\n";
  close(FILEBIT);
  }

###############################################################################
# Display an error message to the user
sub error{
  my($path, $message, $result) = @_;

  dumpfile("$path/common/stdnews-start");
  print "Error!";
  dumpfile("$path/common/stdnews-divider");
  print "$message\n";
  print "</b><BR><BR>\n";
  print "Please contact <a href=\"mailto:mikal\@stillhq.com\">mikal\@stillhq.com</a> and let him know the URL you were trying to access (normally at the top of the page), and what link you clicked on to get here (if there was one).\n";
  dumpfile("$path/common/stdnews-end");
  print $result->end_html;
}


###############################################################################
# This function process a file, and allows us to be recursive
sub processfile{
    my($conffile) = @_;
    local *CONFIG, *FILELIST;

    open CONFIG, "grep -v TITLE $conffile |" or die;
    local $_;
    print "<!-- Processing file $conffile -->\n";

    while (<CONFIG>){
	processline($_);
    }    
    
    # Close the config file
    close(CONFIG);

    print "<!-- End $conffile -->\n";
}

sub processline{
    my($line) = @_;
    my($temp);

    $_ = $line;

    if(/^#.*/){
       # This is a comment, so we ignore it
    }
    elsif(/^FILE:[ \t]*(.*)/){
	# If the line starts with FILE: then it is a request to include 
	# the content of that file $1 is the filename that we matched, 
	# output it, with recursive command parsing
	$temp = $1;
	chomp $temp;
	# dumpfile("$path/$temp");
	processfile("$path/$temp", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
    }
    elsif(/^GETPAGE.*/){
	# This prints out a message about who generated the page and when 
	# (useful for debugging)
	$dateString=`date`;
	print "<BR><BR><i>Generated by <a href=\"http://www.stillhq.com/cgi-bin/getpage?area=getpage&page=index.htm\">getpage</a> on $dateString. ";
	
	# We also put in the date the config file was last changed so 
	# that we can debug versions
	$days=int -M CONFIG;
	
	# And we comment on how long we spent executing
	$elapsedtime=time - $^T;
	print "Generation of this page took $elapsedtime second(s).</i>";
    }
    elsif(/^LOCATION.*/){
	# This is used to build the site navigation option
	print " : <a href=\"/cgi-bin/getpage?area=$area&page=index.htm\">$area</a> : $titleElement ";
    }
    elsif(/^CONTENT:[ \t]*(.*)[ \t]+(.*)/){
	# $1 is the name of the content file, and $2 is the name of the 
	# leader for look and feel elements
	$temp = $2;
	chomp $temp;
	newsitemdisplay($path, "$path/$area/$1", $temp, "DODATE");
    }
    elsif(/^CONTENTX:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
	# $1 is the name of the content file, and $2 is the name of the 
	# leader for look and feel elements $3 is whether we should show 
	# the date on the headline (NODATE means NO)
	$temp = $3;
	chomp $temp;
	newsitemdisplay($path, "$path/$area/$1", $2, $temp);
    }
    elsif(/^ITEM.*/){
	# Dump the item from the index
	newsitemdisplay($path, "$path/$area/$item", "common/indexitem", 
			"DODATE");
    }
    elsif(/^NEWS:[ \t]*(.*)[ \t]+(.*)[ \t]+(.*)/){
	cmdNEWS($1, $2, $3);
    }
    elsif(/^INDEX:[ \t]*(.*)[ \t]+(.*)/){
	cmdINDEX($1, $2);
    }
    elsif(/^OPTIONFTPFILELIST:[ \t]*(.*)/){
	open FILELIST, "ls $ftppath/$1 |";
	while(<FILELIST>){
	    print "<option value=\"$_\">$_</a>\n";
	}
	close FILELIST;
	print "<option value=\"NULL\">End of list</a>\n";
    }
    else{
	# This is a line of content
	print "$_";
    }
}

###############################################################################
# Display a news item to the user
sub newsitemdisplay{
  my($path, $filename, $newsroot, $dateit) = @_;
  my($NEWSITEM); 

  open NEWSITEM, $filename;

  # Output the news starter
  #dumpfile("$path/$newsroot-start");
  processfile("$path/$newsroot-start", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);

  # Output the given news item
  while(<NEWSITEM>){
    if(/^TITLE:[ \t]*(.*)/){
      print "$1\n";

      # This is new and allows for editting is we are running on
      # my laptop
#      if($hostname == "deathstar"){
#	print "<div align=right>Edit\n";
#      }

      #dumpfile("$path/$newsroot-divider");
      processfile("$path/$newsroot-divider", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
      }
    elsif(/POSTDATE:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "$1 - ";
        }
      }
    elsif(/POSTER:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "<a href=\"mailto:$1\">";
        }
      }
    elsif(/POSTERNAME:[ \t]*(.*)/){
      if($dateit ne "NODATE"){
        print "$1</a></b><BR><BR>\n";
        }
      else{
	print "</b>\n";
        }
      }
    elsif(/BEGIN CONTENT/){
      while(<NEWSITEM>){
        #print "$_";
	processline($_, $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
        }

      #dumpfile("$path/$newsroot-end");
      processfile("$path/$newsroot-end", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
      }
    }

  close(NEWSITEM);
  }

###############################################################################
# Display news items on the output page
sub cmdNEWS{
    my($name, $number, $landf) = @_;
    my(@newsareas, $newsitemsmax, $numnewsitems, $newspath, $newspath, $newsroot);

    if($editmode == 1){
      # We are in add mode, at which time we need to add some empty fields to 
      # the page
      print $result->start_form(-action=>"/cgi-bin/auth/commitnews");

      $_ = `ls $path/news/`;
      @newsareas = split; 

      # Output the news starter
      #dumpfile("$path/$landf-start");
      processfile("$path/$landf-start", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);

      print "Add an item to $name <BR> <I>(displays $number with look and feel from $landf)</I> <BR><BR> ";
      print "Cross post to (multiple selections allowed):<BR>";
      print $result->scrolling_list(
			   {-name=>'crosspost', -values=>\@newsareas,
			    -size=>5, -multiple=>'true'});
      print "<BR>";

      # Remember where we are adding the news items to
      print $result->input(
			   {-type=>'hidden', -name=>'newsitem', -value=>$name});

      # News title
      print $result->input(
			   {-type=>'text', -size=>50, -name=>"title"});

      #dumpfile("$path/$landf-divider");
      processfile("$path/$landf-divider", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
      
      # Entry date
      print $result->input(
			   {-type=>'text', -size=>20, -name=>"postdate",
			    -value=>`date "+%d %B %Y"`});

      print " - ";

      # Name of the person who added the entry and their email address
      print $result->input(
			   {-type=>'text', -size=>10, -name=>"poster"});

      print " @ ";

      print $result->input(
			   {-type=>'text', -size=>30, -name=>"postemail"});

      print "<BR><BR>";

      # And finally the entry itself
      print $result->textarea(
			      {-rows=>10, -cols=>70, -wrap=>'physical', -name=>"content"});

      # Finish the entry and then ask for a confirmation
      print "<BR><HR><BR>";
      print $result->submit(-value=>" Are you sure? ", -name=>"commit");
      #dumpfile("$path/$landf-end");
      processfile("$path/$landf-end", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);

      # And finish the form
      print $result->end_form;
      }

    if($archive == 0){
      open NEWS, "ls $path/news/$name | sort -r | head -$number |";
      }
    else{
      open NEWS, "ls $path/news/$name | sort -r |";
      }

    $newsroot=$landf;
    $newsitemsmax=$number;
    $newspath=$name;

    # For each news item, output it
    while(<NEWS>){
      chomp $_;

      newsitemdisplay($path, "$path/news/$name/$_", $newsroot);
      }

    close(NEWS);

    # We check to see if there were any news items that were not displayed, because
    # we make an archive available
    $numnewsitems=`ls $path/news/$newspath | wc -l | tr -d " "`;

    if(($numnewsitems > $newsitemsmax) && ($archive == 0)){
      #dumpfile("$path/common/endnews-start");
      processfile("$path/common/endnews-start", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);

      print "More News...\n";
      #dumpfile("$path/common/endnews-divider");
      processfile("$path/common/endnews-divider", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
      print "</B>There are more items than were displayed. Would you like to <a href=\"/cgi-bin/getpage?area=$area&page=$page&archive=1\">read more</a>?";
      #dumpfile("$path/common/endnews-end");
      processfile("$path/common/endnews-end", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
      }
}

sub cmdINDEX{
    my($indexname, $landf) = @_;
    my($indexitem, %indexhash, $indexentry, $temp, $cellcount);

    # For each file's keywords
    open NEWS, "grep KEYWORDS $path/$indexname/* | sed 's/KEYWORDS:[ \t]*//' |";
    while(<NEWS>){
	# The bit before the colon is the filename, the bit after is the space
	# delimited list of keywords
	/(.*)\/(.*):(.*)/;

	foreach $indexitem (split(/ /, $3)){
	    if($indexhash{$indexitem} ne ""){
		$indexhash{$indexitem} = "$indexhash{$indexitem}!";
	    }

	    $indexhash{$indexitem} = "$indexhash{$indexitem}$2";
	}
    }
    close NEWS;

    # Now we dump the index we just built
    foreach $indexitem (sort(keys(%indexhash))){
        #dumpfile("$path/$landf-start");
	processfile("$path/$landf-start", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
	print "$indexitem";
	#dumpfile("$path/$landf-divider");
	processfile("$path/$landf-divider", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);

	foreach $indexentry (split(/!/, $indexhash{$indexitem})){
	    print "<A href=\"getpage?area=$indexname&page=$indexname&item=$indexentry\">";

	    $temp = gettitle("$path/$indexname/$indexentry");
	    $_ = $temp;
	    /(.*)[ \t]*/;
	    print "<B>$1</B></a> ";

	    $temp = getdate("$path/$indexname/$indexentry");
	    $_ = $temp;
	    /(.*)[ \t]*/;
	    print "($1)<BR>";
	}

	#dumpfile("$path/$landf-end");
	processfile("$path/$landf-end", $path, $dateString, $days, $elapsedtime, $area, $titleElement, $item);
    }
}
