#!/bin/bash

# shdns: take a query and build a response

##############################################################################
# Utility functions
##############################################################################

# The state of a given bit in the byte
dumpbit(){
  local temp
  temp=$1

  if [ $1 -gt $(( $2 - 1 )) ]
  then
    echo -n "1"
    temp=$(( $1 - $2 ))
  else
    echo -n "0"
  fi

  return $temp
}

# The state of the whole byte
dumpbyte(){
  local temp
  temp=$1

  dumpbit $temp 128
  temp=$?
  dumpbit $temp 64
  temp=$?
  dumpbit $temp 32
  temp=$?
  dumpbit $temp 16
  temp=$?
  dumpbit $temp 8
  temp=$?
  dumpbit $temp 4
  temp=$?
  dumpbit $temp 2
  temp=$?
  dumpbit $temp 1
}

# Is a given bit on?
testbit(){
  return `dumpbit $1 $2`
}

# Turn on a given bit in the byte
twiddlebit(){
  local temp
  temp=$1

  testbit $1 $2
  if [ $? = 1 ]
  then
    if [ $3 = 0 ]
    then
      temp=$(( $temp - $2 ))
    fi
  else 
    if [ $3 = 1 ]
    then
      temp=$(( $temp + $2 ))
    fi
  fi

  return $temp
}

# Spin until a byte exists
spinfor(){
  local len

  len=`cat $1 | wc -c | tr -d " "`
  while [ $len -lt $2 ]
  do
    logger "shdns $$ Span on byte $2"
    usleep $3
    len=`cat $1 | wc -c | tr -d " "`
  done
}

# Read a single byte from a file
readbyte(){
  spinfor $1 $2 10 
  cat $1 | cut -b $2
}

# Read a range of bytes from a file
readstring(){
  spinfor $1 $(( $2 + $3 - 1 )) 10
  logger "shdns $$ Getting byte range $1:$2-"$(( $2 + $3 - 1 ))":$3"
  cat $1 | cut -b $2-$(( $2 + $3 - 1 ))
}

# Read a single binary byte from a file
readbytebinary(){
  local temp

  spinfor $1 $2 1000
  temp=`cat $1 | cut -b $2 | od -Ad -c | head -1 | tr -s " " | cut -f 2 -d " "`
  if [ `echo $temp | cut -b 1` = "\\" ]
  then
    case `echo $temp | cut -b 2` in
    0 ) temp="0";;
    a ) temp="7";;
    b ) temp="8";;
    t ) temp="9";;
    n ) temp="10";;
    v ) temp="11";;
    f ) temp="12";;
    \\ ) temp="92";;
    * ) echo "Error: Unknown escape binary sequence"; exit;;
    esac
  fi
  
  return $temp
}

###############################################################################

process(){
  logger "shdns $$ Started parsing $1 at $2"
  inset=$2

  # Identification: 2 bytes
  id=`cat $1 | cut -b $inset,$(( $inset + 1 ))`; inset=$(( $inset + 2 ))
  logger "shdns $$ Packet id: $id"

  # Flags: 2 bytes
  temp=`cat $1 | cut -b $inset |  od -Ad -c | head -1 | cut -f 2 -d " "`; inset=$(( $inset + 1 ))
  testbit $temp 128; qr=$?
  testbit $temp 8; op=$?
  testbit $temp 4; aa=$?
  testbit $temp 2; trun=$?
  testbit $temp 1; rd=$?

  logger "shdns $$ Query / response: $qr"
  logger "shdns $$ Opcode: $op"
  logger "shdns $$ Authoritative answer: $aa"
  logger "shdns $$ Packet truncated: $trun"
  logger "shdns $$ Recursion desired: $rd"

  readbytebinary "$1" $inset; temp=$?; inset=$(( $inset + 1 ))
  testbit $temp 128; ra=$?
  
  logger "shdns $$ Recursion available: $ra"
  
  # The number of questions is the next two bytes
  readbytebinary "$1" $inset; topbyte=$?; inset=$(( $inset + 1 ))
  readbytebinary "$1" $inset; botbyte=$?; inset=$(( $inset + 1 ))
  qcount=$(( ($topbyte * 128) + $botbyte ))
  logger "shdns $$ Number of questions: $qcount"
  
  # The number of answers is the next two bytes
  readbytebinary "$1" $inset; topbyte=$?; inset=$(( $inset + 1 ))
  readbytebinary "$1" $inset; botbyte=$?; inset=$(( $inset + 1 ))
  acount=$(( ($topbyte * 128) + $botbyte ))
  logger "shdns $$ Number of answers: $acount"
  
  # The number of authority RRs is the next two bytes
  readbytebinary "$1" $inset; topbyte=$?; inset=$(( $inset + 1 ))
  readbytebinary "$1" $inset; botbyte=$?; inset=$(( $inset + 1 ))
  authcount=$(( ($topbyte * 128) + $botbyte ))
  logger "shdns $$ Number of authorities: $authcount"
  
  # The number of additional RRs is the next two bytes
  readbytebinary "$1" $inset; topbyte=$?; inset=$(( $inset + 1 ))
  readbytebinary "$1" $inset; botbyte=$?; inset=$(( $inset + 1 ))
  addcount=$(( ($topbyte * 128) + $botbyte ))
  logger "shdns $$ Number of additionals: $addcount"
  
  ######################
  # For each question
  ######################
  
  len=42
  questioncount=0
  
  while [ $questioncount -lt $qcount ]
  do
    logger "shdns $$ Question"
    name=""
  
    readbytebinary "$1" $inset; len=$?
    while [ $len -gt 0 ]
    do
      inset=$(( $inset + 1 ))
      name="$name"`readstring "$1" $inset $len`"."
      inset=$(( $inset + $len ))
      readbytebinary "$1" $inset; len=$? 
    done  
    inset=$(( $inset + 1 ))
    logger "shdns $$ Lookup: $name"
  
    # Type of question
    readbytebinary "$1" $inset; type=$?
    temp="  Query type:"
  
    case $type in
    1 ) temp="$temp A";;
    2 ) temp="$temp NS";;
    5 ) temp="$temp CNAME";;
    12 ) temp="$temp PTR";;
    13 ) temp="$temp HINFO";;
    15 ) temp="$temp MX";;
    * ) temp="Error: Unknown query type"; exit;;
    esac
  
    logger $temp
    inset=$(( $inset + 1 ))  

    # The class should always be 1
    readbytebinary "$1" $inset; class=$?; inset=$(( $inset + 1 ))
    logger "shdns $$ Query class: $class"
  
    # Dodgy bug fix
    name=`echo $name | sed 's/\.$//'`
    
    # Lookup the name in the db file
    logger "shdns $$ Result:" `grep "$name" /home/mikal/opensource/shdns/lookup | tr -s "\t" | cut -f 2`
  
    questioncount=$(( $questioncount + 1 ))
  done

  echo $inset
}

###############################################################################

offset=1
while [ 1 -ne 0 ]
do
  spinfor $1 $offset
  offset=`process $1 $offset`
done

exit

