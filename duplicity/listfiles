#!/usr/bin/python

"""What files are backed up on this media?"""

import sys
sys.path.append('/data/src/stillhq_public/trunk/python/')

import datetime
import os
import random
import re
import subprocess
import time
import traceback
import MySQLdb

import gflags
import sql


FLAGS = gflags.FLAGS
gflags.DEFINE_string('dbuser', 'duplicity', 'DB username')
gflags.DEFINE_string('dbpassword', 'duplicity', 'DB user password')
gflags.DEFINE_string('dbname', 'duplicity', 'DB name')

gflags.DEFINE_string('media', '', 'The name of the backup media')
gflags.DEFINE_string('path', '', 'The path to the backup media')

gflags.DEFINE_boolean('pool', False, 'Process backups in parallel')


SCRIPTS_PATH = '/data/src/stillhq_public/trunk/duplicity'
VERBOSE = False

# Thu Apr 28 13:54:45 2011 www.old/index.html
FILE_RE = re.compile('  ([^ ]+) ([^ ]+) .* \(([0-9]+)\)$')

# duplicity-full-signatures.20110824T155213Z.sigtar.gz
FULL_BACKUP_RE = re.compile('duplicity-full-signatures.'
                            '([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])T'
                            '([0-9][0-9])([0-9][0-9])([0-9][0-9])')

BACKUP_GAP = datetime.timedelta(hours=1)


def PrintProgress(cursor, extra=''):
  global total_days
  global completed_days

  cursor.execute('select count(*) from filesystem;')
  unique_files = cursor.fetchone()['count(*)']
  cursor.execute('select count(*) from versions;')
  unique_versions = cursor.fetchone()['count(*)']

  print ('%s: %d unique files, %d unique versions%s'
         %(datetime.datetime.now(), unique_files, unique_versions, extra))


def SaveBackupFile(cursor, target, backup_file, elements):
  s = ('insert ignore into seen (target, backup_file, elements, media) '
       'values(%s, %s, %d, %s);'
       %(sql.FormatSqlValue('target', target),
         sql.FormatSqlValue('backup_file', backup_file),
         elements, sql.FormatSqlValue('seen_on', FLAGS.media)))
  cursor.execute(s)
  cursor.execute('commit;')


def ProcessBackup(cursor, path):
  target = path[len(FLAGS.path):]
  if not target:
    target = '/'

  print
  print '%s: Checking %s (from %s)' %(datetime.datetime.now(), target, path)

  cmd = '%s/listfiles.sh now %s' %(SCRIPTS_PATH, path)
  print '%s:   Executing %s' %(datetime.datetime.now(), cmd)

  p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  backup_file = None
  elements = 0

  for l in p.stdout.readlines():
    l = l.rstrip()

    try:
      m = FILE_RE.match(l)
      if l == 'Last full backup date: none':
        return None

      elif l.startswith('Local and Remote metadata are synchronized'):
        pass
      elif l.startswith('Warning, found incomplete backup sets'):
        pass
      elif l.startswith('Last full backup date'):
        pass
      elif l.startswith('Copying duplicity'):
        pass
      elif l.startswith('Synchronizing remote metadata'):
        pass
      elif l.startswith('No signature chain for the requested time'):
        pass

      elif l.startswith('Backup file: '):
        if backup_file:
          SaveBackupFile(cursor, target, backup_file, elements)

        _, backup_file = os.path.split(l[len('Backup file: '):])
        elements = 0

      elif not m:
        print ('%s: Failed to parse file entry: %s'
               %(datetime.datetime.now(), l))

      else:
        (directory, filename) = os.path.split(m.group(1))
        filetype = m.group(2)
        epoch = int(m.group(3))

        # Filesystem entry
        s = ('insert ignore into filesystem (filename, parent) '
             'values (%s, %s);'
             %(sql.FormatSqlValue('filename', filename),
               sql.FormatSqlValue('parent', 
                                  os.path.join(target, directory).rstrip('/'))))
        cursor.execute(s)
        cursor.execute('commit;')

        # This version of the file
        path = sql.FormatSqlValue('path', os.path.join(target, directory, filename))
        s = 'select * from versions where path=%s and epoch=%d;' %(path, epoch)
        cursor.execute(s)

        if cursor.rowcount == 0:
          s = ('insert into versions (path, epoch, seen_on) '
               'values (%s, %s, %s);'
               %(path, epoch, sql.FormatSqlValue('seen_on', FLAGS.media)))
          cursor.execute(s)
          cursor.execute('commit;')

        else:
          seen_on = cursor.fetchone()['seen_on'].split()
          if not FLAGS.media in seen_on:
            seen_on.append(FLAGS.media)

            s = ('update versions set seen_on=%s where path=%s and epoch=%d;'
                 %(sql.FormatSqlValue('seen_on', ' '.join(seen_on)), path,  epoch))
            cursor.execute(s)
            cursor.execute('commit;')

        elements += 1
        if elements % 1000 == 0:
          print '%s:     ... %d elements' %(datetime.datetime.now(), elements)

    except sql.FormatException, e:
      print ('%s: %s: SQL format exception %s'
             %(datetime.datetime.now(), path, e))
      f = open('listfiles.problems', 'w+')
      f.write('%s: SQL format exception %s\n' %(path, e))
      f.close()

    except Exception, e:
      exc = None
      print '%s: %s: Exception %s' %(datetime.datetime.now(), path, e)

      try:
        exc = sys.exc_info()
        for tb in traceback.format_exception(exc[0], exc[1], exc[2]):
          print '  %s' % tb
        del tb

      finally:
        del exc
        
      print '  Nearest SQL was:\n\n%s' % s
      sys.exit(1)


def RecurseDirectory(cursor, path):
  if len(path) > len(FLAGS.path):
    target = path[len(FLAGS.path):].rstrip('/')
    p, f = os.path.split(target)
    s = ('insert ignore into filesystem (parent, filename) values (%s, %s);'
         %(sql.FormatSqlValue('parent', p),
           sql.FormatSqlValue('filesystem', f)))
    cursor.execute(s)
    cursor.execute('commit;')

  for ent in os.listdir(path):
    if os.path.isdir(os.path.join(path, ent)):
      RecurseDirectory(cursor, os.path.join(path, ent))

  ProcessBackup(cursor, path)
  PrintProgress(cursor)


def main(argv):
  global processing_queue
  global total_days
  global completed_days

  # Parse flags
  try:
    argv = FLAGS(argv)

  except gflags.FlagsError, e:
    print 'Flags error: %s' % e
    print
    print FLAGS

  if not FLAGS.media:
    print 'Please specify the name of this backup set with --media'
    sys.exit(1)

  if not FLAGS.path:
    print 'Please specify the path to this backup set with --path'
    sys.exit(1)

  db = MySQLdb.connect(user = FLAGS.dbuser, db = FLAGS.dbname,
                       passwd = FLAGS.dbpassword)
  cursor = db.cursor(MySQLdb.cursors.DictCursor)

  # This just creates a queue of directories to process
  RecurseDirectory(cursor, FLAGS.path)

if __name__ == "__main__":
  main(sys.argv)
